// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// List of excluded infoTypes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExcludeInfoTypes {
    /// InfoType list in ExclusionRule rule drops a finding when it overlaps or
    /// contained within with a finding of an infoType from this list. For
    /// example, for `InspectionRuleSet.info_types` containing "PHONE_NUMBER"` and
    /// `exclusion_rule` containing `exclude_info_types.info_types` with
    /// "EMAIL_ADDRESS" the phone number findings are dropped if they overlap
    /// with EMAIL_ADDRESS finding.
    /// That leads to "555-222-2222@example.org" to generate only a single
    /// finding, namely email address.
    pub info_types: std::vec::Vec<crate::model::InfoType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExcludeInfoTypes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_types][crate::model::ExcludeInfoTypes::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoType>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExcludeInfoTypes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ExcludeInfoTypes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExcludeInfoTypes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExcludeInfoTypes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoTypes" => Ok(__FieldTag::__info_types),
                            "info_types" => Ok(__FieldTag::__info_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExcludeInfoTypes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExcludeInfoTypes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_types => {
                            if !fields.insert(__FieldTag::__info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_types",
                                ));
                            }
                            result.info_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InfoType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExcludeInfoTypes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.info_types.is_empty() {
            state.serialize_entry("infoTypes", &self.info_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The rule to exclude findings based on a hotword. For record inspection of
/// tables, column names are considered hotwords. An example of this is to
/// exclude a finding if it belongs to a BigQuery column that matches a specific
/// pattern.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExcludeByHotword {
    /// Regular expression pattern defining what qualifies as a hotword.
    pub hotword_regex: std::option::Option<crate::model::custom_info_type::Regex>,

    /// Range of characters within which the entire hotword must reside.
    /// The total length of the window cannot exceed 1000 characters.
    /// The windowBefore property in proximity should be set to 1 if the hotword
    /// needs to be included in a column header.
    pub proximity: std::option::Option<crate::model::custom_info_type::detection_rule::Proximity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExcludeByHotword {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hotword_regex][crate::model::ExcludeByHotword::hotword_regex].
    pub fn set_hotword_regex<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::custom_info_type::Regex>,
    {
        self.hotword_regex = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hotword_regex][crate::model::ExcludeByHotword::hotword_regex].
    pub fn set_or_clear_hotword_regex<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::custom_info_type::Regex>,
    {
        self.hotword_regex = v.map(|x| x.into());
        self
    }

    /// Sets the value of [proximity][crate::model::ExcludeByHotword::proximity].
    pub fn set_proximity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::custom_info_type::detection_rule::Proximity>,
    {
        self.proximity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [proximity][crate::model::ExcludeByHotword::proximity].
    pub fn set_or_clear_proximity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::custom_info_type::detection_rule::Proximity>,
    {
        self.proximity = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExcludeByHotword {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ExcludeByHotword"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExcludeByHotword {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hotword_regex,
            __proximity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExcludeByHotword")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hotwordRegex" => Ok(__FieldTag::__hotword_regex),
                            "hotword_regex" => Ok(__FieldTag::__hotword_regex),
                            "proximity" => Ok(__FieldTag::__proximity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExcludeByHotword;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExcludeByHotword")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hotword_regex => {
                            if !fields.insert(__FieldTag::__hotword_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hotword_regex",
                                ));
                            }
                            result.hotword_regex = map.next_value::<std::option::Option<crate::model::custom_info_type::Regex>>()?
                                ;
                        }
                        __FieldTag::__proximity => {
                            if !fields.insert(__FieldTag::__proximity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proximity",
                                ));
                            }
                            result.proximity = map.next_value::<std::option::Option<
                                crate::model::custom_info_type::detection_rule::Proximity,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExcludeByHotword {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.hotword_regex.is_some() {
            state.serialize_entry("hotwordRegex", &self.hotword_regex)?;
        }
        if self.proximity.is_some() {
            state.serialize_entry("proximity", &self.proximity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The rule that specifies conditions when findings of infoTypes specified in
/// `InspectionRuleSet` are removed from results.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExclusionRule {
    /// How the rule is applied, see MatchingType documentation for details.
    pub matching_type: crate::model::MatchingType,

    /// Exclusion rule types.
    pub r#type: std::option::Option<crate::model::exclusion_rule::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExclusionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [matching_type][crate::model::ExclusionRule::matching_type].
    pub fn set_matching_type<T: std::convert::Into<crate::model::MatchingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.matching_type = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::exclusion_rule::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `Dictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Dictionary>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::Dictionary(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `Dictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Dictionary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::exclusion_rule::Type::Dictionary(v.into()));
        self
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `Regex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Regex>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::Regex(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `Regex`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Regex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::exclusion_rule::Type::Regex(v.into()));
        self
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `ExcludeInfoTypes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclude_info_types(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExcludeInfoTypes>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::ExcludeInfoTypes(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `ExcludeInfoTypes`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_exclude_info_types<
        T: std::convert::Into<std::boxed::Box<crate::model::ExcludeInfoTypes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::exclusion_rule::Type::ExcludeInfoTypes(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `ExcludeByHotword`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclude_by_hotword(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExcludeByHotword>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::ExcludeByHotword(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `ExcludeByHotword`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_exclude_by_hotword<
        T: std::convert::Into<std::boxed::Box<crate::model::ExcludeByHotword>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::exclusion_rule::Type::ExcludeByHotword(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExclusionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ExclusionRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExclusionRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dictionary,
            __regex,
            __exclude_info_types,
            __exclude_by_hotword,
            __matching_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExclusionRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dictionary" => Ok(__FieldTag::__dictionary),
                            "regex" => Ok(__FieldTag::__regex),
                            "excludeInfoTypes" => Ok(__FieldTag::__exclude_info_types),
                            "exclude_info_types" => Ok(__FieldTag::__exclude_info_types),
                            "excludeByHotword" => Ok(__FieldTag::__exclude_by_hotword),
                            "exclude_by_hotword" => Ok(__FieldTag::__exclude_by_hotword),
                            "matchingType" => Ok(__FieldTag::__matching_type),
                            "matching_type" => Ok(__FieldTag::__matching_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExclusionRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExclusionRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dictionary => {
                            if !fields.insert(__FieldTag::__dictionary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dictionary",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.ExclusionRule.dictionary, latest field was dictionary",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::exclusion_rule::Type::Dictionary(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::custom_info_type::Dictionary>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__regex => {
                            if !fields.insert(__FieldTag::__regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for regex",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.ExclusionRule.regex, latest field was regex",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::exclusion_rule::Type::Regex(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::custom_info_type::Regex>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__exclude_info_types => {
                            if !fields.insert(__FieldTag::__exclude_info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_info_types",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.ExclusionRule.exclude_info_types, latest field was excludeInfoTypes",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::exclusion_rule::Type::ExcludeInfoTypes(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ExcludeInfoTypes>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__exclude_by_hotword => {
                            if !fields.insert(__FieldTag::__exclude_by_hotword) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_by_hotword",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.ExclusionRule.exclude_by_hotword, latest field was excludeByHotword",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::exclusion_rule::Type::ExcludeByHotword(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ExcludeByHotword>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__matching_type => {
                            if !fields.insert(__FieldTag::__matching_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matching_type",
                                ));
                            }
                            result.matching_type = map
                                .next_value::<std::option::Option<crate::model::MatchingType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExclusionRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.dictionary() {
            state.serialize_entry("dictionary", value)?;
        }
        if let Some(value) = self.regex() {
            state.serialize_entry("regex", value)?;
        }
        if let Some(value) = self.exclude_info_types() {
            state.serialize_entry("excludeInfoTypes", value)?;
        }
        if let Some(value) = self.exclude_by_hotword() {
            state.serialize_entry("excludeByHotword", value)?;
        }
        if !wkt::internal::is_default(&self.matching_type) {
            state.serialize_entry("matchingType", &self.matching_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExclusionRule].
pub mod exclusion_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Exclusion rule types.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Dictionary which defines the rule.
        Dictionary(std::boxed::Box<crate::model::custom_info_type::Dictionary>),
        /// Regular expression which defines the rule.
        Regex(std::boxed::Box<crate::model::custom_info_type::Regex>),
        /// Set of infoTypes for which findings would affect this rule.
        ExcludeInfoTypes(std::boxed::Box<crate::model::ExcludeInfoTypes>),
        /// Drop if the hotword rule is contained in the proximate context. For
        /// tabular data, the context includes the column name.
        ExcludeByHotword(std::boxed::Box<crate::model::ExcludeByHotword>),
    }
}

/// A single inspection rule to be applied to infoTypes, specified in
/// `InspectionRuleSet`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InspectionRule {
    /// Inspection rule types.
    pub r#type: std::option::Option<crate::model::inspection_rule::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::InspectionRule::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::inspection_rule::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::InspectionRule::r#type]
    /// if it holds a `HotwordRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hotword_rule(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
    > {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::inspection_rule::Type::HotwordRule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::InspectionRule::r#type]
    /// to hold a `HotwordRule`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_hotword_rule<
        T: std::convert::Into<
                std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::inspection_rule::Type::HotwordRule(v.into()));
        self
    }

    /// The value of [r#type][crate::model::InspectionRule::r#type]
    /// if it holds a `ExclusionRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclusion_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExclusionRule>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::inspection_rule::Type::ExclusionRule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::InspectionRule::r#type]
    /// to hold a `ExclusionRule`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_exclusion_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::ExclusionRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::inspection_rule::Type::ExclusionRule(v.into()));
        self
    }
}

impl wkt::message::Message for InspectionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectionRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InspectionRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hotword_rule,
            __exclusion_rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InspectionRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hotwordRule" => Ok(__FieldTag::__hotword_rule),
                            "hotword_rule" => Ok(__FieldTag::__hotword_rule),
                            "exclusionRule" => Ok(__FieldTag::__exclusion_rule),
                            "exclusion_rule" => Ok(__FieldTag::__exclusion_rule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InspectionRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InspectionRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hotword_rule => {
                            if !fields.insert(__FieldTag::__hotword_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hotword_rule",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.InspectionRule.hotword_rule, latest field was hotwordRule",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::inspection_rule::Type::HotwordRule(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__exclusion_rule => {
                            if !fields.insert(__FieldTag::__exclusion_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusion_rule",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.InspectionRule.exclusion_rule, latest field was exclusionRule",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::inspection_rule::Type::ExclusionRule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ExclusionRule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InspectionRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.hotword_rule() {
            state.serialize_entry("hotwordRule", value)?;
        }
        if let Some(value) = self.exclusion_rule() {
            state.serialize_entry("exclusionRule", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InspectionRule].
pub mod inspection_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Inspection rule types.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Hotword-based detection rule.
        HotwordRule(std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>),
        /// Exclusion rule.
        ExclusionRule(std::boxed::Box<crate::model::ExclusionRule>),
    }
}

/// Rule set for modifying a set of infoTypes to alter behavior under certain
/// circumstances, depending on the specific details of the rules within the set.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InspectionRuleSet {
    /// List of infoTypes this rule set is applied to.
    pub info_types: std::vec::Vec<crate::model::InfoType>,

    /// Set of rules to be applied to infoTypes. The rules are applied in order.
    pub rules: std::vec::Vec<crate::model::InspectionRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectionRuleSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_types][crate::model::InspectionRuleSet::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoType>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rules][crate::model::InspectionRuleSet::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InspectionRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InspectionRuleSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectionRuleSet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InspectionRuleSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_types,
            __rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InspectionRuleSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoTypes" => Ok(__FieldTag::__info_types),
                            "info_types" => Ok(__FieldTag::__info_types),
                            "rules" => Ok(__FieldTag::__rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InspectionRuleSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InspectionRuleSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_types => {
                            if !fields.insert(__FieldTag::__info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_types",
                                ));
                            }
                            result.info_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InfoType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rules => {
                            if !fields.insert(__FieldTag::__rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules",
                                ));
                            }
                            result.rules =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InspectionRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InspectionRuleSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.info_types.is_empty() {
            state.serialize_entry("infoTypes", &self.info_types)?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration description of the scanning process.
/// When used with redactContent only info_types and min_likelihood are currently
/// used.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InspectConfig {
    /// Restricts what info_types to look for. The values must correspond to
    /// InfoType values returned by ListInfoTypes or listed at
    /// <https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference>.
    ///
    /// When no InfoTypes or CustomInfoTypes are specified in a request, the
    /// system may automatically choose a default list of detectors to run, which
    /// may change over time.
    ///
    /// If you need precise control and predictability as to what detectors are
    /// run you should specify specific InfoTypes listed in the reference,
    /// otherwise a default list will be used, which may change over time.
    pub info_types: std::vec::Vec<crate::model::InfoType>,

    /// Only returns findings equal to or above this threshold. The default is
    /// POSSIBLE.
    ///
    /// In general, the highest likelihood setting yields the fewest findings in
    /// results and the lowest chance of a false positive. For more information,
    /// see [Match
    /// likelihood](https://cloud.google.com/sensitive-data-protection/docs/likelihood).
    pub min_likelihood: crate::model::Likelihood,

    /// Minimum likelihood per infotype. For each infotype, a user can specify a
    /// minimum likelihood. The system only returns a finding if its likelihood is
    /// above this threshold. If this field is not set, the system uses the
    /// InspectConfig min_likelihood.
    pub min_likelihood_per_info_type:
        std::vec::Vec<crate::model::inspect_config::InfoTypeLikelihood>,

    /// Configuration to control the number of findings returned.
    /// This is not used for data profiling.
    ///
    /// When redacting sensitive data from images, finding limits don't apply. They
    /// can cause unexpected or inconsistent results, where only some data is
    /// redacted. Don't include finding limits in
    /// [RedactImage][google.privacy.dlp.v2.DlpService.RedactImage]
    /// requests. Otherwise, Cloud DLP returns an error.
    ///
    /// When set within an
    /// [InspectJobConfig][google.privacy.dlp.v2.InspectJobConfig], the specified
    /// maximum values aren't hard limits. If an inspection job reaches these
    /// limits, the job ends gradually, not abruptly. Therefore, the actual number
    /// of findings that Cloud DLP returns can be multiple times higher than these
    /// maximum values.
    ///
    /// [google.privacy.dlp.v2.DlpService.RedactImage]: crate::client::DlpService::redact_image
    /// [google.privacy.dlp.v2.InspectJobConfig]: crate::model::InspectJobConfig
    pub limits: std::option::Option<crate::model::inspect_config::FindingLimits>,

    /// When true, a contextual quote from the data that triggered a finding is
    /// included in the response; see
    /// [Finding.quote][google.privacy.dlp.v2.Finding.quote]. This is not used for
    /// data profiling.
    ///
    /// [google.privacy.dlp.v2.Finding.quote]: crate::model::Finding::quote
    pub include_quote: bool,

    /// When true, excludes type information of the findings.
    /// This is not used for data profiling.
    pub exclude_info_types: bool,

    /// CustomInfoTypes provided by the user. See
    /// <https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes>
    /// to learn more.
    pub custom_info_types: std::vec::Vec<crate::model::CustomInfoType>,

    /// Deprecated and unused.
    pub content_options: std::vec::Vec<crate::model::ContentOption>,

    /// Set of rules to apply to the findings for this InspectConfig.
    /// Exclusion rules, contained in the set are executed in the end, other
    /// rules are executed in the order they are specified for each info type.
    pub rule_set: std::vec::Vec<crate::model::InspectionRuleSet>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_types][crate::model::InspectConfig::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoType>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_likelihood][crate::model::InspectConfig::min_likelihood].
    pub fn set_min_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_likelihood = v.into();
        self
    }

    /// Sets the value of [min_likelihood_per_info_type][crate::model::InspectConfig::min_likelihood_per_info_type].
    pub fn set_min_likelihood_per_info_type<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::inspect_config::InfoTypeLikelihood>,
    {
        use std::iter::Iterator;
        self.min_likelihood_per_info_type = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [limits][crate::model::InspectConfig::limits].
    pub fn set_limits<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::inspect_config::FindingLimits>,
    {
        self.limits = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [limits][crate::model::InspectConfig::limits].
    pub fn set_or_clear_limits<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::inspect_config::FindingLimits>,
    {
        self.limits = v.map(|x| x.into());
        self
    }

    /// Sets the value of [include_quote][crate::model::InspectConfig::include_quote].
    pub fn set_include_quote<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_quote = v.into();
        self
    }

    /// Sets the value of [exclude_info_types][crate::model::InspectConfig::exclude_info_types].
    pub fn set_exclude_info_types<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.exclude_info_types = v.into();
        self
    }

    /// Sets the value of [custom_info_types][crate::model::InspectConfig::custom_info_types].
    pub fn set_custom_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomInfoType>,
    {
        use std::iter::Iterator;
        self.custom_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [content_options][crate::model::InspectConfig::content_options].
    pub fn set_content_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ContentOption>,
    {
        use std::iter::Iterator;
        self.content_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rule_set][crate::model::InspectConfig::rule_set].
    pub fn set_rule_set<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InspectionRuleSet>,
    {
        use std::iter::Iterator;
        self.rule_set = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InspectConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InspectConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_types,
            __min_likelihood,
            __min_likelihood_per_info_type,
            __limits,
            __include_quote,
            __exclude_info_types,
            __custom_info_types,
            __content_options,
            __rule_set,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InspectConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoTypes" => Ok(__FieldTag::__info_types),
                            "info_types" => Ok(__FieldTag::__info_types),
                            "minLikelihood" => Ok(__FieldTag::__min_likelihood),
                            "min_likelihood" => Ok(__FieldTag::__min_likelihood),
                            "minLikelihoodPerInfoType" => {
                                Ok(__FieldTag::__min_likelihood_per_info_type)
                            }
                            "min_likelihood_per_info_type" => {
                                Ok(__FieldTag::__min_likelihood_per_info_type)
                            }
                            "limits" => Ok(__FieldTag::__limits),
                            "includeQuote" => Ok(__FieldTag::__include_quote),
                            "include_quote" => Ok(__FieldTag::__include_quote),
                            "excludeInfoTypes" => Ok(__FieldTag::__exclude_info_types),
                            "exclude_info_types" => Ok(__FieldTag::__exclude_info_types),
                            "customInfoTypes" => Ok(__FieldTag::__custom_info_types),
                            "custom_info_types" => Ok(__FieldTag::__custom_info_types),
                            "contentOptions" => Ok(__FieldTag::__content_options),
                            "content_options" => Ok(__FieldTag::__content_options),
                            "ruleSet" => Ok(__FieldTag::__rule_set),
                            "rule_set" => Ok(__FieldTag::__rule_set),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InspectConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InspectConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_types => {
                            if !fields.insert(__FieldTag::__info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_types",
                                ));
                            }
                            result.info_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InfoType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__min_likelihood => {
                            if !fields.insert(__FieldTag::__min_likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_likelihood",
                                ));
                            }
                            result.min_likelihood = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_likelihood_per_info_type => {
                            if !fields.insert(__FieldTag::__min_likelihood_per_info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_likelihood_per_info_type",
                                ));
                            }
                            result.min_likelihood_per_info_type = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::inspect_config::InfoTypeLikelihood>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__limits => {
                            if !fields.insert(__FieldTag::__limits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for limits",
                                ));
                            }
                            result.limits =
                                map.next_value::<std::option::Option<
                                    crate::model::inspect_config::FindingLimits,
                                >>()?;
                        }
                        __FieldTag::__include_quote => {
                            if !fields.insert(__FieldTag::__include_quote) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_quote",
                                ));
                            }
                            result.include_quote = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exclude_info_types => {
                            if !fields.insert(__FieldTag::__exclude_info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_info_types",
                                ));
                            }
                            result.exclude_info_types = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_info_types => {
                            if !fields.insert(__FieldTag::__custom_info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_info_types",
                                ));
                            }
                            result.custom_info_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CustomInfoType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content_options => {
                            if !fields.insert(__FieldTag::__content_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_options",
                                ));
                            }
                            result.content_options = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ContentOption>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rule_set => {
                            if !fields.insert(__FieldTag::__rule_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_set",
                                ));
                            }
                            result.rule_set =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InspectionRuleSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InspectConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.info_types.is_empty() {
            state.serialize_entry("infoTypes", &self.info_types)?;
        }
        if !wkt::internal::is_default(&self.min_likelihood) {
            state.serialize_entry("minLikelihood", &self.min_likelihood)?;
        }
        if !self.min_likelihood_per_info_type.is_empty() {
            state.serialize_entry(
                "minLikelihoodPerInfoType",
                &self.min_likelihood_per_info_type,
            )?;
        }
        if self.limits.is_some() {
            state.serialize_entry("limits", &self.limits)?;
        }
        if !wkt::internal::is_default(&self.include_quote) {
            state.serialize_entry("includeQuote", &self.include_quote)?;
        }
        if !wkt::internal::is_default(&self.exclude_info_types) {
            state.serialize_entry("excludeInfoTypes", &self.exclude_info_types)?;
        }
        if !self.custom_info_types.is_empty() {
            state.serialize_entry("customInfoTypes", &self.custom_info_types)?;
        }
        if !self.content_options.is_empty() {
            state.serialize_entry("contentOptions", &self.content_options)?;
        }
        if !self.rule_set.is_empty() {
            state.serialize_entry("ruleSet", &self.rule_set)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InspectConfig].
pub mod inspect_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for setting a minimum likelihood per infotype. Used to
    /// customize the minimum likelihood level for specific infotypes in the
    /// request. For example, use this if you want to lower the precision for
    /// PERSON_NAME without lowering the precision for the other infotypes in the
    /// request.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InfoTypeLikelihood {
        /// Type of information the likelihood threshold applies to. Only one
        /// likelihood per info_type should be provided. If InfoTypeLikelihood does
        /// not have an info_type, the configuration fails.
        pub info_type: std::option::Option<crate::model::InfoType>,

        /// Only returns findings equal to or above this threshold. This field is
        /// required or else the configuration fails.
        pub min_likelihood: crate::model::Likelihood,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InfoTypeLikelihood {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [info_type][crate::model::inspect_config::InfoTypeLikelihood::info_type].
        pub fn set_info_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InfoType>,
        {
            self.info_type = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [info_type][crate::model::inspect_config::InfoTypeLikelihood::info_type].
        pub fn set_or_clear_info_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InfoType>,
        {
            self.info_type = v.map(|x| x.into());
            self
        }

        /// Sets the value of [min_likelihood][crate::model::inspect_config::InfoTypeLikelihood::min_likelihood].
        pub fn set_min_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_likelihood = v.into();
            self
        }
    }

    impl wkt::message::Message for InfoTypeLikelihood {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectConfig.InfoTypeLikelihood"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InfoTypeLikelihood {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __info_type,
                __min_likelihood,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InfoTypeLikelihood")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "infoType" => Ok(__FieldTag::__info_type),
                                "info_type" => Ok(__FieldTag::__info_type),
                                "minLikelihood" => Ok(__FieldTag::__min_likelihood),
                                "min_likelihood" => Ok(__FieldTag::__min_likelihood),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InfoTypeLikelihood;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InfoTypeLikelihood")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__info_type => {
                                if !fields.insert(__FieldTag::__info_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for info_type",
                                    ));
                                }
                                result.info_type = map
                                    .next_value::<std::option::Option<crate::model::InfoType>>()?;
                            }
                            __FieldTag::__min_likelihood => {
                                if !fields.insert(__FieldTag::__min_likelihood) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_likelihood",
                                    ));
                                }
                                result.min_likelihood = map
                                    .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InfoTypeLikelihood {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.info_type.is_some() {
                state.serialize_entry("infoType", &self.info_type)?;
            }
            if !wkt::internal::is_default(&self.min_likelihood) {
                state.serialize_entry("minLikelihood", &self.min_likelihood)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration to control the number of findings returned for inspection.
    /// This is not used for de-identification or data profiling.
    ///
    /// When redacting sensitive data from images, finding limits don't apply. They
    /// can cause unexpected or inconsistent results, where only some data is
    /// redacted. Don't include finding limits in
    /// [RedactImage][google.privacy.dlp.v2.DlpService.RedactImage]
    /// requests. Otherwise, Cloud DLP returns an error.
    ///
    /// [google.privacy.dlp.v2.DlpService.RedactImage]: crate::client::DlpService::redact_image
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FindingLimits {
        /// Max number of findings that are returned for each item scanned.
        ///
        /// When set within an
        /// [InspectContentRequest][google.privacy.dlp.v2.InspectContentRequest],
        /// this field is ignored.
        ///
        /// This value isn't a hard limit. If the number of findings for an item
        /// reaches this limit, the inspection of that item ends gradually, not
        /// abruptly. Therefore, the actual number of findings that Cloud DLP returns
        /// for the item can be multiple times higher than this value.
        ///
        /// [google.privacy.dlp.v2.InspectContentRequest]: crate::model::InspectContentRequest
        pub max_findings_per_item: i32,

        /// Max number of findings that are returned per request or job.
        ///
        /// If you set this field in an
        /// [InspectContentRequest][google.privacy.dlp.v2.InspectContentRequest], the
        /// resulting maximum value is the value that you set or 3,000, whichever is
        /// lower.
        ///
        /// This value isn't a hard limit. If an inspection reaches this limit, the
        /// inspection ends gradually, not abruptly. Therefore, the actual number of
        /// findings that Cloud DLP returns can be multiple times higher than this
        /// value.
        ///
        /// [google.privacy.dlp.v2.InspectContentRequest]: crate::model::InspectContentRequest
        pub max_findings_per_request: i32,

        /// Configuration of findings limit given for specified infoTypes.
        pub max_findings_per_info_type:
            std::vec::Vec<crate::model::inspect_config::finding_limits::InfoTypeLimit>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FindingLimits {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_findings_per_item][crate::model::inspect_config::FindingLimits::max_findings_per_item].
        pub fn set_max_findings_per_item<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_findings_per_item = v.into();
            self
        }

        /// Sets the value of [max_findings_per_request][crate::model::inspect_config::FindingLimits::max_findings_per_request].
        pub fn set_max_findings_per_request<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_findings_per_request = v.into();
            self
        }

        /// Sets the value of [max_findings_per_info_type][crate::model::inspect_config::FindingLimits::max_findings_per_info_type].
        pub fn set_max_findings_per_info_type<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::inspect_config::finding_limits::InfoTypeLimit>,
        {
            use std::iter::Iterator;
            self.max_findings_per_info_type = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for FindingLimits {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectConfig.FindingLimits"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FindingLimits {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __max_findings_per_item,
                __max_findings_per_request,
                __max_findings_per_info_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FindingLimits")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "maxFindingsPerItem" => Ok(__FieldTag::__max_findings_per_item),
                                "max_findings_per_item" => Ok(__FieldTag::__max_findings_per_item),
                                "maxFindingsPerRequest" => {
                                    Ok(__FieldTag::__max_findings_per_request)
                                }
                                "max_findings_per_request" => {
                                    Ok(__FieldTag::__max_findings_per_request)
                                }
                                "maxFindingsPerInfoType" => {
                                    Ok(__FieldTag::__max_findings_per_info_type)
                                }
                                "max_findings_per_info_type" => {
                                    Ok(__FieldTag::__max_findings_per_info_type)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FindingLimits;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FindingLimits")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__max_findings_per_item => {
                                if !fields.insert(__FieldTag::__max_findings_per_item) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_findings_per_item",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_findings_per_item =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__max_findings_per_request => {
                                if !fields.insert(__FieldTag::__max_findings_per_request) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_findings_per_request",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_findings_per_request =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__max_findings_per_info_type => {
                                if !fields.insert(__FieldTag::__max_findings_per_info_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_findings_per_info_type",
                                    ));
                                }
                                result.max_findings_per_info_type = map.next_value::<std::option::Option<std::vec::Vec<crate::model::inspect_config::finding_limits::InfoTypeLimit>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FindingLimits {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.max_findings_per_item) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("maxFindingsPerItem", &__With(&self.max_findings_per_item))?;
            }
            if !wkt::internal::is_default(&self.max_findings_per_request) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "maxFindingsPerRequest",
                    &__With(&self.max_findings_per_request),
                )?;
            }
            if !self.max_findings_per_info_type.is_empty() {
                state
                    .serialize_entry("maxFindingsPerInfoType", &self.max_findings_per_info_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [FindingLimits].
    pub mod finding_limits {
        #[allow(unused_imports)]
        use super::*;

        /// Max findings configuration per infoType, per content item or long
        /// running DlpJob.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct InfoTypeLimit {
            /// Type of information the findings limit applies to. Only one limit per
            /// info_type should be provided. If InfoTypeLimit does not have an
            /// info_type, the DLP API applies the limit against all info_types that
            /// are found but not specified in another InfoTypeLimit.
            pub info_type: std::option::Option<crate::model::InfoType>,

            /// Max findings limit for the given infoType.
            pub max_findings: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl InfoTypeLimit {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [info_type][crate::model::inspect_config::finding_limits::InfoTypeLimit::info_type].
            pub fn set_info_type<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::InfoType>,
            {
                self.info_type = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [info_type][crate::model::inspect_config::finding_limits::InfoTypeLimit::info_type].
            pub fn set_or_clear_info_type<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::InfoType>,
            {
                self.info_type = v.map(|x| x.into());
                self
            }

            /// Sets the value of [max_findings][crate::model::inspect_config::finding_limits::InfoTypeLimit::max_findings].
            pub fn set_max_findings<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_findings = v.into();
                self
            }
        }

        impl wkt::message::Message for InfoTypeLimit {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.InspectConfig.FindingLimits.InfoTypeLimit"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for InfoTypeLimit {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __info_type,
                    __max_findings,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for InfoTypeLimit")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "infoType" => Ok(__FieldTag::__info_type),
                                    "info_type" => Ok(__FieldTag::__info_type),
                                    "maxFindings" => Ok(__FieldTag::__max_findings),
                                    "max_findings" => Ok(__FieldTag::__max_findings),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = InfoTypeLimit;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct InfoTypeLimit")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__info_type => {
                                    if !fields.insert(__FieldTag::__info_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for info_type",
                                            ),
                                        );
                                    }
                                    result.info_type = map
                                        .next_value::<std::option::Option<crate::model::InfoType>>(
                                        )?;
                                }
                                __FieldTag::__max_findings => {
                                    if !fields.insert(__FieldTag::__max_findings) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for max_findings",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max_findings =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for InfoTypeLimit {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.info_type.is_some() {
                    state.serialize_entry("infoType", &self.info_type)?;
                }
                if !wkt::internal::is_default(&self.max_findings) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("maxFindings", &__With(&self.max_findings))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }
}

/// Container for bytes to inspect or redact.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ByteContentItem {
    /// The type of data stored in the bytes string. Default will be TEXT_UTF8.
    pub r#type: crate::model::byte_content_item::BytesType,

    /// Content data to inspect or redact.
    pub data: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ByteContentItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::ByteContentItem::type].
    pub fn set_type<T: std::convert::Into<crate::model::byte_content_item::BytesType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [data][crate::model::ByteContentItem::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }
}

impl wkt::message::Message for ByteContentItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ByteContentItem"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ByteContentItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ByteContentItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "data" => Ok(__FieldTag::__data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ByteContentItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ByteContentItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::byte_content_item::BytesType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ByteContentItem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("data", &__With(&self.data))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ByteContentItem].
pub mod byte_content_item {
    #[allow(unused_imports)]
    use super::*;

    /// The type of data being sent for inspection. To learn more, see
    /// [Supported file
    /// types](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types).
    ///
    /// Only the first frame of each multiframe image is inspected. Metadata and
    /// other frames aren't inspected.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BytesType {
        /// Unused
        Unspecified,
        /// Any image type.
        Image,
        /// jpeg
        ImageJpeg,
        /// bmp
        ImageBmp,
        /// png
        ImagePng,
        /// svg
        ImageSvg,
        /// plain text
        TextUtf8,
        /// docx, docm, dotx, dotm
        WordDocument,
        /// pdf
        Pdf,
        /// pptx, pptm, potx, potm, pot
        PowerpointDocument,
        /// xlsx, xlsm, xltx, xltm
        ExcelDocument,
        /// avro
        Avro,
        /// csv
        Csv,
        /// tsv
        Tsv,
        /// Audio file types. Only used for profiling.
        Audio,
        /// Video file types. Only used for profiling.
        Video,
        /// Executable file types. Only used for profiling.
        Executable,
        /// AI model file types. Only used for profiling.
        AiModel,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BytesType::value] or
        /// [BytesType::name].
        UnknownValue(bytes_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod bytes_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BytesType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Image => std::option::Option::Some(6),
                Self::ImageJpeg => std::option::Option::Some(1),
                Self::ImageBmp => std::option::Option::Some(2),
                Self::ImagePng => std::option::Option::Some(3),
                Self::ImageSvg => std::option::Option::Some(4),
                Self::TextUtf8 => std::option::Option::Some(5),
                Self::WordDocument => std::option::Option::Some(7),
                Self::Pdf => std::option::Option::Some(8),
                Self::PowerpointDocument => std::option::Option::Some(9),
                Self::ExcelDocument => std::option::Option::Some(10),
                Self::Avro => std::option::Option::Some(11),
                Self::Csv => std::option::Option::Some(12),
                Self::Tsv => std::option::Option::Some(13),
                Self::Audio => std::option::Option::Some(15),
                Self::Video => std::option::Option::Some(16),
                Self::Executable => std::option::Option::Some(17),
                Self::AiModel => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BYTES_TYPE_UNSPECIFIED"),
                Self::Image => std::option::Option::Some("IMAGE"),
                Self::ImageJpeg => std::option::Option::Some("IMAGE_JPEG"),
                Self::ImageBmp => std::option::Option::Some("IMAGE_BMP"),
                Self::ImagePng => std::option::Option::Some("IMAGE_PNG"),
                Self::ImageSvg => std::option::Option::Some("IMAGE_SVG"),
                Self::TextUtf8 => std::option::Option::Some("TEXT_UTF8"),
                Self::WordDocument => std::option::Option::Some("WORD_DOCUMENT"),
                Self::Pdf => std::option::Option::Some("PDF"),
                Self::PowerpointDocument => std::option::Option::Some("POWERPOINT_DOCUMENT"),
                Self::ExcelDocument => std::option::Option::Some("EXCEL_DOCUMENT"),
                Self::Avro => std::option::Option::Some("AVRO"),
                Self::Csv => std::option::Option::Some("CSV"),
                Self::Tsv => std::option::Option::Some("TSV"),
                Self::Audio => std::option::Option::Some("AUDIO"),
                Self::Video => std::option::Option::Some("VIDEO"),
                Self::Executable => std::option::Option::Some("EXECUTABLE"),
                Self::AiModel => std::option::Option::Some("AI_MODEL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BytesType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BytesType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BytesType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ImageJpeg,
                2 => Self::ImageBmp,
                3 => Self::ImagePng,
                4 => Self::ImageSvg,
                5 => Self::TextUtf8,
                6 => Self::Image,
                7 => Self::WordDocument,
                8 => Self::Pdf,
                9 => Self::PowerpointDocument,
                10 => Self::ExcelDocument,
                11 => Self::Avro,
                12 => Self::Csv,
                13 => Self::Tsv,
                15 => Self::Audio,
                16 => Self::Video,
                17 => Self::Executable,
                18 => Self::AiModel,
                _ => Self::UnknownValue(bytes_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BytesType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BYTES_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMAGE" => Self::Image,
                "IMAGE_JPEG" => Self::ImageJpeg,
                "IMAGE_BMP" => Self::ImageBmp,
                "IMAGE_PNG" => Self::ImagePng,
                "IMAGE_SVG" => Self::ImageSvg,
                "TEXT_UTF8" => Self::TextUtf8,
                "WORD_DOCUMENT" => Self::WordDocument,
                "PDF" => Self::Pdf,
                "POWERPOINT_DOCUMENT" => Self::PowerpointDocument,
                "EXCEL_DOCUMENT" => Self::ExcelDocument,
                "AVRO" => Self::Avro,
                "CSV" => Self::Csv,
                "TSV" => Self::Tsv,
                "AUDIO" => Self::Audio,
                "VIDEO" => Self::Video,
                "EXECUTABLE" => Self::Executable,
                "AI_MODEL" => Self::AiModel,
                _ => Self::UnknownValue(bytes_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BytesType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Image => serializer.serialize_i32(6),
                Self::ImageJpeg => serializer.serialize_i32(1),
                Self::ImageBmp => serializer.serialize_i32(2),
                Self::ImagePng => serializer.serialize_i32(3),
                Self::ImageSvg => serializer.serialize_i32(4),
                Self::TextUtf8 => serializer.serialize_i32(5),
                Self::WordDocument => serializer.serialize_i32(7),
                Self::Pdf => serializer.serialize_i32(8),
                Self::PowerpointDocument => serializer.serialize_i32(9),
                Self::ExcelDocument => serializer.serialize_i32(10),
                Self::Avro => serializer.serialize_i32(11),
                Self::Csv => serializer.serialize_i32(12),
                Self::Tsv => serializer.serialize_i32(13),
                Self::Audio => serializer.serialize_i32(15),
                Self::Video => serializer.serialize_i32(16),
                Self::Executable => serializer.serialize_i32(17),
                Self::AiModel => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BytesType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BytesType>::new(
                ".google.privacy.dlp.v2.ByteContentItem.BytesType",
            ))
        }
    }
}

/// Type of content to inspect.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ContentItem {
    /// Data of the item either in the byte array or UTF-8 string form, or table.
    pub data_item: std::option::Option<crate::model::content_item::DataItem>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContentItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_item][crate::model::ContentItem::data_item].
    ///
    /// Note that all the setters affecting `data_item` are mutually
    /// exclusive.
    pub fn set_data_item<
        T: std::convert::Into<std::option::Option<crate::model::content_item::DataItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_item = v.into();
        self
    }

    /// The value of [data_item][crate::model::ContentItem::data_item]
    /// if it holds a `Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::content_item::DataItem::Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::ContentItem::data_item]
    /// to hold a `Value`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::content_item::DataItem::Value(v.into()));
        self
    }

    /// The value of [data_item][crate::model::ContentItem::data_item]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table(&self) -> std::option::Option<&std::boxed::Box<crate::model::Table>> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::content_item::DataItem::Table(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::ContentItem::data_item]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::Table>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::content_item::DataItem::Table(v.into()));
        self
    }

    /// The value of [data_item][crate::model::ContentItem::data_item]
    /// if it holds a `ByteItem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn byte_item(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ByteContentItem>> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::content_item::DataItem::ByteItem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::ContentItem::data_item]
    /// to hold a `ByteItem`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_byte_item<T: std::convert::Into<std::boxed::Box<crate::model::ByteContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::content_item::DataItem::ByteItem(v.into()));
        self
    }
}

impl wkt::message::Message for ContentItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ContentItem"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ContentItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __table,
            __byte_item,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContentItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "table" => Ok(__FieldTag::__table),
                            "byteItem" => Ok(__FieldTag::__byte_item),
                            "byte_item" => Ok(__FieldTag::__byte_item),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ContentItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContentItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            if result.data_item.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_item`, a oneof with full ID .google.privacy.dlp.v2.ContentItem.value, latest field was value",
                                ));
                            }
                            result.data_item = std::option::Option::Some(
                                crate::model::content_item::DataItem::Value(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            if result.data_item.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_item`, a oneof with full ID .google.privacy.dlp.v2.ContentItem.table, latest field was table",
                                ));
                            }
                            result.data_item =
                                std::option::Option::Some(
                                    crate::model::content_item::DataItem::Table(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Table>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__byte_item => {
                            if !fields.insert(__FieldTag::__byte_item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for byte_item",
                                ));
                            }
                            if result.data_item.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_item`, a oneof with full ID .google.privacy.dlp.v2.ContentItem.byte_item, latest field was byteItem",
                                ));
                            }
                            result.data_item = std::option::Option::Some(
                                crate::model::content_item::DataItem::ByteItem(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ByteContentItem>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ContentItem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.value() {
            state.serialize_entry("value", value)?;
        }
        if let Some(value) = self.table() {
            state.serialize_entry("table", value)?;
        }
        if let Some(value) = self.byte_item() {
            state.serialize_entry("byteItem", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ContentItem].
pub mod content_item {
    #[allow(unused_imports)]
    use super::*;

    /// Data of the item either in the byte array or UTF-8 string form, or table.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataItem {
        /// String data to inspect or redact.
        Value(std::string::String),
        /// Structured content for inspection. See
        /// <https://cloud.google.com/sensitive-data-protection/docs/inspecting-text#inspecting_a_table>
        /// to learn more.
        Table(std::boxed::Box<crate::model::Table>),
        /// Content data to inspect or redact. Replaces `type` and `data`.
        ByteItem(std::boxed::Box<crate::model::ByteContentItem>),
    }
}

/// Structured content to inspect. Up to 50,000 `Value`s per request allowed. See
/// <https://cloud.google.com/sensitive-data-protection/docs/inspecting-structured-text#inspecting_a_table>
/// to learn more.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Table {
    /// Headers of the table.
    pub headers: std::vec::Vec<crate::model::FieldId>,

    /// Rows of the table.
    pub rows: std::vec::Vec<crate::model::table::Row>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Table {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [headers][crate::model::Table::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rows][crate::model::Table::rows].
    pub fn set_rows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::table::Row>,
    {
        use std::iter::Iterator;
        self.rows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Table {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Table"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Table {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __headers,
            __rows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Table")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "headers" => Ok(__FieldTag::__headers),
                            "rows" => Ok(__FieldTag::__rows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Table;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Table")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FieldId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rows => {
                            if !fields.insert(__FieldTag::__rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rows",
                                ));
                            }
                            result.rows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::table::Row>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Table {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !self.rows.is_empty() {
            state.serialize_entry("rows", &self.rows)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Table].
pub mod table {
    #[allow(unused_imports)]
    use super::*;

    /// Values of the row.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Row {
        /// Individual cells.
        pub values: std::vec::Vec<crate::model::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Row {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::table::Row::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Value>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Row {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Table.Row"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Row {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Row")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "values" => Ok(__FieldTag::__values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Row;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Row")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                result.values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Value>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Row {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.values.is_empty() {
                state.serialize_entry("values", &self.values)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// All the findings for a single scanned item.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InspectResult {
    /// List of findings for an item.
    pub findings: std::vec::Vec<crate::model::Finding>,

    /// If true, then this item might have more findings than were returned,
    /// and the findings returned are an arbitrary subset of all findings.
    /// The findings list might be truncated because the input items were too
    /// large, or because the server reached the maximum amount of resources
    /// allowed for a single API call. For best results, divide the input into
    /// smaller batches.
    pub findings_truncated: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [findings][crate::model::InspectResult::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Finding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [findings_truncated][crate::model::InspectResult::findings_truncated].
    pub fn set_findings_truncated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.findings_truncated = v.into();
        self
    }
}

impl wkt::message::Message for InspectResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InspectResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __findings,
            __findings_truncated,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InspectResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "findings" => Ok(__FieldTag::__findings),
                            "findingsTruncated" => Ok(__FieldTag::__findings_truncated),
                            "findings_truncated" => Ok(__FieldTag::__findings_truncated),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InspectResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InspectResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__findings => {
                            if !fields.insert(__FieldTag::__findings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for findings",
                                ));
                            }
                            result.findings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Finding>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__findings_truncated => {
                            if !fields.insert(__FieldTag::__findings_truncated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for findings_truncated",
                                ));
                            }
                            result.findings_truncated = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InspectResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.findings.is_empty() {
            state.serialize_entry("findings", &self.findings)?;
        }
        if !wkt::internal::is_default(&self.findings_truncated) {
            state.serialize_entry("findingsTruncated", &self.findings_truncated)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a piece of potentially sensitive content.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Finding {
    /// Resource name in format
    /// projects/{project}/locations/{location}/findings/{finding} Populated only
    /// when viewing persisted findings.
    pub name: std::string::String,

    /// The content that was found. Even if the content is not textual, it
    /// may be converted to a textual representation here.
    /// Provided if `include_quote` is true and the finding is
    /// less than or equal to 4096 bytes long. If the finding exceeds 4096 bytes
    /// in length, the quote may be omitted.
    pub quote: std::string::String,

    /// The type of content that might have been found.
    /// Provided if `excluded_types` is false.
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Confidence of how likely it is that the `info_type` is correct.
    pub likelihood: crate::model::Likelihood,

    /// Where the content was found.
    pub location: std::option::Option<crate::model::Location>,

    /// Timestamp when finding was detected.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Contains data parsed from quotes. Only populated if include_quote was set
    /// to true and a supported infoType was requested. Currently supported
    /// infoTypes: DATE, DATE_OF_BIRTH and TIME.
    pub quote_info: std::option::Option<crate::model::QuoteInfo>,

    /// The job that stored the finding.
    pub resource_name: std::string::String,

    /// Job trigger name, if applicable, for this finding.
    pub trigger_name: std::string::String,

    /// The labels associated with this `Finding`.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// Label values must be between 0 and 63 characters long and must conform
    /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
    ///
    /// No more than 10 labels can be associated with a given finding.
    ///
    /// Examples:
    ///
    /// * `"environment" : "production"`
    /// * `"pipeline" : "etl"`
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Time the job started that produced this finding.
    pub job_create_time: std::option::Option<wkt::Timestamp>,

    /// The job that stored the finding.
    pub job_name: std::string::String,

    /// The unique finding id.
    pub finding_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Finding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Finding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [quote][crate::model::Finding::quote].
    pub fn set_quote<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.quote = v.into();
        self
    }

    /// Sets the value of [info_type][crate::model::Finding::info_type].
    pub fn set_info_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [info_type][crate::model::Finding::info_type].
    pub fn set_or_clear_info_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [likelihood][crate::model::Finding::likelihood].
    pub fn set_likelihood<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.likelihood = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Finding::location].
    pub fn set_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Location>,
    {
        self.location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location][crate::model::Finding::location].
    pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Location>,
    {
        self.location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Finding::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Finding::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [quote_info][crate::model::Finding::quote_info].
    pub fn set_quote_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuoteInfo>,
    {
        self.quote_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quote_info][crate::model::Finding::quote_info].
    pub fn set_or_clear_quote_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuoteInfo>,
    {
        self.quote_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_name][crate::model::Finding::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [trigger_name][crate::model::Finding::trigger_name].
    pub fn set_trigger_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Finding::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [job_create_time][crate::model::Finding::job_create_time].
    pub fn set_job_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.job_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job_create_time][crate::model::Finding::job_create_time].
    pub fn set_or_clear_job_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.job_create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [job_name][crate::model::Finding::job_name].
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_name = v.into();
        self
    }

    /// Sets the value of [finding_id][crate::model::Finding::finding_id].
    pub fn set_finding_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_id = v.into();
        self
    }
}

impl wkt::message::Message for Finding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Finding"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Finding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __quote,
            __info_type,
            __likelihood,
            __location,
            __create_time,
            __quote_info,
            __resource_name,
            __trigger_name,
            __labels,
            __job_create_time,
            __job_name,
            __finding_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Finding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "quote" => Ok(__FieldTag::__quote),
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            "likelihood" => Ok(__FieldTag::__likelihood),
                            "location" => Ok(__FieldTag::__location),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "quoteInfo" => Ok(__FieldTag::__quote_info),
                            "quote_info" => Ok(__FieldTag::__quote_info),
                            "resourceName" => Ok(__FieldTag::__resource_name),
                            "resource_name" => Ok(__FieldTag::__resource_name),
                            "triggerName" => Ok(__FieldTag::__trigger_name),
                            "trigger_name" => Ok(__FieldTag::__trigger_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "jobCreateTime" => Ok(__FieldTag::__job_create_time),
                            "job_create_time" => Ok(__FieldTag::__job_create_time),
                            "jobName" => Ok(__FieldTag::__job_name),
                            "job_name" => Ok(__FieldTag::__job_name),
                            "findingId" => Ok(__FieldTag::__finding_id),
                            "finding_id" => Ok(__FieldTag::__finding_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Finding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Finding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quote => {
                            if !fields.insert(__FieldTag::__quote) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quote",
                                ));
                            }
                            result.quote = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type",
                                ));
                            }
                            result.info_type =
                                map.next_value::<std::option::Option<crate::model::InfoType>>()?;
                        }
                        __FieldTag::__likelihood => {
                            if !fields.insert(__FieldTag::__likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for likelihood",
                                ));
                            }
                            result.likelihood = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location =
                                map.next_value::<std::option::Option<crate::model::Location>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__quote_info => {
                            if !fields.insert(__FieldTag::__quote_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quote_info",
                                ));
                            }
                            result.quote_info =
                                map.next_value::<std::option::Option<crate::model::QuoteInfo>>()?;
                        }
                        __FieldTag::__resource_name => {
                            if !fields.insert(__FieldTag::__resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_name",
                                ));
                            }
                            result.resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_name => {
                            if !fields.insert(__FieldTag::__trigger_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_name",
                                ));
                            }
                            result.trigger_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_create_time => {
                            if !fields.insert(__FieldTag::__job_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_create_time",
                                ));
                            }
                            result.job_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__job_name => {
                            if !fields.insert(__FieldTag::__job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_name",
                                ));
                            }
                            result.job_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__finding_id => {
                            if !fields.insert(__FieldTag::__finding_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding_id",
                                ));
                            }
                            result.finding_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Finding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.quote.is_empty() {
            state.serialize_entry("quote", &self.quote)?;
        }
        if self.info_type.is_some() {
            state.serialize_entry("infoType", &self.info_type)?;
        }
        if !wkt::internal::is_default(&self.likelihood) {
            state.serialize_entry("likelihood", &self.likelihood)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.quote_info.is_some() {
            state.serialize_entry("quoteInfo", &self.quote_info)?;
        }
        if !self.resource_name.is_empty() {
            state.serialize_entry("resourceName", &self.resource_name)?;
        }
        if !self.trigger_name.is_empty() {
            state.serialize_entry("triggerName", &self.trigger_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.job_create_time.is_some() {
            state.serialize_entry("jobCreateTime", &self.job_create_time)?;
        }
        if !self.job_name.is_empty() {
            state.serialize_entry("jobName", &self.job_name)?;
        }
        if !self.finding_id.is_empty() {
            state.serialize_entry("findingId", &self.finding_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specifies the location of the finding.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Location {
    /// Zero-based byte offsets delimiting the finding.
    /// These are relative to the finding's containing element.
    /// Note that when the content is not textual, this references
    /// the UTF-8 encoded textual representation of the content.
    /// Omitted if content is an image.
    pub byte_range: std::option::Option<crate::model::Range>,

    /// Unicode character offsets delimiting the finding.
    /// These are relative to the finding's containing element.
    /// Provided when the content is text.
    pub codepoint_range: std::option::Option<crate::model::Range>,

    /// List of nested objects pointing to the precise location of the finding
    /// within the file or record.
    pub content_locations: std::vec::Vec<crate::model::ContentLocation>,

    /// Information about the container where this finding occurred, if available.
    pub container: std::option::Option<crate::model::Container>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Location {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [byte_range][crate::model::Location::byte_range].
    pub fn set_byte_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Range>,
    {
        self.byte_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [byte_range][crate::model::Location::byte_range].
    pub fn set_or_clear_byte_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Range>,
    {
        self.byte_range = v.map(|x| x.into());
        self
    }

    /// Sets the value of [codepoint_range][crate::model::Location::codepoint_range].
    pub fn set_codepoint_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Range>,
    {
        self.codepoint_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [codepoint_range][crate::model::Location::codepoint_range].
    pub fn set_or_clear_codepoint_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Range>,
    {
        self.codepoint_range = v.map(|x| x.into());
        self
    }

    /// Sets the value of [content_locations][crate::model::Location::content_locations].
    pub fn set_content_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ContentLocation>,
    {
        use std::iter::Iterator;
        self.content_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [container][crate::model::Location::container].
    pub fn set_container<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Container>,
    {
        self.container = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [container][crate::model::Location::container].
    pub fn set_or_clear_container<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Container>,
    {
        self.container = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Location {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Location"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Location {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __byte_range,
            __codepoint_range,
            __content_locations,
            __container,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Location")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "byteRange" => Ok(__FieldTag::__byte_range),
                            "byte_range" => Ok(__FieldTag::__byte_range),
                            "codepointRange" => Ok(__FieldTag::__codepoint_range),
                            "codepoint_range" => Ok(__FieldTag::__codepoint_range),
                            "contentLocations" => Ok(__FieldTag::__content_locations),
                            "content_locations" => Ok(__FieldTag::__content_locations),
                            "container" => Ok(__FieldTag::__container),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Location;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Location")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__byte_range => {
                            if !fields.insert(__FieldTag::__byte_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for byte_range",
                                ));
                            }
                            result.byte_range =
                                map.next_value::<std::option::Option<crate::model::Range>>()?;
                        }
                        __FieldTag::__codepoint_range => {
                            if !fields.insert(__FieldTag::__codepoint_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for codepoint_range",
                                ));
                            }
                            result.codepoint_range =
                                map.next_value::<std::option::Option<crate::model::Range>>()?;
                        }
                        __FieldTag::__content_locations => {
                            if !fields.insert(__FieldTag::__content_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_locations",
                                ));
                            }
                            result.content_locations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ContentLocation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container => {
                            if !fields.insert(__FieldTag::__container) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container",
                                ));
                            }
                            result.container =
                                map.next_value::<std::option::Option<crate::model::Container>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Location {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.byte_range.is_some() {
            state.serialize_entry("byteRange", &self.byte_range)?;
        }
        if self.codepoint_range.is_some() {
            state.serialize_entry("codepointRange", &self.codepoint_range)?;
        }
        if !self.content_locations.is_empty() {
            state.serialize_entry("contentLocations", &self.content_locations)?;
        }
        if self.container.is_some() {
            state.serialize_entry("container", &self.container)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Precise location of the finding within a document, record, image, or metadata
/// container.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ContentLocation {
    /// Name of the container where the finding is located.
    /// The top level name is the source file name or table name. Names of some
    /// common storage containers are formatted as follows:
    ///
    /// * BigQuery tables:  `{project_id}:{dataset_id}.{table_id}`
    /// * Cloud Storage files: `gs://{bucket}/{path}`
    /// * Datastore namespace: {namespace}
    ///
    /// Nested names could be absent if the embedded object has no string
    /// identifier (for example, an image contained within a document).
    pub container_name: std::string::String,

    /// Finding container modification timestamp, if applicable. For Cloud Storage,
    /// this field contains the last file modification timestamp. For a BigQuery
    /// table, this field contains the last_modified_time property. For Datastore,
    /// this field isn't populated.
    pub container_timestamp: std::option::Option<wkt::Timestamp>,

    /// Finding container version, if available
    /// ("generation" for Cloud Storage).
    pub container_version: std::string::String,

    /// Type of the container within the file with location of the finding.
    pub location: std::option::Option<crate::model::content_location::Location>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContentLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_name][crate::model::ContentLocation::container_name].
    pub fn set_container_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_name = v.into();
        self
    }

    /// Sets the value of [container_timestamp][crate::model::ContentLocation::container_timestamp].
    pub fn set_container_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.container_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [container_timestamp][crate::model::ContentLocation::container_timestamp].
    pub fn set_or_clear_container_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.container_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [container_version][crate::model::ContentLocation::container_version].
    pub fn set_container_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_version = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ContentLocation::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::content_location::Location>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `RecordLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn record_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecordLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::RecordLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `RecordLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_record_location<
        T: std::convert::Into<std::boxed::Box<crate::model::RecordLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::RecordLocation(v.into()),
        );
        self
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `ImageLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImageLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::ImageLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `ImageLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_image_location<
        T: std::convert::Into<std::boxed::Box<crate::model::ImageLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::ImageLocation(v.into()),
        );
        self
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `DocumentLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn document_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DocumentLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::DocumentLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `DocumentLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_document_location<
        T: std::convert::Into<std::boxed::Box<crate::model::DocumentLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::DocumentLocation(v.into()),
        );
        self
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `MetadataLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn metadata_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MetadataLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::MetadataLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `MetadataLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_metadata_location<
        T: std::convert::Into<std::boxed::Box<crate::model::MetadataLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::MetadataLocation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ContentLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ContentLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ContentLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __container_name,
            __record_location,
            __image_location,
            __document_location,
            __metadata_location,
            __container_timestamp,
            __container_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContentLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "containerName" => Ok(__FieldTag::__container_name),
                            "container_name" => Ok(__FieldTag::__container_name),
                            "recordLocation" => Ok(__FieldTag::__record_location),
                            "record_location" => Ok(__FieldTag::__record_location),
                            "imageLocation" => Ok(__FieldTag::__image_location),
                            "image_location" => Ok(__FieldTag::__image_location),
                            "documentLocation" => Ok(__FieldTag::__document_location),
                            "document_location" => Ok(__FieldTag::__document_location),
                            "metadataLocation" => Ok(__FieldTag::__metadata_location),
                            "metadata_location" => Ok(__FieldTag::__metadata_location),
                            "containerTimestamp" => Ok(__FieldTag::__container_timestamp),
                            "container_timestamp" => Ok(__FieldTag::__container_timestamp),
                            "containerVersion" => Ok(__FieldTag::__container_version),
                            "container_version" => Ok(__FieldTag::__container_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ContentLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContentLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__container_name => {
                            if !fields.insert(__FieldTag::__container_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_name",
                                ));
                            }
                            result.container_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__record_location => {
                            if !fields.insert(__FieldTag::__record_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for record_location",
                                ));
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .google.privacy.dlp.v2.ContentLocation.record_location, latest field was recordLocation",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::content_location::Location::RecordLocation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RecordLocation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__image_location => {
                            if !fields.insert(__FieldTag::__image_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_location",
                                ));
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .google.privacy.dlp.v2.ContentLocation.image_location, latest field was imageLocation",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::content_location::Location::ImageLocation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ImageLocation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__document_location => {
                            if !fields.insert(__FieldTag::__document_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_location",
                                ));
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .google.privacy.dlp.v2.ContentLocation.document_location, latest field was documentLocation",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::content_location::Location::DocumentLocation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DocumentLocation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__metadata_location => {
                            if !fields.insert(__FieldTag::__metadata_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_location",
                                ));
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .google.privacy.dlp.v2.ContentLocation.metadata_location, latest field was metadataLocation",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::content_location::Location::MetadataLocation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MetadataLocation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__container_timestamp => {
                            if !fields.insert(__FieldTag::__container_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_timestamp",
                                ));
                            }
                            result.container_timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__container_version => {
                            if !fields.insert(__FieldTag::__container_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_version",
                                ));
                            }
                            result.container_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ContentLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.container_name.is_empty() {
            state.serialize_entry("containerName", &self.container_name)?;
        }
        if let Some(value) = self.record_location() {
            state.serialize_entry("recordLocation", value)?;
        }
        if let Some(value) = self.image_location() {
            state.serialize_entry("imageLocation", value)?;
        }
        if let Some(value) = self.document_location() {
            state.serialize_entry("documentLocation", value)?;
        }
        if let Some(value) = self.metadata_location() {
            state.serialize_entry("metadataLocation", value)?;
        }
        if self.container_timestamp.is_some() {
            state.serialize_entry("containerTimestamp", &self.container_timestamp)?;
        }
        if !self.container_version.is_empty() {
            state.serialize_entry("containerVersion", &self.container_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ContentLocation].
pub mod content_location {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the container within the file with location of the finding.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Location {
        /// Location within a row or record of a database table.
        RecordLocation(std::boxed::Box<crate::model::RecordLocation>),
        /// Location within an image's pixels.
        ImageLocation(std::boxed::Box<crate::model::ImageLocation>),
        /// Location data for document files.
        DocumentLocation(std::boxed::Box<crate::model::DocumentLocation>),
        /// Location within the metadata for inspected content.
        MetadataLocation(std::boxed::Box<crate::model::MetadataLocation>),
    }
}

/// Metadata Location
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MetadataLocation {
    /// Type of metadata containing the finding.
    pub r#type: crate::model::MetadataType,

    /// Label of the piece of metadata containing the finding, for example -
    /// latitude, author, caption.
    pub label: std::option::Option<crate::model::metadata_location::Label>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetadataLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::MetadataLocation::type].
    pub fn set_type<T: std::convert::Into<crate::model::MetadataType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [label][crate::model::MetadataLocation::label].
    ///
    /// Note that all the setters affecting `label` are mutually
    /// exclusive.
    pub fn set_label<
        T: std::convert::Into<std::option::Option<crate::model::metadata_location::Label>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.label = v.into();
        self
    }

    /// The value of [label][crate::model::MetadataLocation::label]
    /// if it holds a `StorageLabel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_label(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageMetadataLabel>> {
        #[allow(unreachable_patterns)]
        self.label.as_ref().and_then(|v| match v {
            crate::model::metadata_location::Label::StorageLabel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [label][crate::model::MetadataLocation::label]
    /// to hold a `StorageLabel`.
    ///
    /// Note that all the setters affecting `label` are
    /// mutually exclusive.
    pub fn set_storage_label<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageMetadataLabel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.label = std::option::Option::Some(
            crate::model::metadata_location::Label::StorageLabel(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MetadataLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.MetadataLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MetadataLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __storage_label,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MetadataLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "storageLabel" => Ok(__FieldTag::__storage_label),
                            "storage_label" => Ok(__FieldTag::__storage_label),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MetadataLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MetadataLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::MetadataType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_label => {
                            if !fields.insert(__FieldTag::__storage_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_label",
                                ));
                            }
                            if result.label.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `label`, a oneof with full ID .google.privacy.dlp.v2.MetadataLocation.storage_label, latest field was storageLabel",
                                ));
                            }
                            result.label = std::option::Option::Some(
                                crate::model::metadata_location::Label::StorageLabel(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StorageMetadataLabel>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MetadataLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if let Some(value) = self.storage_label() {
            state.serialize_entry("storageLabel", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MetadataLocation].
pub mod metadata_location {
    #[allow(unused_imports)]
    use super::*;

    /// Label of the piece of metadata containing the finding, for example -
    /// latitude, author, caption.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Label {
        /// Storage metadata.
        StorageLabel(std::boxed::Box<crate::model::StorageMetadataLabel>),
    }
}

/// Storage metadata label to indicate which metadata entry contains findings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageMetadataLabel {
    /// Label name.
    pub key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageMetadataLabel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::StorageMetadataLabel::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for StorageMetadataLabel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StorageMetadataLabel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageMetadataLabel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageMetadataLabel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageMetadataLabel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageMetadataLabel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageMetadataLabel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Location of a finding within a document.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DocumentLocation {
    /// Offset of the line, from the beginning of the file, where the finding
    /// is located.
    pub file_offset: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DocumentLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_offset][crate::model::DocumentLocation::file_offset].
    pub fn set_file_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.file_offset = v.into();
        self
    }
}

impl wkt::message::Message for DocumentLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DocumentLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DocumentLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_offset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileOffset" => Ok(__FieldTag::__file_offset),
                            "file_offset" => Ok(__FieldTag::__file_offset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DocumentLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_offset => {
                            if !fields.insert(__FieldTag::__file_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_offset",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.file_offset = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DocumentLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.file_offset) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fileOffset", &__With(&self.file_offset))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Location of a finding within a row or record.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecordLocation {
    /// Key of the finding.
    pub record_key: std::option::Option<crate::model::RecordKey>,

    /// Field id of the field containing the finding.
    pub field_id: std::option::Option<crate::model::FieldId>,

    /// Location within a `ContentItem.Table`.
    pub table_location: std::option::Option<crate::model::TableLocation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [record_key][crate::model::RecordLocation::record_key].
    pub fn set_record_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecordKey>,
    {
        self.record_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [record_key][crate::model::RecordLocation::record_key].
    pub fn set_or_clear_record_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecordKey>,
    {
        self.record_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field_id][crate::model::RecordLocation::field_id].
    pub fn set_field_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field_id][crate::model::RecordLocation::field_id].
    pub fn set_or_clear_field_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [table_location][crate::model::RecordLocation::table_location].
    pub fn set_table_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableLocation>,
    {
        self.table_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table_location][crate::model::RecordLocation::table_location].
    pub fn set_or_clear_table_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableLocation>,
    {
        self.table_location = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RecordLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecordLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __record_key,
            __field_id,
            __table_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecordLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recordKey" => Ok(__FieldTag::__record_key),
                            "record_key" => Ok(__FieldTag::__record_key),
                            "fieldId" => Ok(__FieldTag::__field_id),
                            "field_id" => Ok(__FieldTag::__field_id),
                            "tableLocation" => Ok(__FieldTag::__table_location),
                            "table_location" => Ok(__FieldTag::__table_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecordLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecordLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__record_key => {
                            if !fields.insert(__FieldTag::__record_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for record_key",
                                ));
                            }
                            result.record_key =
                                map.next_value::<std::option::Option<crate::model::RecordKey>>()?;
                        }
                        __FieldTag::__field_id => {
                            if !fields.insert(__FieldTag::__field_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_id",
                                ));
                            }
                            result.field_id =
                                map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                        }
                        __FieldTag::__table_location => {
                            if !fields.insert(__FieldTag::__table_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_location",
                                ));
                            }
                            result.table_location = map
                                .next_value::<std::option::Option<crate::model::TableLocation>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecordLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.record_key.is_some() {
            state.serialize_entry("recordKey", &self.record_key)?;
        }
        if self.field_id.is_some() {
            state.serialize_entry("fieldId", &self.field_id)?;
        }
        if self.table_location.is_some() {
            state.serialize_entry("tableLocation", &self.table_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Location of a finding within a table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TableLocation {
    /// The zero-based index of the row where the finding is located. Only
    /// populated for resources that have a natural ordering, not BigQuery. In
    /// BigQuery, to identify the row a finding came from, populate
    /// BigQueryOptions.identifying_fields with your primary key column names and
    /// when you store the findings the value of those columns will be stored
    /// inside of Finding.
    pub row_index: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [row_index][crate::model::TableLocation::row_index].
    pub fn set_row_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_index = v.into();
        self
    }
}

impl wkt::message::Message for TableLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __row_index,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rowIndex" => Ok(__FieldTag::__row_index),
                            "row_index" => Ok(__FieldTag::__row_index),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__row_index => {
                            if !fields.insert(__FieldTag::__row_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_index",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.row_index = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.row_index) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rowIndex", &__With(&self.row_index))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a container that may contain DLP findings.
/// Examples of a container include a file, table, or database record.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Container {
    /// Container type, for example BigQuery or Cloud Storage.
    pub r#type: std::string::String,

    /// Project where the finding was found.
    /// Can be different from the project that owns the finding.
    pub project_id: std::string::String,

    /// A string representation of the full container name.
    /// Examples:
    ///
    /// - BigQuery: 'Project:DataSetId.TableId'
    /// - Cloud Storage: 'gs://Bucket/folders/filename.txt'
    pub full_path: std::string::String,

    /// The root of the container.
    /// Examples:
    ///
    /// - For BigQuery table `project_id:dataset_id.table_id`, the root is
    ///   `dataset_id`
    /// - For Cloud Storage file `gs://bucket/folder/filename.txt`, the root
    ///   is `gs://bucket`
    pub root_path: std::string::String,

    /// The rest of the path after the root.
    /// Examples:
    ///
    /// - For BigQuery table `project_id:dataset_id.table_id`, the relative path is
    ///   `table_id`
    /// - For Cloud Storage file `gs://bucket/folder/filename.txt`, the relative
    ///   path is `folder/filename.txt`
    pub relative_path: std::string::String,

    /// Findings container modification timestamp, if applicable. For Cloud
    /// Storage, this field contains the last file modification timestamp. For a
    /// BigQuery table, this field contains the last_modified_time property. For
    /// Datastore, this field isn't populated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Findings container version, if available
    /// ("generation" for Cloud Storage).
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Container {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Container::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::Container::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [full_path][crate::model::Container::full_path].
    pub fn set_full_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_path = v.into();
        self
    }

    /// Sets the value of [root_path][crate::model::Container::root_path].
    pub fn set_root_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_path = v.into();
        self
    }

    /// Sets the value of [relative_path][crate::model::Container::relative_path].
    pub fn set_relative_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_path = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Container::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Container::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version][crate::model::Container::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for Container {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Container"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Container {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __project_id,
            __full_path,
            __root_path,
            __relative_path,
            __update_time,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Container")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "fullPath" => Ok(__FieldTag::__full_path),
                            "full_path" => Ok(__FieldTag::__full_path),
                            "rootPath" => Ok(__FieldTag::__root_path),
                            "root_path" => Ok(__FieldTag::__root_path),
                            "relativePath" => Ok(__FieldTag::__relative_path),
                            "relative_path" => Ok(__FieldTag::__relative_path),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Container;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Container")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__full_path => {
                            if !fields.insert(__FieldTag::__full_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_path",
                                ));
                            }
                            result.full_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__root_path => {
                            if !fields.insert(__FieldTag::__root_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_path",
                                ));
                            }
                            result.root_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relative_path => {
                            if !fields.insert(__FieldTag::__relative_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relative_path",
                                ));
                            }
                            result.relative_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Container {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.full_path.is_empty() {
            state.serialize_entry("fullPath", &self.full_path)?;
        }
        if !self.root_path.is_empty() {
            state.serialize_entry("rootPath", &self.root_path)?;
        }
        if !self.relative_path.is_empty() {
            state.serialize_entry("relativePath", &self.relative_path)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Generic half-open interval [start, end)
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Range {
    /// Index of the first character of the range (inclusive).
    pub start: i64,

    /// Index of the last character of the range (exclusive).
    pub end: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Range {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start][crate::model::Range::start].
    pub fn set_start<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.start = v.into();
        self
    }

    /// Sets the value of [end][crate::model::Range::end].
    pub fn set_end<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.end = v.into();
        self
    }
}

impl wkt::message::Message for Range {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Range"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Range {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start,
            __end,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Range")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "start" => Ok(__FieldTag::__start),
                            "end" => Ok(__FieldTag::__end),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Range;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Range")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start => {
                            if !fields.insert(__FieldTag::__start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__end => {
                            if !fields.insert(__FieldTag::__end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.end = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Range {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.start) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("start", &__With(&self.start))?;
        }
        if !wkt::internal::is_default(&self.end) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("end", &__With(&self.end))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Location of the finding within an image.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageLocation {
    /// Bounding boxes locating the pixels within the image containing the finding.
    pub bounding_boxes: std::vec::Vec<crate::model::BoundingBox>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bounding_boxes][crate::model::ImageLocation::bounding_boxes].
    pub fn set_bounding_boxes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BoundingBox>,
    {
        use std::iter::Iterator;
        self.bounding_boxes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImageLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ImageLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bounding_boxes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "boundingBoxes" => Ok(__FieldTag::__bounding_boxes),
                            "bounding_boxes" => Ok(__FieldTag::__bounding_boxes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bounding_boxes => {
                            if !fields.insert(__FieldTag::__bounding_boxes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bounding_boxes",
                                ));
                            }
                            result.bounding_boxes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BoundingBox>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bounding_boxes.is_empty() {
            state.serialize_entry("boundingBoxes", &self.bounding_boxes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Bounding box encompassing detected text within an image.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BoundingBox {
    /// Top coordinate of the bounding box. (0,0) is upper left.
    pub top: i32,

    /// Left coordinate of the bounding box. (0,0) is upper left.
    pub left: i32,

    /// Width of the bounding box in pixels.
    pub width: i32,

    /// Height of the bounding box in pixels.
    pub height: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BoundingBox {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [top][crate::model::BoundingBox::top].
    pub fn set_top<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.top = v.into();
        self
    }

    /// Sets the value of [left][crate::model::BoundingBox::left].
    pub fn set_left<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.left = v.into();
        self
    }

    /// Sets the value of [width][crate::model::BoundingBox::width].
    pub fn set_width<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.width = v.into();
        self
    }

    /// Sets the value of [height][crate::model::BoundingBox::height].
    pub fn set_height<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.height = v.into();
        self
    }
}

impl wkt::message::Message for BoundingBox {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BoundingBox"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BoundingBox {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __top,
            __left,
            __width,
            __height,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BoundingBox")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "top" => Ok(__FieldTag::__top),
                            "left" => Ok(__FieldTag::__left),
                            "width" => Ok(__FieldTag::__width),
                            "height" => Ok(__FieldTag::__height),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BoundingBox;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BoundingBox")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__top => {
                            if !fields.insert(__FieldTag::__top) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for top",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.top = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__left => {
                            if !fields.insert(__FieldTag::__left) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for left",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.left = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__width => {
                            if !fields.insert(__FieldTag::__width) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for width",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.width = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__height => {
                            if !fields.insert(__FieldTag::__height) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for height",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.height = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BoundingBox {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.top) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("top", &__With(&self.top))?;
        }
        if !wkt::internal::is_default(&self.left) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("left", &__With(&self.left))?;
        }
        if !wkt::internal::is_default(&self.width) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("width", &__With(&self.width))?;
        }
        if !wkt::internal::is_default(&self.height) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("height", &__With(&self.height))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to search for potentially sensitive info in an image and redact it
/// by covering it with a colored rectangle.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RedactImageRequest {
    /// Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    /// Configuration for the inspector.
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The configuration for specifying what content to redact from images.
    pub image_redaction_configs:
        std::vec::Vec<crate::model::redact_image_request::ImageRedactionConfig>,

    /// Whether the response should include findings along with the redacted
    /// image.
    pub include_findings: bool,

    /// The content must be PNG, JPEG, SVG or BMP.
    pub byte_item: std::option::Option<crate::model::ByteContentItem>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedactImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RedactImageRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::RedactImageRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::RedactImageRequest::inspect_config].
    pub fn set_inspect_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_config][crate::model::RedactImageRequest::inspect_config].
    pub fn set_or_clear_inspect_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [image_redaction_configs][crate::model::RedactImageRequest::image_redaction_configs].
    pub fn set_image_redaction_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::redact_image_request::ImageRedactionConfig>,
    {
        use std::iter::Iterator;
        self.image_redaction_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [include_findings][crate::model::RedactImageRequest::include_findings].
    pub fn set_include_findings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_findings = v.into();
        self
    }

    /// Sets the value of [byte_item][crate::model::RedactImageRequest::byte_item].
    pub fn set_byte_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ByteContentItem>,
    {
        self.byte_item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [byte_item][crate::model::RedactImageRequest::byte_item].
    pub fn set_or_clear_byte_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ByteContentItem>,
    {
        self.byte_item = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RedactImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RedactImageRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RedactImageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __location_id,
            __inspect_config,
            __image_redaction_configs,
            __include_findings,
            __byte_item,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RedactImageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            "inspectConfig" => Ok(__FieldTag::__inspect_config),
                            "inspect_config" => Ok(__FieldTag::__inspect_config),
                            "imageRedactionConfigs" => Ok(__FieldTag::__image_redaction_configs),
                            "image_redaction_configs" => Ok(__FieldTag::__image_redaction_configs),
                            "includeFindings" => Ok(__FieldTag::__include_findings),
                            "include_findings" => Ok(__FieldTag::__include_findings),
                            "byteItem" => Ok(__FieldTag::__byte_item),
                            "byte_item" => Ok(__FieldTag::__byte_item),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RedactImageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RedactImageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inspect_config => {
                            if !fields.insert(__FieldTag::__inspect_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_config",
                                ));
                            }
                            result.inspect_config = map
                                .next_value::<std::option::Option<crate::model::InspectConfig>>()?;
                        }
                        __FieldTag::__image_redaction_configs => {
                            if !fields.insert(__FieldTag::__image_redaction_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_redaction_configs",
                                ));
                            }
                            result.image_redaction_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::redact_image_request::ImageRedactionConfig,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__include_findings => {
                            if !fields.insert(__FieldTag::__include_findings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_findings",
                                ));
                            }
                            result.include_findings = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__byte_item => {
                            if !fields.insert(__FieldTag::__byte_item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for byte_item",
                                ));
                            }
                            result.byte_item = map
                                .next_value::<std::option::Option<crate::model::ByteContentItem>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RedactImageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if self.inspect_config.is_some() {
            state.serialize_entry("inspectConfig", &self.inspect_config)?;
        }
        if !self.image_redaction_configs.is_empty() {
            state.serialize_entry("imageRedactionConfigs", &self.image_redaction_configs)?;
        }
        if !wkt::internal::is_default(&self.include_findings) {
            state.serialize_entry("includeFindings", &self.include_findings)?;
        }
        if self.byte_item.is_some() {
            state.serialize_entry("byteItem", &self.byte_item)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RedactImageRequest].
pub mod redact_image_request {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for determining how redaction of images should occur.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ImageRedactionConfig {
        /// The color to use when redacting content from an image. If not specified,
        /// the default is black.
        pub redaction_color: std::option::Option<crate::model::Color>,

        /// Type of information to redact from images.
        pub target:
            std::option::Option<crate::model::redact_image_request::image_redaction_config::Target>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImageRedactionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [redaction_color][crate::model::redact_image_request::ImageRedactionConfig::redaction_color].
        pub fn set_redaction_color<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Color>,
        {
            self.redaction_color = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [redaction_color][crate::model::redact_image_request::ImageRedactionConfig::redaction_color].
        pub fn set_or_clear_redaction_color<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Color>,
        {
            self.redaction_color = v.map(|x| x.into());
            self
        }

        /// Sets the value of [target][crate::model::redact_image_request::ImageRedactionConfig::target].
        ///
        /// Note that all the setters affecting `target` are mutually
        /// exclusive.
        pub fn set_target<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::redact_image_request::image_redaction_config::Target,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = v.into();
            self
        }

        /// The value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// if it holds a `InfoType`, `None` if the field is not set or
        /// holds a different branch.
        pub fn info_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::InfoType>> {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::redact_image_request::image_redaction_config::Target::InfoType(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// to hold a `InfoType`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_info_type<T: std::convert::Into<std::boxed::Box<crate::model::InfoType>>>(
            mut self,
            v: T,
        ) -> Self {
            self.target = std::option::Option::Some(
                crate::model::redact_image_request::image_redaction_config::Target::InfoType(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// if it holds a `RedactAllText`, `None` if the field is not set or
        /// holds a different branch.
        pub fn redact_all_text(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::redact_image_request::image_redaction_config::Target::RedactAllText(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// to hold a `RedactAllText`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_redact_all_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.target = std::option::Option::Some(
                crate::model::redact_image_request::image_redaction_config::Target::RedactAllText(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for ImageRedactionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RedactImageRequest.ImageRedactionConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ImageRedactionConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __info_type,
                __redact_all_text,
                __redaction_color,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ImageRedactionConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "infoType" => Ok(__FieldTag::__info_type),
                                "info_type" => Ok(__FieldTag::__info_type),
                                "redactAllText" => Ok(__FieldTag::__redact_all_text),
                                "redact_all_text" => Ok(__FieldTag::__redact_all_text),
                                "redactionColor" => Ok(__FieldTag::__redaction_color),
                                "redaction_color" => Ok(__FieldTag::__redaction_color),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ImageRedactionConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ImageRedactionConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__info_type => {
                                if !fields.insert(__FieldTag::__info_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for info_type",
                                    ));
                                }
                                if result.target.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `target`, a oneof with full ID .google.privacy.dlp.v2.RedactImageRequest.ImageRedactionConfig.info_type, latest field was infoType",
                                    ));
                                }
                                result.target = std::option::Option::Some(
                                    crate::model::redact_image_request::image_redaction_config::Target::InfoType(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::InfoType>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__redact_all_text => {
                                if !fields.insert(__FieldTag::__redact_all_text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for redact_all_text",
                                    ));
                                }
                                if result.target.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `target`, a oneof with full ID .google.privacy.dlp.v2.RedactImageRequest.ImageRedactionConfig.redact_all_text, latest field was redactAllText",
                                    ));
                                }
                                result.target = std::option::Option::Some(
                                    crate::model::redact_image_request::image_redaction_config::Target::RedactAllText(
                                        map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__redaction_color => {
                                if !fields.insert(__FieldTag::__redaction_color) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for redaction_color",
                                    ));
                                }
                                result.redaction_color =
                                    map.next_value::<std::option::Option<crate::model::Color>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ImageRedactionConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.info_type() {
                state.serialize_entry("infoType", value)?;
            }
            if let Some(value) = self.redact_all_text() {
                state.serialize_entry("redactAllText", value)?;
            }
            if self.redaction_color.is_some() {
                state.serialize_entry("redactionColor", &self.redaction_color)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ImageRedactionConfig].
    pub mod image_redaction_config {
        #[allow(unused_imports)]
        use super::*;

        /// Type of information to redact from images.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Target {
            /// Only one per info_type should be provided per request. If not
            /// specified, and redact_all_text is false, the DLP API will redact all
            /// text that it matches against all info_types that are found, but not
            /// specified in another ImageRedactionConfig.
            InfoType(std::boxed::Box<crate::model::InfoType>),
            /// If true, all text found in the image, regardless whether it matches an
            /// info_type, is redacted. Only one should be provided.
            RedactAllText(bool),
        }
    }
}

/// Represents a color in the RGB color space.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Color {
    /// The amount of red in the color as a value in the interval [0, 1].
    pub red: f32,

    /// The amount of green in the color as a value in the interval [0, 1].
    pub green: f32,

    /// The amount of blue in the color as a value in the interval [0, 1].
    pub blue: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Color {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [red][crate::model::Color::red].
    pub fn set_red<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.red = v.into();
        self
    }

    /// Sets the value of [green][crate::model::Color::green].
    pub fn set_green<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.green = v.into();
        self
    }

    /// Sets the value of [blue][crate::model::Color::blue].
    pub fn set_blue<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.blue = v.into();
        self
    }
}

impl wkt::message::Message for Color {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Color"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Color {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __red,
            __green,
            __blue,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Color")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "red" => Ok(__FieldTag::__red),
                            "green" => Ok(__FieldTag::__green),
                            "blue" => Ok(__FieldTag::__blue),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Color;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Color")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__red => {
                            if !fields.insert(__FieldTag::__red) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for red",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.red = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__green => {
                            if !fields.insert(__FieldTag::__green) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for green",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.green = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__blue => {
                            if !fields.insert(__FieldTag::__blue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blue",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.blue = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Color {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.red) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("red", &__With(&self.red))?;
        }
        if !wkt::internal::is_default(&self.green) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("green", &__With(&self.green))?;
        }
        if !wkt::internal::is_default(&self.blue) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("blue", &__With(&self.blue))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Results of redacting an image.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RedactImageResponse {
    /// The redacted image. The type will be the same as the original image.
    pub redacted_image: ::bytes::Bytes,

    /// If an image was being inspected and the InspectConfig's include_quote was
    /// set to true, then this field will include all text, if any, that was found
    /// in the image.
    pub extracted_text: std::string::String,

    /// The findings. Populated when include_findings in the request is true.
    pub inspect_result: std::option::Option<crate::model::InspectResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedactImageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [redacted_image][crate::model::RedactImageResponse::redacted_image].
    pub fn set_redacted_image<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.redacted_image = v.into();
        self
    }

    /// Sets the value of [extracted_text][crate::model::RedactImageResponse::extracted_text].
    pub fn set_extracted_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.extracted_text = v.into();
        self
    }

    /// Sets the value of [inspect_result][crate::model::RedactImageResponse::inspect_result].
    pub fn set_inspect_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InspectResult>,
    {
        self.inspect_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_result][crate::model::RedactImageResponse::inspect_result].
    pub fn set_or_clear_inspect_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InspectResult>,
    {
        self.inspect_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RedactImageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RedactImageResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RedactImageResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __redacted_image,
            __extracted_text,
            __inspect_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RedactImageResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "redactedImage" => Ok(__FieldTag::__redacted_image),
                            "redacted_image" => Ok(__FieldTag::__redacted_image),
                            "extractedText" => Ok(__FieldTag::__extracted_text),
                            "extracted_text" => Ok(__FieldTag::__extracted_text),
                            "inspectResult" => Ok(__FieldTag::__inspect_result),
                            "inspect_result" => Ok(__FieldTag::__inspect_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RedactImageResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RedactImageResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__redacted_image => {
                            if !fields.insert(__FieldTag::__redacted_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redacted_image",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.redacted_image =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__extracted_text => {
                            if !fields.insert(__FieldTag::__extracted_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extracted_text",
                                ));
                            }
                            result.extracted_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inspect_result => {
                            if !fields.insert(__FieldTag::__inspect_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_result",
                                ));
                            }
                            result.inspect_result = map
                                .next_value::<std::option::Option<crate::model::InspectResult>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RedactImageResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.redacted_image.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("redactedImage", &__With(&self.redacted_image))?;
        }
        if !self.extracted_text.is_empty() {
            state.serialize_entry("extractedText", &self.extracted_text)?;
        }
        if self.inspect_result.is_some() {
            state.serialize_entry("inspectResult", &self.inspect_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to de-identify a ContentItem.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeidentifyContentRequest {
    /// Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Configuration for the de-identification of the content item.
    /// Items specified here will override the template referenced by the
    /// deidentify_template_name argument.
    pub deidentify_config: std::option::Option<crate::model::DeidentifyConfig>,

    /// Configuration for the inspector.
    /// Items specified here will override the template referenced by the
    /// inspect_template_name argument.
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The item to de-identify. Will be treated as text.
    ///
    /// This value must be of type
    /// [Table][google.privacy.dlp.v2.Table] if your
    /// [deidentify_config][google.privacy.dlp.v2.DeidentifyContentRequest.deidentify_config]
    /// is a
    /// [RecordTransformations][google.privacy.dlp.v2.RecordTransformations]
    /// object.
    ///
    /// [google.privacy.dlp.v2.DeidentifyContentRequest.deidentify_config]: crate::model::DeidentifyContentRequest::deidentify_config
    /// [google.privacy.dlp.v2.RecordTransformations]: crate::model::RecordTransformations
    /// [google.privacy.dlp.v2.Table]: crate::model::Table
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Template to use. Any configuration directly specified in
    /// inspect_config will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    pub inspect_template_name: std::string::String,

    /// Template to use. Any configuration directly specified in
    /// deidentify_config will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    pub deidentify_template_name: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::DeidentifyContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deidentify_config][crate::model::DeidentifyContentRequest::deidentify_config].
    pub fn set_deidentify_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyConfig>,
    {
        self.deidentify_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deidentify_config][crate::model::DeidentifyContentRequest::deidentify_config].
    pub fn set_or_clear_deidentify_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyConfig>,
    {
        self.deidentify_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_config][crate::model::DeidentifyContentRequest::inspect_config].
    pub fn set_inspect_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_config][crate::model::DeidentifyContentRequest::inspect_config].
    pub fn set_or_clear_inspect_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [item][crate::model::DeidentifyContentRequest::item].
    pub fn set_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [item][crate::model::DeidentifyContentRequest::item].
    pub fn set_or_clear_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::DeidentifyContentRequest::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [deidentify_template_name][crate::model::DeidentifyContentRequest::deidentify_template_name].
    pub fn set_deidentify_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template_name = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::DeidentifyContentRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyContentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeidentifyContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __deidentify_config,
            __inspect_config,
            __item,
            __inspect_template_name,
            __deidentify_template_name,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeidentifyContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "deidentifyConfig" => Ok(__FieldTag::__deidentify_config),
                            "deidentify_config" => Ok(__FieldTag::__deidentify_config),
                            "inspectConfig" => Ok(__FieldTag::__inspect_config),
                            "inspect_config" => Ok(__FieldTag::__inspect_config),
                            "item" => Ok(__FieldTag::__item),
                            "inspectTemplateName" => Ok(__FieldTag::__inspect_template_name),
                            "inspect_template_name" => Ok(__FieldTag::__inspect_template_name),
                            "deidentifyTemplateName" => Ok(__FieldTag::__deidentify_template_name),
                            "deidentify_template_name" => {
                                Ok(__FieldTag::__deidentify_template_name)
                            }
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeidentifyContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeidentifyContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deidentify_config => {
                            if !fields.insert(__FieldTag::__deidentify_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_config",
                                ));
                            }
                            result.deidentify_config = map
                                .next_value::<std::option::Option<crate::model::DeidentifyConfig>>(
                                )?;
                        }
                        __FieldTag::__inspect_config => {
                            if !fields.insert(__FieldTag::__inspect_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_config",
                                ));
                            }
                            result.inspect_config = map
                                .next_value::<std::option::Option<crate::model::InspectConfig>>()?;
                        }
                        __FieldTag::__item => {
                            if !fields.insert(__FieldTag::__item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for item",
                                ));
                            }
                            result.item =
                                map.next_value::<std::option::Option<crate::model::ContentItem>>()?;
                        }
                        __FieldTag::__inspect_template_name => {
                            if !fields.insert(__FieldTag::__inspect_template_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template_name",
                                ));
                            }
                            result.inspect_template_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deidentify_template_name => {
                            if !fields.insert(__FieldTag::__deidentify_template_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_template_name",
                                ));
                            }
                            result.deidentify_template_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeidentifyContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.deidentify_config.is_some() {
            state.serialize_entry("deidentifyConfig", &self.deidentify_config)?;
        }
        if self.inspect_config.is_some() {
            state.serialize_entry("inspectConfig", &self.inspect_config)?;
        }
        if self.item.is_some() {
            state.serialize_entry("item", &self.item)?;
        }
        if !self.inspect_template_name.is_empty() {
            state.serialize_entry("inspectTemplateName", &self.inspect_template_name)?;
        }
        if !self.deidentify_template_name.is_empty() {
            state.serialize_entry("deidentifyTemplateName", &self.deidentify_template_name)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Results of de-identifying a ContentItem.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeidentifyContentResponse {
    /// The de-identified item.
    pub item: std::option::Option<crate::model::ContentItem>,

    /// An overview of the changes that were made on the `item`.
    pub overview: std::option::Option<crate::model::TransformationOverview>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [item][crate::model::DeidentifyContentResponse::item].
    pub fn set_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [item][crate::model::DeidentifyContentResponse::item].
    pub fn set_or_clear_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = v.map(|x| x.into());
        self
    }

    /// Sets the value of [overview][crate::model::DeidentifyContentResponse::overview].
    pub fn set_overview<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransformationOverview>,
    {
        self.overview = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [overview][crate::model::DeidentifyContentResponse::overview].
    pub fn set_or_clear_overview<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransformationOverview>,
    {
        self.overview = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeidentifyContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyContentResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeidentifyContentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __item,
            __overview,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeidentifyContentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "item" => Ok(__FieldTag::__item),
                            "overview" => Ok(__FieldTag::__overview),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeidentifyContentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeidentifyContentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__item => {
                            if !fields.insert(__FieldTag::__item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for item",
                                ));
                            }
                            result.item =
                                map.next_value::<std::option::Option<crate::model::ContentItem>>()?;
                        }
                        __FieldTag::__overview => {
                            if !fields.insert(__FieldTag::__overview) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overview",
                                ));
                            }
                            result.overview = map.next_value::<std::option::Option<crate::model::TransformationOverview>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeidentifyContentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.item.is_some() {
            state.serialize_entry("item", &self.item)?;
        }
        if self.overview.is_some() {
            state.serialize_entry("overview", &self.overview)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to re-identify an item.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReidentifyContentRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Configuration for the re-identification of the content item.
    /// This field shares the same proto message type that is used for
    /// de-identification, however its usage here is for the reversal of the
    /// previous de-identification. Re-identification is performed by examining
    /// the transformations used to de-identify the items and executing the
    /// reverse. This requires that only reversible transformations
    /// be provided here. The reversible transformations are:
    ///
    /// - `CryptoDeterministicConfig`
    /// - `CryptoReplaceFfxFpeConfig`
    pub reidentify_config: std::option::Option<crate::model::DeidentifyConfig>,

    /// Configuration for the inspector.
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The item to re-identify. Will be treated as text.
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Template to use. Any configuration directly specified in
    /// `inspect_config` will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    pub inspect_template_name: std::string::String,

    /// Template to use. References an instance of `DeidentifyTemplate`.
    /// Any configuration directly specified in `reidentify_config` or
    /// `inspect_config` will override those set in the template. The
    /// `DeidentifyTemplate` used must include only reversible transformations.
    /// Singular fields that are set in this request will replace their
    /// corresponding fields in the template. Repeated fields are appended.
    /// Singular sub-messages and groups are recursively merged.
    pub reidentify_template_name: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReidentifyContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ReidentifyContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [reidentify_config][crate::model::ReidentifyContentRequest::reidentify_config].
    pub fn set_reidentify_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyConfig>,
    {
        self.reidentify_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reidentify_config][crate::model::ReidentifyContentRequest::reidentify_config].
    pub fn set_or_clear_reidentify_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyConfig>,
    {
        self.reidentify_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_config][crate::model::ReidentifyContentRequest::inspect_config].
    pub fn set_inspect_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_config][crate::model::ReidentifyContentRequest::inspect_config].
    pub fn set_or_clear_inspect_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [item][crate::model::ReidentifyContentRequest::item].
    pub fn set_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [item][crate::model::ReidentifyContentRequest::item].
    pub fn set_or_clear_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::ReidentifyContentRequest::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [reidentify_template_name][crate::model::ReidentifyContentRequest::reidentify_template_name].
    pub fn set_reidentify_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reidentify_template_name = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ReidentifyContentRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ReidentifyContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReidentifyContentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReidentifyContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __reidentify_config,
            __inspect_config,
            __item,
            __inspect_template_name,
            __reidentify_template_name,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReidentifyContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "reidentifyConfig" => Ok(__FieldTag::__reidentify_config),
                            "reidentify_config" => Ok(__FieldTag::__reidentify_config),
                            "inspectConfig" => Ok(__FieldTag::__inspect_config),
                            "inspect_config" => Ok(__FieldTag::__inspect_config),
                            "item" => Ok(__FieldTag::__item),
                            "inspectTemplateName" => Ok(__FieldTag::__inspect_template_name),
                            "inspect_template_name" => Ok(__FieldTag::__inspect_template_name),
                            "reidentifyTemplateName" => Ok(__FieldTag::__reidentify_template_name),
                            "reidentify_template_name" => {
                                Ok(__FieldTag::__reidentify_template_name)
                            }
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReidentifyContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReidentifyContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reidentify_config => {
                            if !fields.insert(__FieldTag::__reidentify_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reidentify_config",
                                ));
                            }
                            result.reidentify_config = map
                                .next_value::<std::option::Option<crate::model::DeidentifyConfig>>(
                                )?;
                        }
                        __FieldTag::__inspect_config => {
                            if !fields.insert(__FieldTag::__inspect_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_config",
                                ));
                            }
                            result.inspect_config = map
                                .next_value::<std::option::Option<crate::model::InspectConfig>>()?;
                        }
                        __FieldTag::__item => {
                            if !fields.insert(__FieldTag::__item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for item",
                                ));
                            }
                            result.item =
                                map.next_value::<std::option::Option<crate::model::ContentItem>>()?;
                        }
                        __FieldTag::__inspect_template_name => {
                            if !fields.insert(__FieldTag::__inspect_template_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template_name",
                                ));
                            }
                            result.inspect_template_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reidentify_template_name => {
                            if !fields.insert(__FieldTag::__reidentify_template_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reidentify_template_name",
                                ));
                            }
                            result.reidentify_template_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReidentifyContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.reidentify_config.is_some() {
            state.serialize_entry("reidentifyConfig", &self.reidentify_config)?;
        }
        if self.inspect_config.is_some() {
            state.serialize_entry("inspectConfig", &self.inspect_config)?;
        }
        if self.item.is_some() {
            state.serialize_entry("item", &self.item)?;
        }
        if !self.inspect_template_name.is_empty() {
            state.serialize_entry("inspectTemplateName", &self.inspect_template_name)?;
        }
        if !self.reidentify_template_name.is_empty() {
            state.serialize_entry("reidentifyTemplateName", &self.reidentify_template_name)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Results of re-identifying an item.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReidentifyContentResponse {
    /// The re-identified item.
    pub item: std::option::Option<crate::model::ContentItem>,

    /// An overview of the changes that were made to the `item`.
    pub overview: std::option::Option<crate::model::TransformationOverview>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReidentifyContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [item][crate::model::ReidentifyContentResponse::item].
    pub fn set_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [item][crate::model::ReidentifyContentResponse::item].
    pub fn set_or_clear_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = v.map(|x| x.into());
        self
    }

    /// Sets the value of [overview][crate::model::ReidentifyContentResponse::overview].
    pub fn set_overview<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransformationOverview>,
    {
        self.overview = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [overview][crate::model::ReidentifyContentResponse::overview].
    pub fn set_or_clear_overview<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransformationOverview>,
    {
        self.overview = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReidentifyContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReidentifyContentResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReidentifyContentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __item,
            __overview,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReidentifyContentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "item" => Ok(__FieldTag::__item),
                            "overview" => Ok(__FieldTag::__overview),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReidentifyContentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReidentifyContentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__item => {
                            if !fields.insert(__FieldTag::__item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for item",
                                ));
                            }
                            result.item =
                                map.next_value::<std::option::Option<crate::model::ContentItem>>()?;
                        }
                        __FieldTag::__overview => {
                            if !fields.insert(__FieldTag::__overview) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overview",
                                ));
                            }
                            result.overview = map.next_value::<std::option::Option<crate::model::TransformationOverview>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReidentifyContentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.item.is_some() {
            state.serialize_entry("item", &self.item)?;
        }
        if self.overview.is_some() {
            state.serialize_entry("overview", &self.overview)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to search for potentially sensitive info in a ContentItem.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InspectContentRequest {
    /// Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Configuration for the inspector. What specified here will override
    /// the template referenced by the inspect_template_name argument.
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The item to inspect.
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Template to use. Any configuration directly specified in
    /// inspect_config will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    pub inspect_template_name: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::InspectContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::InspectContentRequest::inspect_config].
    pub fn set_inspect_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_config][crate::model::InspectContentRequest::inspect_config].
    pub fn set_or_clear_inspect_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [item][crate::model::InspectContentRequest::item].
    pub fn set_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [item][crate::model::InspectContentRequest::item].
    pub fn set_or_clear_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::InspectContentRequest::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::InspectContentRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for InspectContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectContentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InspectContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __inspect_config,
            __item,
            __inspect_template_name,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InspectContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "inspectConfig" => Ok(__FieldTag::__inspect_config),
                            "inspect_config" => Ok(__FieldTag::__inspect_config),
                            "item" => Ok(__FieldTag::__item),
                            "inspectTemplateName" => Ok(__FieldTag::__inspect_template_name),
                            "inspect_template_name" => Ok(__FieldTag::__inspect_template_name),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InspectContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InspectContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inspect_config => {
                            if !fields.insert(__FieldTag::__inspect_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_config",
                                ));
                            }
                            result.inspect_config = map
                                .next_value::<std::option::Option<crate::model::InspectConfig>>()?;
                        }
                        __FieldTag::__item => {
                            if !fields.insert(__FieldTag::__item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for item",
                                ));
                            }
                            result.item =
                                map.next_value::<std::option::Option<crate::model::ContentItem>>()?;
                        }
                        __FieldTag::__inspect_template_name => {
                            if !fields.insert(__FieldTag::__inspect_template_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template_name",
                                ));
                            }
                            result.inspect_template_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InspectContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.inspect_config.is_some() {
            state.serialize_entry("inspectConfig", &self.inspect_config)?;
        }
        if self.item.is_some() {
            state.serialize_entry("item", &self.item)?;
        }
        if !self.inspect_template_name.is_empty() {
            state.serialize_entry("inspectTemplateName", &self.inspect_template_name)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Results of inspecting an item.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InspectContentResponse {
    /// The findings.
    pub result: std::option::Option<crate::model::InspectResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::InspectContentResponse::result].
    pub fn set_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InspectResult>,
    {
        self.result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [result][crate::model::InspectContentResponse::result].
    pub fn set_or_clear_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InspectResult>,
    {
        self.result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InspectContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectContentResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InspectContentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InspectContentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "result" => Ok(__FieldTag::__result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InspectContentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InspectContentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map
                                .next_value::<std::option::Option<crate::model::InspectResult>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InspectContentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Cloud repository for storing output.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OutputStorageConfig {
    /// Schema used for writing the findings for Inspect jobs. This field is only
    /// used for Inspect and must be unspecified for Risk jobs. Columns are derived
    /// from the `Finding` object. If appending to an existing table, any columns
    /// from the predefined schema that are missing will be added. No columns in
    /// the existing table will be deleted.
    ///
    /// If unspecified, then all available columns will be used for a new table or
    /// an (existing) table with no schema, and no changes will be made to an
    /// existing table that has a schema.
    /// Only for use with external storage.
    pub output_schema: crate::model::output_storage_config::OutputSchema,

    /// Output storage types.
    pub r#type: std::option::Option<crate::model::output_storage_config::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutputStorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_schema][crate::model::OutputStorageConfig::output_schema].
    pub fn set_output_schema<
        T: std::convert::Into<crate::model::output_storage_config::OutputSchema>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_schema = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::OutputStorageConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::output_storage_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::OutputStorageConfig::r#type]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table(&self) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTable>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::output_storage_config::Type::Table(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::OutputStorageConfig::r#type]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTable>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::output_storage_config::Type::Table(v.into()));
        self
    }
}

impl wkt::message::Message for OutputStorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OutputStorageConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutputStorageConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table,
            __output_schema,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputStorageConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "table" => Ok(__FieldTag::__table),
                            "outputSchema" => Ok(__FieldTag::__output_schema),
                            "output_schema" => Ok(__FieldTag::__output_schema),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutputStorageConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputStorageConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.OutputStorageConfig.table, latest field was table",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::output_storage_config::Type::Table(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryTable>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__output_schema => {
                            if !fields.insert(__FieldTag::__output_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_schema",
                                ));
                            }
                            result.output_schema = map
                                .next_value::<std::option::Option<
                                    crate::model::output_storage_config::OutputSchema,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OutputStorageConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.table() {
            state.serialize_entry("table", value)?;
        }
        if !wkt::internal::is_default(&self.output_schema) {
            state.serialize_entry("outputSchema", &self.output_schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [OutputStorageConfig].
pub mod output_storage_config {
    #[allow(unused_imports)]
    use super::*;

    /// Predefined schemas for storing findings.
    /// Only for use with external storage.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OutputSchema {
        /// Unused.
        Unspecified,
        /// Basic schema including only `info_type`, `quote`, `certainty`, and
        /// `timestamp`.
        BasicColumns,
        /// Schema tailored to findings from scanning Cloud Storage.
        GcsColumns,
        /// Schema tailored to findings from scanning Google Datastore.
        DatastoreColumns,
        /// Schema tailored to findings from scanning Google BigQuery.
        BigQueryColumns,
        /// Schema containing all columns.
        AllColumns,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OutputSchema::value] or
        /// [OutputSchema::name].
        UnknownValue(output_schema::UnknownValue),
    }

    #[doc(hidden)]
    pub mod output_schema {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OutputSchema {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BasicColumns => std::option::Option::Some(1),
                Self::GcsColumns => std::option::Option::Some(2),
                Self::DatastoreColumns => std::option::Option::Some(3),
                Self::BigQueryColumns => std::option::Option::Some(4),
                Self::AllColumns => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OUTPUT_SCHEMA_UNSPECIFIED"),
                Self::BasicColumns => std::option::Option::Some("BASIC_COLUMNS"),
                Self::GcsColumns => std::option::Option::Some("GCS_COLUMNS"),
                Self::DatastoreColumns => std::option::Option::Some("DATASTORE_COLUMNS"),
                Self::BigQueryColumns => std::option::Option::Some("BIG_QUERY_COLUMNS"),
                Self::AllColumns => std::option::Option::Some("ALL_COLUMNS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OutputSchema {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OutputSchema {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OutputSchema {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BasicColumns,
                2 => Self::GcsColumns,
                3 => Self::DatastoreColumns,
                4 => Self::BigQueryColumns,
                5 => Self::AllColumns,
                _ => Self::UnknownValue(output_schema::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OutputSchema {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OUTPUT_SCHEMA_UNSPECIFIED" => Self::Unspecified,
                "BASIC_COLUMNS" => Self::BasicColumns,
                "GCS_COLUMNS" => Self::GcsColumns,
                "DATASTORE_COLUMNS" => Self::DatastoreColumns,
                "BIG_QUERY_COLUMNS" => Self::BigQueryColumns,
                "ALL_COLUMNS" => Self::AllColumns,
                _ => Self::UnknownValue(output_schema::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OutputSchema {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BasicColumns => serializer.serialize_i32(1),
                Self::GcsColumns => serializer.serialize_i32(2),
                Self::DatastoreColumns => serializer.serialize_i32(3),
                Self::BigQueryColumns => serializer.serialize_i32(4),
                Self::AllColumns => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OutputSchema {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OutputSchema>::new(
                ".google.privacy.dlp.v2.OutputStorageConfig.OutputSchema",
            ))
        }
    }

    /// Output storage types.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Store findings in an existing table or a new table in an existing
        /// dataset. If table_id is not set a new one will be generated
        /// for you with the following format:
        /// dlp_googleapis_yyyy_mm_dd_[dlp_job_id]. Pacific time zone will be used
        /// for generating the date details.
        ///
        /// For Inspect, each column in an existing output table must have the same
        /// name, type, and mode of a field in the `Finding` object.
        ///
        /// For Risk, an existing output table should be the output of a previous
        /// Risk analysis job run on the same source table, with the same privacy
        /// metric and quasi-identifiers. Risk jobs that analyze the same table but
        /// compute a different privacy metric, or use different sets of
        /// quasi-identifiers, cannot store their results in the same table.
        Table(std::boxed::Box<crate::model::BigQueryTable>),
    }
}

/// Statistics regarding a specific InfoType.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InfoTypeStats {
    /// The type of finding this stat is for.
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Number of findings for this infoType.
    pub count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoTypeStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::InfoTypeStats::info_type].
    pub fn set_info_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [info_type][crate::model::InfoTypeStats::info_type].
    pub fn set_or_clear_info_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [count][crate::model::InfoTypeStats::count].
    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.count = v.into();
        self
    }
}

impl wkt::message::Message for InfoTypeStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeStats"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InfoTypeStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_type,
            __count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InfoTypeStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            "count" => Ok(__FieldTag::__count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InfoTypeStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InfoTypeStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type",
                                ));
                            }
                            result.info_type =
                                map.next_value::<std::option::Option<crate::model::InfoType>>()?;
                        }
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InfoTypeStats {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.info_type.is_some() {
            state.serialize_entry("infoType", &self.info_type)?;
        }
        if !wkt::internal::is_default(&self.count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The results of an inspect DataSource job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InspectDataSourceDetails {
    /// The configuration used for this job.
    pub requested_options:
        std::option::Option<crate::model::inspect_data_source_details::RequestedOptions>,

    /// A summary of the outcome of this inspection job.
    pub result: std::option::Option<crate::model::inspect_data_source_details::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectDataSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_options][crate::model::InspectDataSourceDetails::requested_options].
    pub fn set_requested_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::inspect_data_source_details::RequestedOptions>,
    {
        self.requested_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_options][crate::model::InspectDataSourceDetails::requested_options].
    pub fn set_or_clear_requested_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::inspect_data_source_details::RequestedOptions>,
    {
        self.requested_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [result][crate::model::InspectDataSourceDetails::result].
    pub fn set_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::inspect_data_source_details::Result>,
    {
        self.result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [result][crate::model::InspectDataSourceDetails::result].
    pub fn set_or_clear_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::inspect_data_source_details::Result>,
    {
        self.result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InspectDataSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectDataSourceDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InspectDataSourceDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __requested_options,
            __result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InspectDataSourceDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requestedOptions" => Ok(__FieldTag::__requested_options),
                            "requested_options" => Ok(__FieldTag::__requested_options),
                            "result" => Ok(__FieldTag::__result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InspectDataSourceDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InspectDataSourceDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__requested_options => {
                            if !fields.insert(__FieldTag::__requested_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_options",
                                ));
                            }
                            result.requested_options = map.next_value::<std::option::Option<
                                crate::model::inspect_data_source_details::RequestedOptions,
                            >>()?;
                        }
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map.next_value::<std::option::Option<
                                crate::model::inspect_data_source_details::Result,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InspectDataSourceDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.requested_options.is_some() {
            state.serialize_entry("requestedOptions", &self.requested_options)?;
        }
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InspectDataSourceDetails].
pub mod inspect_data_source_details {
    #[allow(unused_imports)]
    use super::*;

    /// Snapshot of the inspection configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RequestedOptions {
        /// If run with an InspectTemplate, a snapshot of its state at the time of
        /// this run.
        pub snapshot_inspect_template: std::option::Option<crate::model::InspectTemplate>,

        /// Inspect config.
        pub job_config: std::option::Option<crate::model::InspectJobConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RequestedOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [snapshot_inspect_template][crate::model::inspect_data_source_details::RequestedOptions::snapshot_inspect_template].
        pub fn set_snapshot_inspect_template<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InspectTemplate>,
        {
            self.snapshot_inspect_template = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [snapshot_inspect_template][crate::model::inspect_data_source_details::RequestedOptions::snapshot_inspect_template].
        pub fn set_or_clear_snapshot_inspect_template<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::InspectTemplate>,
        {
            self.snapshot_inspect_template = v.map(|x| x.into());
            self
        }

        /// Sets the value of [job_config][crate::model::inspect_data_source_details::RequestedOptions::job_config].
        pub fn set_job_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InspectJobConfig>,
        {
            self.job_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [job_config][crate::model::inspect_data_source_details::RequestedOptions::job_config].
        pub fn set_or_clear_job_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InspectJobConfig>,
        {
            self.job_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for RequestedOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectDataSourceDetails.RequestedOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RequestedOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __snapshot_inspect_template,
                __job_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RequestedOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "snapshotInspectTemplate" => {
                                    Ok(__FieldTag::__snapshot_inspect_template)
                                }
                                "snapshot_inspect_template" => {
                                    Ok(__FieldTag::__snapshot_inspect_template)
                                }
                                "jobConfig" => Ok(__FieldTag::__job_config),
                                "job_config" => Ok(__FieldTag::__job_config),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RequestedOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RequestedOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__snapshot_inspect_template => {
                                if !fields.insert(__FieldTag::__snapshot_inspect_template) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for snapshot_inspect_template",
                                    ));
                                }
                                result.snapshot_inspect_template = map.next_value::<std::option::Option<crate::model::InspectTemplate>>()?
                                    ;
                            }
                            __FieldTag::__job_config => {
                                if !fields.insert(__FieldTag::__job_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for job_config",
                                    ));
                                }
                                result.job_config = map.next_value::<std::option::Option<crate::model::InspectJobConfig>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RequestedOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.snapshot_inspect_template.is_some() {
                state
                    .serialize_entry("snapshotInspectTemplate", &self.snapshot_inspect_template)?;
            }
            if self.job_config.is_some() {
                state.serialize_entry("jobConfig", &self.job_config)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// All result fields mentioned below are updated while the job is processing.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Result {
        /// Total size in bytes that were processed.
        pub processed_bytes: i64,

        /// Estimate of the number of bytes to process.
        pub total_estimated_bytes: i64,

        /// Statistics of how many instances of each info type were found during
        /// inspect job.
        pub info_type_stats: std::vec::Vec<crate::model::InfoTypeStats>,

        /// Number of rows scanned after sampling and time filtering (applicable for
        /// row based stores such as BigQuery).
        pub num_rows_processed: i64,

        /// Statistics related to the processing of hybrid inspect.
        pub hybrid_stats: std::option::Option<crate::model::HybridInspectStatistics>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Result {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [processed_bytes][crate::model::inspect_data_source_details::Result::processed_bytes].
        pub fn set_processed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.processed_bytes = v.into();
            self
        }

        /// Sets the value of [total_estimated_bytes][crate::model::inspect_data_source_details::Result::total_estimated_bytes].
        pub fn set_total_estimated_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_estimated_bytes = v.into();
            self
        }

        /// Sets the value of [info_type_stats][crate::model::inspect_data_source_details::Result::info_type_stats].
        pub fn set_info_type_stats<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::InfoTypeStats>,
        {
            use std::iter::Iterator;
            self.info_type_stats = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [num_rows_processed][crate::model::inspect_data_source_details::Result::num_rows_processed].
        pub fn set_num_rows_processed<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.num_rows_processed = v.into();
            self
        }

        /// Sets the value of [hybrid_stats][crate::model::inspect_data_source_details::Result::hybrid_stats].
        pub fn set_hybrid_stats<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::HybridInspectStatistics>,
        {
            self.hybrid_stats = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [hybrid_stats][crate::model::inspect_data_source_details::Result::hybrid_stats].
        pub fn set_or_clear_hybrid_stats<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::HybridInspectStatistics>,
        {
            self.hybrid_stats = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Result {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectDataSourceDetails.Result"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Result {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __processed_bytes,
                __total_estimated_bytes,
                __info_type_stats,
                __num_rows_processed,
                __hybrid_stats,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Result")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "processedBytes" => Ok(__FieldTag::__processed_bytes),
                                "processed_bytes" => Ok(__FieldTag::__processed_bytes),
                                "totalEstimatedBytes" => Ok(__FieldTag::__total_estimated_bytes),
                                "total_estimated_bytes" => Ok(__FieldTag::__total_estimated_bytes),
                                "infoTypeStats" => Ok(__FieldTag::__info_type_stats),
                                "info_type_stats" => Ok(__FieldTag::__info_type_stats),
                                "numRowsProcessed" => Ok(__FieldTag::__num_rows_processed),
                                "num_rows_processed" => Ok(__FieldTag::__num_rows_processed),
                                "hybridStats" => Ok(__FieldTag::__hybrid_stats),
                                "hybrid_stats" => Ok(__FieldTag::__hybrid_stats),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Result;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Result")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__processed_bytes => {
                                if !fields.insert(__FieldTag::__processed_bytes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for processed_bytes",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.processed_bytes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__total_estimated_bytes => {
                                if !fields.insert(__FieldTag::__total_estimated_bytes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_estimated_bytes",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.total_estimated_bytes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__info_type_stats => {
                                if !fields.insert(__FieldTag::__info_type_stats) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for info_type_stats",
                                    ));
                                }
                                result.info_type_stats =
                                    map.next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::InfoTypeStats>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__num_rows_processed => {
                                if !fields.insert(__FieldTag::__num_rows_processed) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for num_rows_processed",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.num_rows_processed =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__hybrid_stats => {
                                if !fields.insert(__FieldTag::__hybrid_stats) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hybrid_stats",
                                    ));
                                }
                                result.hybrid_stats = map.next_value::<std::option::Option<crate::model::HybridInspectStatistics>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Result {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.processed_bytes) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("processedBytes", &__With(&self.processed_bytes))?;
            }
            if !wkt::internal::is_default(&self.total_estimated_bytes) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("totalEstimatedBytes", &__With(&self.total_estimated_bytes))?;
            }
            if !self.info_type_stats.is_empty() {
                state.serialize_entry("infoTypeStats", &self.info_type_stats)?;
            }
            if !wkt::internal::is_default(&self.num_rows_processed) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("numRowsProcessed", &__With(&self.num_rows_processed))?;
            }
            if self.hybrid_stats.is_some() {
                state.serialize_entry("hybridStats", &self.hybrid_stats)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The schema of data to be saved to the BigQuery table when the
/// `DataProfileAction` is enabled.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfileBigQueryRowSchema {
    /// Data profile type.
    pub data_profile:
        std::option::Option<crate::model::data_profile_big_query_row_schema::DataProfile>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileBigQueryRowSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile].
    ///
    /// Note that all the setters affecting `data_profile` are mutually
    /// exclusive.
    pub fn set_data_profile<
        T: std::convert::Into<
                std::option::Option<crate::model::data_profile_big_query_row_schema::DataProfile>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = v.into();
        self
    }

    /// The value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// if it holds a `TableProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TableDataProfile>> {
        #[allow(unreachable_patterns)]
        self.data_profile.as_ref().and_then(|v| match v {
            crate::model::data_profile_big_query_row_schema::DataProfile::TableProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// to hold a `TableProfile`.
    ///
    /// Note that all the setters affecting `data_profile` are
    /// mutually exclusive.
    pub fn set_table_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::TableDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = std::option::Option::Some(
            crate::model::data_profile_big_query_row_schema::DataProfile::TableProfile(v.into()),
        );
        self
    }

    /// The value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// if it holds a `ColumnProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn column_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ColumnDataProfile>> {
        #[allow(unreachable_patterns)]
        self.data_profile.as_ref().and_then(|v| match v {
            crate::model::data_profile_big_query_row_schema::DataProfile::ColumnProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// to hold a `ColumnProfile`.
    ///
    /// Note that all the setters affecting `data_profile` are
    /// mutually exclusive.
    pub fn set_column_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::ColumnDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = std::option::Option::Some(
            crate::model::data_profile_big_query_row_schema::DataProfile::ColumnProfile(v.into()),
        );
        self
    }

    /// The value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// if it holds a `FileStoreProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn file_store_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileStoreDataProfile>> {
        #[allow(unreachable_patterns)]
        self.data_profile.as_ref().and_then(|v| match v {
            crate::model::data_profile_big_query_row_schema::DataProfile::FileStoreProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// to hold a `FileStoreProfile`.
    ///
    /// Note that all the setters affecting `data_profile` are
    /// mutually exclusive.
    pub fn set_file_store_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::FileStoreDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = std::option::Option::Some(
            crate::model::data_profile_big_query_row_schema::DataProfile::FileStoreProfile(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DataProfileBigQueryRowSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileBigQueryRowSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfileBigQueryRowSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table_profile,
            __column_profile,
            __file_store_profile,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfileBigQueryRowSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tableProfile" => Ok(__FieldTag::__table_profile),
                            "table_profile" => Ok(__FieldTag::__table_profile),
                            "columnProfile" => Ok(__FieldTag::__column_profile),
                            "column_profile" => Ok(__FieldTag::__column_profile),
                            "fileStoreProfile" => Ok(__FieldTag::__file_store_profile),
                            "file_store_profile" => Ok(__FieldTag::__file_store_profile),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfileBigQueryRowSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfileBigQueryRowSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table_profile => {
                            if !fields.insert(__FieldTag::__table_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_profile",
                                ));
                            }
                            if result.data_profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_profile`, a oneof with full ID .google.privacy.dlp.v2.DataProfileBigQueryRowSchema.table_profile, latest field was tableProfile",
                                ));
                            }
                            result.data_profile = std::option::Option::Some(
                                crate::model::data_profile_big_query_row_schema::DataProfile::TableProfile(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TableDataProfile>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__column_profile => {
                            if !fields.insert(__FieldTag::__column_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_profile",
                                ));
                            }
                            if result.data_profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_profile`, a oneof with full ID .google.privacy.dlp.v2.DataProfileBigQueryRowSchema.column_profile, latest field was columnProfile",
                                ));
                            }
                            result.data_profile = std::option::Option::Some(
                                crate::model::data_profile_big_query_row_schema::DataProfile::ColumnProfile(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ColumnDataProfile>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__file_store_profile => {
                            if !fields.insert(__FieldTag::__file_store_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_store_profile",
                                ));
                            }
                            if result.data_profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_profile`, a oneof with full ID .google.privacy.dlp.v2.DataProfileBigQueryRowSchema.file_store_profile, latest field was fileStoreProfile",
                                ));
                            }
                            result.data_profile = std::option::Option::Some(
                                crate::model::data_profile_big_query_row_schema::DataProfile::FileStoreProfile(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::FileStoreDataProfile>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfileBigQueryRowSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.table_profile() {
            state.serialize_entry("tableProfile", value)?;
        }
        if let Some(value) = self.column_profile() {
            state.serialize_entry("columnProfile", value)?;
        }
        if let Some(value) = self.file_store_profile() {
            state.serialize_entry("fileStoreProfile", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataProfileBigQueryRowSchema].
pub mod data_profile_big_query_row_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Data profile type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataProfile {
        /// Table data profile column
        TableProfile(std::boxed::Box<crate::model::TableDataProfile>),
        /// Column data profile column
        ColumnProfile(std::boxed::Box<crate::model::ColumnDataProfile>),
        /// File store data profile column.
        FileStoreProfile(std::boxed::Box<crate::model::FileStoreDataProfile>),
    }
}

/// Statistics related to processing hybrid inspect requests.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HybridInspectStatistics {
    /// The number of hybrid inspection requests processed within this job.
    pub processed_count: i64,

    /// The number of hybrid inspection requests aborted because the job ran
    /// out of quota or was ended before they could be processed.
    pub aborted_count: i64,

    /// The number of hybrid requests currently being processed. Only populated
    /// when called via method `getDlpJob`.
    /// A burst of traffic may cause hybrid inspect requests to be enqueued.
    /// Processing will take place as quickly as possible, but resource limitations
    /// may impact how long a request is enqueued for.
    pub pending_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridInspectStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [processed_count][crate::model::HybridInspectStatistics::processed_count].
    pub fn set_processed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.processed_count = v.into();
        self
    }

    /// Sets the value of [aborted_count][crate::model::HybridInspectStatistics::aborted_count].
    pub fn set_aborted_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.aborted_count = v.into();
        self
    }

    /// Sets the value of [pending_count][crate::model::HybridInspectStatistics::pending_count].
    pub fn set_pending_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pending_count = v.into();
        self
    }
}

impl wkt::message::Message for HybridInspectStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectStatistics"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HybridInspectStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __processed_count,
            __aborted_count,
            __pending_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HybridInspectStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "processedCount" => Ok(__FieldTag::__processed_count),
                            "processed_count" => Ok(__FieldTag::__processed_count),
                            "abortedCount" => Ok(__FieldTag::__aborted_count),
                            "aborted_count" => Ok(__FieldTag::__aborted_count),
                            "pendingCount" => Ok(__FieldTag::__pending_count),
                            "pending_count" => Ok(__FieldTag::__pending_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HybridInspectStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HybridInspectStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__processed_count => {
                            if !fields.insert(__FieldTag::__processed_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processed_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.processed_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__aborted_count => {
                            if !fields.insert(__FieldTag::__aborted_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aborted_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.aborted_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__pending_count => {
                            if !fields.insert(__FieldTag::__pending_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pending_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pending_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HybridInspectStatistics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.processed_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("processedCount", &__With(&self.processed_count))?;
        }
        if !wkt::internal::is_default(&self.aborted_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("abortedCount", &__With(&self.aborted_count))?;
        }
        if !wkt::internal::is_default(&self.pending_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pendingCount", &__With(&self.pending_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The results of an [Action][google.privacy.dlp.v2.Action].
///
/// [google.privacy.dlp.v2.Action]: crate::model::Action
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ActionDetails {
    /// Summary of what occurred in the actions.
    pub details: std::option::Option<crate::model::action_details::Details>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ActionDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::ActionDetails::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::action_details::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::ActionDetails::details]
    /// if it holds a `DeidentifyDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deidentify_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeidentifyDataSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action_details::Details::DeidentifyDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::ActionDetails::details]
    /// to hold a `DeidentifyDetails`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_deidentify_details<
        T: std::convert::Into<std::boxed::Box<crate::model::DeidentifyDataSourceDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action_details::Details::DeidentifyDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ActionDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ActionDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ActionDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deidentify_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ActionDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deidentifyDetails" => Ok(__FieldTag::__deidentify_details),
                            "deidentify_details" => Ok(__FieldTag::__deidentify_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ActionDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ActionDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deidentify_details => {
                            if !fields.insert(__FieldTag::__deidentify_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_details",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.privacy.dlp.v2.ActionDetails.deidentify_details, latest field was deidentifyDetails",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::action_details::Details::DeidentifyDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeidentifyDataSourceDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ActionDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.deidentify_details() {
            state.serialize_entry("deidentifyDetails", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ActionDetails].
pub mod action_details {
    #[allow(unused_imports)]
    use super::*;

    /// Summary of what occurred in the actions.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Details {
        /// Outcome of a de-identification action.
        DeidentifyDetails(std::boxed::Box<crate::model::DeidentifyDataSourceDetails>),
    }
}

/// Summary of what was modified during a transformation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeidentifyDataSourceStats {
    /// Total size in bytes that were transformed in some way.
    pub transformed_bytes: i64,

    /// Number of successfully applied transformations.
    pub transformation_count: i64,

    /// Number of errors encountered while trying to apply transformations.
    pub transformation_error_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyDataSourceStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformed_bytes][crate::model::DeidentifyDataSourceStats::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [transformation_count][crate::model::DeidentifyDataSourceStats::transformation_count].
    pub fn set_transformation_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformation_count = v.into();
        self
    }

    /// Sets the value of [transformation_error_count][crate::model::DeidentifyDataSourceStats::transformation_error_count].
    pub fn set_transformation_error_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformation_error_count = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyDataSourceStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyDataSourceStats"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeidentifyDataSourceStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transformed_bytes,
            __transformation_count,
            __transformation_error_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeidentifyDataSourceStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transformedBytes" => Ok(__FieldTag::__transformed_bytes),
                            "transformed_bytes" => Ok(__FieldTag::__transformed_bytes),
                            "transformationCount" => Ok(__FieldTag::__transformation_count),
                            "transformation_count" => Ok(__FieldTag::__transformation_count),
                            "transformationErrorCount" => {
                                Ok(__FieldTag::__transformation_error_count)
                            }
                            "transformation_error_count" => {
                                Ok(__FieldTag::__transformation_error_count)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeidentifyDataSourceStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeidentifyDataSourceStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transformed_bytes => {
                            if !fields.insert(__FieldTag::__transformed_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformed_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transformed_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__transformation_count => {
                            if !fields.insert(__FieldTag::__transformation_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformation_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transformation_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__transformation_error_count => {
                            if !fields.insert(__FieldTag::__transformation_error_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformation_error_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transformation_error_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeidentifyDataSourceStats {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.transformed_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("transformedBytes", &__With(&self.transformed_bytes))?;
        }
        if !wkt::internal::is_default(&self.transformation_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("transformationCount", &__With(&self.transformation_count))?;
        }
        if !wkt::internal::is_default(&self.transformation_error_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "transformationErrorCount",
                &__With(&self.transformation_error_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The results of a [Deidentify][google.privacy.dlp.v2.Action.Deidentify] action
/// from an inspect job.
///
/// [google.privacy.dlp.v2.Action.Deidentify]: crate::model::action::Deidentify
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeidentifyDataSourceDetails {
    /// De-identification config used for the request.
    pub requested_options: std::option::Option<
        crate::model::deidentify_data_source_details::RequestedDeidentifyOptions,
    >,

    /// Stats about the de-identification operation.
    pub deidentify_stats: std::option::Option<crate::model::DeidentifyDataSourceStats>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyDataSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_options][crate::model::DeidentifyDataSourceDetails::requested_options].
    pub fn set_requested_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::deidentify_data_source_details::RequestedDeidentifyOptions,
            >,
    {
        self.requested_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_options][crate::model::DeidentifyDataSourceDetails::requested_options].
    pub fn set_or_clear_requested_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::deidentify_data_source_details::RequestedDeidentifyOptions,
            >,
    {
        self.requested_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deidentify_stats][crate::model::DeidentifyDataSourceDetails::deidentify_stats].
    pub fn set_deidentify_stats<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyDataSourceStats>,
    {
        self.deidentify_stats = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deidentify_stats][crate::model::DeidentifyDataSourceDetails::deidentify_stats].
    pub fn set_or_clear_deidentify_stats<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyDataSourceStats>,
    {
        self.deidentify_stats = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeidentifyDataSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyDataSourceDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeidentifyDataSourceDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __requested_options,
            __deidentify_stats,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeidentifyDataSourceDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requestedOptions" => Ok(__FieldTag::__requested_options),
                            "requested_options" => Ok(__FieldTag::__requested_options),
                            "deidentifyStats" => Ok(__FieldTag::__deidentify_stats),
                            "deidentify_stats" => Ok(__FieldTag::__deidentify_stats),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeidentifyDataSourceDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeidentifyDataSourceDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__requested_options => {
                            if !fields.insert(__FieldTag::__requested_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_options",
                                ));
                            }
                            result.requested_options = map.next_value::<std::option::Option<crate::model::deidentify_data_source_details::RequestedDeidentifyOptions>>()?
                                ;
                        }
                        __FieldTag::__deidentify_stats => {
                            if !fields.insert(__FieldTag::__deidentify_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_stats",
                                ));
                            }
                            result.deidentify_stats = map.next_value::<std::option::Option<crate::model::DeidentifyDataSourceStats>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeidentifyDataSourceDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.requested_options.is_some() {
            state.serialize_entry("requestedOptions", &self.requested_options)?;
        }
        if self.deidentify_stats.is_some() {
            state.serialize_entry("deidentifyStats", &self.deidentify_stats)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DeidentifyDataSourceDetails].
pub mod deidentify_data_source_details {
    #[allow(unused_imports)]
    use super::*;

    /// De-identification options.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RequestedDeidentifyOptions {
        /// Snapshot of the state of the `DeidentifyTemplate` from the
        /// [Deidentify][google.privacy.dlp.v2.Action.Deidentify] action at the time
        /// this job was run.
        ///
        /// [google.privacy.dlp.v2.Action.Deidentify]: crate::model::action::Deidentify
        pub snapshot_deidentify_template: std::option::Option<crate::model::DeidentifyTemplate>,

        /// Snapshot of the state of the structured `DeidentifyTemplate` from the
        /// `Deidentify` action at the time this job was run.
        pub snapshot_structured_deidentify_template:
            std::option::Option<crate::model::DeidentifyTemplate>,

        /// Snapshot of the state of the image transformation `DeidentifyTemplate`
        /// from the `Deidentify` action at the time this job was run.
        pub snapshot_image_redact_template: std::option::Option<crate::model::DeidentifyTemplate>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RequestedDeidentifyOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [snapshot_deidentify_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_deidentify_template].
        pub fn set_snapshot_deidentify_template<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::DeidentifyTemplate>,
        {
            self.snapshot_deidentify_template = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [snapshot_deidentify_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_deidentify_template].
        pub fn set_or_clear_snapshot_deidentify_template<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::DeidentifyTemplate>,
        {
            self.snapshot_deidentify_template = v.map(|x| x.into());
            self
        }

        /// Sets the value of [snapshot_structured_deidentify_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_structured_deidentify_template].
        pub fn set_snapshot_structured_deidentify_template<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::DeidentifyTemplate>,
        {
            self.snapshot_structured_deidentify_template = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [snapshot_structured_deidentify_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_structured_deidentify_template].
        pub fn set_or_clear_snapshot_structured_deidentify_template<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::DeidentifyTemplate>,
        {
            self.snapshot_structured_deidentify_template = v.map(|x| x.into());
            self
        }

        /// Sets the value of [snapshot_image_redact_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_image_redact_template].
        pub fn set_snapshot_image_redact_template<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::DeidentifyTemplate>,
        {
            self.snapshot_image_redact_template = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [snapshot_image_redact_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_image_redact_template].
        pub fn set_or_clear_snapshot_image_redact_template<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::DeidentifyTemplate>,
        {
            self.snapshot_image_redact_template = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for RequestedDeidentifyOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DeidentifyDataSourceDetails.RequestedDeidentifyOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RequestedDeidentifyOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __snapshot_deidentify_template,
                __snapshot_structured_deidentify_template,
                __snapshot_image_redact_template,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RequestedDeidentifyOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "snapshotDeidentifyTemplate" => {
                                    Ok(__FieldTag::__snapshot_deidentify_template)
                                }
                                "snapshot_deidentify_template" => {
                                    Ok(__FieldTag::__snapshot_deidentify_template)
                                }
                                "snapshotStructuredDeidentifyTemplate" => {
                                    Ok(__FieldTag::__snapshot_structured_deidentify_template)
                                }
                                "snapshot_structured_deidentify_template" => {
                                    Ok(__FieldTag::__snapshot_structured_deidentify_template)
                                }
                                "snapshotImageRedactTemplate" => {
                                    Ok(__FieldTag::__snapshot_image_redact_template)
                                }
                                "snapshot_image_redact_template" => {
                                    Ok(__FieldTag::__snapshot_image_redact_template)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RequestedDeidentifyOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RequestedDeidentifyOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__snapshot_deidentify_template => {
                                if !fields.insert(__FieldTag::__snapshot_deidentify_template) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for snapshot_deidentify_template",
                                    ));
                                }
                                result.snapshot_deidentify_template = map.next_value::<std::option::Option<crate::model::DeidentifyTemplate>>()?
                                    ;
                            }
                            __FieldTag::__snapshot_structured_deidentify_template => {
                                if !fields
                                    .insert(__FieldTag::__snapshot_structured_deidentify_template)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for snapshot_structured_deidentify_template",
                                    ));
                                }
                                result.snapshot_structured_deidentify_template = map.next_value::<std::option::Option<crate::model::DeidentifyTemplate>>()?
                                    ;
                            }
                            __FieldTag::__snapshot_image_redact_template => {
                                if !fields.insert(__FieldTag::__snapshot_image_redact_template) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for snapshot_image_redact_template",
                                    ));
                                }
                                result.snapshot_image_redact_template = map.next_value::<std::option::Option<crate::model::DeidentifyTemplate>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RequestedDeidentifyOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.snapshot_deidentify_template.is_some() {
                state.serialize_entry(
                    "snapshotDeidentifyTemplate",
                    &self.snapshot_deidentify_template,
                )?;
            }
            if self.snapshot_structured_deidentify_template.is_some() {
                state.serialize_entry(
                    "snapshotStructuredDeidentifyTemplate",
                    &self.snapshot_structured_deidentify_template,
                )?;
            }
            if self.snapshot_image_redact_template.is_some() {
                state.serialize_entry(
                    "snapshotImageRedactTemplate",
                    &self.snapshot_image_redact_template,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// InfoType description.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InfoTypeDescription {
    /// Internal name of the infoType.
    pub name: std::string::String,

    /// Human readable form of the infoType name.
    pub display_name: std::string::String,

    /// Which parts of the API supports this InfoType.
    pub supported_by: std::vec::Vec<crate::model::InfoTypeSupportedBy>,

    /// Description of the infotype. Translated when language is provided in the
    /// request.
    pub description: std::string::String,

    /// A sample that is a true positive for this infoType.
    pub example: std::string::String,

    /// A list of available versions for the infotype.
    pub versions: std::vec::Vec<crate::model::VersionDescription>,

    /// The category of the infoType.
    pub categories: std::vec::Vec<crate::model::InfoTypeCategory>,

    /// The default sensitivity of the infoType.
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// If this field is set, this infoType is a general infoType and these
    /// specific infoTypes are contained within it.
    /// General infoTypes are infoTypes that encompass multiple specific infoTypes.
    /// For example, the "GEOGRAPHIC_DATA" general infoType would have set for this
    /// field "LOCATION", "LOCATION_COORDINATES", and "STREET_ADDRESS".
    pub specific_info_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoTypeDescription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InfoTypeDescription::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InfoTypeDescription::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [supported_by][crate::model::InfoTypeDescription::supported_by].
    pub fn set_supported_by<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeSupportedBy>,
    {
        use std::iter::Iterator;
        self.supported_by = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [description][crate::model::InfoTypeDescription::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [example][crate::model::InfoTypeDescription::example].
    pub fn set_example<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.example = v.into();
        self
    }

    /// Sets the value of [versions][crate::model::InfoTypeDescription::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VersionDescription>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [categories][crate::model::InfoTypeDescription::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::InfoTypeDescription::sensitivity_score].
    pub fn set_sensitivity_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sensitivity_score][crate::model::InfoTypeDescription::sensitivity_score].
    pub fn set_or_clear_sensitivity_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [specific_info_types][crate::model::InfoTypeDescription::specific_info_types].
    pub fn set_specific_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.specific_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InfoTypeDescription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeDescription"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InfoTypeDescription {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __supported_by,
            __description,
            __example,
            __versions,
            __categories,
            __sensitivity_score,
            __specific_info_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InfoTypeDescription")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "supportedBy" => Ok(__FieldTag::__supported_by),
                            "supported_by" => Ok(__FieldTag::__supported_by),
                            "description" => Ok(__FieldTag::__description),
                            "example" => Ok(__FieldTag::__example),
                            "versions" => Ok(__FieldTag::__versions),
                            "categories" => Ok(__FieldTag::__categories),
                            "sensitivityScore" => Ok(__FieldTag::__sensitivity_score),
                            "sensitivity_score" => Ok(__FieldTag::__sensitivity_score),
                            "specificInfoTypes" => Ok(__FieldTag::__specific_info_types),
                            "specific_info_types" => Ok(__FieldTag::__specific_info_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InfoTypeDescription;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InfoTypeDescription")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_by => {
                            if !fields.insert(__FieldTag::__supported_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_by",
                                ));
                            }
                            result.supported_by = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InfoTypeSupportedBy>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__example => {
                            if !fields.insert(__FieldTag::__example) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for example",
                                ));
                            }
                            result.example = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VersionDescription>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__categories => {
                            if !fields.insert(__FieldTag::__categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categories",
                                ));
                            }
                            result.categories =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InfoTypeCategory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sensitivity_score => {
                            if !fields.insert(__FieldTag::__sensitivity_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sensitivity_score",
                                ));
                            }
                            result.sensitivity_score = map
                                .next_value::<std::option::Option<crate::model::SensitivityScore>>(
                                )?;
                        }
                        __FieldTag::__specific_info_types => {
                            if !fields.insert(__FieldTag::__specific_info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for specific_info_types",
                                ));
                            }
                            result.specific_info_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InfoTypeDescription {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.supported_by.is_empty() {
            state.serialize_entry("supportedBy", &self.supported_by)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.example.is_empty() {
            state.serialize_entry("example", &self.example)?;
        }
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self.categories.is_empty() {
            state.serialize_entry("categories", &self.categories)?;
        }
        if self.sensitivity_score.is_some() {
            state.serialize_entry("sensitivityScore", &self.sensitivity_score)?;
        }
        if !self.specific_info_types.is_empty() {
            state.serialize_entry("specificInfoTypes", &self.specific_info_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Classification of infoTypes to organize them according to geographic
/// location, industry, and data type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InfoTypeCategory {
    /// Categories of infotypes.
    pub category: std::option::Option<crate::model::info_type_category::Category>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoTypeCategory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [category][crate::model::InfoTypeCategory::category].
    ///
    /// Note that all the setters affecting `category` are mutually
    /// exclusive.
    pub fn set_category<
        T: std::convert::Into<std::option::Option<crate::model::info_type_category::Category>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = v.into();
        self
    }

    /// The value of [category][crate::model::InfoTypeCategory::category]
    /// if it holds a `LocationCategory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn location_category(
        &self,
    ) -> std::option::Option<&crate::model::info_type_category::LocationCategory> {
        #[allow(unreachable_patterns)]
        self.category.as_ref().and_then(|v| match v {
            crate::model::info_type_category::Category::LocationCategory(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [category][crate::model::InfoTypeCategory::category]
    /// to hold a `LocationCategory`.
    ///
    /// Note that all the setters affecting `category` are
    /// mutually exclusive.
    pub fn set_location_category<
        T: std::convert::Into<crate::model::info_type_category::LocationCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = std::option::Option::Some(
            crate::model::info_type_category::Category::LocationCategory(v.into()),
        );
        self
    }

    /// The value of [category][crate::model::InfoTypeCategory::category]
    /// if it holds a `IndustryCategory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn industry_category(
        &self,
    ) -> std::option::Option<&crate::model::info_type_category::IndustryCategory> {
        #[allow(unreachable_patterns)]
        self.category.as_ref().and_then(|v| match v {
            crate::model::info_type_category::Category::IndustryCategory(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [category][crate::model::InfoTypeCategory::category]
    /// to hold a `IndustryCategory`.
    ///
    /// Note that all the setters affecting `category` are
    /// mutually exclusive.
    pub fn set_industry_category<
        T: std::convert::Into<crate::model::info_type_category::IndustryCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = std::option::Option::Some(
            crate::model::info_type_category::Category::IndustryCategory(v.into()),
        );
        self
    }

    /// The value of [category][crate::model::InfoTypeCategory::category]
    /// if it holds a `TypeCategory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn type_category(
        &self,
    ) -> std::option::Option<&crate::model::info_type_category::TypeCategory> {
        #[allow(unreachable_patterns)]
        self.category.as_ref().and_then(|v| match v {
            crate::model::info_type_category::Category::TypeCategory(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [category][crate::model::InfoTypeCategory::category]
    /// to hold a `TypeCategory`.
    ///
    /// Note that all the setters affecting `category` are
    /// mutually exclusive.
    pub fn set_type_category<
        T: std::convert::Into<crate::model::info_type_category::TypeCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = std::option::Option::Some(
            crate::model::info_type_category::Category::TypeCategory(v.into()),
        );
        self
    }
}

impl wkt::message::Message for InfoTypeCategory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeCategory"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InfoTypeCategory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location_category,
            __industry_category,
            __type_category,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InfoTypeCategory")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "locationCategory" => Ok(__FieldTag::__location_category),
                            "location_category" => Ok(__FieldTag::__location_category),
                            "industryCategory" => Ok(__FieldTag::__industry_category),
                            "industry_category" => Ok(__FieldTag::__industry_category),
                            "typeCategory" => Ok(__FieldTag::__type_category),
                            "type_category" => Ok(__FieldTag::__type_category),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InfoTypeCategory;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InfoTypeCategory")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location_category => {
                            if !fields.insert(__FieldTag::__location_category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_category",
                                ));
                            }
                            if result.category.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `category`, a oneof with full ID .google.privacy.dlp.v2.InfoTypeCategory.location_category, latest field was locationCategory",
                                ));
                            }
                            result.category = std::option::Option::Some(
                                crate::model::info_type_category::Category::LocationCategory(
                                    map.next_value::<std::option::Option<
                                        crate::model::info_type_category::LocationCategory,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__industry_category => {
                            if !fields.insert(__FieldTag::__industry_category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for industry_category",
                                ));
                            }
                            if result.category.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `category`, a oneof with full ID .google.privacy.dlp.v2.InfoTypeCategory.industry_category, latest field was industryCategory",
                                ));
                            }
                            result.category = std::option::Option::Some(
                                crate::model::info_type_category::Category::IndustryCategory(
                                    map.next_value::<std::option::Option<
                                        crate::model::info_type_category::IndustryCategory,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__type_category => {
                            if !fields.insert(__FieldTag::__type_category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type_category",
                                ));
                            }
                            if result.category.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `category`, a oneof with full ID .google.privacy.dlp.v2.InfoTypeCategory.type_category, latest field was typeCategory",
                                ));
                            }
                            result.category = std::option::Option::Some(
                                crate::model::info_type_category::Category::TypeCategory(
                                    map.next_value::<std::option::Option<
                                        crate::model::info_type_category::TypeCategory,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InfoTypeCategory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.location_category() {
            state.serialize_entry("locationCategory", value)?;
        }
        if let Some(value) = self.industry_category() {
            state.serialize_entry("industryCategory", value)?;
        }
        if let Some(value) = self.type_category() {
            state.serialize_entry("typeCategory", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InfoTypeCategory].
pub mod info_type_category {
    #[allow(unused_imports)]
    use super::*;

    /// Enum of the current locations.
    /// We might add more locations in the future.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocationCategory {
        /// Unused location
        LocationUnspecified,
        /// The infoType is not issued by or tied to a specific region, but is used
        /// almost everywhere.
        Global,
        /// The infoType is typically used in Argentina.
        Argentina,
        /// The infoType is typically used in Armenia.
        Armenia,
        /// The infoType is typically used in Australia.
        Australia,
        /// The infoType is typically used in Azerbaijan.
        Azerbaijan,
        /// The infoType is typically used in Belarus.
        Belarus,
        /// The infoType is typically used in Belgium.
        Belgium,
        /// The infoType is typically used in Brazil.
        Brazil,
        /// The infoType is typically used in Canada.
        Canada,
        /// The infoType is typically used in Chile.
        Chile,
        /// The infoType is typically used in China.
        China,
        /// The infoType is typically used in Colombia.
        Colombia,
        /// The infoType is typically used in Croatia.
        Croatia,
        /// The infoType is typically used in Czechia.
        Czechia,
        /// The infoType is typically used in Denmark.
        Denmark,
        /// The infoType is typically used in France.
        France,
        /// The infoType is typically used in Finland.
        Finland,
        /// The infoType is typically used in Germany.
        Germany,
        /// The infoType is typically used in Hong Kong.
        HongKong,
        /// The infoType is typically used in India.
        India,
        /// The infoType is typically used in Indonesia.
        Indonesia,
        /// The infoType is typically used in Ireland.
        Ireland,
        /// The infoType is typically used in Israel.
        Israel,
        /// The infoType is typically used in Italy.
        Italy,
        /// The infoType is typically used in Japan.
        Japan,
        /// The infoType is typically used in Kazakhstan.
        Kazakhstan,
        /// The infoType is typically used in Korea.
        Korea,
        /// The infoType is typically used in Mexico.
        Mexico,
        /// The infoType is typically used in the Netherlands.
        TheNetherlands,
        /// The infoType is typically used in New Zealand.
        NewZealand,
        /// The infoType is typically used in Norway.
        Norway,
        /// The infoType is typically used in Paraguay.
        Paraguay,
        /// The infoType is typically used in Peru.
        Peru,
        /// The infoType is typically used in Poland.
        Poland,
        /// The infoType is typically used in Portugal.
        Portugal,
        /// The infoType is typically used in Russia.
        Russia,
        /// The infoType is typically used in Singapore.
        Singapore,
        /// The infoType is typically used in South Africa.
        SouthAfrica,
        /// The infoType is typically used in Spain.
        Spain,
        /// The infoType is typically used in Sweden.
        Sweden,
        /// The infoType is typically used in Switzerland.
        Switzerland,
        /// The infoType is typically used in Taiwan.
        Taiwan,
        /// The infoType is typically used in Thailand.
        Thailand,
        /// The infoType is typically used in Turkey.
        Turkey,
        /// The infoType is typically used in Ukraine.
        Ukraine,
        /// The infoType is typically used in the United Kingdom.
        UnitedKingdom,
        /// The infoType is typically used in the United States.
        UnitedStates,
        /// The infoType is typically used in Uruguay.
        Uruguay,
        /// The infoType is typically used in Uzbekistan.
        Uzbekistan,
        /// The infoType is typically used in Venezuela.
        Venezuela,
        /// The infoType is typically used in Google internally.
        Internal,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LocationCategory::value] or
        /// [LocationCategory::name].
        UnknownValue(location_category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod location_category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LocationCategory {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::LocationUnspecified => std::option::Option::Some(0),
                Self::Global => std::option::Option::Some(1),
                Self::Argentina => std::option::Option::Some(2),
                Self::Armenia => std::option::Option::Some(51),
                Self::Australia => std::option::Option::Some(3),
                Self::Azerbaijan => std::option::Option::Some(48),
                Self::Belarus => std::option::Option::Some(50),
                Self::Belgium => std::option::Option::Some(4),
                Self::Brazil => std::option::Option::Some(5),
                Self::Canada => std::option::Option::Some(6),
                Self::Chile => std::option::Option::Some(7),
                Self::China => std::option::Option::Some(8),
                Self::Colombia => std::option::Option::Some(9),
                Self::Croatia => std::option::Option::Some(42),
                Self::Czechia => std::option::Option::Some(52),
                Self::Denmark => std::option::Option::Some(10),
                Self::France => std::option::Option::Some(11),
                Self::Finland => std::option::Option::Some(12),
                Self::Germany => std::option::Option::Some(13),
                Self::HongKong => std::option::Option::Some(14),
                Self::India => std::option::Option::Some(15),
                Self::Indonesia => std::option::Option::Some(16),
                Self::Ireland => std::option::Option::Some(17),
                Self::Israel => std::option::Option::Some(18),
                Self::Italy => std::option::Option::Some(19),
                Self::Japan => std::option::Option::Some(20),
                Self::Kazakhstan => std::option::Option::Some(47),
                Self::Korea => std::option::Option::Some(21),
                Self::Mexico => std::option::Option::Some(22),
                Self::TheNetherlands => std::option::Option::Some(23),
                Self::NewZealand => std::option::Option::Some(41),
                Self::Norway => std::option::Option::Some(24),
                Self::Paraguay => std::option::Option::Some(25),
                Self::Peru => std::option::Option::Some(26),
                Self::Poland => std::option::Option::Some(27),
                Self::Portugal => std::option::Option::Some(28),
                Self::Russia => std::option::Option::Some(44),
                Self::Singapore => std::option::Option::Some(29),
                Self::SouthAfrica => std::option::Option::Some(30),
                Self::Spain => std::option::Option::Some(31),
                Self::Sweden => std::option::Option::Some(32),
                Self::Switzerland => std::option::Option::Some(43),
                Self::Taiwan => std::option::Option::Some(33),
                Self::Thailand => std::option::Option::Some(34),
                Self::Turkey => std::option::Option::Some(35),
                Self::Ukraine => std::option::Option::Some(45),
                Self::UnitedKingdom => std::option::Option::Some(36),
                Self::UnitedStates => std::option::Option::Some(37),
                Self::Uruguay => std::option::Option::Some(38),
                Self::Uzbekistan => std::option::Option::Some(46),
                Self::Venezuela => std::option::Option::Some(39),
                Self::Internal => std::option::Option::Some(40),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::LocationUnspecified => std::option::Option::Some("LOCATION_UNSPECIFIED"),
                Self::Global => std::option::Option::Some("GLOBAL"),
                Self::Argentina => std::option::Option::Some("ARGENTINA"),
                Self::Armenia => std::option::Option::Some("ARMENIA"),
                Self::Australia => std::option::Option::Some("AUSTRALIA"),
                Self::Azerbaijan => std::option::Option::Some("AZERBAIJAN"),
                Self::Belarus => std::option::Option::Some("BELARUS"),
                Self::Belgium => std::option::Option::Some("BELGIUM"),
                Self::Brazil => std::option::Option::Some("BRAZIL"),
                Self::Canada => std::option::Option::Some("CANADA"),
                Self::Chile => std::option::Option::Some("CHILE"),
                Self::China => std::option::Option::Some("CHINA"),
                Self::Colombia => std::option::Option::Some("COLOMBIA"),
                Self::Croatia => std::option::Option::Some("CROATIA"),
                Self::Czechia => std::option::Option::Some("CZECHIA"),
                Self::Denmark => std::option::Option::Some("DENMARK"),
                Self::France => std::option::Option::Some("FRANCE"),
                Self::Finland => std::option::Option::Some("FINLAND"),
                Self::Germany => std::option::Option::Some("GERMANY"),
                Self::HongKong => std::option::Option::Some("HONG_KONG"),
                Self::India => std::option::Option::Some("INDIA"),
                Self::Indonesia => std::option::Option::Some("INDONESIA"),
                Self::Ireland => std::option::Option::Some("IRELAND"),
                Self::Israel => std::option::Option::Some("ISRAEL"),
                Self::Italy => std::option::Option::Some("ITALY"),
                Self::Japan => std::option::Option::Some("JAPAN"),
                Self::Kazakhstan => std::option::Option::Some("KAZAKHSTAN"),
                Self::Korea => std::option::Option::Some("KOREA"),
                Self::Mexico => std::option::Option::Some("MEXICO"),
                Self::TheNetherlands => std::option::Option::Some("THE_NETHERLANDS"),
                Self::NewZealand => std::option::Option::Some("NEW_ZEALAND"),
                Self::Norway => std::option::Option::Some("NORWAY"),
                Self::Paraguay => std::option::Option::Some("PARAGUAY"),
                Self::Peru => std::option::Option::Some("PERU"),
                Self::Poland => std::option::Option::Some("POLAND"),
                Self::Portugal => std::option::Option::Some("PORTUGAL"),
                Self::Russia => std::option::Option::Some("RUSSIA"),
                Self::Singapore => std::option::Option::Some("SINGAPORE"),
                Self::SouthAfrica => std::option::Option::Some("SOUTH_AFRICA"),
                Self::Spain => std::option::Option::Some("SPAIN"),
                Self::Sweden => std::option::Option::Some("SWEDEN"),
                Self::Switzerland => std::option::Option::Some("SWITZERLAND"),
                Self::Taiwan => std::option::Option::Some("TAIWAN"),
                Self::Thailand => std::option::Option::Some("THAILAND"),
                Self::Turkey => std::option::Option::Some("TURKEY"),
                Self::Ukraine => std::option::Option::Some("UKRAINE"),
                Self::UnitedKingdom => std::option::Option::Some("UNITED_KINGDOM"),
                Self::UnitedStates => std::option::Option::Some("UNITED_STATES"),
                Self::Uruguay => std::option::Option::Some("URUGUAY"),
                Self::Uzbekistan => std::option::Option::Some("UZBEKISTAN"),
                Self::Venezuela => std::option::Option::Some("VENEZUELA"),
                Self::Internal => std::option::Option::Some("INTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LocationCategory {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LocationCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LocationCategory {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::LocationUnspecified,
                1 => Self::Global,
                2 => Self::Argentina,
                3 => Self::Australia,
                4 => Self::Belgium,
                5 => Self::Brazil,
                6 => Self::Canada,
                7 => Self::Chile,
                8 => Self::China,
                9 => Self::Colombia,
                10 => Self::Denmark,
                11 => Self::France,
                12 => Self::Finland,
                13 => Self::Germany,
                14 => Self::HongKong,
                15 => Self::India,
                16 => Self::Indonesia,
                17 => Self::Ireland,
                18 => Self::Israel,
                19 => Self::Italy,
                20 => Self::Japan,
                21 => Self::Korea,
                22 => Self::Mexico,
                23 => Self::TheNetherlands,
                24 => Self::Norway,
                25 => Self::Paraguay,
                26 => Self::Peru,
                27 => Self::Poland,
                28 => Self::Portugal,
                29 => Self::Singapore,
                30 => Self::SouthAfrica,
                31 => Self::Spain,
                32 => Self::Sweden,
                33 => Self::Taiwan,
                34 => Self::Thailand,
                35 => Self::Turkey,
                36 => Self::UnitedKingdom,
                37 => Self::UnitedStates,
                38 => Self::Uruguay,
                39 => Self::Venezuela,
                40 => Self::Internal,
                41 => Self::NewZealand,
                42 => Self::Croatia,
                43 => Self::Switzerland,
                44 => Self::Russia,
                45 => Self::Ukraine,
                46 => Self::Uzbekistan,
                47 => Self::Kazakhstan,
                48 => Self::Azerbaijan,
                50 => Self::Belarus,
                51 => Self::Armenia,
                52 => Self::Czechia,
                _ => Self::UnknownValue(location_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LocationCategory {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCATION_UNSPECIFIED" => Self::LocationUnspecified,
                "GLOBAL" => Self::Global,
                "ARGENTINA" => Self::Argentina,
                "ARMENIA" => Self::Armenia,
                "AUSTRALIA" => Self::Australia,
                "AZERBAIJAN" => Self::Azerbaijan,
                "BELARUS" => Self::Belarus,
                "BELGIUM" => Self::Belgium,
                "BRAZIL" => Self::Brazil,
                "CANADA" => Self::Canada,
                "CHILE" => Self::Chile,
                "CHINA" => Self::China,
                "COLOMBIA" => Self::Colombia,
                "CROATIA" => Self::Croatia,
                "CZECHIA" => Self::Czechia,
                "DENMARK" => Self::Denmark,
                "FRANCE" => Self::France,
                "FINLAND" => Self::Finland,
                "GERMANY" => Self::Germany,
                "HONG_KONG" => Self::HongKong,
                "INDIA" => Self::India,
                "INDONESIA" => Self::Indonesia,
                "IRELAND" => Self::Ireland,
                "ISRAEL" => Self::Israel,
                "ITALY" => Self::Italy,
                "JAPAN" => Self::Japan,
                "KAZAKHSTAN" => Self::Kazakhstan,
                "KOREA" => Self::Korea,
                "MEXICO" => Self::Mexico,
                "THE_NETHERLANDS" => Self::TheNetherlands,
                "NEW_ZEALAND" => Self::NewZealand,
                "NORWAY" => Self::Norway,
                "PARAGUAY" => Self::Paraguay,
                "PERU" => Self::Peru,
                "POLAND" => Self::Poland,
                "PORTUGAL" => Self::Portugal,
                "RUSSIA" => Self::Russia,
                "SINGAPORE" => Self::Singapore,
                "SOUTH_AFRICA" => Self::SouthAfrica,
                "SPAIN" => Self::Spain,
                "SWEDEN" => Self::Sweden,
                "SWITZERLAND" => Self::Switzerland,
                "TAIWAN" => Self::Taiwan,
                "THAILAND" => Self::Thailand,
                "TURKEY" => Self::Turkey,
                "UKRAINE" => Self::Ukraine,
                "UNITED_KINGDOM" => Self::UnitedKingdom,
                "UNITED_STATES" => Self::UnitedStates,
                "URUGUAY" => Self::Uruguay,
                "UZBEKISTAN" => Self::Uzbekistan,
                "VENEZUELA" => Self::Venezuela,
                "INTERNAL" => Self::Internal,
                _ => Self::UnknownValue(location_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LocationCategory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::LocationUnspecified => serializer.serialize_i32(0),
                Self::Global => serializer.serialize_i32(1),
                Self::Argentina => serializer.serialize_i32(2),
                Self::Armenia => serializer.serialize_i32(51),
                Self::Australia => serializer.serialize_i32(3),
                Self::Azerbaijan => serializer.serialize_i32(48),
                Self::Belarus => serializer.serialize_i32(50),
                Self::Belgium => serializer.serialize_i32(4),
                Self::Brazil => serializer.serialize_i32(5),
                Self::Canada => serializer.serialize_i32(6),
                Self::Chile => serializer.serialize_i32(7),
                Self::China => serializer.serialize_i32(8),
                Self::Colombia => serializer.serialize_i32(9),
                Self::Croatia => serializer.serialize_i32(42),
                Self::Czechia => serializer.serialize_i32(52),
                Self::Denmark => serializer.serialize_i32(10),
                Self::France => serializer.serialize_i32(11),
                Self::Finland => serializer.serialize_i32(12),
                Self::Germany => serializer.serialize_i32(13),
                Self::HongKong => serializer.serialize_i32(14),
                Self::India => serializer.serialize_i32(15),
                Self::Indonesia => serializer.serialize_i32(16),
                Self::Ireland => serializer.serialize_i32(17),
                Self::Israel => serializer.serialize_i32(18),
                Self::Italy => serializer.serialize_i32(19),
                Self::Japan => serializer.serialize_i32(20),
                Self::Kazakhstan => serializer.serialize_i32(47),
                Self::Korea => serializer.serialize_i32(21),
                Self::Mexico => serializer.serialize_i32(22),
                Self::TheNetherlands => serializer.serialize_i32(23),
                Self::NewZealand => serializer.serialize_i32(41),
                Self::Norway => serializer.serialize_i32(24),
                Self::Paraguay => serializer.serialize_i32(25),
                Self::Peru => serializer.serialize_i32(26),
                Self::Poland => serializer.serialize_i32(27),
                Self::Portugal => serializer.serialize_i32(28),
                Self::Russia => serializer.serialize_i32(44),
                Self::Singapore => serializer.serialize_i32(29),
                Self::SouthAfrica => serializer.serialize_i32(30),
                Self::Spain => serializer.serialize_i32(31),
                Self::Sweden => serializer.serialize_i32(32),
                Self::Switzerland => serializer.serialize_i32(43),
                Self::Taiwan => serializer.serialize_i32(33),
                Self::Thailand => serializer.serialize_i32(34),
                Self::Turkey => serializer.serialize_i32(35),
                Self::Ukraine => serializer.serialize_i32(45),
                Self::UnitedKingdom => serializer.serialize_i32(36),
                Self::UnitedStates => serializer.serialize_i32(37),
                Self::Uruguay => serializer.serialize_i32(38),
                Self::Uzbekistan => serializer.serialize_i32(46),
                Self::Venezuela => serializer.serialize_i32(39),
                Self::Internal => serializer.serialize_i32(40),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LocationCategory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocationCategory>::new(
                ".google.privacy.dlp.v2.InfoTypeCategory.LocationCategory",
            ))
        }
    }

    /// Enum of the current industries in the category.
    /// We might add more industries in the future.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IndustryCategory {
        /// Unused industry
        IndustryUnspecified,
        /// The infoType is typically used in the finance industry.
        Finance,
        /// The infoType is typically used in the health industry.
        Health,
        /// The infoType is typically used in the telecommunications industry.
        Telecommunications,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IndustryCategory::value] or
        /// [IndustryCategory::name].
        UnknownValue(industry_category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod industry_category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IndustryCategory {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::IndustryUnspecified => std::option::Option::Some(0),
                Self::Finance => std::option::Option::Some(1),
                Self::Health => std::option::Option::Some(2),
                Self::Telecommunications => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::IndustryUnspecified => std::option::Option::Some("INDUSTRY_UNSPECIFIED"),
                Self::Finance => std::option::Option::Some("FINANCE"),
                Self::Health => std::option::Option::Some("HEALTH"),
                Self::Telecommunications => std::option::Option::Some("TELECOMMUNICATIONS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IndustryCategory {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IndustryCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IndustryCategory {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::IndustryUnspecified,
                1 => Self::Finance,
                2 => Self::Health,
                3 => Self::Telecommunications,
                _ => Self::UnknownValue(industry_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IndustryCategory {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INDUSTRY_UNSPECIFIED" => Self::IndustryUnspecified,
                "FINANCE" => Self::Finance,
                "HEALTH" => Self::Health,
                "TELECOMMUNICATIONS" => Self::Telecommunications,
                _ => Self::UnknownValue(industry_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IndustryCategory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::IndustryUnspecified => serializer.serialize_i32(0),
                Self::Finance => serializer.serialize_i32(1),
                Self::Health => serializer.serialize_i32(2),
                Self::Telecommunications => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IndustryCategory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IndustryCategory>::new(
                ".google.privacy.dlp.v2.InfoTypeCategory.IndustryCategory",
            ))
        }
    }

    /// Enum of the current types in the category.
    /// We might add more types in the future.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TypeCategory {
        /// Unused type
        TypeUnspecified,
        /// Personally identifiable information, for example, a
        /// name or phone number
        Pii,
        /// Personally identifiable information that is especially sensitive, for
        /// example, a passport number.
        Spii,
        /// Attributes that can partially identify someone, especially in
        /// combination with other attributes, like age, height, and gender.
        Demographic,
        /// Confidential or secret information, for example, a password.
        Credential,
        /// An identification document issued by a government.
        GovernmentId,
        /// A document, for example, a resume or source code.
        Document,
        /// Information that is not sensitive on its own, but provides details about
        /// the circumstances surrounding an entity or an event.
        ContextualInformation,
        /// Category for `CustomInfoType` types.
        Custom,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TypeCategory::value] or
        /// [TypeCategory::name].
        UnknownValue(type_category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod type_category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TypeCategory {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some(0),
                Self::Pii => std::option::Option::Some(1),
                Self::Spii => std::option::Option::Some(2),
                Self::Demographic => std::option::Option::Some(3),
                Self::Credential => std::option::Option::Some(4),
                Self::GovernmentId => std::option::Option::Some(5),
                Self::Document => std::option::Option::Some(6),
                Self::ContextualInformation => std::option::Option::Some(7),
                Self::Custom => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Pii => std::option::Option::Some("PII"),
                Self::Spii => std::option::Option::Some("SPII"),
                Self::Demographic => std::option::Option::Some("DEMOGRAPHIC"),
                Self::Credential => std::option::Option::Some("CREDENTIAL"),
                Self::GovernmentId => std::option::Option::Some("GOVERNMENT_ID"),
                Self::Document => std::option::Option::Some("DOCUMENT"),
                Self::ContextualInformation => std::option::Option::Some("CONTEXTUAL_INFORMATION"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TypeCategory {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TypeCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TypeCategory {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::TypeUnspecified,
                1 => Self::Pii,
                2 => Self::Spii,
                3 => Self::Demographic,
                4 => Self::Credential,
                5 => Self::GovernmentId,
                6 => Self::Document,
                7 => Self::ContextualInformation,
                8 => Self::Custom,
                _ => Self::UnknownValue(type_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TypeCategory {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::TypeUnspecified,
                "PII" => Self::Pii,
                "SPII" => Self::Spii,
                "DEMOGRAPHIC" => Self::Demographic,
                "CREDENTIAL" => Self::Credential,
                "GOVERNMENT_ID" => Self::GovernmentId,
                "DOCUMENT" => Self::Document,
                "CONTEXTUAL_INFORMATION" => Self::ContextualInformation,
                "CUSTOM" => Self::Custom,
                _ => Self::UnknownValue(type_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TypeCategory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::TypeUnspecified => serializer.serialize_i32(0),
                Self::Pii => serializer.serialize_i32(1),
                Self::Spii => serializer.serialize_i32(2),
                Self::Demographic => serializer.serialize_i32(3),
                Self::Credential => serializer.serialize_i32(4),
                Self::GovernmentId => serializer.serialize_i32(5),
                Self::Document => serializer.serialize_i32(6),
                Self::ContextualInformation => serializer.serialize_i32(7),
                Self::Custom => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TypeCategory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TypeCategory>::new(
                ".google.privacy.dlp.v2.InfoTypeCategory.TypeCategory",
            ))
        }
    }

    /// Categories of infotypes.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Category {
        /// The region or country that issued the ID or document represented by the
        /// infoType.
        LocationCategory(crate::model::info_type_category::LocationCategory),
        /// The group of relevant businesses where this infoType is commonly used
        IndustryCategory(crate::model::info_type_category::IndustryCategory),
        /// The class of identifiers where this infoType belongs
        TypeCategory(crate::model::info_type_category::TypeCategory),
    }
}

/// Details about each available version for an infotype.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VersionDescription {
    /// Name of the version
    pub version: std::string::String,

    /// Description of the version.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VersionDescription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::VersionDescription::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [description][crate::model::VersionDescription::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for VersionDescription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VersionDescription"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VersionDescription {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VersionDescription")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VersionDescription;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VersionDescription")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VersionDescription {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the list of infoTypes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInfoTypesRequest {
    /// The parent resource name.
    ///
    /// The format of this value is as follows:
    ///
    /// ```norust
    /// `locations/{location_id}`
    /// ```
    pub parent: std::string::String,

    /// BCP-47 language code for localized infoType friendly
    /// names. If omitted, or if localized strings are not available,
    /// en-US strings will be returned.
    pub language_code: std::string::String,

    /// filter to only return infoTypes supported by certain parts of the
    /// API. Defaults to supported_by=INSPECT.
    pub filter: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInfoTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInfoTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ListInfoTypesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInfoTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListInfoTypesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListInfoTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInfoTypesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInfoTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __language_code,
            __filter,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInfoTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "filter" => Ok(__FieldTag::__filter),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInfoTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInfoTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInfoTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response to the ListInfoTypes request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInfoTypesResponse {
    /// Set of sensitive infoTypes.
    pub info_types: std::vec::Vec<crate::model::InfoTypeDescription>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInfoTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_types][crate::model::ListInfoTypesResponse::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeDescription>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInfoTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInfoTypesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInfoTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInfoTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoTypes" => Ok(__FieldTag::__info_types),
                            "info_types" => Ok(__FieldTag::__info_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInfoTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInfoTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_types => {
                            if !fields.insert(__FieldTag::__info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_types",
                                ));
                            }
                            result.info_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InfoTypeDescription>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInfoTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.info_types.is_empty() {
            state.serialize_entry("infoTypes", &self.info_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for a risk analysis job. See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-risk-analysis>
/// to learn more.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RiskAnalysisJobConfig {
    /// Privacy metric to compute.
    pub privacy_metric: std::option::Option<crate::model::PrivacyMetric>,

    /// Input dataset to compute metrics over.
    pub source_table: std::option::Option<crate::model::BigQueryTable>,

    /// Actions to execute at the completion of the job. Are executed in the order
    /// provided.
    pub actions: std::vec::Vec<crate::model::Action>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RiskAnalysisJobConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [privacy_metric][crate::model::RiskAnalysisJobConfig::privacy_metric].
    pub fn set_privacy_metric<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivacyMetric>,
    {
        self.privacy_metric = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [privacy_metric][crate::model::RiskAnalysisJobConfig::privacy_metric].
    pub fn set_or_clear_privacy_metric<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivacyMetric>,
    {
        self.privacy_metric = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_table][crate::model::RiskAnalysisJobConfig::source_table].
    pub fn set_source_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.source_table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_table][crate::model::RiskAnalysisJobConfig::source_table].
    pub fn set_or_clear_source_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.source_table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [actions][crate::model::RiskAnalysisJobConfig::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Action>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RiskAnalysisJobConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RiskAnalysisJobConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RiskAnalysisJobConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __privacy_metric,
            __source_table,
            __actions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RiskAnalysisJobConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privacyMetric" => Ok(__FieldTag::__privacy_metric),
                            "privacy_metric" => Ok(__FieldTag::__privacy_metric),
                            "sourceTable" => Ok(__FieldTag::__source_table),
                            "source_table" => Ok(__FieldTag::__source_table),
                            "actions" => Ok(__FieldTag::__actions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RiskAnalysisJobConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RiskAnalysisJobConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__privacy_metric => {
                            if !fields.insert(__FieldTag::__privacy_metric) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privacy_metric",
                                ));
                            }
                            result.privacy_metric = map
                                .next_value::<std::option::Option<crate::model::PrivacyMetric>>()?;
                        }
                        __FieldTag::__source_table => {
                            if !fields.insert(__FieldTag::__source_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_table",
                                ));
                            }
                            result.source_table = map
                                .next_value::<std::option::Option<crate::model::BigQueryTable>>()?;
                        }
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Action>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RiskAnalysisJobConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.privacy_metric.is_some() {
            state.serialize_entry("privacyMetric", &self.privacy_metric)?;
        }
        if self.source_table.is_some() {
            state.serialize_entry("sourceTable", &self.source_table)?;
        }
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A column with a semantic tag attached.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QuasiId {
    /// Required. Identifies the column.
    pub field: std::option::Option<crate::model::FieldId>,

    /// Semantic tag that identifies what a column contains, to determine which
    /// statistical model to use to estimate the reidentifiability of each
    /// value. [required]
    pub tag: std::option::Option<crate::model::quasi_id::Tag>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuasiId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::QuasiId::field].
    pub fn set_field<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field][crate::model::QuasiId::field].
    pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tag][crate::model::QuasiId::tag].
    ///
    /// Note that all the setters affecting `tag` are mutually
    /// exclusive.
    pub fn set_tag<T: std::convert::Into<std::option::Option<crate::model::quasi_id::Tag>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = v.into();
        self
    }

    /// The value of [tag][crate::model::QuasiId::tag]
    /// if it holds a `InfoType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn info_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::InfoType>> {
        #[allow(unreachable_patterns)]
        self.tag.as_ref().and_then(|v| match v {
            crate::model::quasi_id::Tag::InfoType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tag][crate::model::QuasiId::tag]
    /// to hold a `InfoType`.
    ///
    /// Note that all the setters affecting `tag` are
    /// mutually exclusive.
    pub fn set_info_type<T: std::convert::Into<std::boxed::Box<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = std::option::Option::Some(crate::model::quasi_id::Tag::InfoType(v.into()));
        self
    }

    /// The value of [tag][crate::model::QuasiId::tag]
    /// if it holds a `CustomTag`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_tag(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.tag.as_ref().and_then(|v| match v {
            crate::model::quasi_id::Tag::CustomTag(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tag][crate::model::QuasiId::tag]
    /// to hold a `CustomTag`.
    ///
    /// Note that all the setters affecting `tag` are
    /// mutually exclusive.
    pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = std::option::Option::Some(crate::model::quasi_id::Tag::CustomTag(v.into()));
        self
    }

    /// The value of [tag][crate::model::QuasiId::tag]
    /// if it holds a `Inferred`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inferred(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.tag.as_ref().and_then(|v| match v {
            crate::model::quasi_id::Tag::Inferred(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tag][crate::model::QuasiId::tag]
    /// to hold a `Inferred`.
    ///
    /// Note that all the setters affecting `tag` are
    /// mutually exclusive.
    pub fn set_inferred<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = std::option::Option::Some(crate::model::quasi_id::Tag::Inferred(v.into()));
        self
    }
}

impl wkt::message::Message for QuasiId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.QuasiId"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QuasiId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            __info_type,
            __custom_tag,
            __inferred,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QuasiId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            "customTag" => Ok(__FieldTag::__custom_tag),
                            "custom_tag" => Ok(__FieldTag::__custom_tag),
                            "inferred" => Ok(__FieldTag::__inferred),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QuasiId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QuasiId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field =
                                map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                        }
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type",
                                ));
                            }
                            if result.tag.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `tag`, a oneof with full ID .google.privacy.dlp.v2.QuasiId.info_type, latest field was infoType",
                                ));
                            }
                            result.tag =
                                std::option::Option::Some(crate::model::quasi_id::Tag::InfoType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InfoType>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__custom_tag => {
                            if !fields.insert(__FieldTag::__custom_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_tag",
                                ));
                            }
                            if result.tag.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `tag`, a oneof with full ID .google.privacy.dlp.v2.QuasiId.custom_tag, latest field was customTag",
                                ));
                            }
                            result.tag =
                                std::option::Option::Some(crate::model::quasi_id::Tag::CustomTag(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__inferred => {
                            if !fields.insert(__FieldTag::__inferred) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inferred",
                                ));
                            }
                            if result.tag.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `tag`, a oneof with full ID .google.privacy.dlp.v2.QuasiId.inferred, latest field was inferred",
                                ));
                            }
                            result.tag = std::option::Option::Some(
                                crate::model::quasi_id::Tag::Inferred(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Empty>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QuasiId {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.field.is_some() {
            state.serialize_entry("field", &self.field)?;
        }
        if let Some(value) = self.info_type() {
            state.serialize_entry("infoType", value)?;
        }
        if let Some(value) = self.custom_tag() {
            state.serialize_entry("customTag", value)?;
        }
        if let Some(value) = self.inferred() {
            state.serialize_entry("inferred", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [QuasiId].
pub mod quasi_id {
    #[allow(unused_imports)]
    use super::*;

    /// Semantic tag that identifies what a column contains, to determine which
    /// statistical model to use to estimate the reidentifiability of each
    /// value. [required]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Tag {
        /// A column can be tagged with a InfoType to use the relevant public
        /// dataset as a statistical model of population, if available. We
        /// currently support US ZIP codes, region codes, ages and genders.
        /// To programmatically obtain the list of supported InfoTypes, use
        /// ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
        InfoType(std::boxed::Box<crate::model::InfoType>),
        /// A column can be tagged with a custom tag. In this case, the user must
        /// indicate an auxiliary table that contains statistical information on
        /// the possible values of this column (below).
        CustomTag(std::string::String),
        /// If no semantic tag is indicated, we infer the statistical model from
        /// the distribution of values in the input data
        Inferred(std::boxed::Box<wkt::Empty>),
    }
}

/// An auxiliary table containing statistical information on the relative
/// frequency of different quasi-identifiers values. It has one or several
/// quasi-identifiers columns, and one column that indicates the relative
/// frequency of each quasi-identifier tuple.
/// If a tuple is present in the data but not in the auxiliary table, the
/// corresponding relative frequency is assumed to be zero (and thus, the
/// tuple is highly reidentifiable).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StatisticalTable {
    /// Required. Auxiliary table location.
    pub table: std::option::Option<crate::model::BigQueryTable>,

    /// Required. Quasi-identifier columns.
    pub quasi_ids: std::vec::Vec<crate::model::statistical_table::QuasiIdentifierField>,

    /// Required. The relative frequency column must contain a floating-point
    /// number between 0 and 1 (inclusive). Null values are assumed to be zero.
    pub relative_frequency: std::option::Option<crate::model::FieldId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StatisticalTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::StatisticalTable::table].
    pub fn set_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table][crate::model::StatisticalTable::table].
    pub fn set_or_clear_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [quasi_ids][crate::model::StatisticalTable::quasi_ids].
    pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::statistical_table::QuasiIdentifierField>,
    {
        use std::iter::Iterator;
        self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [relative_frequency][crate::model::StatisticalTable::relative_frequency].
    pub fn set_relative_frequency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.relative_frequency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [relative_frequency][crate::model::StatisticalTable::relative_frequency].
    pub fn set_or_clear_relative_frequency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.relative_frequency = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StatisticalTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StatisticalTable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StatisticalTable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table,
            __quasi_ids,
            __relative_frequency,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StatisticalTable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "table" => Ok(__FieldTag::__table),
                            "quasiIds" => Ok(__FieldTag::__quasi_ids),
                            "quasi_ids" => Ok(__FieldTag::__quasi_ids),
                            "relativeFrequency" => Ok(__FieldTag::__relative_frequency),
                            "relative_frequency" => Ok(__FieldTag::__relative_frequency),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StatisticalTable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StatisticalTable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table = map
                                .next_value::<std::option::Option<crate::model::BigQueryTable>>()?;
                        }
                        __FieldTag::__quasi_ids => {
                            if !fields.insert(__FieldTag::__quasi_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quasi_ids",
                                ));
                            }
                            result.quasi_ids = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::statistical_table::QuasiIdentifierField,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relative_frequency => {
                            if !fields.insert(__FieldTag::__relative_frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relative_frequency",
                                ));
                            }
                            result.relative_frequency =
                                map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StatisticalTable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.table.is_some() {
            state.serialize_entry("table", &self.table)?;
        }
        if !self.quasi_ids.is_empty() {
            state.serialize_entry("quasiIds", &self.quasi_ids)?;
        }
        if self.relative_frequency.is_some() {
            state.serialize_entry("relativeFrequency", &self.relative_frequency)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StatisticalTable].
pub mod statistical_table {
    #[allow(unused_imports)]
    use super::*;

    /// A quasi-identifier column has a custom_tag, used to know which column
    /// in the data corresponds to which column in the statistical model.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QuasiIdentifierField {
        /// Identifies the column.
        pub field: std::option::Option<crate::model::FieldId>,

        /// A column can be tagged with a custom tag. In this case, the user must
        /// indicate an auxiliary table that contains statistical information on
        /// the possible values of this column (below).
        pub custom_tag: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QuasiIdentifierField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::statistical_table::QuasiIdentifierField::field].
        pub fn set_field<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.field = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [field][crate::model::statistical_table::QuasiIdentifierField::field].
        pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.field = v.map(|x| x.into());
            self
        }

        /// Sets the value of [custom_tag][crate::model::statistical_table::QuasiIdentifierField::custom_tag].
        pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.custom_tag = v.into();
            self
        }
    }

    impl wkt::message::Message for QuasiIdentifierField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.StatisticalTable.QuasiIdentifierField"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QuasiIdentifierField {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __field,
                __custom_tag,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QuasiIdentifierField")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "field" => Ok(__FieldTag::__field),
                                "customTag" => Ok(__FieldTag::__custom_tag),
                                "custom_tag" => Ok(__FieldTag::__custom_tag),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QuasiIdentifierField;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QuasiIdentifierField")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__field => {
                                if !fields.insert(__FieldTag::__field) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field",
                                    ));
                                }
                                result.field =
                                    map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                            }
                            __FieldTag::__custom_tag => {
                                if !fields.insert(__FieldTag::__custom_tag) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for custom_tag",
                                    ));
                                }
                                result.custom_tag = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QuasiIdentifierField {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.field.is_some() {
                state.serialize_entry("field", &self.field)?;
            }
            if !self.custom_tag.is_empty() {
                state.serialize_entry("customTag", &self.custom_tag)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Privacy metric to compute for reidentification risk analysis.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivacyMetric {
    /// Types of analysis.
    pub r#type: std::option::Option<crate::model::privacy_metric::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivacyMetric {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::privacy_metric::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `NumericalStatsConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn numerical_stats_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::NumericalStatsConfig>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::NumericalStatsConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `NumericalStatsConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_numerical_stats_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::NumericalStatsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::NumericalStatsConfig(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `CategoricalStatsConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn categorical_stats_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::CategoricalStatsConfig>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::CategoricalStatsConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `CategoricalStatsConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_categorical_stats_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::CategoricalStatsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::CategoricalStatsConfig(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `KAnonymityConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn k_anonymity_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::KAnonymityConfig>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::KAnonymityConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `KAnonymityConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_k_anonymity_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::KAnonymityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::KAnonymityConfig(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `LDiversityConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn l_diversity_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::LDiversityConfig>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::LDiversityConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `LDiversityConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_l_diversity_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::LDiversityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::LDiversityConfig(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `KMapEstimationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn k_map_estimation_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::KMapEstimationConfig>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::KMapEstimationConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `KMapEstimationConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_k_map_estimation_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::KMapEstimationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::KMapEstimationConfig(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `DeltaPresenceEstimationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delta_presence_estimation_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::privacy_metric::DeltaPresenceEstimationConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::DeltaPresenceEstimationConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `DeltaPresenceEstimationConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_delta_presence_estimation_config<
        T: std::convert::Into<
                std::boxed::Box<crate::model::privacy_metric::DeltaPresenceEstimationConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::DeltaPresenceEstimationConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PrivacyMetric {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivacyMetric {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __numerical_stats_config,
            __categorical_stats_config,
            __k_anonymity_config,
            __l_diversity_config,
            __k_map_estimation_config,
            __delta_presence_estimation_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivacyMetric")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "numericalStatsConfig" => Ok(__FieldTag::__numerical_stats_config),
                            "numerical_stats_config" => Ok(__FieldTag::__numerical_stats_config),
                            "categoricalStatsConfig" => Ok(__FieldTag::__categorical_stats_config),
                            "categorical_stats_config" => {
                                Ok(__FieldTag::__categorical_stats_config)
                            }
                            "kAnonymityConfig" => Ok(__FieldTag::__k_anonymity_config),
                            "k_anonymity_config" => Ok(__FieldTag::__k_anonymity_config),
                            "lDiversityConfig" => Ok(__FieldTag::__l_diversity_config),
                            "l_diversity_config" => Ok(__FieldTag::__l_diversity_config),
                            "kMapEstimationConfig" => Ok(__FieldTag::__k_map_estimation_config),
                            "k_map_estimation_config" => Ok(__FieldTag::__k_map_estimation_config),
                            "deltaPresenceEstimationConfig" => {
                                Ok(__FieldTag::__delta_presence_estimation_config)
                            }
                            "delta_presence_estimation_config" => {
                                Ok(__FieldTag::__delta_presence_estimation_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivacyMetric;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivacyMetric")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__numerical_stats_config => {
                            if !fields.insert(__FieldTag::__numerical_stats_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for numerical_stats_config",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.PrivacyMetric.numerical_stats_config, latest field was numericalStatsConfig",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::privacy_metric::Type::NumericalStatsConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::privacy_metric::NumericalStatsConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__categorical_stats_config => {
                            if !fields.insert(__FieldTag::__categorical_stats_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categorical_stats_config",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.PrivacyMetric.categorical_stats_config, latest field was categoricalStatsConfig",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::privacy_metric::Type::CategoricalStatsConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::privacy_metric::CategoricalStatsConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__k_anonymity_config => {
                            if !fields.insert(__FieldTag::__k_anonymity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for k_anonymity_config",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.PrivacyMetric.k_anonymity_config, latest field was kAnonymityConfig",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::privacy_metric::Type::KAnonymityConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::privacy_metric::KAnonymityConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__l_diversity_config => {
                            if !fields.insert(__FieldTag::__l_diversity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for l_diversity_config",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.PrivacyMetric.l_diversity_config, latest field was lDiversityConfig",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::privacy_metric::Type::LDiversityConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::privacy_metric::LDiversityConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__k_map_estimation_config => {
                            if !fields.insert(__FieldTag::__k_map_estimation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for k_map_estimation_config",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.PrivacyMetric.k_map_estimation_config, latest field was kMapEstimationConfig",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::privacy_metric::Type::KMapEstimationConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::privacy_metric::KMapEstimationConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__delta_presence_estimation_config => {
                            if !fields.insert(__FieldTag::__delta_presence_estimation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delta_presence_estimation_config",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.PrivacyMetric.delta_presence_estimation_config, latest field was deltaPresenceEstimationConfig",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::privacy_metric::Type::DeltaPresenceEstimationConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::privacy_metric::DeltaPresenceEstimationConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivacyMetric {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.numerical_stats_config() {
            state.serialize_entry("numericalStatsConfig", value)?;
        }
        if let Some(value) = self.categorical_stats_config() {
            state.serialize_entry("categoricalStatsConfig", value)?;
        }
        if let Some(value) = self.k_anonymity_config() {
            state.serialize_entry("kAnonymityConfig", value)?;
        }
        if let Some(value) = self.l_diversity_config() {
            state.serialize_entry("lDiversityConfig", value)?;
        }
        if let Some(value) = self.k_map_estimation_config() {
            state.serialize_entry("kMapEstimationConfig", value)?;
        }
        if let Some(value) = self.delta_presence_estimation_config() {
            state.serialize_entry("deltaPresenceEstimationConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PrivacyMetric].
pub mod privacy_metric {
    #[allow(unused_imports)]
    use super::*;

    /// Compute numerical stats over an individual column, including
    /// min, max, and quantiles.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NumericalStatsConfig {
        /// Field to compute numerical stats on. Supported types are
        /// integer, float, date, datetime, timestamp, time.
        pub field: std::option::Option<crate::model::FieldId>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NumericalStatsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::privacy_metric::NumericalStatsConfig::field].
        pub fn set_field<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.field = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [field][crate::model::privacy_metric::NumericalStatsConfig::field].
        pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.field = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for NumericalStatsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.NumericalStatsConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NumericalStatsConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __field,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NumericalStatsConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "field" => Ok(__FieldTag::__field),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NumericalStatsConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NumericalStatsConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__field => {
                                if !fields.insert(__FieldTag::__field) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field",
                                    ));
                                }
                                result.field =
                                    map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NumericalStatsConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.field.is_some() {
                state.serialize_entry("field", &self.field)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Compute numerical stats over an individual column, including
    /// number of distinct values and value count distribution.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CategoricalStatsConfig {
        /// Field to compute categorical stats on. All column types are
        /// supported except for arrays and structs. However, it may be more
        /// informative to use NumericalStats when the field type is supported,
        /// depending on the data.
        pub field: std::option::Option<crate::model::FieldId>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CategoricalStatsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::privacy_metric::CategoricalStatsConfig::field].
        pub fn set_field<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.field = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [field][crate::model::privacy_metric::CategoricalStatsConfig::field].
        pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.field = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for CategoricalStatsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.CategoricalStatsConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CategoricalStatsConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __field,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CategoricalStatsConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "field" => Ok(__FieldTag::__field),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CategoricalStatsConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CategoricalStatsConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__field => {
                                if !fields.insert(__FieldTag::__field) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field",
                                    ));
                                }
                                result.field =
                                    map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CategoricalStatsConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.field.is_some() {
                state.serialize_entry("field", &self.field)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// k-anonymity metric, used for analysis of reidentification risk.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KAnonymityConfig {
        /// Set of fields to compute k-anonymity over. When multiple fields are
        /// specified, they are considered a single composite key. Structs and
        /// repeated data types are not supported; however, nested fields are
        /// supported so long as they are not structs themselves or nested within
        /// a repeated field.
        pub quasi_ids: std::vec::Vec<crate::model::FieldId>,

        /// Message indicating that multiple rows might be associated to a
        /// single individual. If the same entity_id is associated to multiple
        /// quasi-identifier tuples over distinct rows, we consider the entire
        /// collection of tuples as the composite quasi-identifier. This collection
        /// is a multiset: the order in which the different tuples appear in the
        /// dataset is ignored, but their frequency is taken into account.
        ///
        /// Important note: a maximum of 1000 rows can be associated to a single
        /// entity ID. If more rows are associated with the same entity ID, some
        /// might be ignored.
        pub entity_id: std::option::Option<crate::model::EntityId>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KAnonymityConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::KAnonymityConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FieldId>,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [entity_id][crate::model::privacy_metric::KAnonymityConfig::entity_id].
        pub fn set_entity_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::EntityId>,
        {
            self.entity_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [entity_id][crate::model::privacy_metric::KAnonymityConfig::entity_id].
        pub fn set_or_clear_entity_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::EntityId>,
        {
            self.entity_id = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for KAnonymityConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KAnonymityConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KAnonymityConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __quasi_ids,
                __entity_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KAnonymityConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "quasiIds" => Ok(__FieldTag::__quasi_ids),
                                "quasi_ids" => Ok(__FieldTag::__quasi_ids),
                                "entityId" => Ok(__FieldTag::__entity_id),
                                "entity_id" => Ok(__FieldTag::__entity_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KAnonymityConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KAnonymityConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__quasi_ids => {
                                if !fields.insert(__FieldTag::__quasi_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quasi_ids",
                                    ));
                                }
                                result.quasi_ids = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FieldId>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__entity_id => {
                                if !fields.insert(__FieldTag::__entity_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity_id",
                                    ));
                                }
                                result.entity_id = map
                                    .next_value::<std::option::Option<crate::model::EntityId>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for KAnonymityConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.quasi_ids.is_empty() {
                state.serialize_entry("quasiIds", &self.quasi_ids)?;
            }
            if self.entity_id.is_some() {
                state.serialize_entry("entityId", &self.entity_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// l-diversity metric, used for analysis of reidentification risk.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LDiversityConfig {
        /// Set of quasi-identifiers indicating how equivalence classes are
        /// defined for the l-diversity computation. When multiple fields are
        /// specified, they are considered a single composite key.
        pub quasi_ids: std::vec::Vec<crate::model::FieldId>,

        /// Sensitive field for computing the l-value.
        pub sensitive_attribute: std::option::Option<crate::model::FieldId>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LDiversityConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::LDiversityConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FieldId>,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [sensitive_attribute][crate::model::privacy_metric::LDiversityConfig::sensitive_attribute].
        pub fn set_sensitive_attribute<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.sensitive_attribute = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [sensitive_attribute][crate::model::privacy_metric::LDiversityConfig::sensitive_attribute].
        pub fn set_or_clear_sensitive_attribute<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.sensitive_attribute = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for LDiversityConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.LDiversityConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LDiversityConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __quasi_ids,
                __sensitive_attribute,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LDiversityConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "quasiIds" => Ok(__FieldTag::__quasi_ids),
                                "quasi_ids" => Ok(__FieldTag::__quasi_ids),
                                "sensitiveAttribute" => Ok(__FieldTag::__sensitive_attribute),
                                "sensitive_attribute" => Ok(__FieldTag::__sensitive_attribute),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LDiversityConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LDiversityConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__quasi_ids => {
                                if !fields.insert(__FieldTag::__quasi_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quasi_ids",
                                    ));
                                }
                                result.quasi_ids = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FieldId>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__sensitive_attribute => {
                                if !fields.insert(__FieldTag::__sensitive_attribute) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sensitive_attribute",
                                    ));
                                }
                                result.sensitive_attribute =
                                    map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LDiversityConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.quasi_ids.is_empty() {
                state.serialize_entry("quasiIds", &self.quasi_ids)?;
            }
            if self.sensitive_attribute.is_some() {
                state.serialize_entry("sensitiveAttribute", &self.sensitive_attribute)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Reidentifiability metric. This corresponds to a risk model similar to what
    /// is called "journalist risk" in the literature, except the attack dataset is
    /// statistically modeled instead of being perfectly known. This can be done
    /// using publicly available data (like the US Census), or using a custom
    /// statistical model (indicated as one or several BigQuery tables), or by
    /// extrapolating from the distribution of values in the input dataset.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KMapEstimationConfig {
        /// Required. Fields considered to be quasi-identifiers. No two columns can
        /// have the same tag.
        pub quasi_ids:
            std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::TaggedField>,

        /// ISO 3166-1 alpha-2 region code to use in the statistical modeling.
        /// Set if no column is tagged with a region-specific InfoType (like
        /// US_ZIP_5) or a region code.
        pub region_code: std::string::String,

        /// Several auxiliary tables can be used in the analysis. Each custom_tag
        /// used to tag a quasi-identifiers column must appear in exactly one column
        /// of one auxiliary table.
        pub auxiliary_tables:
            std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KMapEstimationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::KMapEstimationConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::privacy_metric::k_map_estimation_config::TaggedField,
                >,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [region_code][crate::model::privacy_metric::KMapEstimationConfig::region_code].
        pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region_code = v.into();
            self
        }

        /// Sets the value of [auxiliary_tables][crate::model::privacy_metric::KMapEstimationConfig::auxiliary_tables].
        pub fn set_auxiliary_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable,
                >,
        {
            use std::iter::Iterator;
            self.auxiliary_tables = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for KMapEstimationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KMapEstimationConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __quasi_ids,
                __region_code,
                __auxiliary_tables,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KMapEstimationConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "quasiIds" => Ok(__FieldTag::__quasi_ids),
                                "quasi_ids" => Ok(__FieldTag::__quasi_ids),
                                "regionCode" => Ok(__FieldTag::__region_code),
                                "region_code" => Ok(__FieldTag::__region_code),
                                "auxiliaryTables" => Ok(__FieldTag::__auxiliary_tables),
                                "auxiliary_tables" => Ok(__FieldTag::__auxiliary_tables),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KMapEstimationConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KMapEstimationConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__quasi_ids => {
                                if !fields.insert(__FieldTag::__quasi_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quasi_ids",
                                    ));
                                }
                                result.quasi_ids = map.next_value::<std::option::Option<std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::TaggedField>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__region_code => {
                                if !fields.insert(__FieldTag::__region_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for region_code",
                                    ));
                                }
                                result.region_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__auxiliary_tables => {
                                if !fields.insert(__FieldTag::__auxiliary_tables) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for auxiliary_tables",
                                    ));
                                }
                                result.auxiliary_tables = map.next_value::<std::option::Option<std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for KMapEstimationConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.quasi_ids.is_empty() {
                state.serialize_entry("quasiIds", &self.quasi_ids)?;
            }
            if !self.region_code.is_empty() {
                state.serialize_entry("regionCode", &self.region_code)?;
            }
            if !self.auxiliary_tables.is_empty() {
                state.serialize_entry("auxiliaryTables", &self.auxiliary_tables)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [KMapEstimationConfig].
    pub mod k_map_estimation_config {
        #[allow(unused_imports)]
        use super::*;

        /// A column with a semantic tag attached.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TaggedField {
            /// Required. Identifies the column.
            pub field: std::option::Option<crate::model::FieldId>,

            /// Semantic tag that identifies what a column contains, to determine which
            /// statistical model to use to estimate the reidentifiability of each
            /// value. [required]
            pub tag: std::option::Option<
                crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TaggedField {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [field][crate::model::privacy_metric::k_map_estimation_config::TaggedField::field].
            pub fn set_field<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::FieldId>,
            {
                self.field = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [field][crate::model::privacy_metric::k_map_estimation_config::TaggedField::field].
            pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::FieldId>,
            {
                self.field = v.map(|x| x.into());
                self
            }

            /// Sets the value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag].
            ///
            /// Note that all the setters affecting `tag` are mutually
            /// exclusive.
            pub fn set_tag<T: std::convert::Into<std::option::Option<crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag>>>(mut self, v: T) -> Self
            {
                self.tag = v.into();
                self
            }

            /// The value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// if it holds a `InfoType`, `None` if the field is not set or
            /// holds a different branch.
            pub fn info_type(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::InfoType>> {
                #[allow(unreachable_patterns)]
                self.tag.as_ref().and_then(|v| match v {
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::InfoType(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// to hold a `InfoType`.
            ///
            /// Note that all the setters affecting `tag` are
            /// mutually exclusive.
            pub fn set_info_type<T: std::convert::Into<std::boxed::Box<crate::model::InfoType>>>(
                mut self,
                v: T,
            ) -> Self {
                self.tag = std::option::Option::Some(
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::InfoType(
                        v.into()
                    )
                );
                self
            }

            /// The value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// if it holds a `CustomTag`, `None` if the field is not set or
            /// holds a different branch.
            pub fn custom_tag(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.tag.as_ref().and_then(|v| match v {
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::CustomTag(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// to hold a `CustomTag`.
            ///
            /// Note that all the setters affecting `tag` are
            /// mutually exclusive.
            pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.tag = std::option::Option::Some(
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::CustomTag(
                        v.into()
                    )
                );
                self
            }

            /// The value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// if it holds a `Inferred`, `None` if the field is not set or
            /// holds a different branch.
            pub fn inferred(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
                #[allow(unreachable_patterns)]
                self.tag.as_ref().and_then(|v| match v {
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::Inferred(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// to hold a `Inferred`.
            ///
            /// Note that all the setters affecting `tag` are
            /// mutually exclusive.
            pub fn set_inferred<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
                mut self,
                v: T,
            ) -> Self {
                self.tag = std::option::Option::Some(
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::Inferred(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for TaggedField {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.TaggedField"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for TaggedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __field,
                    __info_type,
                    __custom_tag,
                    __inferred,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for TaggedField")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "field" => Ok(__FieldTag::__field),
                                    "infoType" => Ok(__FieldTag::__info_type),
                                    "info_type" => Ok(__FieldTag::__info_type),
                                    "customTag" => Ok(__FieldTag::__custom_tag),
                                    "custom_tag" => Ok(__FieldTag::__custom_tag),
                                    "inferred" => Ok(__FieldTag::__inferred),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = TaggedField;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct TaggedField")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__field => {
                                    if !fields.insert(__FieldTag::__field) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for field"),
                                        );
                                    }
                                    result.field = map
                                        .next_value::<std::option::Option<crate::model::FieldId>>(
                                        )?;
                                }
                                __FieldTag::__info_type => {
                                    if !fields.insert(__FieldTag::__info_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for info_type",
                                            ),
                                        );
                                    }
                                    if result.tag.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `tag`, a oneof with full ID .google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.TaggedField.info_type, latest field was infoType",
                                            ),
                                        );
                                    }
                                    result.tag = std::option::Option::Some(
                                        crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::InfoType(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::InfoType>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__custom_tag => {
                                    if !fields.insert(__FieldTag::__custom_tag) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for custom_tag",
                                            ),
                                        );
                                    }
                                    if result.tag.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `tag`, a oneof with full ID .google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.TaggedField.custom_tag, latest field was customTag",
                                            ),
                                        );
                                    }
                                    result.tag = std::option::Option::Some(
                                        crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::CustomTag(
                                            map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__inferred => {
                                    if !fields.insert(__FieldTag::__inferred) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for inferred",
                                            ),
                                        );
                                    }
                                    if result.tag.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `tag`, a oneof with full ID .google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.TaggedField.inferred, latest field was inferred",
                                            ),
                                        );
                                    }
                                    result.tag = std::option::Option::Some(
                                        crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::Inferred(
                                            map.next_value::<std::option::Option<std::boxed::Box<wkt::Empty>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for TaggedField {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.field.is_some() {
                    state.serialize_entry("field", &self.field)?;
                }
                if let Some(value) = self.info_type() {
                    state.serialize_entry("infoType", value)?;
                }
                if let Some(value) = self.custom_tag() {
                    state.serialize_entry("customTag", value)?;
                }
                if let Some(value) = self.inferred() {
                    state.serialize_entry("inferred", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [TaggedField].
        pub mod tagged_field {
            #[allow(unused_imports)]
            use super::*;

            /// Semantic tag that identifies what a column contains, to determine which
            /// statistical model to use to estimate the reidentifiability of each
            /// value. [required]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Tag {
                /// A column can be tagged with a InfoType to use the relevant public
                /// dataset as a statistical model of population, if available. We
                /// currently support US ZIP codes, region codes, ages and genders.
                /// To programmatically obtain the list of supported InfoTypes, use
                /// ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
                InfoType(std::boxed::Box<crate::model::InfoType>),
                /// A column can be tagged with a custom tag. In this case, the user must
                /// indicate an auxiliary table that contains statistical information on
                /// the possible values of this column (below).
                CustomTag(std::string::String),
                /// If no semantic tag is indicated, we infer the statistical model from
                /// the distribution of values in the input data
                Inferred(std::boxed::Box<wkt::Empty>),
            }
        }

        /// An auxiliary table contains statistical information on the relative
        /// frequency of different quasi-identifiers values. It has one or several
        /// quasi-identifiers columns, and one column that indicates the relative
        /// frequency of each quasi-identifier tuple.
        /// If a tuple is present in the data but not in the auxiliary table, the
        /// corresponding relative frequency is assumed to be zero (and thus, the
        /// tuple is highly reidentifiable).
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AuxiliaryTable {

            /// Required. Auxiliary table location.
            pub table: std::option::Option<crate::model::BigQueryTable>,

            /// Required. Quasi-identifier columns.
            pub quasi_ids: std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField>,

            /// Required. The relative frequency column must contain a floating-point
            /// number between 0 and 1 (inclusive). Null values are assumed to be zero.
            pub relative_frequency: std::option::Option<crate::model::FieldId>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AuxiliaryTable {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [table][crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable::table].
            pub fn set_table<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::BigQueryTable>,
            {
                self.table = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [table][crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable::table].
            pub fn set_or_clear_table<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::BigQueryTable>,
            {
                self.table = v.map(|x| x.into());
                self
            }

            /// Sets the value of [quasi_ids][crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable::quasi_ids].
            pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField>
            {
                use std::iter::Iterator;
                self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [relative_frequency][crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable::relative_frequency].
            pub fn set_relative_frequency<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::FieldId>,
            {
                self.relative_frequency = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [relative_frequency][crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable::relative_frequency].
            pub fn set_or_clear_relative_frequency<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::FieldId>,
            {
                self.relative_frequency = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for AuxiliaryTable {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.AuxiliaryTable"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AuxiliaryTable {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __table,
                    __quasi_ids,
                    __relative_frequency,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AuxiliaryTable")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "table" => Ok(__FieldTag::__table),
                                    "quasiIds" => Ok(__FieldTag::__quasi_ids),
                                    "quasi_ids" => Ok(__FieldTag::__quasi_ids),
                                    "relativeFrequency" => Ok(__FieldTag::__relative_frequency),
                                    "relative_frequency" => Ok(__FieldTag::__relative_frequency),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AuxiliaryTable;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AuxiliaryTable")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__table => {
                                    if !fields.insert(__FieldTag::__table) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for table"),
                                        );
                                    }
                                    result.table = map.next_value::<std::option::Option<crate::model::BigQueryTable>>()?
                                        ;
                                }
                                __FieldTag::__quasi_ids => {
                                    if !fields.insert(__FieldTag::__quasi_ids) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for quasi_ids",
                                            ),
                                        );
                                    }
                                    result.quasi_ids = map.next_value::<std::option::Option<std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__relative_frequency => {
                                    if !fields.insert(__FieldTag::__relative_frequency) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for relative_frequency",
                                            ),
                                        );
                                    }
                                    result.relative_frequency = map
                                        .next_value::<std::option::Option<crate::model::FieldId>>(
                                        )?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AuxiliaryTable {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.table.is_some() {
                    state.serialize_entry("table", &self.table)?;
                }
                if !self.quasi_ids.is_empty() {
                    state.serialize_entry("quasiIds", &self.quasi_ids)?;
                }
                if self.relative_frequency.is_some() {
                    state.serialize_entry("relativeFrequency", &self.relative_frequency)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [AuxiliaryTable].
        pub mod auxiliary_table {
            #[allow(unused_imports)]
            use super::*;

            /// A quasi-identifier column has a custom_tag, used to know which column
            /// in the data corresponds to which column in the statistical model.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct QuasiIdField {
                /// Identifies the column.
                pub field: std::option::Option<crate::model::FieldId>,

                /// A auxiliary field.
                pub custom_tag: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl QuasiIdField {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [field][crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField::field].
                pub fn set_field<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::FieldId>,
                {
                    self.field = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [field][crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField::field].
                pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::FieldId>,
                {
                    self.field = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [custom_tag][crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField::custom_tag].
                pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.custom_tag = v.into();
                    self
                }
            }

            impl wkt::message::Message for QuasiIdField {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.AuxiliaryTable.QuasiIdField"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for QuasiIdField {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __field,
                        __custom_tag,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for QuasiIdField")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "field" => Ok(__FieldTag::__field),
                                        "customTag" => Ok(__FieldTag::__custom_tag),
                                        "custom_tag" => Ok(__FieldTag::__custom_tag),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = QuasiIdField;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct QuasiIdField")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__field => {
                                        if !fields.insert(__FieldTag::__field) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for field",
                                                ),
                                            );
                                        }
                                        result.field = map.next_value::<std::option::Option<crate::model::FieldId>>()?
                                            ;
                                    }
                                    __FieldTag::__custom_tag => {
                                        if !fields.insert(__FieldTag::__custom_tag) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for custom_tag",
                                                ),
                                            );
                                        }
                                        result.custom_tag = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for QuasiIdField {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.field.is_some() {
                        state.serialize_entry("field", &self.field)?;
                    }
                    if !self.custom_tag.is_empty() {
                        state.serialize_entry("customTag", &self.custom_tag)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }
    }

    /// δ-presence metric, used to estimate how likely it is for an attacker to
    /// figure out that one given individual appears in a de-identified dataset.
    /// Similarly to the k-map metric, we cannot compute δ-presence exactly without
    /// knowing the attack dataset, so we use a statistical model instead.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeltaPresenceEstimationConfig {
        /// Required. Fields considered to be quasi-identifiers. No two fields can
        /// have the same tag.
        pub quasi_ids: std::vec::Vec<crate::model::QuasiId>,

        /// ISO 3166-1 alpha-2 region code to use in the statistical modeling.
        /// Set if no column is tagged with a region-specific InfoType (like
        /// US_ZIP_5) or a region code.
        pub region_code: std::string::String,

        /// Several auxiliary tables can be used in the analysis. Each custom_tag
        /// used to tag a quasi-identifiers field must appear in exactly one
        /// field of one auxiliary table.
        pub auxiliary_tables: std::vec::Vec<crate::model::StatisticalTable>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DeltaPresenceEstimationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::DeltaPresenceEstimationConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::QuasiId>,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [region_code][crate::model::privacy_metric::DeltaPresenceEstimationConfig::region_code].
        pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region_code = v.into();
            self
        }

        /// Sets the value of [auxiliary_tables][crate::model::privacy_metric::DeltaPresenceEstimationConfig::auxiliary_tables].
        pub fn set_auxiliary_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::StatisticalTable>,
        {
            use std::iter::Iterator;
            self.auxiliary_tables = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DeltaPresenceEstimationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.DeltaPresenceEstimationConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DeltaPresenceEstimationConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __quasi_ids,
                __region_code,
                __auxiliary_tables,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DeltaPresenceEstimationConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "quasiIds" => Ok(__FieldTag::__quasi_ids),
                                "quasi_ids" => Ok(__FieldTag::__quasi_ids),
                                "regionCode" => Ok(__FieldTag::__region_code),
                                "region_code" => Ok(__FieldTag::__region_code),
                                "auxiliaryTables" => Ok(__FieldTag::__auxiliary_tables),
                                "auxiliary_tables" => Ok(__FieldTag::__auxiliary_tables),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DeltaPresenceEstimationConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DeltaPresenceEstimationConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__quasi_ids => {
                                if !fields.insert(__FieldTag::__quasi_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quasi_ids",
                                    ));
                                }
                                result.quasi_ids = map.next_value::<std::option::Option<std::vec::Vec<crate::model::QuasiId>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__region_code => {
                                if !fields.insert(__FieldTag::__region_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for region_code",
                                    ));
                                }
                                result.region_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__auxiliary_tables => {
                                if !fields.insert(__FieldTag::__auxiliary_tables) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for auxiliary_tables",
                                    ));
                                }
                                result.auxiliary_tables = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::StatisticalTable>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DeltaPresenceEstimationConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.quasi_ids.is_empty() {
                state.serialize_entry("quasiIds", &self.quasi_ids)?;
            }
            if !self.region_code.is_empty() {
                state.serialize_entry("regionCode", &self.region_code)?;
            }
            if !self.auxiliary_tables.is_empty() {
                state.serialize_entry("auxiliaryTables", &self.auxiliary_tables)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Types of analysis.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Numerical stats
        NumericalStatsConfig(std::boxed::Box<crate::model::privacy_metric::NumericalStatsConfig>),
        /// Categorical stats
        CategoricalStatsConfig(
            std::boxed::Box<crate::model::privacy_metric::CategoricalStatsConfig>,
        ),
        /// K-anonymity
        KAnonymityConfig(std::boxed::Box<crate::model::privacy_metric::KAnonymityConfig>),
        /// l-diversity
        LDiversityConfig(std::boxed::Box<crate::model::privacy_metric::LDiversityConfig>),
        /// k-map
        KMapEstimationConfig(std::boxed::Box<crate::model::privacy_metric::KMapEstimationConfig>),
        /// delta-presence
        DeltaPresenceEstimationConfig(
            std::boxed::Box<crate::model::privacy_metric::DeltaPresenceEstimationConfig>,
        ),
    }
}

/// Result of a risk analysis operation request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeDataSourceRiskDetails {
    /// Privacy metric to compute.
    pub requested_privacy_metric: std::option::Option<crate::model::PrivacyMetric>,

    /// Input dataset to compute metrics over.
    pub requested_source_table: std::option::Option<crate::model::BigQueryTable>,

    /// The configuration used for this job.
    pub requested_options: std::option::Option<
        crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions,
    >,

    /// Values associated with this metric.
    pub result: std::option::Option<crate::model::analyze_data_source_risk_details::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeDataSourceRiskDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_privacy_metric][crate::model::AnalyzeDataSourceRiskDetails::requested_privacy_metric].
    pub fn set_requested_privacy_metric<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivacyMetric>,
    {
        self.requested_privacy_metric = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_privacy_metric][crate::model::AnalyzeDataSourceRiskDetails::requested_privacy_metric].
    pub fn set_or_clear_requested_privacy_metric<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivacyMetric>,
    {
        self.requested_privacy_metric = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requested_source_table][crate::model::AnalyzeDataSourceRiskDetails::requested_source_table].
    pub fn set_requested_source_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.requested_source_table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_source_table][crate::model::AnalyzeDataSourceRiskDetails::requested_source_table].
    pub fn set_or_clear_requested_source_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.requested_source_table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requested_options][crate::model::AnalyzeDataSourceRiskDetails::requested_options].
    pub fn set_requested_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions,
            >,
    {
        self.requested_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_options][crate::model::AnalyzeDataSourceRiskDetails::requested_options].
    pub fn set_or_clear_requested_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions,
            >,
    {
        self.requested_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<
                std::option::Option<crate::model::analyze_data_source_risk_details::Result>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `NumericalStatsResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn numerical_stats_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::NumericalStatsResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::NumericalStatsResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `NumericalStatsResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_numerical_stats_result<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::analyze_data_source_risk_details::NumericalStatsResult,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::NumericalStatsResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `CategoricalStatsResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn categorical_stats_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::CategoricalStatsResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::CategoricalStatsResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `CategoricalStatsResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_categorical_stats_result<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::analyze_data_source_risk_details::CategoricalStatsResult,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::CategoricalStatsResult(
                v.into(),
            ),
        );
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `KAnonymityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn k_anonymity_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::KAnonymityResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::KAnonymityResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `KAnonymityResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_k_anonymity_result<
        T: std::convert::Into<
                std::boxed::Box<crate::model::analyze_data_source_risk_details::KAnonymityResult>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::KAnonymityResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `LDiversityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn l_diversity_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::LDiversityResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::LDiversityResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `LDiversityResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_l_diversity_result<
        T: std::convert::Into<
                std::boxed::Box<crate::model::analyze_data_source_risk_details::LDiversityResult>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::LDiversityResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `KMapEstimationResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn k_map_estimation_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::KMapEstimationResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::KMapEstimationResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `KMapEstimationResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_k_map_estimation_result<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::analyze_data_source_risk_details::KMapEstimationResult,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::KMapEstimationResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `DeltaPresenceEstimationResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delta_presence_estimation_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<
            crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult,
        >,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::DeltaPresenceEstimationResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `DeltaPresenceEstimationResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_delta_presence_estimation_result<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::DeltaPresenceEstimationResult(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for AnalyzeDataSourceRiskDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeDataSourceRiskDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __requested_privacy_metric,
            __requested_source_table,
            __numerical_stats_result,
            __categorical_stats_result,
            __k_anonymity_result,
            __l_diversity_result,
            __k_map_estimation_result,
            __delta_presence_estimation_result,
            __requested_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeDataSourceRiskDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requestedPrivacyMetric" => Ok(__FieldTag::__requested_privacy_metric),
                            "requested_privacy_metric" => {
                                Ok(__FieldTag::__requested_privacy_metric)
                            }
                            "requestedSourceTable" => Ok(__FieldTag::__requested_source_table),
                            "requested_source_table" => Ok(__FieldTag::__requested_source_table),
                            "numericalStatsResult" => Ok(__FieldTag::__numerical_stats_result),
                            "numerical_stats_result" => Ok(__FieldTag::__numerical_stats_result),
                            "categoricalStatsResult" => Ok(__FieldTag::__categorical_stats_result),
                            "categorical_stats_result" => {
                                Ok(__FieldTag::__categorical_stats_result)
                            }
                            "kAnonymityResult" => Ok(__FieldTag::__k_anonymity_result),
                            "k_anonymity_result" => Ok(__FieldTag::__k_anonymity_result),
                            "lDiversityResult" => Ok(__FieldTag::__l_diversity_result),
                            "l_diversity_result" => Ok(__FieldTag::__l_diversity_result),
                            "kMapEstimationResult" => Ok(__FieldTag::__k_map_estimation_result),
                            "k_map_estimation_result" => Ok(__FieldTag::__k_map_estimation_result),
                            "deltaPresenceEstimationResult" => {
                                Ok(__FieldTag::__delta_presence_estimation_result)
                            }
                            "delta_presence_estimation_result" => {
                                Ok(__FieldTag::__delta_presence_estimation_result)
                            }
                            "requestedOptions" => Ok(__FieldTag::__requested_options),
                            "requested_options" => Ok(__FieldTag::__requested_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeDataSourceRiskDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeDataSourceRiskDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__requested_privacy_metric => {
                            if !fields.insert(__FieldTag::__requested_privacy_metric) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_privacy_metric",
                                ));
                            }
                            result.requested_privacy_metric = map
                                .next_value::<std::option::Option<crate::model::PrivacyMetric>>()?;
                        }
                        __FieldTag::__requested_source_table => {
                            if !fields.insert(__FieldTag::__requested_source_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_source_table",
                                ));
                            }
                            result.requested_source_table = map
                                .next_value::<std::option::Option<crate::model::BigQueryTable>>()?;
                        }
                        __FieldTag::__numerical_stats_result => {
                            if !fields.insert(__FieldTag::__numerical_stats_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for numerical_stats_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.numerical_stats_result, latest field was numericalStatsResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::analyze_data_source_risk_details::Result::NumericalStatsResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyze_data_source_risk_details::NumericalStatsResult>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__categorical_stats_result => {
                            if !fields.insert(__FieldTag::__categorical_stats_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categorical_stats_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.categorical_stats_result, latest field was categoricalStatsResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::analyze_data_source_risk_details::Result::CategoricalStatsResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyze_data_source_risk_details::CategoricalStatsResult>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__k_anonymity_result => {
                            if !fields.insert(__FieldTag::__k_anonymity_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for k_anonymity_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.k_anonymity_result, latest field was kAnonymityResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::analyze_data_source_risk_details::Result::KAnonymityResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyze_data_source_risk_details::KAnonymityResult>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__l_diversity_result => {
                            if !fields.insert(__FieldTag::__l_diversity_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for l_diversity_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.l_diversity_result, latest field was lDiversityResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::analyze_data_source_risk_details::Result::LDiversityResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyze_data_source_risk_details::LDiversityResult>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__k_map_estimation_result => {
                            if !fields.insert(__FieldTag::__k_map_estimation_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for k_map_estimation_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.k_map_estimation_result, latest field was kMapEstimationResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::analyze_data_source_risk_details::Result::KMapEstimationResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyze_data_source_risk_details::KMapEstimationResult>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__delta_presence_estimation_result => {
                            if !fields.insert(__FieldTag::__delta_presence_estimation_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delta_presence_estimation_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.delta_presence_estimation_result, latest field was deltaPresenceEstimationResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::analyze_data_source_risk_details::Result::DeltaPresenceEstimationResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__requested_options => {
                            if !fields.insert(__FieldTag::__requested_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_options",
                                ));
                            }
                            result.requested_options = map.next_value::<std::option::Option<crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeDataSourceRiskDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.requested_privacy_metric.is_some() {
            state.serialize_entry("requestedPrivacyMetric", &self.requested_privacy_metric)?;
        }
        if self.requested_source_table.is_some() {
            state.serialize_entry("requestedSourceTable", &self.requested_source_table)?;
        }
        if let Some(value) = self.numerical_stats_result() {
            state.serialize_entry("numericalStatsResult", value)?;
        }
        if let Some(value) = self.categorical_stats_result() {
            state.serialize_entry("categoricalStatsResult", value)?;
        }
        if let Some(value) = self.k_anonymity_result() {
            state.serialize_entry("kAnonymityResult", value)?;
        }
        if let Some(value) = self.l_diversity_result() {
            state.serialize_entry("lDiversityResult", value)?;
        }
        if let Some(value) = self.k_map_estimation_result() {
            state.serialize_entry("kMapEstimationResult", value)?;
        }
        if let Some(value) = self.delta_presence_estimation_result() {
            state.serialize_entry("deltaPresenceEstimationResult", value)?;
        }
        if self.requested_options.is_some() {
            state.serialize_entry("requestedOptions", &self.requested_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AnalyzeDataSourceRiskDetails].
pub mod analyze_data_source_risk_details {
    #[allow(unused_imports)]
    use super::*;

    /// Result of the numerical stats computation.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NumericalStatsResult {
        /// Minimum value appearing in the column.
        pub min_value: std::option::Option<crate::model::Value>,

        /// Maximum value appearing in the column.
        pub max_value: std::option::Option<crate::model::Value>,

        /// List of 99 values that partition the set of field values into 100 equal
        /// sized buckets.
        pub quantile_values: std::vec::Vec<crate::model::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NumericalStatsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_value][crate::model::analyze_data_source_risk_details::NumericalStatsResult::min_value].
        pub fn set_min_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.min_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_value][crate::model::analyze_data_source_risk_details::NumericalStatsResult::min_value].
        pub fn set_or_clear_min_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.min_value = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_value][crate::model::analyze_data_source_risk_details::NumericalStatsResult::max_value].
        pub fn set_max_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.max_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_value][crate::model::analyze_data_source_risk_details::NumericalStatsResult::max_value].
        pub fn set_or_clear_max_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.max_value = v.map(|x| x.into());
            self
        }

        /// Sets the value of [quantile_values][crate::model::analyze_data_source_risk_details::NumericalStatsResult::quantile_values].
        pub fn set_quantile_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Value>,
        {
            use std::iter::Iterator;
            self.quantile_values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NumericalStatsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.NumericalStatsResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NumericalStatsResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __min_value,
                __max_value,
                __quantile_values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NumericalStatsResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "minValue" => Ok(__FieldTag::__min_value),
                                "min_value" => Ok(__FieldTag::__min_value),
                                "maxValue" => Ok(__FieldTag::__max_value),
                                "max_value" => Ok(__FieldTag::__max_value),
                                "quantileValues" => Ok(__FieldTag::__quantile_values),
                                "quantile_values" => Ok(__FieldTag::__quantile_values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NumericalStatsResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NumericalStatsResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__min_value => {
                                if !fields.insert(__FieldTag::__min_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_value",
                                    ));
                                }
                                result.min_value =
                                    map.next_value::<std::option::Option<crate::model::Value>>()?;
                            }
                            __FieldTag::__max_value => {
                                if !fields.insert(__FieldTag::__max_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_value",
                                    ));
                                }
                                result.max_value =
                                    map.next_value::<std::option::Option<crate::model::Value>>()?;
                            }
                            __FieldTag::__quantile_values => {
                                if !fields.insert(__FieldTag::__quantile_values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quantile_values",
                                    ));
                                }
                                result.quantile_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Value>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NumericalStatsResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.min_value.is_some() {
                state.serialize_entry("minValue", &self.min_value)?;
            }
            if self.max_value.is_some() {
                state.serialize_entry("maxValue", &self.max_value)?;
            }
            if !self.quantile_values.is_empty() {
                state.serialize_entry("quantileValues", &self.quantile_values)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Result of the categorical stats computation.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CategoricalStatsResult {

        /// Histogram of value frequencies in the column.
        pub value_frequency_histogram_buckets: std::vec::Vec<crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CategoricalStatsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value_frequency_histogram_buckets][crate::model::analyze_data_source_risk_details::CategoricalStatsResult::value_frequency_histogram_buckets].
        pub fn set_value_frequency_histogram_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket>
        {
            use std::iter::Iterator;
            self.value_frequency_histogram_buckets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CategoricalStatsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.CategoricalStatsResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CategoricalStatsResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __value_frequency_histogram_buckets,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CategoricalStatsResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "valueFrequencyHistogramBuckets" => {
                                    Ok(__FieldTag::__value_frequency_histogram_buckets)
                                }
                                "value_frequency_histogram_buckets" => {
                                    Ok(__FieldTag::__value_frequency_histogram_buckets)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CategoricalStatsResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CategoricalStatsResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__value_frequency_histogram_buckets => {
                                if !fields.insert(__FieldTag::__value_frequency_histogram_buckets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value_frequency_histogram_buckets",
                                    ));
                                }
                                result.value_frequency_histogram_buckets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CategoricalStatsResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.value_frequency_histogram_buckets.is_empty() {
                state.serialize_entry(
                    "valueFrequencyHistogramBuckets",
                    &self.value_frequency_histogram_buckets,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [CategoricalStatsResult].
    pub mod categorical_stats_result {
        #[allow(unused_imports)]
        use super::*;

        /// Histogram of value frequencies in the column.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CategoricalStatsHistogramBucket {
            /// Lower bound on the value frequency of the values in this bucket.
            pub value_frequency_lower_bound: i64,

            /// Upper bound on the value frequency of the values in this bucket.
            pub value_frequency_upper_bound: i64,

            /// Total number of values in this bucket.
            pub bucket_size: i64,

            /// Sample of value frequencies in this bucket. The total number of
            /// values returned per bucket is capped at 20.
            pub bucket_values: std::vec::Vec<crate::model::ValueFrequency>,

            /// Total number of distinct values in this bucket.
            pub bucket_value_count: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CategoricalStatsHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [value_frequency_lower_bound][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::value_frequency_lower_bound].
            pub fn set_value_frequency_lower_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.value_frequency_lower_bound = v.into();
                self
            }

            /// Sets the value of [value_frequency_upper_bound][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::value_frequency_upper_bound].
            pub fn set_value_frequency_upper_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.value_frequency_upper_bound = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::ValueFrequency>,
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }
        }

        impl wkt::message::Message for CategoricalStatsHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.CategoricalStatsResult.CategoricalStatsHistogramBucket"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CategoricalStatsHistogramBucket {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __value_frequency_lower_bound,
                    __value_frequency_upper_bound,
                    __bucket_size,
                    __bucket_values,
                    __bucket_value_count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter
                                    .write_str("a field name for CategoricalStatsHistogramBucket")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "valueFrequencyLowerBound" => {
                                        Ok(__FieldTag::__value_frequency_lower_bound)
                                    }
                                    "value_frequency_lower_bound" => {
                                        Ok(__FieldTag::__value_frequency_lower_bound)
                                    }
                                    "valueFrequencyUpperBound" => {
                                        Ok(__FieldTag::__value_frequency_upper_bound)
                                    }
                                    "value_frequency_upper_bound" => {
                                        Ok(__FieldTag::__value_frequency_upper_bound)
                                    }
                                    "bucketSize" => Ok(__FieldTag::__bucket_size),
                                    "bucket_size" => Ok(__FieldTag::__bucket_size),
                                    "bucketValues" => Ok(__FieldTag::__bucket_values),
                                    "bucket_values" => Ok(__FieldTag::__bucket_values),
                                    "bucketValueCount" => Ok(__FieldTag::__bucket_value_count),
                                    "bucket_value_count" => Ok(__FieldTag::__bucket_value_count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CategoricalStatsHistogramBucket;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CategoricalStatsHistogramBucket")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__value_frequency_lower_bound => {
                                    if !fields.insert(__FieldTag::__value_frequency_lower_bound) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for value_frequency_lower_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.value_frequency_lower_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__value_frequency_upper_bound => {
                                    if !fields.insert(__FieldTag::__value_frequency_upper_bound) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for value_frequency_upper_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.value_frequency_upper_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__bucket_size => {
                                    if !fields.insert(__FieldTag::__bucket_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.bucket_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__bucket_values => {
                                    if !fields.insert(__FieldTag::__bucket_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_values",
                                            ),
                                        );
                                    }
                                    result.bucket_values = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::ValueFrequency>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__bucket_value_count => {
                                    if !fields.insert(__FieldTag::__bucket_value_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_value_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.bucket_value_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CategoricalStatsHistogramBucket {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.value_frequency_lower_bound) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "valueFrequencyLowerBound",
                        &__With(&self.value_frequency_lower_bound),
                    )?;
                }
                if !wkt::internal::is_default(&self.value_frequency_upper_bound) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "valueFrequencyUpperBound",
                        &__With(&self.value_frequency_upper_bound),
                    )?;
                }
                if !wkt::internal::is_default(&self.bucket_size) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("bucketSize", &__With(&self.bucket_size))?;
                }
                if !self.bucket_values.is_empty() {
                    state.serialize_entry("bucketValues", &self.bucket_values)?;
                }
                if !wkt::internal::is_default(&self.bucket_value_count) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("bucketValueCount", &__With(&self.bucket_value_count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Result of the k-anonymity computation.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KAnonymityResult {

        /// Histogram of k-anonymity equivalence classes.
        pub equivalence_class_histogram_buckets: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KAnonymityResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [equivalence_class_histogram_buckets][crate::model::analyze_data_source_risk_details::KAnonymityResult::equivalence_class_histogram_buckets].
        pub fn set_equivalence_class_histogram_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket>
        {
            use std::iter::Iterator;
            self.equivalence_class_histogram_buckets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for KAnonymityResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KAnonymityResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KAnonymityResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __equivalence_class_histogram_buckets,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KAnonymityResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "equivalenceClassHistogramBuckets" => {
                                    Ok(__FieldTag::__equivalence_class_histogram_buckets)
                                }
                                "equivalence_class_histogram_buckets" => {
                                    Ok(__FieldTag::__equivalence_class_histogram_buckets)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KAnonymityResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KAnonymityResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__equivalence_class_histogram_buckets => {
                                if !fields.insert(__FieldTag::__equivalence_class_histogram_buckets)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for equivalence_class_histogram_buckets",
                                    ));
                                }
                                result.equivalence_class_histogram_buckets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for KAnonymityResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.equivalence_class_histogram_buckets.is_empty() {
                state.serialize_entry(
                    "equivalenceClassHistogramBuckets",
                    &self.equivalence_class_histogram_buckets,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [KAnonymityResult].
    pub mod k_anonymity_result {
        #[allow(unused_imports)]
        use super::*;

        /// The set of columns' values that share the same ldiversity value
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct KAnonymityEquivalenceClass {
            /// Set of values defining the equivalence class. One value per
            /// quasi-identifier column in the original KAnonymity metric message.
            /// The order is always the same as the original request.
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// Size of the equivalence class, for example number of rows with the
            /// above set of values.
            pub equivalence_class_size: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl KAnonymityEquivalenceClass {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [equivalence_class_size][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass::equivalence_class_size].
            pub fn set_equivalence_class_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.equivalence_class_size = v.into();
                self
            }
        }

        impl wkt::message::Message for KAnonymityEquivalenceClass {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityEquivalenceClass"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for KAnonymityEquivalenceClass {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __quasi_ids_values,
                    __equivalence_class_size,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for KAnonymityEquivalenceClass")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "quasiIdsValues" => Ok(__FieldTag::__quasi_ids_values),
                                    "quasi_ids_values" => Ok(__FieldTag::__quasi_ids_values),
                                    "equivalenceClassSize" => {
                                        Ok(__FieldTag::__equivalence_class_size)
                                    }
                                    "equivalence_class_size" => {
                                        Ok(__FieldTag::__equivalence_class_size)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = KAnonymityEquivalenceClass;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct KAnonymityEquivalenceClass")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__quasi_ids_values => {
                                    if !fields.insert(__FieldTag::__quasi_ids_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for quasi_ids_values",
                                            ),
                                        );
                                    }
                                    result.quasi_ids_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Value>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__equivalence_class_size => {
                                    if !fields.insert(__FieldTag::__equivalence_class_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for equivalence_class_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.equivalence_class_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for KAnonymityEquivalenceClass {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.quasi_ids_values.is_empty() {
                    state.serialize_entry("quasiIdsValues", &self.quasi_ids_values)?;
                }
                if !wkt::internal::is_default(&self.equivalence_class_size) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "equivalenceClassSize",
                        &__With(&self.equivalence_class_size),
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Histogram of k-anonymity equivalence classes.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct KAnonymityHistogramBucket {

            /// Lower bound on the size of the equivalence classes in this bucket.
            pub equivalence_class_size_lower_bound: i64,

            /// Upper bound on the size of the equivalence classes in this bucket.
            pub equivalence_class_size_upper_bound: i64,

            /// Total number of equivalence classes in this bucket.
            pub bucket_size: i64,

            /// Sample of equivalence classes in this bucket. The total number of
            /// classes returned per bucket is capped at 20.
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass>,

            /// Total number of distinct equivalence classes in this bucket.
            pub bucket_value_count: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl KAnonymityHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [equivalence_class_size_lower_bound][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::equivalence_class_size_lower_bound].
            pub fn set_equivalence_class_size_lower_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.equivalence_class_size_lower_bound = v.into();
                self
            }

            /// Sets the value of [equivalence_class_size_upper_bound][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::equivalence_class_size_upper_bound].
            pub fn set_equivalence_class_size_upper_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.equivalence_class_size_upper_bound = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }
        }

        impl wkt::message::Message for KAnonymityHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityHistogramBucket"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for KAnonymityHistogramBucket {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __equivalence_class_size_lower_bound,
                    __equivalence_class_size_upper_bound,
                    __bucket_size,
                    __bucket_values,
                    __bucket_value_count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for KAnonymityHistogramBucket")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "equivalenceClassSizeLowerBound" => {
                                        Ok(__FieldTag::__equivalence_class_size_lower_bound)
                                    }
                                    "equivalence_class_size_lower_bound" => {
                                        Ok(__FieldTag::__equivalence_class_size_lower_bound)
                                    }
                                    "equivalenceClassSizeUpperBound" => {
                                        Ok(__FieldTag::__equivalence_class_size_upper_bound)
                                    }
                                    "equivalence_class_size_upper_bound" => {
                                        Ok(__FieldTag::__equivalence_class_size_upper_bound)
                                    }
                                    "bucketSize" => Ok(__FieldTag::__bucket_size),
                                    "bucket_size" => Ok(__FieldTag::__bucket_size),
                                    "bucketValues" => Ok(__FieldTag::__bucket_values),
                                    "bucket_values" => Ok(__FieldTag::__bucket_values),
                                    "bucketValueCount" => Ok(__FieldTag::__bucket_value_count),
                                    "bucket_value_count" => Ok(__FieldTag::__bucket_value_count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = KAnonymityHistogramBucket;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct KAnonymityHistogramBucket")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__equivalence_class_size_lower_bound => {
                                    if !fields
                                        .insert(__FieldTag::__equivalence_class_size_lower_bound)
                                    {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for equivalence_class_size_lower_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.equivalence_class_size_lower_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__equivalence_class_size_upper_bound => {
                                    if !fields
                                        .insert(__FieldTag::__equivalence_class_size_upper_bound)
                                    {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for equivalence_class_size_upper_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.equivalence_class_size_upper_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__bucket_size => {
                                    if !fields.insert(__FieldTag::__bucket_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.bucket_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__bucket_values => {
                                    if !fields.insert(__FieldTag::__bucket_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_values",
                                            ),
                                        );
                                    }
                                    result.bucket_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__bucket_value_count => {
                                    if !fields.insert(__FieldTag::__bucket_value_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_value_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.bucket_value_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for KAnonymityHistogramBucket {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.equivalence_class_size_lower_bound) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "equivalenceClassSizeLowerBound",
                        &__With(&self.equivalence_class_size_lower_bound),
                    )?;
                }
                if !wkt::internal::is_default(&self.equivalence_class_size_upper_bound) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "equivalenceClassSizeUpperBound",
                        &__With(&self.equivalence_class_size_upper_bound),
                    )?;
                }
                if !wkt::internal::is_default(&self.bucket_size) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("bucketSize", &__With(&self.bucket_size))?;
                }
                if !self.bucket_values.is_empty() {
                    state.serialize_entry("bucketValues", &self.bucket_values)?;
                }
                if !wkt::internal::is_default(&self.bucket_value_count) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("bucketValueCount", &__With(&self.bucket_value_count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Result of the l-diversity computation.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LDiversityResult {

        /// Histogram of l-diversity equivalence class sensitive value frequencies.
        pub sensitive_value_frequency_histogram_buckets: std::vec::Vec<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LDiversityResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sensitive_value_frequency_histogram_buckets][crate::model::analyze_data_source_risk_details::LDiversityResult::sensitive_value_frequency_histogram_buckets].
        pub fn set_sensitive_value_frequency_histogram_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket>
        {
            use std::iter::Iterator;
            self.sensitive_value_frequency_histogram_buckets =
                v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for LDiversityResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.LDiversityResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LDiversityResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sensitive_value_frequency_histogram_buckets,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LDiversityResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sensitiveValueFrequencyHistogramBuckets" => {
                                    Ok(__FieldTag::__sensitive_value_frequency_histogram_buckets)
                                }
                                "sensitive_value_frequency_histogram_buckets" => {
                                    Ok(__FieldTag::__sensitive_value_frequency_histogram_buckets)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LDiversityResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LDiversityResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sensitive_value_frequency_histogram_buckets => {
                                if !fields.insert(
                                    __FieldTag::__sensitive_value_frequency_histogram_buckets,
                                ) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sensitive_value_frequency_histogram_buckets",
                                    ));
                                }
                                result.sensitive_value_frequency_histogram_buckets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LDiversityResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.sensitive_value_frequency_histogram_buckets.is_empty() {
                state.serialize_entry(
                    "sensitiveValueFrequencyHistogramBuckets",
                    &self.sensitive_value_frequency_histogram_buckets,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [LDiversityResult].
    pub mod l_diversity_result {
        #[allow(unused_imports)]
        use super::*;

        /// The set of columns' values that share the same ldiversity value.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct LDiversityEquivalenceClass {
            /// Quasi-identifier values defining the k-anonymity equivalence
            /// class. The order is always the same as the original request.
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// Size of the k-anonymity equivalence class.
            pub equivalence_class_size: i64,

            /// Number of distinct sensitive values in this equivalence class.
            pub num_distinct_sensitive_values: i64,

            /// Estimated frequencies of top sensitive values.
            pub top_sensitive_values: std::vec::Vec<crate::model::ValueFrequency>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl LDiversityEquivalenceClass {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [equivalence_class_size][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::equivalence_class_size].
            pub fn set_equivalence_class_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.equivalence_class_size = v.into();
                self
            }

            /// Sets the value of [num_distinct_sensitive_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::num_distinct_sensitive_values].
            pub fn set_num_distinct_sensitive_values<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.num_distinct_sensitive_values = v.into();
                self
            }

            /// Sets the value of [top_sensitive_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::top_sensitive_values].
            pub fn set_top_sensitive_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::ValueFrequency>,
            {
                use std::iter::Iterator;
                self.top_sensitive_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for LDiversityEquivalenceClass {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityEquivalenceClass"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for LDiversityEquivalenceClass {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __quasi_ids_values,
                    __equivalence_class_size,
                    __num_distinct_sensitive_values,
                    __top_sensitive_values,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for LDiversityEquivalenceClass")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "quasiIdsValues" => Ok(__FieldTag::__quasi_ids_values),
                                    "quasi_ids_values" => Ok(__FieldTag::__quasi_ids_values),
                                    "equivalenceClassSize" => {
                                        Ok(__FieldTag::__equivalence_class_size)
                                    }
                                    "equivalence_class_size" => {
                                        Ok(__FieldTag::__equivalence_class_size)
                                    }
                                    "numDistinctSensitiveValues" => {
                                        Ok(__FieldTag::__num_distinct_sensitive_values)
                                    }
                                    "num_distinct_sensitive_values" => {
                                        Ok(__FieldTag::__num_distinct_sensitive_values)
                                    }
                                    "topSensitiveValues" => Ok(__FieldTag::__top_sensitive_values),
                                    "top_sensitive_values" => {
                                        Ok(__FieldTag::__top_sensitive_values)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = LDiversityEquivalenceClass;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct LDiversityEquivalenceClass")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__quasi_ids_values => {
                                    if !fields.insert(__FieldTag::__quasi_ids_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for quasi_ids_values",
                                            ),
                                        );
                                    }
                                    result.quasi_ids_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Value>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__equivalence_class_size => {
                                    if !fields.insert(__FieldTag::__equivalence_class_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for equivalence_class_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.equivalence_class_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__num_distinct_sensitive_values => {
                                    if !fields.insert(__FieldTag::__num_distinct_sensitive_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for num_distinct_sensitive_values",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.num_distinct_sensitive_values =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__top_sensitive_values => {
                                    if !fields.insert(__FieldTag::__top_sensitive_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for top_sensitive_values",
                                            ),
                                        );
                                    }
                                    result.top_sensitive_values = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::ValueFrequency>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for LDiversityEquivalenceClass {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.quasi_ids_values.is_empty() {
                    state.serialize_entry("quasiIdsValues", &self.quasi_ids_values)?;
                }
                if !wkt::internal::is_default(&self.equivalence_class_size) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "equivalenceClassSize",
                        &__With(&self.equivalence_class_size),
                    )?;
                }
                if !wkt::internal::is_default(&self.num_distinct_sensitive_values) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "numDistinctSensitiveValues",
                        &__With(&self.num_distinct_sensitive_values),
                    )?;
                }
                if !self.top_sensitive_values.is_empty() {
                    state.serialize_entry("topSensitiveValues", &self.top_sensitive_values)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Histogram of l-diversity equivalence class sensitive value frequencies.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct LDiversityHistogramBucket {

            /// Lower bound on the sensitive value frequencies of the equivalence
            /// classes in this bucket.
            pub sensitive_value_frequency_lower_bound: i64,

            /// Upper bound on the sensitive value frequencies of the equivalence
            /// classes in this bucket.
            pub sensitive_value_frequency_upper_bound: i64,

            /// Total number of equivalence classes in this bucket.
            pub bucket_size: i64,

            /// Sample of equivalence classes in this bucket. The total number of
            /// classes returned per bucket is capped at 20.
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass>,

            /// Total number of distinct equivalence classes in this bucket.
            pub bucket_value_count: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl LDiversityHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [sensitive_value_frequency_lower_bound][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::sensitive_value_frequency_lower_bound].
            pub fn set_sensitive_value_frequency_lower_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.sensitive_value_frequency_lower_bound = v.into();
                self
            }

            /// Sets the value of [sensitive_value_frequency_upper_bound][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::sensitive_value_frequency_upper_bound].
            pub fn set_sensitive_value_frequency_upper_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.sensitive_value_frequency_upper_bound = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }
        }

        impl wkt::message::Message for LDiversityHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityHistogramBucket"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for LDiversityHistogramBucket {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __sensitive_value_frequency_lower_bound,
                    __sensitive_value_frequency_upper_bound,
                    __bucket_size,
                    __bucket_values,
                    __bucket_value_count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for LDiversityHistogramBucket")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "sensitiveValueFrequencyLowerBound" => {
                                        Ok(__FieldTag::__sensitive_value_frequency_lower_bound)
                                    }
                                    "sensitive_value_frequency_lower_bound" => {
                                        Ok(__FieldTag::__sensitive_value_frequency_lower_bound)
                                    }
                                    "sensitiveValueFrequencyUpperBound" => {
                                        Ok(__FieldTag::__sensitive_value_frequency_upper_bound)
                                    }
                                    "sensitive_value_frequency_upper_bound" => {
                                        Ok(__FieldTag::__sensitive_value_frequency_upper_bound)
                                    }
                                    "bucketSize" => Ok(__FieldTag::__bucket_size),
                                    "bucket_size" => Ok(__FieldTag::__bucket_size),
                                    "bucketValues" => Ok(__FieldTag::__bucket_values),
                                    "bucket_values" => Ok(__FieldTag::__bucket_values),
                                    "bucketValueCount" => Ok(__FieldTag::__bucket_value_count),
                                    "bucket_value_count" => Ok(__FieldTag::__bucket_value_count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = LDiversityHistogramBucket;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct LDiversityHistogramBucket")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__sensitive_value_frequency_lower_bound => {
                                    if !fields
                                        .insert(__FieldTag::__sensitive_value_frequency_lower_bound)
                                    {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for sensitive_value_frequency_lower_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.sensitive_value_frequency_lower_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__sensitive_value_frequency_upper_bound => {
                                    if !fields
                                        .insert(__FieldTag::__sensitive_value_frequency_upper_bound)
                                    {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for sensitive_value_frequency_upper_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.sensitive_value_frequency_upper_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__bucket_size => {
                                    if !fields.insert(__FieldTag::__bucket_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.bucket_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__bucket_values => {
                                    if !fields.insert(__FieldTag::__bucket_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_values",
                                            ),
                                        );
                                    }
                                    result.bucket_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__bucket_value_count => {
                                    if !fields.insert(__FieldTag::__bucket_value_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_value_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.bucket_value_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for LDiversityHistogramBucket {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.sensitive_value_frequency_lower_bound) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "sensitiveValueFrequencyLowerBound",
                        &__With(&self.sensitive_value_frequency_lower_bound),
                    )?;
                }
                if !wkt::internal::is_default(&self.sensitive_value_frequency_upper_bound) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "sensitiveValueFrequencyUpperBound",
                        &__With(&self.sensitive_value_frequency_upper_bound),
                    )?;
                }
                if !wkt::internal::is_default(&self.bucket_size) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("bucketSize", &__With(&self.bucket_size))?;
                }
                if !self.bucket_values.is_empty() {
                    state.serialize_entry("bucketValues", &self.bucket_values)?;
                }
                if !wkt::internal::is_default(&self.bucket_value_count) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("bucketValueCount", &__With(&self.bucket_value_count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Result of the reidentifiability analysis. Note that these results are an
    /// estimation, not exact values.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KMapEstimationResult {

        /// The intervals [min_anonymity, max_anonymity] do not overlap. If a value
        /// doesn't correspond to any such interval, the associated frequency is
        /// zero. For example, the following records:
        /// {min_anonymity: 1, max_anonymity: 1, frequency: 17}
        /// {min_anonymity: 2, max_anonymity: 3, frequency: 42}
        /// {min_anonymity: 5, max_anonymity: 10, frequency: 99}
        /// mean that there are no record with an estimated anonymity of 4, 5, or
        /// larger than 10.
        pub k_map_estimation_histogram: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KMapEstimationResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [k_map_estimation_histogram][crate::model::analyze_data_source_risk_details::KMapEstimationResult::k_map_estimation_histogram].
        pub fn set_k_map_estimation_histogram<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket>
        {
            use std::iter::Iterator;
            self.k_map_estimation_histogram = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for KMapEstimationResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KMapEstimationResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KMapEstimationResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __k_map_estimation_histogram,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KMapEstimationResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kMapEstimationHistogram" => {
                                    Ok(__FieldTag::__k_map_estimation_histogram)
                                }
                                "k_map_estimation_histogram" => {
                                    Ok(__FieldTag::__k_map_estimation_histogram)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KMapEstimationResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KMapEstimationResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__k_map_estimation_histogram => {
                                if !fields.insert(__FieldTag::__k_map_estimation_histogram) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for k_map_estimation_histogram",
                                    ));
                                }
                                result.k_map_estimation_histogram = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for KMapEstimationResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.k_map_estimation_histogram.is_empty() {
                state
                    .serialize_entry("kMapEstimationHistogram", &self.k_map_estimation_histogram)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [KMapEstimationResult].
    pub mod k_map_estimation_result {
        #[allow(unused_imports)]
        use super::*;

        /// A tuple of values for the quasi-identifier columns.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct KMapEstimationQuasiIdValues {
            /// The quasi-identifier values.
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// The estimated anonymity for these quasi-identifier values.
            pub estimated_anonymity: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl KMapEstimationQuasiIdValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [estimated_anonymity][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues::estimated_anonymity].
            pub fn set_estimated_anonymity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.estimated_anonymity = v.into();
                self
            }
        }

        impl wkt::message::Message for KMapEstimationQuasiIdValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationQuasiIdValues"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for KMapEstimationQuasiIdValues {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __quasi_ids_values,
                    __estimated_anonymity,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for KMapEstimationQuasiIdValues")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "quasiIdsValues" => Ok(__FieldTag::__quasi_ids_values),
                                    "quasi_ids_values" => Ok(__FieldTag::__quasi_ids_values),
                                    "estimatedAnonymity" => Ok(__FieldTag::__estimated_anonymity),
                                    "estimated_anonymity" => Ok(__FieldTag::__estimated_anonymity),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = KMapEstimationQuasiIdValues;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct KMapEstimationQuasiIdValues")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__quasi_ids_values => {
                                    if !fields.insert(__FieldTag::__quasi_ids_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for quasi_ids_values",
                                            ),
                                        );
                                    }
                                    result.quasi_ids_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Value>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__estimated_anonymity => {
                                    if !fields.insert(__FieldTag::__estimated_anonymity) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for estimated_anonymity",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.estimated_anonymity =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for KMapEstimationQuasiIdValues {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.quasi_ids_values.is_empty() {
                    state.serialize_entry("quasiIdsValues", &self.quasi_ids_values)?;
                }
                if !wkt::internal::is_default(&self.estimated_anonymity) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "estimatedAnonymity",
                        &__With(&self.estimated_anonymity),
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// A KMapEstimationHistogramBucket message with the following values:
        /// min_anonymity: 3
        /// max_anonymity: 5
        /// frequency: 42
        /// means that there are 42 records whose quasi-identifier values correspond
        /// to 3, 4 or 5 people in the overlying population. An important particular
        /// case is when min_anonymity = max_anonymity = 1: the frequency field then
        /// corresponds to the number of uniquely identifiable records.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct KMapEstimationHistogramBucket {

            /// Always positive.
            pub min_anonymity: i64,

            /// Always greater than or equal to min_anonymity.
            pub max_anonymity: i64,

            /// Number of records within these anonymity bounds.
            pub bucket_size: i64,

            /// Sample of quasi-identifier tuple values in this bucket. The total
            /// number of classes returned per bucket is capped at 20.
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues>,

            /// Total number of distinct quasi-identifier tuple values in this bucket.
            pub bucket_value_count: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl KMapEstimationHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_anonymity][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::min_anonymity].
            pub fn set_min_anonymity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.min_anonymity = v.into();
                self
            }

            /// Sets the value of [max_anonymity][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::max_anonymity].
            pub fn set_max_anonymity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_anonymity = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }
        }

        impl wkt::message::Message for KMapEstimationHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationHistogramBucket"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for KMapEstimationHistogramBucket {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __min_anonymity,
                    __max_anonymity,
                    __bucket_size,
                    __bucket_values,
                    __bucket_value_count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter
                                    .write_str("a field name for KMapEstimationHistogramBucket")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "minAnonymity" => Ok(__FieldTag::__min_anonymity),
                                    "min_anonymity" => Ok(__FieldTag::__min_anonymity),
                                    "maxAnonymity" => Ok(__FieldTag::__max_anonymity),
                                    "max_anonymity" => Ok(__FieldTag::__max_anonymity),
                                    "bucketSize" => Ok(__FieldTag::__bucket_size),
                                    "bucket_size" => Ok(__FieldTag::__bucket_size),
                                    "bucketValues" => Ok(__FieldTag::__bucket_values),
                                    "bucket_values" => Ok(__FieldTag::__bucket_values),
                                    "bucketValueCount" => Ok(__FieldTag::__bucket_value_count),
                                    "bucket_value_count" => Ok(__FieldTag::__bucket_value_count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = KMapEstimationHistogramBucket;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct KMapEstimationHistogramBucket")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__min_anonymity => {
                                    if !fields.insert(__FieldTag::__min_anonymity) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for min_anonymity",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.min_anonymity =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__max_anonymity => {
                                    if !fields.insert(__FieldTag::__max_anonymity) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for max_anonymity",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max_anonymity =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__bucket_size => {
                                    if !fields.insert(__FieldTag::__bucket_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.bucket_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__bucket_values => {
                                    if !fields.insert(__FieldTag::__bucket_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_values",
                                            ),
                                        );
                                    }
                                    result.bucket_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__bucket_value_count => {
                                    if !fields.insert(__FieldTag::__bucket_value_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_value_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.bucket_value_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for KMapEstimationHistogramBucket {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.min_anonymity) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("minAnonymity", &__With(&self.min_anonymity))?;
                }
                if !wkt::internal::is_default(&self.max_anonymity) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("maxAnonymity", &__With(&self.max_anonymity))?;
                }
                if !wkt::internal::is_default(&self.bucket_size) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("bucketSize", &__With(&self.bucket_size))?;
                }
                if !self.bucket_values.is_empty() {
                    state.serialize_entry("bucketValues", &self.bucket_values)?;
                }
                if !wkt::internal::is_default(&self.bucket_value_count) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("bucketValueCount", &__With(&self.bucket_value_count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Result of the δ-presence computation. Note that these results are an
    /// estimation, not exact values.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeltaPresenceEstimationResult {

        /// The intervals [min_probability, max_probability) do not overlap. If a
        /// value doesn't correspond to any such interval, the associated frequency
        /// is zero. For example, the following records:
        /// {min_probability: 0, max_probability: 0.1, frequency: 17}
        /// {min_probability: 0.2, max_probability: 0.3, frequency: 42}
        /// {min_probability: 0.3, max_probability: 0.4, frequency: 99}
        /// mean that there are no record with an estimated probability in [0.1, 0.2)
        /// nor larger or equal to 0.4.
        pub delta_presence_estimation_histogram: std::vec::Vec<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DeltaPresenceEstimationResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [delta_presence_estimation_histogram][crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult::delta_presence_estimation_histogram].
        pub fn set_delta_presence_estimation_histogram<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket>
        {
            use std::iter::Iterator;
            self.delta_presence_estimation_histogram = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DeltaPresenceEstimationResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DeltaPresenceEstimationResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __delta_presence_estimation_histogram,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DeltaPresenceEstimationResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "deltaPresenceEstimationHistogram" => {
                                    Ok(__FieldTag::__delta_presence_estimation_histogram)
                                }
                                "delta_presence_estimation_histogram" => {
                                    Ok(__FieldTag::__delta_presence_estimation_histogram)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DeltaPresenceEstimationResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DeltaPresenceEstimationResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__delta_presence_estimation_histogram => {
                                if !fields.insert(__FieldTag::__delta_presence_estimation_histogram)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for delta_presence_estimation_histogram",
                                    ));
                                }
                                result.delta_presence_estimation_histogram = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DeltaPresenceEstimationResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.delta_presence_estimation_histogram.is_empty() {
                state.serialize_entry(
                    "deltaPresenceEstimationHistogram",
                    &self.delta_presence_estimation_histogram,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [DeltaPresenceEstimationResult].
    pub mod delta_presence_estimation_result {
        #[allow(unused_imports)]
        use super::*;

        /// A tuple of values for the quasi-identifier columns.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DeltaPresenceEstimationQuasiIdValues {
            /// The quasi-identifier values.
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// The estimated probability that a given individual sharing these
            /// quasi-identifier values is in the dataset. This value, typically
            /// called δ, is the ratio between the number of records in the dataset
            /// with these quasi-identifier values, and the total number of individuals
            /// (inside *and* outside the dataset) with these quasi-identifier values.
            /// For example, if there are 15 individuals in the dataset who share the
            /// same quasi-identifier values, and an estimated 100 people in the entire
            /// population with these values, then δ is 0.15.
            pub estimated_probability: f64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DeltaPresenceEstimationQuasiIdValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [estimated_probability][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues::estimated_probability].
            pub fn set_estimated_probability<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.estimated_probability = v.into();
                self
            }
        }

        impl wkt::message::Message for DeltaPresenceEstimationQuasiIdValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationQuasiIdValues"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DeltaPresenceEstimationQuasiIdValues {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __quasi_ids_values,
                    __estimated_probability,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str(
                                    "a field name for DeltaPresenceEstimationQuasiIdValues",
                                )
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "quasiIdsValues" => Ok(__FieldTag::__quasi_ids_values),
                                    "quasi_ids_values" => Ok(__FieldTag::__quasi_ids_values),
                                    "estimatedProbability" => {
                                        Ok(__FieldTag::__estimated_probability)
                                    }
                                    "estimated_probability" => {
                                        Ok(__FieldTag::__estimated_probability)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DeltaPresenceEstimationQuasiIdValues;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DeltaPresenceEstimationQuasiIdValues")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__quasi_ids_values => {
                                    if !fields.insert(__FieldTag::__quasi_ids_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for quasi_ids_values",
                                            ),
                                        );
                                    }
                                    result.quasi_ids_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Value>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__estimated_probability => {
                                    if !fields.insert(__FieldTag::__estimated_probability) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for estimated_probability",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.estimated_probability =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DeltaPresenceEstimationQuasiIdValues {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.quasi_ids_values.is_empty() {
                    state.serialize_entry("quasiIdsValues", &self.quasi_ids_values)?;
                }
                if !wkt::internal::is_default(&self.estimated_probability) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "estimatedProbability",
                        &__With(&self.estimated_probability),
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// A DeltaPresenceEstimationHistogramBucket message with the following
        /// values:
        /// min_probability: 0.1
        /// max_probability: 0.2
        /// frequency: 42
        /// means that there are 42 records for which δ is in [0.1, 0.2). An
        /// important particular case is when min_probability = max_probability = 1:
        /// then, every individual who shares this quasi-identifier combination is in
        /// the dataset.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DeltaPresenceEstimationHistogramBucket {

            /// Between 0 and 1.
            pub min_probability: f64,

            /// Always greater than or equal to min_probability.
            pub max_probability: f64,

            /// Number of records within these probability bounds.
            pub bucket_size: i64,

            /// Sample of quasi-identifier tuple values in this bucket. The total
            /// number of classes returned per bucket is capped at 20.
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues>,

            /// Total number of distinct quasi-identifier tuple values in this bucket.
            pub bucket_value_count: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DeltaPresenceEstimationHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_probability][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::min_probability].
            pub fn set_min_probability<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.min_probability = v.into();
                self
            }

            /// Sets the value of [max_probability][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::max_probability].
            pub fn set_max_probability<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.max_probability = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }
        }

        impl wkt::message::Message for DeltaPresenceEstimationHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationHistogramBucket"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DeltaPresenceEstimationHistogramBucket {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __min_probability,
                    __max_probability,
                    __bucket_size,
                    __bucket_values,
                    __bucket_value_count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str(
                                    "a field name for DeltaPresenceEstimationHistogramBucket",
                                )
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "minProbability" => Ok(__FieldTag::__min_probability),
                                    "min_probability" => Ok(__FieldTag::__min_probability),
                                    "maxProbability" => Ok(__FieldTag::__max_probability),
                                    "max_probability" => Ok(__FieldTag::__max_probability),
                                    "bucketSize" => Ok(__FieldTag::__bucket_size),
                                    "bucket_size" => Ok(__FieldTag::__bucket_size),
                                    "bucketValues" => Ok(__FieldTag::__bucket_values),
                                    "bucket_values" => Ok(__FieldTag::__bucket_values),
                                    "bucketValueCount" => Ok(__FieldTag::__bucket_value_count),
                                    "bucket_value_count" => Ok(__FieldTag::__bucket_value_count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DeltaPresenceEstimationHistogramBucket;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DeltaPresenceEstimationHistogramBucket")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__min_probability => {
                                    if !fields.insert(__FieldTag::__min_probability) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for min_probability",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.min_probability =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__max_probability => {
                                    if !fields.insert(__FieldTag::__max_probability) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for max_probability",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max_probability =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__bucket_size => {
                                    if !fields.insert(__FieldTag::__bucket_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.bucket_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__bucket_values => {
                                    if !fields.insert(__FieldTag::__bucket_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_values",
                                            ),
                                        );
                                    }
                                    result.bucket_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__bucket_value_count => {
                                    if !fields.insert(__FieldTag::__bucket_value_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_value_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.bucket_value_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DeltaPresenceEstimationHistogramBucket {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.min_probability) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("minProbability", &__With(&self.min_probability))?;
                }
                if !wkt::internal::is_default(&self.max_probability) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("maxProbability", &__With(&self.max_probability))?;
                }
                if !wkt::internal::is_default(&self.bucket_size) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("bucketSize", &__With(&self.bucket_size))?;
                }
                if !self.bucket_values.is_empty() {
                    state.serialize_entry("bucketValues", &self.bucket_values)?;
                }
                if !wkt::internal::is_default(&self.bucket_value_count) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("bucketValueCount", &__With(&self.bucket_value_count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Risk analysis options.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RequestedRiskAnalysisOptions {
        /// The job config for the risk job.
        pub job_config: std::option::Option<crate::model::RiskAnalysisJobConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RequestedRiskAnalysisOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [job_config][crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions::job_config].
        pub fn set_job_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RiskAnalysisJobConfig>,
        {
            self.job_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [job_config][crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions::job_config].
        pub fn set_or_clear_job_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RiskAnalysisJobConfig>,
        {
            self.job_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for RequestedRiskAnalysisOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.RequestedRiskAnalysisOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RequestedRiskAnalysisOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __job_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RequestedRiskAnalysisOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "jobConfig" => Ok(__FieldTag::__job_config),
                                "job_config" => Ok(__FieldTag::__job_config),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RequestedRiskAnalysisOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RequestedRiskAnalysisOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__job_config => {
                                if !fields.insert(__FieldTag::__job_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for job_config",
                                    ));
                                }
                                result.job_config = map.next_value::<std::option::Option<crate::model::RiskAnalysisJobConfig>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RequestedRiskAnalysisOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.job_config.is_some() {
                state.serialize_entry("jobConfig", &self.job_config)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Values associated with this metric.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// Numerical stats result
        NumericalStatsResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::NumericalStatsResult>,
        ),
        /// Categorical stats result
        CategoricalStatsResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::CategoricalStatsResult>,
        ),
        /// K-anonymity result
        KAnonymityResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::KAnonymityResult>,
        ),
        /// L-divesity result
        LDiversityResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::LDiversityResult>,
        ),
        /// K-map result
        KMapEstimationResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::KMapEstimationResult>,
        ),
        /// Delta-presence result
        DeltaPresenceEstimationResult(
            std::boxed::Box<
                crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult,
            >,
        ),
    }
}

/// A value of a field, including its frequency.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ValueFrequency {
    /// A value contained in the field in question.
    pub value: std::option::Option<crate::model::Value>,

    /// How many times the value is contained in the field.
    pub count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValueFrequency {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::ValueFrequency::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Value>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::ValueFrequency::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Value>,
    {
        self.value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [count][crate::model::ValueFrequency::count].
    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.count = v.into();
        self
    }
}

impl wkt::message::Message for ValueFrequency {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ValueFrequency"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValueFrequency {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValueFrequency")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "count" => Ok(__FieldTag::__count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValueFrequency;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValueFrequency")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value =
                                map.next_value::<std::option::Option<crate::model::Value>>()?;
                        }
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValueFrequency {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !wkt::internal::is_default(&self.count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Set of primitive values supported by the system.
/// Note that for the purposes of inspection or transformation, the number
/// of bytes considered to comprise a 'Value' is based on its representation
/// as a UTF-8 encoded string. For example, if 'integer_value' is set to
/// 123456789, the number of bytes would be counted as 9, even though an
/// int64 only holds up to 8 bytes of data.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Value {
    /// Value types
    pub r#type: std::option::Option<crate::model::value::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Value {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Value::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::value::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `IntegerValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn integer_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::IntegerValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `IntegerValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_integer_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::IntegerValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `FloatValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn float_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::FloatValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `FloatValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_float_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::FloatValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::StringValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `BooleanValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn boolean_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::BooleanValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `BooleanValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_boolean_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::BooleanValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `TimestampValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timestamp_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::TimestampValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `TimestampValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_timestamp_value<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::value::Type::TimestampValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `TimeValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_value(&self) -> std::option::Option<&std::boxed::Box<gtype::model::TimeOfDay>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::TimeValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `TimeValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_time_value<T: std::convert::Into<std::boxed::Box<gtype::model::TimeOfDay>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::TimeValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `DateValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn date_value(&self) -> std::option::Option<&std::boxed::Box<gtype::model::Date>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::DateValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `DateValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_date_value<T: std::convert::Into<std::boxed::Box<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::DateValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `DayOfWeekValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn day_of_week_value(&self) -> std::option::Option<&gtype::model::DayOfWeek> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::DayOfWeekValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `DayOfWeekValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_day_of_week_value<T: std::convert::Into<gtype::model::DayOfWeek>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::value::Type::DayOfWeekValue(v.into()));
        self
    }
}

impl wkt::message::Message for Value {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Value"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Value {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __integer_value,
            __float_value,
            __string_value,
            __boolean_value,
            __timestamp_value,
            __time_value,
            __date_value,
            __day_of_week_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Value")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "integerValue" => Ok(__FieldTag::__integer_value),
                            "integer_value" => Ok(__FieldTag::__integer_value),
                            "floatValue" => Ok(__FieldTag::__float_value),
                            "float_value" => Ok(__FieldTag::__float_value),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "booleanValue" => Ok(__FieldTag::__boolean_value),
                            "boolean_value" => Ok(__FieldTag::__boolean_value),
                            "timestampValue" => Ok(__FieldTag::__timestamp_value),
                            "timestamp_value" => Ok(__FieldTag::__timestamp_value),
                            "timeValue" => Ok(__FieldTag::__time_value),
                            "time_value" => Ok(__FieldTag::__time_value),
                            "dateValue" => Ok(__FieldTag::__date_value),
                            "date_value" => Ok(__FieldTag::__date_value),
                            "dayOfWeekValue" => Ok(__FieldTag::__day_of_week_value),
                            "day_of_week_value" => Ok(__FieldTag::__day_of_week_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Value;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Value")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__integer_value => {
                            if !fields.insert(__FieldTag::__integer_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integer_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.Value.integer_value, latest field was integerValue",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::value::Type::IntegerValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__float_value => {
                            if !fields.insert(__FieldTag::__float_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for float_value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.Value.float_value, latest field was floatValue",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::value::Type::FloatValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.Value.string_value, latest field was stringValue",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::value::Type::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__boolean_value => {
                            if !fields.insert(__FieldTag::__boolean_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boolean_value",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.Value.boolean_value, latest field was booleanValue",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::value::Type::BooleanValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__timestamp_value => {
                            if !fields.insert(__FieldTag::__timestamp_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp_value",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.Value.timestamp_value, latest field was timestampValue",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::value::Type::TimestampValue(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__time_value => {
                            if !fields.insert(__FieldTag::__time_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_value",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.Value.time_value, latest field was timeValue",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::value::Type::TimeValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<gtype::model::TimeOfDay>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__date_value => {
                            if !fields.insert(__FieldTag::__date_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for date_value",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.Value.date_value, latest field was dateValue",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(
                                    crate::model::value::Type::DateValue(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<gtype::model::Date>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__day_of_week_value => {
                            if !fields.insert(__FieldTag::__day_of_week_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day_of_week_value",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.Value.day_of_week_value, latest field was dayOfWeekValue",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::value::Type::DayOfWeekValue(
                                    map.next_value::<std::option::Option<gtype::model::DayOfWeek>>(
                                    )?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Value {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.integer_value() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("integerValue", &__With(value))?;
        }
        if let Some(value) = self.float_value() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("floatValue", &__With(value))?;
        }
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if let Some(value) = self.boolean_value() {
            state.serialize_entry("booleanValue", value)?;
        }
        if let Some(value) = self.timestamp_value() {
            state.serialize_entry("timestampValue", value)?;
        }
        if let Some(value) = self.time_value() {
            state.serialize_entry("timeValue", value)?;
        }
        if let Some(value) = self.date_value() {
            state.serialize_entry("dateValue", value)?;
        }
        if let Some(value) = self.day_of_week_value() {
            state.serialize_entry("dayOfWeekValue", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Value].
pub mod value {
    #[allow(unused_imports)]
    use super::*;

    /// Value types
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// integer
        IntegerValue(i64),
        /// float
        FloatValue(f64),
        /// string
        StringValue(std::string::String),
        /// boolean
        BooleanValue(bool),
        /// timestamp
        TimestampValue(std::boxed::Box<wkt::Timestamp>),
        /// time of day
        TimeValue(std::boxed::Box<gtype::model::TimeOfDay>),
        /// date
        DateValue(std::boxed::Box<gtype::model::Date>),
        /// day of week
        DayOfWeekValue(gtype::model::DayOfWeek),
    }
}

/// Message for infoType-dependent details parsed from quote.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QuoteInfo {
    /// Object representation of the quote.
    pub parsed_quote: std::option::Option<crate::model::quote_info::ParsedQuote>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuoteInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parsed_quote][crate::model::QuoteInfo::parsed_quote].
    ///
    /// Note that all the setters affecting `parsed_quote` are mutually
    /// exclusive.
    pub fn set_parsed_quote<
        T: std::convert::Into<std::option::Option<crate::model::quote_info::ParsedQuote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parsed_quote = v.into();
        self
    }

    /// The value of [parsed_quote][crate::model::QuoteInfo::parsed_quote]
    /// if it holds a `DateTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn date_time(&self) -> std::option::Option<&std::boxed::Box<crate::model::DateTime>> {
        #[allow(unreachable_patterns)]
        self.parsed_quote.as_ref().and_then(|v| match v {
            crate::model::quote_info::ParsedQuote::DateTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [parsed_quote][crate::model::QuoteInfo::parsed_quote]
    /// to hold a `DateTime`.
    ///
    /// Note that all the setters affecting `parsed_quote` are
    /// mutually exclusive.
    pub fn set_date_time<T: std::convert::Into<std::boxed::Box<crate::model::DateTime>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parsed_quote =
            std::option::Option::Some(crate::model::quote_info::ParsedQuote::DateTime(v.into()));
        self
    }
}

impl wkt::message::Message for QuoteInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.QuoteInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QuoteInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __date_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QuoteInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dateTime" => Ok(__FieldTag::__date_time),
                            "date_time" => Ok(__FieldTag::__date_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QuoteInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QuoteInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__date_time => {
                            if !fields.insert(__FieldTag::__date_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for date_time",
                                ));
                            }
                            if result.parsed_quote.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `parsed_quote`, a oneof with full ID .google.privacy.dlp.v2.QuoteInfo.date_time, latest field was dateTime",
                                ));
                            }
                            result.parsed_quote = std::option::Option::Some(
                                crate::model::quote_info::ParsedQuote::DateTime(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DateTime>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QuoteInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.date_time() {
            state.serialize_entry("dateTime", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [QuoteInfo].
pub mod quote_info {
    #[allow(unused_imports)]
    use super::*;

    /// Object representation of the quote.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ParsedQuote {
        /// The date time indicated by the quote.
        DateTime(std::boxed::Box<crate::model::DateTime>),
    }
}

/// Message for a date time object.
/// e.g. 2018-01-01, 5th August.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DateTime {
    /// One or more of the following must be set.
    /// Must be a valid date or time value.
    pub date: std::option::Option<gtype::model::Date>,

    /// Day of week
    pub day_of_week: gtype::model::DayOfWeek,

    /// Time of day
    pub time: std::option::Option<gtype::model::TimeOfDay>,

    /// Time zone
    pub time_zone: std::option::Option<crate::model::date_time::TimeZone>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DateTime {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [date][crate::model::DateTime::date].
    pub fn set_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [date][crate::model::DateTime::date].
    pub fn set_or_clear_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [day_of_week][crate::model::DateTime::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }

    /// Sets the value of [time][crate::model::DateTime::time].
    pub fn set_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time][crate::model::DateTime::time].
    pub fn set_or_clear_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_zone][crate::model::DateTime::time_zone].
    pub fn set_time_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::date_time::TimeZone>,
    {
        self.time_zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_zone][crate::model::DateTime::time_zone].
    pub fn set_or_clear_time_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::date_time::TimeZone>,
    {
        self.time_zone = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DateTime {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DateTime"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DateTime {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __date,
            __day_of_week,
            __time,
            __time_zone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DateTime")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "date" => Ok(__FieldTag::__date),
                            "dayOfWeek" => Ok(__FieldTag::__day_of_week),
                            "day_of_week" => Ok(__FieldTag::__day_of_week),
                            "time" => Ok(__FieldTag::__time),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DateTime;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DateTime")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__date => {
                            if !fields.insert(__FieldTag::__date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for date",
                                ));
                            }
                            result.date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__day_of_week => {
                            if !fields.insert(__FieldTag::__day_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day_of_week",
                                ));
                            }
                            result.day_of_week = map
                                .next_value::<std::option::Option<gtype::model::DayOfWeek>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time => {
                            if !fields.insert(__FieldTag::__time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time",
                                ));
                            }
                            result.time =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map.next_value::<std::option::Option<crate::model::date_time::TimeZone>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DateTime {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.date.is_some() {
            state.serialize_entry("date", &self.date)?;
        }
        if !wkt::internal::is_default(&self.day_of_week) {
            state.serialize_entry("dayOfWeek", &self.day_of_week)?;
        }
        if self.time.is_some() {
            state.serialize_entry("time", &self.time)?;
        }
        if self.time_zone.is_some() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DateTime].
pub mod date_time {
    #[allow(unused_imports)]
    use super::*;

    /// Time zone of the date time object.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TimeZone {
        /// Set only if the offset can be determined. Positive for time ahead of UTC.
        /// E.g. For "UTC-9", this value is -540.
        pub offset_minutes: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeZone {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [offset_minutes][crate::model::date_time::TimeZone::offset_minutes].
        pub fn set_offset_minutes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.offset_minutes = v.into();
            self
        }
    }

    impl wkt::message::Message for TimeZone {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DateTime.TimeZone"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TimeZone {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __offset_minutes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TimeZone")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "offsetMinutes" => Ok(__FieldTag::__offset_minutes),
                                "offset_minutes" => Ok(__FieldTag::__offset_minutes),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TimeZone;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TimeZone")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__offset_minutes => {
                                if !fields.insert(__FieldTag::__offset_minutes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for offset_minutes",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.offset_minutes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TimeZone {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.offset_minutes) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("offsetMinutes", &__With(&self.offset_minutes))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The configuration that controls how the data will change.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeidentifyConfig {
    /// Mode for handling transformation errors. If left unspecified, the default
    /// mode is `TransformationErrorHandling.ThrowError`.
    pub transformation_error_handling:
        std::option::Option<crate::model::TransformationErrorHandling>,

    /// Type of transformation
    pub transformation: std::option::Option<crate::model::deidentify_config::Transformation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformation_error_handling][crate::model::DeidentifyConfig::transformation_error_handling].
    pub fn set_transformation_error_handling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransformationErrorHandling>,
    {
        self.transformation_error_handling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transformation_error_handling][crate::model::DeidentifyConfig::transformation_error_handling].
    pub fn set_or_clear_transformation_error_handling<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::TransformationErrorHandling>,
    {
        self.transformation_error_handling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transformation][crate::model::DeidentifyConfig::transformation].
    ///
    /// Note that all the setters affecting `transformation` are mutually
    /// exclusive.
    pub fn set_transformation<
        T: std::convert::Into<std::option::Option<crate::model::deidentify_config::Transformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = v.into();
        self
    }

    /// The value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// if it holds a `InfoTypeTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn info_type_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InfoTypeTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::deidentify_config::Transformation::InfoTypeTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// to hold a `InfoTypeTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_info_type_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::InfoTypeTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::deidentify_config::Transformation::InfoTypeTransformations(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// if it holds a `RecordTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn record_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecordTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::deidentify_config::Transformation::RecordTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// to hold a `RecordTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_record_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::RecordTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::deidentify_config::Transformation::RecordTransformations(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// if it holds a `ImageTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImageTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::deidentify_config::Transformation::ImageTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// to hold a `ImageTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_image_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::ImageTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::deidentify_config::Transformation::ImageTransformations(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DeidentifyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeidentifyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_type_transformations,
            __record_transformations,
            __image_transformations,
            __transformation_error_handling,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeidentifyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoTypeTransformations" => {
                                Ok(__FieldTag::__info_type_transformations)
                            }
                            "info_type_transformations" => {
                                Ok(__FieldTag::__info_type_transformations)
                            }
                            "recordTransformations" => Ok(__FieldTag::__record_transformations),
                            "record_transformations" => Ok(__FieldTag::__record_transformations),
                            "imageTransformations" => Ok(__FieldTag::__image_transformations),
                            "image_transformations" => Ok(__FieldTag::__image_transformations),
                            "transformationErrorHandling" => {
                                Ok(__FieldTag::__transformation_error_handling)
                            }
                            "transformation_error_handling" => {
                                Ok(__FieldTag::__transformation_error_handling)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeidentifyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeidentifyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_type_transformations => {
                            if !fields.insert(__FieldTag::__info_type_transformations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type_transformations",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.DeidentifyConfig.info_type_transformations, latest field was infoTypeTransformations",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::deidentify_config::Transformation::InfoTypeTransformations(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InfoTypeTransformations>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__record_transformations => {
                            if !fields.insert(__FieldTag::__record_transformations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for record_transformations",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.DeidentifyConfig.record_transformations, latest field was recordTransformations",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::deidentify_config::Transformation::RecordTransformations(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::RecordTransformations>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__image_transformations => {
                            if !fields.insert(__FieldTag::__image_transformations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_transformations",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.DeidentifyConfig.image_transformations, latest field was imageTransformations",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::deidentify_config::Transformation::ImageTransformations(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ImageTransformations>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__transformation_error_handling => {
                            if !fields.insert(__FieldTag::__transformation_error_handling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformation_error_handling",
                                ));
                            }
                            result.transformation_error_handling = map.next_value::<std::option::Option<crate::model::TransformationErrorHandling>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeidentifyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.info_type_transformations() {
            state.serialize_entry("infoTypeTransformations", value)?;
        }
        if let Some(value) = self.record_transformations() {
            state.serialize_entry("recordTransformations", value)?;
        }
        if let Some(value) = self.image_transformations() {
            state.serialize_entry("imageTransformations", value)?;
        }
        if self.transformation_error_handling.is_some() {
            state.serialize_entry(
                "transformationErrorHandling",
                &self.transformation_error_handling,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DeidentifyConfig].
pub mod deidentify_config {
    #[allow(unused_imports)]
    use super::*;

    /// Type of transformation
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Transformation {
        /// Treat the dataset as free-form text and apply the same free text
        /// transformation everywhere.
        InfoTypeTransformations(std::boxed::Box<crate::model::InfoTypeTransformations>),
        /// Treat the dataset as structured. Transformations can be applied to
        /// specific locations within structured datasets, such as transforming
        /// a column within a table.
        RecordTransformations(std::boxed::Box<crate::model::RecordTransformations>),
        /// Treat the dataset as an image and redact.
        ImageTransformations(std::boxed::Box<crate::model::ImageTransformations>),
    }
}

/// A type of transformation that is applied over images.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageTransformations {
    /// List of transforms to make.
    pub transforms: std::vec::Vec<crate::model::image_transformations::ImageTransformation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageTransformations {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transforms][crate::model::ImageTransformations::transforms].
    pub fn set_transforms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::image_transformations::ImageTransformation>,
    {
        use std::iter::Iterator;
        self.transforms = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImageTransformations {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageTransformations {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transforms,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageTransformations")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transforms" => Ok(__FieldTag::__transforms),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageTransformations;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageTransformations")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transforms => {
                            if !fields.insert(__FieldTag::__transforms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transforms",
                                ));
                            }
                            result.transforms = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::image_transformations::ImageTransformation,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageTransformations {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transforms.is_empty() {
            state.serialize_entry("transforms", &self.transforms)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImageTransformations].
pub mod image_transformations {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for determining how redaction of images should occur.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ImageTransformation {
        /// The color to use when redacting content from an image. If not
        /// specified, the default is black.
        pub redaction_color: std::option::Option<crate::model::Color>,

        /// Part of the image to transform.
        pub target:
            std::option::Option<crate::model::image_transformations::image_transformation::Target>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImageTransformation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [redaction_color][crate::model::image_transformations::ImageTransformation::redaction_color].
        pub fn set_redaction_color<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Color>,
        {
            self.redaction_color = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [redaction_color][crate::model::image_transformations::ImageTransformation::redaction_color].
        pub fn set_or_clear_redaction_color<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Color>,
        {
            self.redaction_color = v.map(|x| x.into());
            self
        }

        /// Sets the value of [target][crate::model::image_transformations::ImageTransformation::target].
        ///
        /// Note that all the setters affecting `target` are mutually
        /// exclusive.
        pub fn set_target<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::image_transformations::image_transformation::Target,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = v.into();
            self
        }

        /// The value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// if it holds a `SelectedInfoTypes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn selected_info_types(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::image_transformations::image_transformation::SelectedInfoTypes,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::image_transformations::image_transformation::Target::SelectedInfoTypes(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// to hold a `SelectedInfoTypes`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_selected_info_types<T: std::convert::Into<std::boxed::Box<crate::model::image_transformations::image_transformation::SelectedInfoTypes>>>(mut self, v: T) -> Self{
            self.target = std::option::Option::Some(
                crate::model::image_transformations::image_transformation::Target::SelectedInfoTypes(
                    v.into()
                )
            );
            self
        }

        /// The value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// if it holds a `AllInfoTypes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn all_info_types(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::image_transformations::image_transformation::AllInfoTypes,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::image_transformations::image_transformation::Target::AllInfoTypes(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// to hold a `AllInfoTypes`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_all_info_types<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::image_transformations::image_transformation::AllInfoTypes,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = std::option::Option::Some(
                crate::model::image_transformations::image_transformation::Target::AllInfoTypes(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// if it holds a `AllText`, `None` if the field is not set or
        /// holds a different branch.
        pub fn all_text(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::image_transformations::image_transformation::AllText>,
        > {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::image_transformations::image_transformation::Target::AllText(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// to hold a `AllText`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_all_text<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::image_transformations::image_transformation::AllText,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = std::option::Option::Some(
                crate::model::image_transformations::image_transformation::Target::AllText(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for ImageTransformation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ImageTransformation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __selected_info_types,
                __all_info_types,
                __all_text,
                __redaction_color,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ImageTransformation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "selectedInfoTypes" => Ok(__FieldTag::__selected_info_types),
                                "selected_info_types" => Ok(__FieldTag::__selected_info_types),
                                "allInfoTypes" => Ok(__FieldTag::__all_info_types),
                                "all_info_types" => Ok(__FieldTag::__all_info_types),
                                "allText" => Ok(__FieldTag::__all_text),
                                "all_text" => Ok(__FieldTag::__all_text),
                                "redactionColor" => Ok(__FieldTag::__redaction_color),
                                "redaction_color" => Ok(__FieldTag::__redaction_color),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ImageTransformation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ImageTransformation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__selected_info_types => {
                                if !fields.insert(__FieldTag::__selected_info_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for selected_info_types",
                                    ));
                                }
                                if result.target.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `target`, a oneof with full ID .google.privacy.dlp.v2.ImageTransformations.ImageTransformation.selected_info_types, latest field was selectedInfoTypes",
                                    ));
                                }
                                result.target = std::option::Option::Some(
                                    crate::model::image_transformations::image_transformation::Target::SelectedInfoTypes(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::image_transformations::image_transformation::SelectedInfoTypes>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__all_info_types => {
                                if !fields.insert(__FieldTag::__all_info_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for all_info_types",
                                    ));
                                }
                                if result.target.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `target`, a oneof with full ID .google.privacy.dlp.v2.ImageTransformations.ImageTransformation.all_info_types, latest field was allInfoTypes",
                                    ));
                                }
                                result.target = std::option::Option::Some(
                                    crate::model::image_transformations::image_transformation::Target::AllInfoTypes(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::image_transformations::image_transformation::AllInfoTypes>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__all_text => {
                                if !fields.insert(__FieldTag::__all_text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for all_text",
                                    ));
                                }
                                if result.target.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `target`, a oneof with full ID .google.privacy.dlp.v2.ImageTransformations.ImageTransformation.all_text, latest field was allText",
                                    ));
                                }
                                result.target = std::option::Option::Some(
                                    crate::model::image_transformations::image_transformation::Target::AllText(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::image_transformations::image_transformation::AllText>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__redaction_color => {
                                if !fields.insert(__FieldTag::__redaction_color) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for redaction_color",
                                    ));
                                }
                                result.redaction_color =
                                    map.next_value::<std::option::Option<crate::model::Color>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ImageTransformation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.selected_info_types() {
                state.serialize_entry("selectedInfoTypes", value)?;
            }
            if let Some(value) = self.all_info_types() {
                state.serialize_entry("allInfoTypes", value)?;
            }
            if let Some(value) = self.all_text() {
                state.serialize_entry("allText", value)?;
            }
            if self.redaction_color.is_some() {
                state.serialize_entry("redactionColor", &self.redaction_color)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ImageTransformation].
    pub mod image_transformation {
        #[allow(unused_imports)]
        use super::*;

        /// Apply transformation to the selected info_types.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct SelectedInfoTypes {
            /// Required. InfoTypes to apply the transformation to. Required. Provided
            /// InfoType must be unique within the ImageTransformations message.
            pub info_types: std::vec::Vec<crate::model::InfoType>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SelectedInfoTypes {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [info_types][crate::model::image_transformations::image_transformation::SelectedInfoTypes::info_types].
            pub fn set_info_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::InfoType>,
            {
                use std::iter::Iterator;
                self.info_types = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for SelectedInfoTypes {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation.SelectedInfoTypes"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for SelectedInfoTypes {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __info_types,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for SelectedInfoTypes")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "infoTypes" => Ok(__FieldTag::__info_types),
                                    "info_types" => Ok(__FieldTag::__info_types),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = SelectedInfoTypes;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct SelectedInfoTypes")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__info_types => {
                                    if !fields.insert(__FieldTag::__info_types) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for info_types",
                                            ),
                                        );
                                    }
                                    result.info_types =
                                        map.next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::InfoType>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for SelectedInfoTypes {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.info_types.is_empty() {
                    state.serialize_entry("infoTypes", &self.info_types)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Apply transformation to all findings.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AllInfoTypes {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AllInfoTypes {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for AllInfoTypes {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation.AllInfoTypes"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AllInfoTypes {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AllInfoTypes")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AllInfoTypes;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AllInfoTypes")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AllInfoTypes {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Apply to all text.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AllText {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AllText {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for AllText {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation.AllText"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AllText {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AllText")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AllText;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AllText")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AllText {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Part of the image to transform.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Target {
            /// Apply transformation to the selected info_types.
            SelectedInfoTypes(
                std::boxed::Box<
                    crate::model::image_transformations::image_transformation::SelectedInfoTypes,
                >,
            ),
            /// Apply transformation to all findings not specified in other
            /// ImageTransformation's selected_info_types. Only one instance is allowed
            /// within the ImageTransformations message.
            AllInfoTypes(
                std::boxed::Box<
                    crate::model::image_transformations::image_transformation::AllInfoTypes,
                >,
            ),
            /// Apply transformation to all text that doesn't match an infoType. Only
            /// one instance is allowed within the ImageTransformations message.
            AllText(
                std::boxed::Box<crate::model::image_transformations::image_transformation::AllText>,
            ),
        }
    }
}

/// How to handle transformation errors during de-identification. A
/// transformation error occurs when the requested transformation is incompatible
/// with the data. For example, trying to de-identify an IP address using a
/// `DateShift` transformation would result in a transformation error, since date
/// info cannot be extracted from an IP address.
/// Information about any incompatible transformations, and how they were
/// handled, is returned in the response as part of the
/// `TransformationOverviews`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransformationErrorHandling {
    /// How transformation errors should be handled.
    pub mode: std::option::Option<crate::model::transformation_error_handling::Mode>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationErrorHandling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::TransformationErrorHandling::mode].
    ///
    /// Note that all the setters affecting `mode` are mutually
    /// exclusive.
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::transformation_error_handling::Mode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::TransformationErrorHandling::mode]
    /// if it holds a `ThrowError`, `None` if the field is not set or
    /// holds a different branch.
    pub fn throw_error(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::transformation_error_handling::ThrowError>,
    > {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::transformation_error_handling::Mode::ThrowError(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::TransformationErrorHandling::mode]
    /// to hold a `ThrowError`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_throw_error<
        T: std::convert::Into<
                std::boxed::Box<crate::model::transformation_error_handling::ThrowError>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::transformation_error_handling::Mode::ThrowError(v.into()),
        );
        self
    }

    /// The value of [mode][crate::model::TransformationErrorHandling::mode]
    /// if it holds a `LeaveUntransformed`, `None` if the field is not set or
    /// holds a different branch.
    pub fn leave_untransformed(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::transformation_error_handling::LeaveUntransformed>,
    > {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::transformation_error_handling::Mode::LeaveUntransformed(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::TransformationErrorHandling::mode]
    /// to hold a `LeaveUntransformed`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_leave_untransformed<
        T: std::convert::Into<
                std::boxed::Box<crate::model::transformation_error_handling::LeaveUntransformed>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::transformation_error_handling::Mode::LeaveUntransformed(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TransformationErrorHandling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationErrorHandling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransformationErrorHandling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __throw_error,
            __leave_untransformed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransformationErrorHandling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "throwError" => Ok(__FieldTag::__throw_error),
                            "throw_error" => Ok(__FieldTag::__throw_error),
                            "leaveUntransformed" => Ok(__FieldTag::__leave_untransformed),
                            "leave_untransformed" => Ok(__FieldTag::__leave_untransformed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransformationErrorHandling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransformationErrorHandling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__throw_error => {
                            if !fields.insert(__FieldTag::__throw_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for throw_error",
                                ));
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.privacy.dlp.v2.TransformationErrorHandling.throw_error, latest field was throwError",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::transformation_error_handling::Mode::ThrowError(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::transformation_error_handling::ThrowError,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__leave_untransformed => {
                            if !fields.insert(__FieldTag::__leave_untransformed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for leave_untransformed",
                                ));
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.privacy.dlp.v2.TransformationErrorHandling.leave_untransformed, latest field was leaveUntransformed",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::transformation_error_handling::Mode::LeaveUntransformed(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::transformation_error_handling::LeaveUntransformed>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransformationErrorHandling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.throw_error() {
            state.serialize_entry("throwError", value)?;
        }
        if let Some(value) = self.leave_untransformed() {
            state.serialize_entry("leaveUntransformed", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TransformationErrorHandling].
pub mod transformation_error_handling {
    #[allow(unused_imports)]
    use super::*;

    /// Throw an error and fail the request when a transformation error occurs.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ThrowError {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThrowError {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for ThrowError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.TransformationErrorHandling.ThrowError"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ThrowError {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ThrowError")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ThrowError;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ThrowError")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ThrowError {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Skips the data without modifying it if the requested transformation would
    /// cause an error. For example, if a `DateShift` transformation were applied
    /// an an IP address, this mode would leave the IP address unchanged in the
    /// response.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LeaveUntransformed {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LeaveUntransformed {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for LeaveUntransformed {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.TransformationErrorHandling.LeaveUntransformed"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LeaveUntransformed {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LeaveUntransformed")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LeaveUntransformed;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LeaveUntransformed")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LeaveUntransformed {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// How transformation errors should be handled.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Throw an error
        ThrowError(std::boxed::Box<crate::model::transformation_error_handling::ThrowError>),
        /// Ignore errors
        LeaveUntransformed(
            std::boxed::Box<crate::model::transformation_error_handling::LeaveUntransformed>,
        ),
    }
}

/// A rule for transforming a value.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PrimitiveTransformation {
    /// Type of transformation.
    pub transformation: std::option::Option<crate::model::primitive_transformation::Transformation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrimitiveTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation].
    ///
    /// Note that all the setters affecting `transformation` are mutually
    /// exclusive.
    pub fn set_transformation<
        T: std::convert::Into<
                std::option::Option<crate::model::primitive_transformation::Transformation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = v.into();
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `ReplaceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn replace_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplaceValueConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::ReplaceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `ReplaceConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_replace_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplaceValueConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::ReplaceConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `RedactConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redact_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RedactConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::RedactConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `RedactConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_redact_config<T: std::convert::Into<std::boxed::Box<crate::model::RedactConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::RedactConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CharacterMaskConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn character_mask_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CharacterMaskConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CharacterMaskConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CharacterMaskConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_character_mask_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CharacterMaskConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CharacterMaskConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CryptoReplaceFfxFpeConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn crypto_replace_ffx_fpe_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CryptoReplaceFfxFpeConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CryptoReplaceFfxFpeConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CryptoReplaceFfxFpeConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_crypto_replace_ffx_fpe_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CryptoReplaceFfxFpeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CryptoReplaceFfxFpeConfig(
                v.into(),
            ),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `FixedSizeBucketingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fixed_size_bucketing_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FixedSizeBucketingConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::FixedSizeBucketingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `FixedSizeBucketingConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_fixed_size_bucketing_config<
        T: std::convert::Into<std::boxed::Box<crate::model::FixedSizeBucketingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::FixedSizeBucketingConfig(
                v.into(),
            ),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `BucketingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bucketing_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BucketingConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::BucketingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `BucketingConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_bucketing_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BucketingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::BucketingConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `ReplaceWithInfoTypeConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn replace_with_info_type_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplaceWithInfoTypeConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::ReplaceWithInfoTypeConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `ReplaceWithInfoTypeConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_replace_with_info_type_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplaceWithInfoTypeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::ReplaceWithInfoTypeConfig(
                v.into(),
            ),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `TimePartConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_part_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimePartConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::TimePartConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `TimePartConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_time_part_config<
        T: std::convert::Into<std::boxed::Box<crate::model::TimePartConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::TimePartConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CryptoHashConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn crypto_hash_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CryptoHashConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CryptoHashConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CryptoHashConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_crypto_hash_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CryptoHashConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CryptoHashConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `DateShiftConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn date_shift_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DateShiftConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::DateShiftConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `DateShiftConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_date_shift_config<
        T: std::convert::Into<std::boxed::Box<crate::model::DateShiftConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::DateShiftConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CryptoDeterministicConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn crypto_deterministic_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CryptoDeterministicConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CryptoDeterministicConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CryptoDeterministicConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_crypto_deterministic_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CryptoDeterministicConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CryptoDeterministicConfig(
                v.into(),
            ),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `ReplaceDictionaryConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn replace_dictionary_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplaceDictionaryConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::ReplaceDictionaryConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `ReplaceDictionaryConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_replace_dictionary_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplaceDictionaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::ReplaceDictionaryConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for PrimitiveTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.PrimitiveTransformation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrimitiveTransformation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __replace_config,
            __redact_config,
            __character_mask_config,
            __crypto_replace_ffx_fpe_config,
            __fixed_size_bucketing_config,
            __bucketing_config,
            __replace_with_info_type_config,
            __time_part_config,
            __crypto_hash_config,
            __date_shift_config,
            __crypto_deterministic_config,
            __replace_dictionary_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrimitiveTransformation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "replaceConfig" => Ok(__FieldTag::__replace_config),
                            "replace_config" => Ok(__FieldTag::__replace_config),
                            "redactConfig" => Ok(__FieldTag::__redact_config),
                            "redact_config" => Ok(__FieldTag::__redact_config),
                            "characterMaskConfig" => Ok(__FieldTag::__character_mask_config),
                            "character_mask_config" => Ok(__FieldTag::__character_mask_config),
                            "cryptoReplaceFfxFpeConfig" => {
                                Ok(__FieldTag::__crypto_replace_ffx_fpe_config)
                            }
                            "crypto_replace_ffx_fpe_config" => {
                                Ok(__FieldTag::__crypto_replace_ffx_fpe_config)
                            }
                            "fixedSizeBucketingConfig" => {
                                Ok(__FieldTag::__fixed_size_bucketing_config)
                            }
                            "fixed_size_bucketing_config" => {
                                Ok(__FieldTag::__fixed_size_bucketing_config)
                            }
                            "bucketingConfig" => Ok(__FieldTag::__bucketing_config),
                            "bucketing_config" => Ok(__FieldTag::__bucketing_config),
                            "replaceWithInfoTypeConfig" => {
                                Ok(__FieldTag::__replace_with_info_type_config)
                            }
                            "replace_with_info_type_config" => {
                                Ok(__FieldTag::__replace_with_info_type_config)
                            }
                            "timePartConfig" => Ok(__FieldTag::__time_part_config),
                            "time_part_config" => Ok(__FieldTag::__time_part_config),
                            "cryptoHashConfig" => Ok(__FieldTag::__crypto_hash_config),
                            "crypto_hash_config" => Ok(__FieldTag::__crypto_hash_config),
                            "dateShiftConfig" => Ok(__FieldTag::__date_shift_config),
                            "date_shift_config" => Ok(__FieldTag::__date_shift_config),
                            "cryptoDeterministicConfig" => {
                                Ok(__FieldTag::__crypto_deterministic_config)
                            }
                            "crypto_deterministic_config" => {
                                Ok(__FieldTag::__crypto_deterministic_config)
                            }
                            "replaceDictionaryConfig" => {
                                Ok(__FieldTag::__replace_dictionary_config)
                            }
                            "replace_dictionary_config" => {
                                Ok(__FieldTag::__replace_dictionary_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrimitiveTransformation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrimitiveTransformation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__replace_config => {
                            if !fields.insert(__FieldTag::__replace_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replace_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.replace_config, latest field was replaceConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::ReplaceConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ReplaceValueConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__redact_config => {
                            if !fields.insert(__FieldTag::__redact_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redact_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.redact_config, latest field was redactConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::RedactConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::RedactConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__character_mask_config => {
                            if !fields.insert(__FieldTag::__character_mask_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for character_mask_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.character_mask_config, latest field was characterMaskConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::CharacterMaskConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CharacterMaskConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__crypto_replace_ffx_fpe_config => {
                            if !fields.insert(__FieldTag::__crypto_replace_ffx_fpe_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_replace_ffx_fpe_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.crypto_replace_ffx_fpe_config, latest field was cryptoReplaceFfxFpeConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::CryptoReplaceFfxFpeConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CryptoReplaceFfxFpeConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__fixed_size_bucketing_config => {
                            if !fields.insert(__FieldTag::__fixed_size_bucketing_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed_size_bucketing_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.fixed_size_bucketing_config, latest field was fixedSizeBucketingConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::FixedSizeBucketingConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::FixedSizeBucketingConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__bucketing_config => {
                            if !fields.insert(__FieldTag::__bucketing_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucketing_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.bucketing_config, latest field was bucketingConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::BucketingConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::BucketingConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__replace_with_info_type_config => {
                            if !fields.insert(__FieldTag::__replace_with_info_type_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replace_with_info_type_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.replace_with_info_type_config, latest field was replaceWithInfoTypeConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::ReplaceWithInfoTypeConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ReplaceWithInfoTypeConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__time_part_config => {
                            if !fields.insert(__FieldTag::__time_part_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_part_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.time_part_config, latest field was timePartConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::TimePartConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TimePartConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__crypto_hash_config => {
                            if !fields.insert(__FieldTag::__crypto_hash_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_hash_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.crypto_hash_config, latest field was cryptoHashConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::CryptoHashConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CryptoHashConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__date_shift_config => {
                            if !fields.insert(__FieldTag::__date_shift_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for date_shift_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.date_shift_config, latest field was dateShiftConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::DateShiftConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DateShiftConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__crypto_deterministic_config => {
                            if !fields.insert(__FieldTag::__crypto_deterministic_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_deterministic_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.crypto_deterministic_config, latest field was cryptoDeterministicConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::CryptoDeterministicConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CryptoDeterministicConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__replace_dictionary_config => {
                            if !fields.insert(__FieldTag::__replace_dictionary_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replace_dictionary_config",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.PrimitiveTransformation.replace_dictionary_config, latest field was replaceDictionaryConfig",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::primitive_transformation::Transformation::ReplaceDictionaryConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ReplaceDictionaryConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrimitiveTransformation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.replace_config() {
            state.serialize_entry("replaceConfig", value)?;
        }
        if let Some(value) = self.redact_config() {
            state.serialize_entry("redactConfig", value)?;
        }
        if let Some(value) = self.character_mask_config() {
            state.serialize_entry("characterMaskConfig", value)?;
        }
        if let Some(value) = self.crypto_replace_ffx_fpe_config() {
            state.serialize_entry("cryptoReplaceFfxFpeConfig", value)?;
        }
        if let Some(value) = self.fixed_size_bucketing_config() {
            state.serialize_entry("fixedSizeBucketingConfig", value)?;
        }
        if let Some(value) = self.bucketing_config() {
            state.serialize_entry("bucketingConfig", value)?;
        }
        if let Some(value) = self.replace_with_info_type_config() {
            state.serialize_entry("replaceWithInfoTypeConfig", value)?;
        }
        if let Some(value) = self.time_part_config() {
            state.serialize_entry("timePartConfig", value)?;
        }
        if let Some(value) = self.crypto_hash_config() {
            state.serialize_entry("cryptoHashConfig", value)?;
        }
        if let Some(value) = self.date_shift_config() {
            state.serialize_entry("dateShiftConfig", value)?;
        }
        if let Some(value) = self.crypto_deterministic_config() {
            state.serialize_entry("cryptoDeterministicConfig", value)?;
        }
        if let Some(value) = self.replace_dictionary_config() {
            state.serialize_entry("replaceDictionaryConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PrimitiveTransformation].
pub mod primitive_transformation {
    #[allow(unused_imports)]
    use super::*;

    /// Type of transformation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Transformation {
        /// Replace with a specified value.
        ReplaceConfig(std::boxed::Box<crate::model::ReplaceValueConfig>),
        /// Redact
        RedactConfig(std::boxed::Box<crate::model::RedactConfig>),
        /// Mask
        CharacterMaskConfig(std::boxed::Box<crate::model::CharacterMaskConfig>),
        /// Ffx-Fpe. Strongly discouraged, consider using CryptoDeterministicConfig
        /// instead. Fpe is computationally expensive incurring latency costs.
        CryptoReplaceFfxFpeConfig(std::boxed::Box<crate::model::CryptoReplaceFfxFpeConfig>),
        /// Fixed size bucketing
        FixedSizeBucketingConfig(std::boxed::Box<crate::model::FixedSizeBucketingConfig>),
        /// Bucketing
        BucketingConfig(std::boxed::Box<crate::model::BucketingConfig>),
        /// Replace with infotype
        ReplaceWithInfoTypeConfig(std::boxed::Box<crate::model::ReplaceWithInfoTypeConfig>),
        /// Time extraction
        TimePartConfig(std::boxed::Box<crate::model::TimePartConfig>),
        /// Crypto
        CryptoHashConfig(std::boxed::Box<crate::model::CryptoHashConfig>),
        /// Date Shift
        DateShiftConfig(std::boxed::Box<crate::model::DateShiftConfig>),
        /// Deterministic Crypto
        CryptoDeterministicConfig(std::boxed::Box<crate::model::CryptoDeterministicConfig>),
        /// Replace with a value randomly drawn (with replacement) from a dictionary.
        ReplaceDictionaryConfig(std::boxed::Box<crate::model::ReplaceDictionaryConfig>),
    }
}

/// For use with `Date`, `Timestamp`, and `TimeOfDay`, extract or preserve a
/// portion of the value.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimePartConfig {
    /// The part of the time to keep.
    pub part_to_extract: crate::model::time_part_config::TimePart,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimePartConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [part_to_extract][crate::model::TimePartConfig::part_to_extract].
    pub fn set_part_to_extract<T: std::convert::Into<crate::model::time_part_config::TimePart>>(
        mut self,
        v: T,
    ) -> Self {
        self.part_to_extract = v.into();
        self
    }
}

impl wkt::message::Message for TimePartConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TimePartConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimePartConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __part_to_extract,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimePartConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "partToExtract" => Ok(__FieldTag::__part_to_extract),
                            "part_to_extract" => Ok(__FieldTag::__part_to_extract),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimePartConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimePartConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__part_to_extract => {
                            if !fields.insert(__FieldTag::__part_to_extract) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for part_to_extract",
                                ));
                            }
                            result.part_to_extract = map.next_value::<std::option::Option<crate::model::time_part_config::TimePart>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimePartConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.part_to_extract) {
            state.serialize_entry("partToExtract", &self.part_to_extract)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TimePartConfig].
pub mod time_part_config {
    #[allow(unused_imports)]
    use super::*;

    /// Components that make up time.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimePart {
        /// Unused
        Unspecified,
        /// [0-9999]
        Year,
        /// [1-12]
        Month,
        /// [1-31]
        DayOfMonth,
        /// [1-7]
        DayOfWeek,
        /// [1-53]
        WeekOfYear,
        /// [0-23]
        HourOfDay,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimePart::value] or
        /// [TimePart::name].
        UnknownValue(time_part::UnknownValue),
    }

    #[doc(hidden)]
    pub mod time_part {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimePart {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Year => std::option::Option::Some(1),
                Self::Month => std::option::Option::Some(2),
                Self::DayOfMonth => std::option::Option::Some(3),
                Self::DayOfWeek => std::option::Option::Some(4),
                Self::WeekOfYear => std::option::Option::Some(5),
                Self::HourOfDay => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIME_PART_UNSPECIFIED"),
                Self::Year => std::option::Option::Some("YEAR"),
                Self::Month => std::option::Option::Some("MONTH"),
                Self::DayOfMonth => std::option::Option::Some("DAY_OF_MONTH"),
                Self::DayOfWeek => std::option::Option::Some("DAY_OF_WEEK"),
                Self::WeekOfYear => std::option::Option::Some("WEEK_OF_YEAR"),
                Self::HourOfDay => std::option::Option::Some("HOUR_OF_DAY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimePart {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimePart {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimePart {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Year,
                2 => Self::Month,
                3 => Self::DayOfMonth,
                4 => Self::DayOfWeek,
                5 => Self::WeekOfYear,
                6 => Self::HourOfDay,
                _ => Self::UnknownValue(time_part::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimePart {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIME_PART_UNSPECIFIED" => Self::Unspecified,
                "YEAR" => Self::Year,
                "MONTH" => Self::Month,
                "DAY_OF_MONTH" => Self::DayOfMonth,
                "DAY_OF_WEEK" => Self::DayOfWeek,
                "WEEK_OF_YEAR" => Self::WeekOfYear,
                "HOUR_OF_DAY" => Self::HourOfDay,
                _ => Self::UnknownValue(time_part::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimePart {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Year => serializer.serialize_i32(1),
                Self::Month => serializer.serialize_i32(2),
                Self::DayOfMonth => serializer.serialize_i32(3),
                Self::DayOfWeek => serializer.serialize_i32(4),
                Self::WeekOfYear => serializer.serialize_i32(5),
                Self::HourOfDay => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimePart {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimePart>::new(
                ".google.privacy.dlp.v2.TimePartConfig.TimePart",
            ))
        }
    }
}

/// Pseudonymization method that generates surrogates via cryptographic hashing.
/// Uses SHA-256.
/// The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output
/// (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See <https://cloud.google.com/sensitive-data-protection/docs/pseudonymization>
/// to learn more.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CryptoHashConfig {
    /// The key used by the hash function.
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoHashConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key][crate::model::CryptoHashConfig::crypto_key].
    pub fn set_crypto_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKey>,
    {
        self.crypto_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crypto_key][crate::model::CryptoHashConfig::crypto_key].
    pub fn set_or_clear_crypto_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKey>,
    {
        self.crypto_key = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CryptoHashConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoHashConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CryptoHashConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __crypto_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CryptoHashConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cryptoKey" => Ok(__FieldTag::__crypto_key),
                            "crypto_key" => Ok(__FieldTag::__crypto_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CryptoHashConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CryptoHashConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__crypto_key => {
                            if !fields.insert(__FieldTag::__crypto_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key",
                                ));
                            }
                            result.crypto_key =
                                map.next_value::<std::option::Option<crate::model::CryptoKey>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CryptoHashConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.crypto_key.is_some() {
            state.serialize_entry("cryptoKey", &self.crypto_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Pseudonymization method that generates deterministic encryption for the given
/// input. Outputs a base64 encoded representation of the encrypted output.
/// Uses AES-SIV based on the RFC <https://tools.ietf.org/html/rfc5297>.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CryptoDeterministicConfig {
    /// The key used by the encryption function. For deterministic encryption
    /// using AES-SIV, the provided key is internally expanded to 64 bytes prior to
    /// use.
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    /// The custom info type to annotate the surrogate with.
    /// This annotation will be applied to the surrogate by prefixing it with
    /// the name of the custom info type followed by the number of
    /// characters comprising the surrogate. The following scheme defines the
    /// format: {info type name}({surrogate character count}):{surrogate}
    ///
    /// For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and
    /// the surrogate is 'abc', the full replacement value
    /// will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    ///
    /// This annotation identifies the surrogate when inspecting content using the
    /// custom info type 'Surrogate'. This facilitates reversal of the
    /// surrogate when it occurs in free text.
    ///
    /// Note: For record transformations where the entire cell in a table is being
    /// transformed, surrogates are not mandatory. Surrogates are used to denote
    /// the location of the token and are necessary for re-identification in free
    /// form text.
    ///
    /// In order for inspection to work properly, the name of this info type must
    /// not occur naturally anywhere in your data; otherwise, inspection may either
    ///
    /// - reverse a surrogate that does not correspond to an actual identifier
    /// - be unable to parse the surrogate and result in an error
    ///
    /// Therefore, choose your custom info type name carefully after considering
    /// what your data looks like. One way to select a name that has a high chance
    /// of yielding reliable detection is to include one or more unicode characters
    /// that are highly improbable to exist in your data.
    /// For example, assuming your data is entered from a regular ASCII keyboard,
    /// the symbol with the hex code point 29DD might be used like so:
    /// ⧝MY_TOKEN_TYPE.
    pub surrogate_info_type: std::option::Option<crate::model::InfoType>,

    /// A context may be used for higher security and maintaining
    /// referential integrity such that the same identifier in two different
    /// contexts will be given a distinct surrogate. The context is appended to
    /// plaintext value being encrypted. On decryption the provided context is
    /// validated against the value used during encryption. If a context was
    /// provided during encryption, same context must be provided during decryption
    /// as well.
    ///
    /// If the context is not set, plaintext would be used as is for encryption.
    /// If the context is set but:
    ///
    /// 1. there is no record present when transforming a given value or
    /// 1. the field is not present when transforming a given value,
    ///
    /// plaintext would be used as is for encryption.
    ///
    /// Note that case (1) is expected when an `InfoTypeTransformation` is
    /// applied to both structured and unstructured `ContentItem`s.
    pub context: std::option::Option<crate::model::FieldId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoDeterministicConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key][crate::model::CryptoDeterministicConfig::crypto_key].
    pub fn set_crypto_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKey>,
    {
        self.crypto_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crypto_key][crate::model::CryptoDeterministicConfig::crypto_key].
    pub fn set_or_clear_crypto_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKey>,
    {
        self.crypto_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [surrogate_info_type][crate::model::CryptoDeterministicConfig::surrogate_info_type].
    pub fn set_surrogate_info_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.surrogate_info_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [surrogate_info_type][crate::model::CryptoDeterministicConfig::surrogate_info_type].
    pub fn set_or_clear_surrogate_info_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.surrogate_info_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [context][crate::model::CryptoDeterministicConfig::context].
    pub fn set_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [context][crate::model::CryptoDeterministicConfig::context].
    pub fn set_or_clear_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CryptoDeterministicConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoDeterministicConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CryptoDeterministicConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __crypto_key,
            __surrogate_info_type,
            __context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CryptoDeterministicConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cryptoKey" => Ok(__FieldTag::__crypto_key),
                            "crypto_key" => Ok(__FieldTag::__crypto_key),
                            "surrogateInfoType" => Ok(__FieldTag::__surrogate_info_type),
                            "surrogate_info_type" => Ok(__FieldTag::__surrogate_info_type),
                            "context" => Ok(__FieldTag::__context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CryptoDeterministicConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CryptoDeterministicConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__crypto_key => {
                            if !fields.insert(__FieldTag::__crypto_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key",
                                ));
                            }
                            result.crypto_key =
                                map.next_value::<std::option::Option<crate::model::CryptoKey>>()?;
                        }
                        __FieldTag::__surrogate_info_type => {
                            if !fields.insert(__FieldTag::__surrogate_info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for surrogate_info_type",
                                ));
                            }
                            result.surrogate_info_type =
                                map.next_value::<std::option::Option<crate::model::InfoType>>()?;
                        }
                        __FieldTag::__context => {
                            if !fields.insert(__FieldTag::__context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context",
                                ));
                            }
                            result.context =
                                map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CryptoDeterministicConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.crypto_key.is_some() {
            state.serialize_entry("cryptoKey", &self.crypto_key)?;
        }
        if self.surrogate_info_type.is_some() {
            state.serialize_entry("surrogateInfoType", &self.surrogate_info_type)?;
        }
        if self.context.is_some() {
            state.serialize_entry("context", &self.context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Replace each input value with a given `Value`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplaceValueConfig {
    /// Value to replace it with.
    pub new_value: std::option::Option<crate::model::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplaceValueConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_value][crate::model::ReplaceValueConfig::new_value].
    pub fn set_new_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Value>,
    {
        self.new_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [new_value][crate::model::ReplaceValueConfig::new_value].
    pub fn set_or_clear_new_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Value>,
    {
        self.new_value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReplaceValueConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReplaceValueConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplaceValueConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __new_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplaceValueConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "newValue" => Ok(__FieldTag::__new_value),
                            "new_value" => Ok(__FieldTag::__new_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplaceValueConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplaceValueConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__new_value => {
                            if !fields.insert(__FieldTag::__new_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_value",
                                ));
                            }
                            result.new_value =
                                map.next_value::<std::option::Option<crate::model::Value>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplaceValueConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.new_value.is_some() {
            state.serialize_entry("newValue", &self.new_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Replace each input value with a value randomly selected from the dictionary.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplaceDictionaryConfig {
    /// Type of dictionary.
    pub r#type: std::option::Option<crate::model::replace_dictionary_config::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplaceDictionaryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::ReplaceDictionaryConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::replace_dictionary_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::ReplaceDictionaryConfig::r#type]
    /// if it holds a `WordList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn word_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::replace_dictionary_config::Type::WordList(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ReplaceDictionaryConfig::r#type]
    /// to hold a `WordList`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_word_list<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::replace_dictionary_config::Type::WordList(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ReplaceDictionaryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReplaceDictionaryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplaceDictionaryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __word_list,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplaceDictionaryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "wordList" => Ok(__FieldTag::__word_list),
                            "word_list" => Ok(__FieldTag::__word_list),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplaceDictionaryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplaceDictionaryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__word_list => {
                            if !fields.insert(__FieldTag::__word_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for word_list",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.ReplaceDictionaryConfig.word_list, latest field was wordList",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::replace_dictionary_config::Type::WordList(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::custom_info_type::dictionary::WordList,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplaceDictionaryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.word_list() {
            state.serialize_entry("wordList", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ReplaceDictionaryConfig].
pub mod replace_dictionary_config {
    #[allow(unused_imports)]
    use super::*;

    /// Type of dictionary.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// A list of words to select from for random replacement. The
        /// [limits](https://cloud.google.com/sensitive-data-protection/limits) page
        /// contains details about the size limits of dictionaries.
        WordList(std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>),
    }
}

/// Replace each matching finding with the name of the info_type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplaceWithInfoTypeConfig {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplaceWithInfoTypeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ReplaceWithInfoTypeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReplaceWithInfoTypeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplaceWithInfoTypeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplaceWithInfoTypeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplaceWithInfoTypeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplaceWithInfoTypeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplaceWithInfoTypeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Redact a given value. For example, if used with an `InfoTypeTransformation`
/// transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the
/// output would be 'My phone number is '.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RedactConfig {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedactConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RedactConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RedactConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RedactConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RedactConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RedactConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RedactConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RedactConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Characters to skip when doing deidentification of a value. These will be left
/// alone and skipped.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CharsToIgnore {
    /// Type of characters to skip.
    pub characters: std::option::Option<crate::model::chars_to_ignore::Characters>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CharsToIgnore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [characters][crate::model::CharsToIgnore::characters].
    ///
    /// Note that all the setters affecting `characters` are mutually
    /// exclusive.
    pub fn set_characters<
        T: std::convert::Into<std::option::Option<crate::model::chars_to_ignore::Characters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.characters = v.into();
        self
    }

    /// The value of [characters][crate::model::CharsToIgnore::characters]
    /// if it holds a `CharactersToSkip`, `None` if the field is not set or
    /// holds a different branch.
    pub fn characters_to_skip(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.characters.as_ref().and_then(|v| match v {
            crate::model::chars_to_ignore::Characters::CharactersToSkip(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [characters][crate::model::CharsToIgnore::characters]
    /// to hold a `CharactersToSkip`.
    ///
    /// Note that all the setters affecting `characters` are
    /// mutually exclusive.
    pub fn set_characters_to_skip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.characters = std::option::Option::Some(
            crate::model::chars_to_ignore::Characters::CharactersToSkip(v.into()),
        );
        self
    }

    /// The value of [characters][crate::model::CharsToIgnore::characters]
    /// if it holds a `CommonCharactersToIgnore`, `None` if the field is not set or
    /// holds a different branch.
    pub fn common_characters_to_ignore(
        &self,
    ) -> std::option::Option<&crate::model::chars_to_ignore::CommonCharsToIgnore> {
        #[allow(unreachable_patterns)]
        self.characters.as_ref().and_then(|v| match v {
            crate::model::chars_to_ignore::Characters::CommonCharactersToIgnore(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [characters][crate::model::CharsToIgnore::characters]
    /// to hold a `CommonCharactersToIgnore`.
    ///
    /// Note that all the setters affecting `characters` are
    /// mutually exclusive.
    pub fn set_common_characters_to_ignore<
        T: std::convert::Into<crate::model::chars_to_ignore::CommonCharsToIgnore>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.characters = std::option::Option::Some(
            crate::model::chars_to_ignore::Characters::CommonCharactersToIgnore(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CharsToIgnore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CharsToIgnore"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CharsToIgnore {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __characters_to_skip,
            __common_characters_to_ignore,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CharsToIgnore")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "charactersToSkip" => Ok(__FieldTag::__characters_to_skip),
                            "characters_to_skip" => Ok(__FieldTag::__characters_to_skip),
                            "commonCharactersToIgnore" => {
                                Ok(__FieldTag::__common_characters_to_ignore)
                            }
                            "common_characters_to_ignore" => {
                                Ok(__FieldTag::__common_characters_to_ignore)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CharsToIgnore;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CharsToIgnore")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__characters_to_skip => {
                            if !fields.insert(__FieldTag::__characters_to_skip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for characters_to_skip",
                                ));
                            }
                            if result.characters.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `characters`, a oneof with full ID .google.privacy.dlp.v2.CharsToIgnore.characters_to_skip, latest field was charactersToSkip",
                                ));
                            }
                            result.characters = std::option::Option::Some(
                                crate::model::chars_to_ignore::Characters::CharactersToSkip(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__common_characters_to_ignore => {
                            if !fields.insert(__FieldTag::__common_characters_to_ignore) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_characters_to_ignore",
                                ));
                            }
                            if result.characters.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `characters`, a oneof with full ID .google.privacy.dlp.v2.CharsToIgnore.common_characters_to_ignore, latest field was commonCharactersToIgnore",
                                ));
                            }
                            result.characters = std::option::Option::Some(
                                crate::model::chars_to_ignore::Characters::CommonCharactersToIgnore(
                                    map.next_value::<std::option::Option<
                                        crate::model::chars_to_ignore::CommonCharsToIgnore,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CharsToIgnore {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.characters_to_skip() {
            state.serialize_entry("charactersToSkip", value)?;
        }
        if let Some(value) = self.common_characters_to_ignore() {
            state.serialize_entry("commonCharactersToIgnore", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CharsToIgnore].
pub mod chars_to_ignore {
    #[allow(unused_imports)]
    use super::*;

    /// Convenience enum for indicating common characters to not transform.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CommonCharsToIgnore {
        /// Unused.
        Unspecified,
        /// 0-9
        Numeric,
        /// A-Z
        AlphaUpperCase,
        /// a-z
        AlphaLowerCase,
        /// US Punctuation, one of !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
        Punctuation,
        /// Whitespace character, one of [ \t\n\x0B\f\r]
        Whitespace,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CommonCharsToIgnore::value] or
        /// [CommonCharsToIgnore::name].
        UnknownValue(common_chars_to_ignore::UnknownValue),
    }

    #[doc(hidden)]
    pub mod common_chars_to_ignore {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CommonCharsToIgnore {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Numeric => std::option::Option::Some(1),
                Self::AlphaUpperCase => std::option::Option::Some(2),
                Self::AlphaLowerCase => std::option::Option::Some(3),
                Self::Punctuation => std::option::Option::Some(4),
                Self::Whitespace => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("COMMON_CHARS_TO_IGNORE_UNSPECIFIED")
                }
                Self::Numeric => std::option::Option::Some("NUMERIC"),
                Self::AlphaUpperCase => std::option::Option::Some("ALPHA_UPPER_CASE"),
                Self::AlphaLowerCase => std::option::Option::Some("ALPHA_LOWER_CASE"),
                Self::Punctuation => std::option::Option::Some("PUNCTUATION"),
                Self::Whitespace => std::option::Option::Some("WHITESPACE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CommonCharsToIgnore {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CommonCharsToIgnore {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CommonCharsToIgnore {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Numeric,
                2 => Self::AlphaUpperCase,
                3 => Self::AlphaLowerCase,
                4 => Self::Punctuation,
                5 => Self::Whitespace,
                _ => Self::UnknownValue(common_chars_to_ignore::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CommonCharsToIgnore {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMMON_CHARS_TO_IGNORE_UNSPECIFIED" => Self::Unspecified,
                "NUMERIC" => Self::Numeric,
                "ALPHA_UPPER_CASE" => Self::AlphaUpperCase,
                "ALPHA_LOWER_CASE" => Self::AlphaLowerCase,
                "PUNCTUATION" => Self::Punctuation,
                "WHITESPACE" => Self::Whitespace,
                _ => Self::UnknownValue(common_chars_to_ignore::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CommonCharsToIgnore {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Numeric => serializer.serialize_i32(1),
                Self::AlphaUpperCase => serializer.serialize_i32(2),
                Self::AlphaLowerCase => serializer.serialize_i32(3),
                Self::Punctuation => serializer.serialize_i32(4),
                Self::Whitespace => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CommonCharsToIgnore {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CommonCharsToIgnore>::new(
                ".google.privacy.dlp.v2.CharsToIgnore.CommonCharsToIgnore",
            ))
        }
    }

    /// Type of characters to skip.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Characters {
        /// Characters to not transform when masking.
        CharactersToSkip(std::string::String),
        /// Common characters to not transform when masking. Useful to avoid removing
        /// punctuation.
        CommonCharactersToIgnore(crate::model::chars_to_ignore::CommonCharsToIgnore),
    }
}

/// Partially mask a string by replacing a given number of characters with a
/// fixed character. Masking can start from the beginning or end of the string.
/// This can be used on data of any type (numbers, longs, and so on) and when
/// de-identifying structured data we'll attempt to preserve the original data's
/// type. (This allows you to take a long like 123 and modify it to a string like
/// **3.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CharacterMaskConfig {
    /// Character to use to mask the sensitive values&mdash;for example, `*` for an
    /// alphabetic string such as a name, or `0` for a numeric string such as ZIP
    /// code or credit card number. This string must have a length of 1. If not
    /// supplied, this value defaults to `*` for strings, and `0` for digits.
    pub masking_character: std::string::String,

    /// Number of characters to mask. If not set, all matching chars will be
    /// masked. Skipped characters do not count towards this tally.
    ///
    /// If `number_to_mask` is negative, this denotes inverse masking. Cloud DLP
    /// masks all but a number of characters.
    /// For example, suppose you have the following values:
    ///
    /// - `masking_character` is `*`
    /// - `number_to_mask` is `-4`
    /// - `reverse_order` is `false`
    /// - `CharsToIgnore` includes `-`
    /// - Input string is `1234-5678-9012-3456`
    ///
    /// The resulting de-identified string is
    /// `****-****-****-3456`. Cloud DLP masks all but the last four characters.
    /// If `reverse_order` is `true`, all but the first four characters are masked
    /// as `1234-****-****-****`.
    pub number_to_mask: i32,

    /// Mask characters in reverse order. For example, if `masking_character` is
    /// `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the
    /// input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
    /// If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order`
    /// is `true`, then the string `12345` is masked as `12***`.
    pub reverse_order: bool,

    /// When masking a string, items in this list will be skipped when replacing
    /// characters. For example, if the input string is `555-555-5555` and you
    /// instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP
    /// returns `***-**5-5555`.
    pub characters_to_ignore: std::vec::Vec<crate::model::CharsToIgnore>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CharacterMaskConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [masking_character][crate::model::CharacterMaskConfig::masking_character].
    pub fn set_masking_character<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.masking_character = v.into();
        self
    }

    /// Sets the value of [number_to_mask][crate::model::CharacterMaskConfig::number_to_mask].
    pub fn set_number_to_mask<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.number_to_mask = v.into();
        self
    }

    /// Sets the value of [reverse_order][crate::model::CharacterMaskConfig::reverse_order].
    pub fn set_reverse_order<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reverse_order = v.into();
        self
    }

    /// Sets the value of [characters_to_ignore][crate::model::CharacterMaskConfig::characters_to_ignore].
    pub fn set_characters_to_ignore<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CharsToIgnore>,
    {
        use std::iter::Iterator;
        self.characters_to_ignore = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CharacterMaskConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CharacterMaskConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CharacterMaskConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __masking_character,
            __number_to_mask,
            __reverse_order,
            __characters_to_ignore,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CharacterMaskConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maskingCharacter" => Ok(__FieldTag::__masking_character),
                            "masking_character" => Ok(__FieldTag::__masking_character),
                            "numberToMask" => Ok(__FieldTag::__number_to_mask),
                            "number_to_mask" => Ok(__FieldTag::__number_to_mask),
                            "reverseOrder" => Ok(__FieldTag::__reverse_order),
                            "reverse_order" => Ok(__FieldTag::__reverse_order),
                            "charactersToIgnore" => Ok(__FieldTag::__characters_to_ignore),
                            "characters_to_ignore" => Ok(__FieldTag::__characters_to_ignore),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CharacterMaskConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CharacterMaskConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__masking_character => {
                            if !fields.insert(__FieldTag::__masking_character) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for masking_character",
                                ));
                            }
                            result.masking_character = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__number_to_mask => {
                            if !fields.insert(__FieldTag::__number_to_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for number_to_mask",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.number_to_mask =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__reverse_order => {
                            if !fields.insert(__FieldTag::__reverse_order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reverse_order",
                                ));
                            }
                            result.reverse_order = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__characters_to_ignore => {
                            if !fields.insert(__FieldTag::__characters_to_ignore) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for characters_to_ignore",
                                ));
                            }
                            result.characters_to_ignore = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CharsToIgnore>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CharacterMaskConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.masking_character.is_empty() {
            state.serialize_entry("maskingCharacter", &self.masking_character)?;
        }
        if !wkt::internal::is_default(&self.number_to_mask) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numberToMask", &__With(&self.number_to_mask))?;
        }
        if !wkt::internal::is_default(&self.reverse_order) {
            state.serialize_entry("reverseOrder", &self.reverse_order)?;
        }
        if !self.characters_to_ignore.is_empty() {
            state.serialize_entry("charactersToIgnore", &self.characters_to_ignore)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Buckets values based on fixed size ranges. The
/// Bucketing transformation can provide all of this functionality,
/// but requires more configuration. This message is provided as a convenience to
/// the user for simple bucketing strategies.
///
/// The transformed value will be a hyphenated string of
/// {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound
/// = 20, all values that are within this bucket will be replaced with "10-20".
///
/// This can be used on data of type: double, long.
///
/// If the bound Value type differs from the type of data
/// being transformed, we will first attempt converting the type of the data to
/// be transformed to match the type of the bound before comparing.
///
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-bucketing> to
/// learn more.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FixedSizeBucketingConfig {
    /// Required. Lower bound value of buckets. All values less than `lower_bound`
    /// are grouped together into a single bucket; for example if `lower_bound` =
    /// 10, then all values less than 10 are replaced with the value "-10".
    pub lower_bound: std::option::Option<crate::model::Value>,

    /// Required. Upper bound value of buckets. All values greater than upper_bound
    /// are grouped together into a single bucket; for example if `upper_bound` =
    /// 89, then all values greater than 89 are replaced with the value "89+".
    pub upper_bound: std::option::Option<crate::model::Value>,

    /// Required. Size of each bucket (except for minimum and maximum buckets). So
    /// if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the
    /// following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60,
    /// 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
    pub bucket_size: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FixedSizeBucketingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lower_bound][crate::model::FixedSizeBucketingConfig::lower_bound].
    pub fn set_lower_bound<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Value>,
    {
        self.lower_bound = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lower_bound][crate::model::FixedSizeBucketingConfig::lower_bound].
    pub fn set_or_clear_lower_bound<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Value>,
    {
        self.lower_bound = v.map(|x| x.into());
        self
    }

    /// Sets the value of [upper_bound][crate::model::FixedSizeBucketingConfig::upper_bound].
    pub fn set_upper_bound<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Value>,
    {
        self.upper_bound = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upper_bound][crate::model::FixedSizeBucketingConfig::upper_bound].
    pub fn set_or_clear_upper_bound<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Value>,
    {
        self.upper_bound = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bucket_size][crate::model::FixedSizeBucketingConfig::bucket_size].
    pub fn set_bucket_size<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.bucket_size = v.into();
        self
    }
}

impl wkt::message::Message for FixedSizeBucketingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FixedSizeBucketingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FixedSizeBucketingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __lower_bound,
            __upper_bound,
            __bucket_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FixedSizeBucketingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lowerBound" => Ok(__FieldTag::__lower_bound),
                            "lower_bound" => Ok(__FieldTag::__lower_bound),
                            "upperBound" => Ok(__FieldTag::__upper_bound),
                            "upper_bound" => Ok(__FieldTag::__upper_bound),
                            "bucketSize" => Ok(__FieldTag::__bucket_size),
                            "bucket_size" => Ok(__FieldTag::__bucket_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FixedSizeBucketingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FixedSizeBucketingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__lower_bound => {
                            if !fields.insert(__FieldTag::__lower_bound) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lower_bound",
                                ));
                            }
                            result.lower_bound =
                                map.next_value::<std::option::Option<crate::model::Value>>()?;
                        }
                        __FieldTag::__upper_bound => {
                            if !fields.insert(__FieldTag::__upper_bound) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upper_bound",
                                ));
                            }
                            result.upper_bound =
                                map.next_value::<std::option::Option<crate::model::Value>>()?;
                        }
                        __FieldTag::__bucket_size => {
                            if !fields.insert(__FieldTag::__bucket_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_size",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bucket_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FixedSizeBucketingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.lower_bound.is_some() {
            state.serialize_entry("lowerBound", &self.lower_bound)?;
        }
        if self.upper_bound.is_some() {
            state.serialize_entry("upperBound", &self.upper_bound)?;
        }
        if !wkt::internal::is_default(&self.bucket_size) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("bucketSize", &__With(&self.bucket_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Generalization function that buckets values based on ranges. The ranges and
/// replacement values are dynamically provided by the user for custom behavior,
/// such as 1-30 -> LOW, 31-65 -> MEDIUM, 66-100 -> HIGH.
///
/// This can be used on data of type: number, long, string, timestamp.
///
/// If the bound `Value` type differs from the type of data being transformed, we
/// will first attempt converting the type of the data to be transformed to match
/// the type of the bound before comparing.
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-bucketing> to
/// learn more.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    pub buckets: std::vec::Vec<crate::model::bucketing_config::Bucket>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BucketingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [buckets][crate::model::BucketingConfig::buckets].
    pub fn set_buckets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::bucketing_config::Bucket>,
    {
        use std::iter::Iterator;
        self.buckets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BucketingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BucketingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BucketingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __buckets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BucketingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buckets" => Ok(__FieldTag::__buckets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BucketingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BucketingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__buckets => {
                            if !fields.insert(__FieldTag::__buckets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for buckets",
                                ));
                            }
                            result.buckets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::bucketing_config::Bucket>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BucketingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.buckets.is_empty() {
            state.serialize_entry("buckets", &self.buckets)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BucketingConfig].
pub mod bucketing_config {
    #[allow(unused_imports)]
    use super::*;

    /// Bucket is represented as a range, along with replacement values.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Bucket {
        /// Lower bound of the range, inclusive. Type should be the same as max if
        /// used.
        pub min: std::option::Option<crate::model::Value>,

        /// Upper bound of the range, exclusive; type must match min.
        pub max: std::option::Option<crate::model::Value>,

        /// Required. Replacement value for this bucket.
        pub replacement_value: std::option::Option<crate::model::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Bucket {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min][crate::model::bucketing_config::Bucket::min].
        pub fn set_min<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.min = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min][crate::model::bucketing_config::Bucket::min].
        pub fn set_or_clear_min<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.min = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max][crate::model::bucketing_config::Bucket::max].
        pub fn set_max<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.max = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max][crate::model::bucketing_config::Bucket::max].
        pub fn set_or_clear_max<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.max = v.map(|x| x.into());
            self
        }

        /// Sets the value of [replacement_value][crate::model::bucketing_config::Bucket::replacement_value].
        pub fn set_replacement_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.replacement_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [replacement_value][crate::model::bucketing_config::Bucket::replacement_value].
        pub fn set_or_clear_replacement_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.replacement_value = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Bucket {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.BucketingConfig.Bucket"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Bucket {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __min,
                __max,
                __replacement_value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Bucket")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "min" => Ok(__FieldTag::__min),
                                "max" => Ok(__FieldTag::__max),
                                "replacementValue" => Ok(__FieldTag::__replacement_value),
                                "replacement_value" => Ok(__FieldTag::__replacement_value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Bucket;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Bucket")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__min => {
                                if !fields.insert(__FieldTag::__min) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min",
                                    ));
                                }
                                result.min =
                                    map.next_value::<std::option::Option<crate::model::Value>>()?;
                            }
                            __FieldTag::__max => {
                                if !fields.insert(__FieldTag::__max) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max",
                                    ));
                                }
                                result.max =
                                    map.next_value::<std::option::Option<crate::model::Value>>()?;
                            }
                            __FieldTag::__replacement_value => {
                                if !fields.insert(__FieldTag::__replacement_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for replacement_value",
                                    ));
                                }
                                result.replacement_value =
                                    map.next_value::<std::option::Option<crate::model::Value>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Bucket {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.min.is_some() {
                state.serialize_entry("min", &self.min)?;
            }
            if self.max.is_some() {
                state.serialize_entry("max", &self.max)?;
            }
            if self.replacement_value.is_some() {
                state.serialize_entry("replacementValue", &self.replacement_value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption
/// (FPE) with the FFX mode of operation; however when used in the
/// `ReidentifyContent` API method, it serves the opposite function by reversing
/// the surrogate back into the original identifier. The identifier must be
/// encoded as ASCII. For a given crypto key and context, the same identifier
/// will be replaced with the same surrogate. Identifiers must be at least two
/// characters long. In the case that the identifier is the empty string, it will
/// be skipped. See
/// <https://cloud.google.com/sensitive-data-protection/docs/pseudonymization> to
/// learn more.
///
/// Note: We recommend using  CryptoDeterministicConfig for all use cases which
/// do not require preserving the input alphabet space and size, plus warrant
/// referential integrity. FPE incurs significant latency costs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CryptoReplaceFfxFpeConfig {
    /// Required. The key used by the encryption algorithm.
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    /// The 'tweak', a context may be used for higher security since the same
    /// identifier in two different contexts won't be given the same surrogate. If
    /// the context is not set, a default tweak will be used.
    ///
    /// If the context is set but:
    ///
    /// 1. there is no record present when transforming a given value or
    /// 1. the field is not present when transforming a given value,
    ///
    /// a default tweak will be used.
    ///
    /// Note that case (1) is expected when an `InfoTypeTransformation` is
    /// applied to both structured and unstructured `ContentItem`s.
    /// Currently, the referenced field may be of value type integer or string.
    ///
    /// The tweak is constructed as a sequence of bytes in big endian byte order
    /// such that:
    ///
    /// - a 64 bit integer is encoded followed by a single byte of value 1
    /// - a string is encoded in UTF-8 format followed by a single byte of value 2
    pub context: std::option::Option<crate::model::FieldId>,

    /// The custom infoType to annotate the surrogate with.
    /// This annotation will be applied to the surrogate by prefixing it with
    /// the name of the custom infoType followed by the number of
    /// characters comprising the surrogate. The following scheme defines the
    /// format: info_type_name(surrogate_character_count):surrogate
    ///
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and
    /// the surrogate is 'abc', the full replacement value
    /// will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    ///
    /// This annotation identifies the surrogate when inspecting content using the
    /// custom infoType
    /// [`SurrogateType`](https://cloud.google.com/sensitive-data-protection/docs/reference/rest/v2/InspectConfig#surrogatetype).
    /// This facilitates reversal of the surrogate when it occurs in free text.
    ///
    /// In order for inspection to work properly, the name of this infoType must
    /// not occur naturally anywhere in your data; otherwise, inspection may
    /// find a surrogate that does not correspond to an actual identifier.
    /// Therefore, choose your custom infoType name carefully after considering
    /// what your data looks like. One way to select a name that has a high chance
    /// of yielding reliable detection is to include one or more unicode characters
    /// that are highly improbable to exist in your data.
    /// For example, assuming your data is entered from a regular ASCII keyboard,
    /// the symbol with the hex code point 29DD might be used like so:
    /// ⧝MY_TOKEN_TYPE
    pub surrogate_info_type: std::option::Option<crate::model::InfoType>,

    /// Choose an alphabet which the data being transformed will be made up of.
    pub alphabet: std::option::Option<crate::model::crypto_replace_ffx_fpe_config::Alphabet>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoReplaceFfxFpeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key][crate::model::CryptoReplaceFfxFpeConfig::crypto_key].
    pub fn set_crypto_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKey>,
    {
        self.crypto_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crypto_key][crate::model::CryptoReplaceFfxFpeConfig::crypto_key].
    pub fn set_or_clear_crypto_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKey>,
    {
        self.crypto_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [context][crate::model::CryptoReplaceFfxFpeConfig::context].
    pub fn set_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [context][crate::model::CryptoReplaceFfxFpeConfig::context].
    pub fn set_or_clear_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [surrogate_info_type][crate::model::CryptoReplaceFfxFpeConfig::surrogate_info_type].
    pub fn set_surrogate_info_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.surrogate_info_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [surrogate_info_type][crate::model::CryptoReplaceFfxFpeConfig::surrogate_info_type].
    pub fn set_or_clear_surrogate_info_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.surrogate_info_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet].
    ///
    /// Note that all the setters affecting `alphabet` are mutually
    /// exclusive.
    pub fn set_alphabet<
        T: std::convert::Into<
                std::option::Option<crate::model::crypto_replace_ffx_fpe_config::Alphabet>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alphabet = v.into();
        self
    }

    /// The value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// if it holds a `CommonAlphabet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn common_alphabet(
        &self,
    ) -> std::option::Option<&crate::model::crypto_replace_ffx_fpe_config::FfxCommonNativeAlphabet>
    {
        #[allow(unreachable_patterns)]
        self.alphabet.as_ref().and_then(|v| match v {
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CommonAlphabet(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// to hold a `CommonAlphabet`.
    ///
    /// Note that all the setters affecting `alphabet` are
    /// mutually exclusive.
    pub fn set_common_alphabet<
        T: std::convert::Into<crate::model::crypto_replace_ffx_fpe_config::FfxCommonNativeAlphabet>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alphabet = std::option::Option::Some(
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CommonAlphabet(v.into()),
        );
        self
    }

    /// The value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// if it holds a `CustomAlphabet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_alphabet(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.alphabet.as_ref().and_then(|v| match v {
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CustomAlphabet(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// to hold a `CustomAlphabet`.
    ///
    /// Note that all the setters affecting `alphabet` are
    /// mutually exclusive.
    pub fn set_custom_alphabet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.alphabet = std::option::Option::Some(
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CustomAlphabet(v.into()),
        );
        self
    }

    /// The value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// if it holds a `Radix`, `None` if the field is not set or
    /// holds a different branch.
    pub fn radix(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.alphabet.as_ref().and_then(|v| match v {
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::Radix(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// to hold a `Radix`.
    ///
    /// Note that all the setters affecting `alphabet` are
    /// mutually exclusive.
    pub fn set_radix<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.alphabet = std::option::Option::Some(
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::Radix(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CryptoReplaceFfxFpeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoReplaceFfxFpeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CryptoReplaceFfxFpeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __crypto_key,
            __context,
            __common_alphabet,
            __custom_alphabet,
            __radix,
            __surrogate_info_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CryptoReplaceFfxFpeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cryptoKey" => Ok(__FieldTag::__crypto_key),
                            "crypto_key" => Ok(__FieldTag::__crypto_key),
                            "context" => Ok(__FieldTag::__context),
                            "commonAlphabet" => Ok(__FieldTag::__common_alphabet),
                            "common_alphabet" => Ok(__FieldTag::__common_alphabet),
                            "customAlphabet" => Ok(__FieldTag::__custom_alphabet),
                            "custom_alphabet" => Ok(__FieldTag::__custom_alphabet),
                            "radix" => Ok(__FieldTag::__radix),
                            "surrogateInfoType" => Ok(__FieldTag::__surrogate_info_type),
                            "surrogate_info_type" => Ok(__FieldTag::__surrogate_info_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CryptoReplaceFfxFpeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CryptoReplaceFfxFpeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__crypto_key => {
                            if !fields.insert(__FieldTag::__crypto_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key",
                                ));
                            }
                            result.crypto_key =
                                map.next_value::<std::option::Option<crate::model::CryptoKey>>()?;
                        }
                        __FieldTag::__context => {
                            if !fields.insert(__FieldTag::__context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context",
                                ));
                            }
                            result.context =
                                map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                        }
                        __FieldTag::__common_alphabet => {
                            if !fields.insert(__FieldTag::__common_alphabet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_alphabet",
                                ));
                            }
                            if result.alphabet.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `alphabet`, a oneof with full ID .google.privacy.dlp.v2.CryptoReplaceFfxFpeConfig.common_alphabet, latest field was commonAlphabet",
                                ));
                            }
                            result.alphabet = std::option::Option::Some(
                                crate::model::crypto_replace_ffx_fpe_config::Alphabet::CommonAlphabet(
                                    map.next_value::<std::option::Option<crate::model::crypto_replace_ffx_fpe_config::FfxCommonNativeAlphabet>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__custom_alphabet => {
                            if !fields.insert(__FieldTag::__custom_alphabet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_alphabet",
                                ));
                            }
                            if result.alphabet.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `alphabet`, a oneof with full ID .google.privacy.dlp.v2.CryptoReplaceFfxFpeConfig.custom_alphabet, latest field was customAlphabet",
                                ));
                            }
                            result.alphabet = std::option::Option::Some(
                                crate::model::crypto_replace_ffx_fpe_config::Alphabet::CustomAlphabet(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__radix => {
                            if !fields.insert(__FieldTag::__radix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for radix",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.alphabet.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `alphabet`, a oneof with full ID .google.privacy.dlp.v2.CryptoReplaceFfxFpeConfig.radix, latest field was radix",
                                ));
                            }
                            result.alphabet = std::option::Option::Some(
                                crate::model::crypto_replace_ffx_fpe_config::Alphabet::Radix(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__surrogate_info_type => {
                            if !fields.insert(__FieldTag::__surrogate_info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for surrogate_info_type",
                                ));
                            }
                            result.surrogate_info_type =
                                map.next_value::<std::option::Option<crate::model::InfoType>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CryptoReplaceFfxFpeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.crypto_key.is_some() {
            state.serialize_entry("cryptoKey", &self.crypto_key)?;
        }
        if self.context.is_some() {
            state.serialize_entry("context", &self.context)?;
        }
        if let Some(value) = self.common_alphabet() {
            state.serialize_entry("commonAlphabet", value)?;
        }
        if let Some(value) = self.custom_alphabet() {
            state.serialize_entry("customAlphabet", value)?;
        }
        if let Some(value) = self.radix() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("radix", &__With(value))?;
        }
        if self.surrogate_info_type.is_some() {
            state.serialize_entry("surrogateInfoType", &self.surrogate_info_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CryptoReplaceFfxFpeConfig].
pub mod crypto_replace_ffx_fpe_config {
    #[allow(unused_imports)]
    use super::*;

    /// These are commonly used subsets of the alphabet that the FFX mode
    /// natively supports. In the algorithm, the alphabet is selected using
    /// the "radix". Therefore each corresponds to a particular radix.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FfxCommonNativeAlphabet {
        /// Unused.
        Unspecified,
        /// `[0-9]` (radix of 10)
        Numeric,
        /// `[0-9A-F]` (radix of 16)
        Hexadecimal,
        /// `[0-9A-Z]` (radix of 36)
        UpperCaseAlphaNumeric,
        /// `[0-9A-Za-z]` (radix of 62)
        AlphaNumeric,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FfxCommonNativeAlphabet::value] or
        /// [FfxCommonNativeAlphabet::name].
        UnknownValue(ffx_common_native_alphabet::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ffx_common_native_alphabet {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FfxCommonNativeAlphabet {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Numeric => std::option::Option::Some(1),
                Self::Hexadecimal => std::option::Option::Some(2),
                Self::UpperCaseAlphaNumeric => std::option::Option::Some(3),
                Self::AlphaNumeric => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED")
                }
                Self::Numeric => std::option::Option::Some("NUMERIC"),
                Self::Hexadecimal => std::option::Option::Some("HEXADECIMAL"),
                Self::UpperCaseAlphaNumeric => {
                    std::option::Option::Some("UPPER_CASE_ALPHA_NUMERIC")
                }
                Self::AlphaNumeric => std::option::Option::Some("ALPHA_NUMERIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FfxCommonNativeAlphabet {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FfxCommonNativeAlphabet {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FfxCommonNativeAlphabet {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Numeric,
                2 => Self::Hexadecimal,
                3 => Self::UpperCaseAlphaNumeric,
                4 => Self::AlphaNumeric,
                _ => Self::UnknownValue(ffx_common_native_alphabet::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FfxCommonNativeAlphabet {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED" => Self::Unspecified,
                "NUMERIC" => Self::Numeric,
                "HEXADECIMAL" => Self::Hexadecimal,
                "UPPER_CASE_ALPHA_NUMERIC" => Self::UpperCaseAlphaNumeric,
                "ALPHA_NUMERIC" => Self::AlphaNumeric,
                _ => Self::UnknownValue(ffx_common_native_alphabet::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FfxCommonNativeAlphabet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Numeric => serializer.serialize_i32(1),
                Self::Hexadecimal => serializer.serialize_i32(2),
                Self::UpperCaseAlphaNumeric => serializer.serialize_i32(3),
                Self::AlphaNumeric => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FfxCommonNativeAlphabet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<FfxCommonNativeAlphabet>::new(
                    ".google.privacy.dlp.v2.CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet",
                ),
            )
        }
    }

    /// Choose an alphabet which the data being transformed will be made up of.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Alphabet {
        /// Common alphabets.
        CommonAlphabet(crate::model::crypto_replace_ffx_fpe_config::FfxCommonNativeAlphabet),
        /// This is supported by mapping these to the alphanumeric characters
        /// that the FFX mode natively supports. This happens before/after
        /// encryption/decryption.
        /// Each character listed must appear only once.
        /// Number of characters must be in the range [2, 95].
        /// This must be encoded as ASCII.
        /// The order of characters does not matter.
        /// The full list of allowed characters is:
        /// ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz~`!@#$%^&*()_-+={[}]|\:;"'<,>.?/``
        CustomAlphabet(std::string::String),
        /// The native way to select the alphabet. Must be in the range [2, 95].
        Radix(i32),
    }
}

/// This is a data encryption key (DEK) (as opposed to
/// a key encryption key (KEK) stored by Cloud Key Management Service
/// (Cloud KMS).
/// When using Cloud KMS to wrap or unwrap a DEK, be sure to set an appropriate
/// IAM policy on the KEK to ensure an attacker cannot
/// unwrap the DEK.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CryptoKey {
    /// Sources of crypto keys.
    pub source: std::option::Option<crate::model::crypto_key::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::CryptoKey::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::crypto_key::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::CryptoKey::source]
    /// if it holds a `Transient`, `None` if the field is not set or
    /// holds a different branch.
    pub fn transient(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TransientCryptoKey>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::crypto_key::Source::Transient(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::CryptoKey::source]
    /// to hold a `Transient`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_transient<
        T: std::convert::Into<std::boxed::Box<crate::model::TransientCryptoKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::crypto_key::Source::Transient(v.into()));
        self
    }

    /// The value of [source][crate::model::CryptoKey::source]
    /// if it holds a `Unwrapped`, `None` if the field is not set or
    /// holds a different branch.
    pub fn unwrapped(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UnwrappedCryptoKey>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::crypto_key::Source::Unwrapped(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::CryptoKey::source]
    /// to hold a `Unwrapped`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_unwrapped<
        T: std::convert::Into<std::boxed::Box<crate::model::UnwrappedCryptoKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::crypto_key::Source::Unwrapped(v.into()));
        self
    }

    /// The value of [source][crate::model::CryptoKey::source]
    /// if it holds a `KmsWrapped`, `None` if the field is not set or
    /// holds a different branch.
    pub fn kms_wrapped(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::KmsWrappedCryptoKey>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::crypto_key::Source::KmsWrapped(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::CryptoKey::source]
    /// to hold a `KmsWrapped`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_kms_wrapped<
        T: std::convert::Into<std::boxed::Box<crate::model::KmsWrappedCryptoKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::crypto_key::Source::KmsWrapped(v.into()));
        self
    }
}

impl wkt::message::Message for CryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CryptoKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transient,
            __unwrapped,
            __kms_wrapped,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CryptoKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transient" => Ok(__FieldTag::__transient),
                            "unwrapped" => Ok(__FieldTag::__unwrapped),
                            "kmsWrapped" => Ok(__FieldTag::__kms_wrapped),
                            "kms_wrapped" => Ok(__FieldTag::__kms_wrapped),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CryptoKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CryptoKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transient => {
                            if !fields.insert(__FieldTag::__transient) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transient",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.privacy.dlp.v2.CryptoKey.transient, latest field was transient",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::crypto_key::Source::Transient(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TransientCryptoKey>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__unwrapped => {
                            if !fields.insert(__FieldTag::__unwrapped) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unwrapped",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.privacy.dlp.v2.CryptoKey.unwrapped, latest field was unwrapped",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::crypto_key::Source::Unwrapped(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UnwrappedCryptoKey>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__kms_wrapped => {
                            if !fields.insert(__FieldTag::__kms_wrapped) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_wrapped",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.privacy.dlp.v2.CryptoKey.kms_wrapped, latest field was kmsWrapped",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::crypto_key::Source::KmsWrapped(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::KmsWrappedCryptoKey>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CryptoKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.transient() {
            state.serialize_entry("transient", value)?;
        }
        if let Some(value) = self.unwrapped() {
            state.serialize_entry("unwrapped", value)?;
        }
        if let Some(value) = self.kms_wrapped() {
            state.serialize_entry("kmsWrapped", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CryptoKey].
pub mod crypto_key {
    #[allow(unused_imports)]
    use super::*;

    /// Sources of crypto keys.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Transient crypto key
        Transient(std::boxed::Box<crate::model::TransientCryptoKey>),
        /// Unwrapped crypto key
        Unwrapped(std::boxed::Box<crate::model::UnwrappedCryptoKey>),
        /// Key wrapped using Cloud KMS
        KmsWrapped(std::boxed::Box<crate::model::KmsWrappedCryptoKey>),
    }
}

/// Use this to have a random data crypto key generated.
/// It will be discarded after the request finishes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransientCryptoKey {
    /// Required. Name of the key.
    /// This is an arbitrary string used to differentiate different keys.
    /// A unique key is generated per name: two separate `TransientCryptoKey`
    /// protos share the same generated key if their names are the same.
    /// When the data crypto key is generated, this name is not used in any way
    /// (repeating the api call will result in a different key being generated).
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransientCryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransientCryptoKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for TransientCryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransientCryptoKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransientCryptoKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransientCryptoKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransientCryptoKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransientCryptoKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransientCryptoKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Using raw keys is prone to security risks due to accidentally
/// leaking the key. Choose another type of key if possible.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UnwrappedCryptoKey {
    /// Required. A 128/192/256 bit key.
    pub key: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnwrappedCryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::UnwrappedCryptoKey::key].
    pub fn set_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for UnwrappedCryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UnwrappedCryptoKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UnwrappedCryptoKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UnwrappedCryptoKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UnwrappedCryptoKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UnwrappedCryptoKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UnwrappedCryptoKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("key", &__With(&self.key))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Include to use an existing data crypto key wrapped by KMS.
/// The wrapped key must be a 128-, 192-, or 256-bit key.
/// Authorization requires the following IAM permissions when sending a request
/// to perform a crypto transformation using a KMS-wrapped crypto key:
/// dlp.kms.encrypt
///
/// For more information, see [Creating a wrapped key]
/// (<https://cloud.google.com/sensitive-data-protection/docs/create-wrapped-key>).
///
/// Note: When you use Cloud KMS for cryptographic operations,
/// [charges apply](https://cloud.google.com/kms/pricing).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KmsWrappedCryptoKey {
    /// Required. The wrapped data crypto key.
    pub wrapped_key: ::bytes::Bytes,

    /// Required. The resource name of the KMS CryptoKey to use for unwrapping.
    pub crypto_key_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KmsWrappedCryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [wrapped_key][crate::model::KmsWrappedCryptoKey::wrapped_key].
    pub fn set_wrapped_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.wrapped_key = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::KmsWrappedCryptoKey::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }
}

impl wkt::message::Message for KmsWrappedCryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.KmsWrappedCryptoKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KmsWrappedCryptoKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __wrapped_key,
            __crypto_key_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KmsWrappedCryptoKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "wrappedKey" => Ok(__FieldTag::__wrapped_key),
                            "wrapped_key" => Ok(__FieldTag::__wrapped_key),
                            "cryptoKeyName" => Ok(__FieldTag::__crypto_key_name),
                            "crypto_key_name" => Ok(__FieldTag::__crypto_key_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KmsWrappedCryptoKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KmsWrappedCryptoKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__wrapped_key => {
                            if !fields.insert(__FieldTag::__wrapped_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wrapped_key",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.wrapped_key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__crypto_key_name => {
                            if !fields.insert(__FieldTag::__crypto_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_name",
                                ));
                            }
                            result.crypto_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KmsWrappedCryptoKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.wrapped_key.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("wrappedKey", &__With(&self.wrapped_key))?;
        }
        if !self.crypto_key_name.is_empty() {
            state.serialize_entry("cryptoKeyName", &self.crypto_key_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Shifts dates by random number of days, with option to be consistent for the
/// same context. See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-date-shifting>
/// to learn more.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DateShiftConfig {
    /// Required. Range of shift in days. Actual shift will be selected at random
    /// within this range (inclusive ends). Negative means shift to earlier in
    /// time. Must not be more than 365250 days (1000 years) each direction.
    ///
    /// For example, 3 means shift date to at most 3 days into the future.
    pub upper_bound_days: i32,

    /// Required. For example, -5 means shift date to at most 5 days back in the
    /// past.
    pub lower_bound_days: i32,

    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the
    /// given context.
    pub context: std::option::Option<crate::model::FieldId>,

    /// Method for calculating shift that takes context into consideration. If
    /// set, must also set context. Can only be applied to table items.
    pub method: std::option::Option<crate::model::date_shift_config::Method>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DateShiftConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upper_bound_days][crate::model::DateShiftConfig::upper_bound_days].
    pub fn set_upper_bound_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.upper_bound_days = v.into();
        self
    }

    /// Sets the value of [lower_bound_days][crate::model::DateShiftConfig::lower_bound_days].
    pub fn set_lower_bound_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.lower_bound_days = v.into();
        self
    }

    /// Sets the value of [context][crate::model::DateShiftConfig::context].
    pub fn set_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [context][crate::model::DateShiftConfig::context].
    pub fn set_or_clear_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [method][crate::model::DateShiftConfig::method].
    ///
    /// Note that all the setters affecting `method` are mutually
    /// exclusive.
    pub fn set_method<
        T: std::convert::Into<std::option::Option<crate::model::date_shift_config::Method>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }

    /// The value of [method][crate::model::DateShiftConfig::method]
    /// if it holds a `CryptoKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn crypto_key(&self) -> std::option::Option<&std::boxed::Box<crate::model::CryptoKey>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::date_shift_config::Method::CryptoKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::DateShiftConfig::method]
    /// to hold a `CryptoKey`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_crypto_key<T: std::convert::Into<std::boxed::Box<crate::model::CryptoKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.method =
            std::option::Option::Some(crate::model::date_shift_config::Method::CryptoKey(v.into()));
        self
    }
}

impl wkt::message::Message for DateShiftConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DateShiftConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DateShiftConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __upper_bound_days,
            __lower_bound_days,
            __context,
            __crypto_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DateShiftConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "upperBoundDays" => Ok(__FieldTag::__upper_bound_days),
                            "upper_bound_days" => Ok(__FieldTag::__upper_bound_days),
                            "lowerBoundDays" => Ok(__FieldTag::__lower_bound_days),
                            "lower_bound_days" => Ok(__FieldTag::__lower_bound_days),
                            "context" => Ok(__FieldTag::__context),
                            "cryptoKey" => Ok(__FieldTag::__crypto_key),
                            "crypto_key" => Ok(__FieldTag::__crypto_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DateShiftConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DateShiftConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__upper_bound_days => {
                            if !fields.insert(__FieldTag::__upper_bound_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upper_bound_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.upper_bound_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__lower_bound_days => {
                            if !fields.insert(__FieldTag::__lower_bound_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lower_bound_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.lower_bound_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__context => {
                            if !fields.insert(__FieldTag::__context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context",
                                ));
                            }
                            result.context =
                                map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                        }
                        __FieldTag::__crypto_key => {
                            if !fields.insert(__FieldTag::__crypto_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key",
                                ));
                            }
                            if result.method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `method`, a oneof with full ID .google.privacy.dlp.v2.DateShiftConfig.crypto_key, latest field was cryptoKey",
                                ));
                            }
                            result.method = std::option::Option::Some(
                                crate::model::date_shift_config::Method::CryptoKey(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CryptoKey>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DateShiftConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.upper_bound_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("upperBoundDays", &__With(&self.upper_bound_days))?;
        }
        if !wkt::internal::is_default(&self.lower_bound_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lowerBoundDays", &__With(&self.lower_bound_days))?;
        }
        if self.context.is_some() {
            state.serialize_entry("context", &self.context)?;
        }
        if let Some(value) = self.crypto_key() {
            state.serialize_entry("cryptoKey", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DateShiftConfig].
pub mod date_shift_config {
    #[allow(unused_imports)]
    use super::*;

    /// Method for calculating shift that takes context into consideration. If
    /// set, must also set context. Can only be applied to table items.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Method {
        /// Causes the shift to be computed based on this key and the context. This
        /// results in the same shift for the same context and crypto_key. If
        /// set, must also set context. Can only be applied to table items.
        CryptoKey(std::boxed::Box<crate::model::CryptoKey>),
    }
}

/// A type of transformation that will scan unstructured text and
/// apply various `PrimitiveTransformation`s to each finding, where the
/// transformation is applied to only values that were identified as a specific
/// info_type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InfoTypeTransformations {
    /// Required. Transformation for each infoType. Cannot specify more than one
    /// for a given infoType.
    pub transformations:
        std::vec::Vec<crate::model::info_type_transformations::InfoTypeTransformation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoTypeTransformations {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformations][crate::model::InfoTypeTransformations::transformations].
    pub fn set_transformations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::info_type_transformations::InfoTypeTransformation>,
    {
        use std::iter::Iterator;
        self.transformations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InfoTypeTransformations {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeTransformations"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InfoTypeTransformations {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transformations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InfoTypeTransformations")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transformations" => Ok(__FieldTag::__transformations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InfoTypeTransformations;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InfoTypeTransformations")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transformations => {
                            if !fields.insert(__FieldTag::__transformations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformations",
                                ));
                            }
                            result.transformations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::info_type_transformations::InfoTypeTransformation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InfoTypeTransformations {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transformations.is_empty() {
            state.serialize_entry("transformations", &self.transformations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InfoTypeTransformations].
pub mod info_type_transformations {
    #[allow(unused_imports)]
    use super::*;

    /// A transformation to apply to text that is identified as a specific
    /// info_type.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InfoTypeTransformation {
        /// InfoTypes to apply the transformation to. An empty list will cause
        /// this transformation to apply to all findings that correspond to
        /// infoTypes that were requested in `InspectConfig`.
        pub info_types: std::vec::Vec<crate::model::InfoType>,

        /// Required. Primitive transformation to apply to the infoType.
        pub primitive_transformation: std::option::Option<crate::model::PrimitiveTransformation>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InfoTypeTransformation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [info_types][crate::model::info_type_transformations::InfoTypeTransformation::info_types].
        pub fn set_info_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::InfoType>,
        {
            use std::iter::Iterator;
            self.info_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [primitive_transformation][crate::model::info_type_transformations::InfoTypeTransformation::primitive_transformation].
        pub fn set_primitive_transformation<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::PrimitiveTransformation>,
        {
            self.primitive_transformation = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [primitive_transformation][crate::model::info_type_transformations::InfoTypeTransformation::primitive_transformation].
        pub fn set_or_clear_primitive_transformation<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::PrimitiveTransformation>,
        {
            self.primitive_transformation = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for InfoTypeTransformation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InfoTypeTransformations.InfoTypeTransformation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InfoTypeTransformation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __info_types,
                __primitive_transformation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InfoTypeTransformation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "infoTypes" => Ok(__FieldTag::__info_types),
                                "info_types" => Ok(__FieldTag::__info_types),
                                "primitiveTransformation" => {
                                    Ok(__FieldTag::__primitive_transformation)
                                }
                                "primitive_transformation" => {
                                    Ok(__FieldTag::__primitive_transformation)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InfoTypeTransformation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InfoTypeTransformation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__info_types => {
                                if !fields.insert(__FieldTag::__info_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for info_types",
                                    ));
                                }
                                result.info_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InfoType>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__primitive_transformation => {
                                if !fields.insert(__FieldTag::__primitive_transformation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for primitive_transformation",
                                    ));
                                }
                                result.primitive_transformation = map.next_value::<std::option::Option<crate::model::PrimitiveTransformation>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InfoTypeTransformation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.info_types.is_empty() {
                state.serialize_entry("infoTypes", &self.info_types)?;
            }
            if self.primitive_transformation.is_some() {
                state.serialize_entry("primitiveTransformation", &self.primitive_transformation)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The transformation to apply to the field.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FieldTransformation {
    /// Required. Input field(s) to apply the transformation to.
    /// When you have columns that reference their position within a list,
    /// omit the index from the FieldId. FieldId name matching ignores the index.
    /// For example, instead of "contact.nums[0].type", use "contact.nums.type".
    pub fields: std::vec::Vec<crate::model::FieldId>,

    /// Only apply the transformation if the condition evaluates to true for the
    /// given `RecordCondition`. The conditions are allowed to reference fields
    /// that are not used in the actual transformation.
    ///
    /// Example Use Cases:
    ///
    /// - Apply a different bucket transformation to an age column if the zip code
    ///   column for the same record is within a specific range.
    /// - Redact a field if the date of birth field is greater than 85.
    pub condition: std::option::Option<crate::model::RecordCondition>,

    /// Transformation to apply. [required]
    pub transformation: std::option::Option<crate::model::field_transformation::Transformation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FieldTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fields][crate::model::FieldTransformation::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [condition][crate::model::FieldTransformation::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecordCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::FieldTransformation::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecordCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transformation][crate::model::FieldTransformation::transformation].
    ///
    /// Note that all the setters affecting `transformation` are mutually
    /// exclusive.
    pub fn set_transformation<
        T: std::convert::Into<std::option::Option<crate::model::field_transformation::Transformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = v.into();
        self
    }

    /// The value of [transformation][crate::model::FieldTransformation::transformation]
    /// if it holds a `PrimitiveTransformation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn primitive_transformation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrimitiveTransformation>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::field_transformation::Transformation::PrimitiveTransformation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::FieldTransformation::transformation]
    /// to hold a `PrimitiveTransformation`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_primitive_transformation<
        T: std::convert::Into<std::boxed::Box<crate::model::PrimitiveTransformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::field_transformation::Transformation::PrimitiveTransformation(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::FieldTransformation::transformation]
    /// if it holds a `InfoTypeTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn info_type_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InfoTypeTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::field_transformation::Transformation::InfoTypeTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::FieldTransformation::transformation]
    /// to hold a `InfoTypeTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_info_type_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::InfoTypeTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::field_transformation::Transformation::InfoTypeTransformations(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FieldTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FieldTransformation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FieldTransformation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fields,
            __condition,
            __primitive_transformation,
            __info_type_transformations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FieldTransformation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fields" => Ok(__FieldTag::__fields),
                            "condition" => Ok(__FieldTag::__condition),
                            "primitiveTransformation" => Ok(__FieldTag::__primitive_transformation),
                            "primitive_transformation" => {
                                Ok(__FieldTag::__primitive_transformation)
                            }
                            "infoTypeTransformations" => {
                                Ok(__FieldTag::__info_type_transformations)
                            }
                            "info_type_transformations" => {
                                Ok(__FieldTag::__info_type_transformations)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FieldTransformation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FieldTransformation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FieldId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map
                                .next_value::<std::option::Option<crate::model::RecordCondition>>(
                                )?;
                        }
                        __FieldTag::__primitive_transformation => {
                            if !fields.insert(__FieldTag::__primitive_transformation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primitive_transformation",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.FieldTransformation.primitive_transformation, latest field was primitiveTransformation",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::field_transformation::Transformation::PrimitiveTransformation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PrimitiveTransformation>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__info_type_transformations => {
                            if !fields.insert(__FieldTag::__info_type_transformations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type_transformations",
                                ));
                            }
                            if result.transformation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transformation`, a oneof with full ID .google.privacy.dlp.v2.FieldTransformation.info_type_transformations, latest field was infoTypeTransformations",
                                ));
                            }
                            result.transformation = std::option::Option::Some(
                                crate::model::field_transformation::Transformation::InfoTypeTransformations(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InfoTypeTransformations>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FieldTransformation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if let Some(value) = self.primitive_transformation() {
            state.serialize_entry("primitiveTransformation", value)?;
        }
        if let Some(value) = self.info_type_transformations() {
            state.serialize_entry("infoTypeTransformations", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FieldTransformation].
pub mod field_transformation {
    #[allow(unused_imports)]
    use super::*;

    /// Transformation to apply. [required]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Transformation {
        /// Apply the transformation to the entire field.
        PrimitiveTransformation(std::boxed::Box<crate::model::PrimitiveTransformation>),
        /// Treat the contents of the field as free text, and selectively
        /// transform content that matches an `InfoType`.
        InfoTypeTransformations(std::boxed::Box<crate::model::InfoTypeTransformations>),
    }
}

/// A type of transformation that is applied over structured data such as a
/// table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecordTransformations {
    /// Transform the record by applying various field transformations.
    pub field_transformations: std::vec::Vec<crate::model::FieldTransformation>,

    /// Configuration defining which records get suppressed entirely. Records that
    /// match any suppression rule are omitted from the output.
    pub record_suppressions: std::vec::Vec<crate::model::RecordSuppression>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordTransformations {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field_transformations][crate::model::RecordTransformations::field_transformations].
    pub fn set_field_transformations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldTransformation>,
    {
        use std::iter::Iterator;
        self.field_transformations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [record_suppressions][crate::model::RecordTransformations::record_suppressions].
    pub fn set_record_suppressions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RecordSuppression>,
    {
        use std::iter::Iterator;
        self.record_suppressions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RecordTransformations {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordTransformations"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecordTransformations {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field_transformations,
            __record_suppressions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecordTransformations")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fieldTransformations" => Ok(__FieldTag::__field_transformations),
                            "field_transformations" => Ok(__FieldTag::__field_transformations),
                            "recordSuppressions" => Ok(__FieldTag::__record_suppressions),
                            "record_suppressions" => Ok(__FieldTag::__record_suppressions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecordTransformations;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecordTransformations")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field_transformations => {
                            if !fields.insert(__FieldTag::__field_transformations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_transformations",
                                ));
                            }
                            result.field_transformations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FieldTransformation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__record_suppressions => {
                            if !fields.insert(__FieldTag::__record_suppressions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for record_suppressions",
                                ));
                            }
                            result.record_suppressions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RecordSuppression>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecordTransformations {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field_transformations.is_empty() {
            state.serialize_entry("fieldTransformations", &self.field_transformations)?;
        }
        if !self.record_suppressions.is_empty() {
            state.serialize_entry("recordSuppressions", &self.record_suppressions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration to suppress records whose suppression conditions evaluate to
/// true.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecordSuppression {
    /// A condition that when it evaluates to true will result in the record being
    /// evaluated to be suppressed from the transformed content.
    pub condition: std::option::Option<crate::model::RecordCondition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordSuppression {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [condition][crate::model::RecordSuppression::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecordCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::RecordSuppression::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecordCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RecordSuppression {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordSuppression"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecordSuppression {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __condition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecordSuppression")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "condition" => Ok(__FieldTag::__condition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecordSuppression;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecordSuppression")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map
                                .next_value::<std::option::Option<crate::model::RecordCondition>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecordSuppression {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A condition for determining whether a transformation should be applied to
/// a field.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecordCondition {
    /// An expression.
    pub expressions: std::option::Option<crate::model::record_condition::Expressions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expressions][crate::model::RecordCondition::expressions].
    pub fn set_expressions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::record_condition::Expressions>,
    {
        self.expressions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expressions][crate::model::RecordCondition::expressions].
    pub fn set_or_clear_expressions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::record_condition::Expressions>,
    {
        self.expressions = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RecordCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordCondition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecordCondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __expressions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecordCondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "expressions" => Ok(__FieldTag::__expressions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecordCondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecordCondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__expressions => {
                            if !fields.insert(__FieldTag::__expressions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expressions",
                                ));
                            }
                            result.expressions =
                                map.next_value::<std::option::Option<
                                    crate::model::record_condition::Expressions,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecordCondition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.expressions.is_some() {
            state.serialize_entry("expressions", &self.expressions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RecordCondition].
pub mod record_condition {
    #[allow(unused_imports)]
    use super::*;

    /// The field type of `value` and `field` do not need to match to be
    /// considered equal, but not all comparisons are possible.
    /// EQUAL_TO and NOT_EQUAL_TO attempt to compare even with incompatible types,
    /// but all other comparisons are invalid with incompatible types.
    /// A `value` of type:
    ///
    /// - `string` can be compared against all other types
    /// - `boolean` can only be compared against other booleans
    /// - `integer` can be compared against doubles or a string if the string value
    ///   can be parsed as an integer.
    /// - `double` can be compared against integers or a string if the string can
    ///   be parsed as a double.
    /// - `Timestamp` can be compared against strings in RFC 3339 date string
    ///   format.
    /// - `TimeOfDay` can be compared against timestamps and strings in the format
    ///   of 'HH:mm:ss'.
    ///
    /// If we fail to compare do to type mismatch, a warning will be given and
    /// the condition will evaluate to false.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Condition {
        /// Required. Field within the record this condition is evaluated against.
        pub field: std::option::Option<crate::model::FieldId>,

        /// Required. Operator used to compare the field or infoType to the value.
        pub operator: crate::model::RelationalOperator,

        /// Value to compare against. [Mandatory, except for `EXISTS` tests.]
        pub value: std::option::Option<crate::model::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Condition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::record_condition::Condition::field].
        pub fn set_field<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.field = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [field][crate::model::record_condition::Condition::field].
        pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.field = v.map(|x| x.into());
            self
        }

        /// Sets the value of [operator][crate::model::record_condition::Condition::operator].
        pub fn set_operator<T: std::convert::Into<crate::model::RelationalOperator>>(
            mut self,
            v: T,
        ) -> Self {
            self.operator = v.into();
            self
        }

        /// Sets the value of [value][crate::model::record_condition::Condition::value].
        pub fn set_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [value][crate::model::record_condition::Condition::value].
        pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Value>,
        {
            self.value = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Condition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RecordCondition.Condition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Condition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __field,
                __operator,
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Condition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "field" => Ok(__FieldTag::__field),
                                "operator" => Ok(__FieldTag::__operator),
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Condition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Condition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__field => {
                                if !fields.insert(__FieldTag::__field) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field",
                                    ));
                                }
                                result.field =
                                    map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                            }
                            __FieldTag::__operator => {
                                if !fields.insert(__FieldTag::__operator) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for operator",
                                    ));
                                }
                                result.operator = map.next_value::<std::option::Option<crate::model::RelationalOperator>>()?.unwrap_or_default();
                            }
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value =
                                    map.next_value::<std::option::Option<crate::model::Value>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Condition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.field.is_some() {
                state.serialize_entry("field", &self.field)?;
            }
            if !wkt::internal::is_default(&self.operator) {
                state.serialize_entry("operator", &self.operator)?;
            }
            if self.value.is_some() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A collection of conditions.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Conditions {
        /// A collection of conditions.
        pub conditions: std::vec::Vec<crate::model::record_condition::Condition>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Conditions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [conditions][crate::model::record_condition::Conditions::conditions].
        pub fn set_conditions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::record_condition::Condition>,
        {
            use std::iter::Iterator;
            self.conditions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Conditions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RecordCondition.Conditions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Conditions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __conditions,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Conditions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "conditions" => Ok(__FieldTag::__conditions),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Conditions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Conditions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__conditions => {
                                if !fields.insert(__FieldTag::__conditions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for conditions",
                                    ));
                                }
                                result.conditions = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::record_condition::Condition>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Conditions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.conditions.is_empty() {
                state.serialize_entry("conditions", &self.conditions)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// An expression, consisting of an operator and conditions.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Expressions {
        /// The operator to apply to the result of conditions. Default and currently
        /// only supported value is `AND`.
        pub logical_operator: crate::model::record_condition::expressions::LogicalOperator,

        /// Expression types.
        pub r#type: std::option::Option<crate::model::record_condition::expressions::Type>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Expressions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [logical_operator][crate::model::record_condition::Expressions::logical_operator].
        pub fn set_logical_operator<
            T: std::convert::Into<crate::model::record_condition::expressions::LogicalOperator>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.logical_operator = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::record_condition::Expressions::type].
        ///
        /// Note that all the setters affecting `r#type` are mutually
        /// exclusive.
        pub fn set_type<
            T: std::convert::Into<
                    std::option::Option<crate::model::record_condition::expressions::Type>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// The value of [r#type][crate::model::record_condition::Expressions::r#type]
        /// if it holds a `Conditions`, `None` if the field is not set or
        /// holds a different branch.
        pub fn conditions(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::record_condition::Conditions>>
        {
            #[allow(unreachable_patterns)]
            self.r#type.as_ref().and_then(|v| match v {
                crate::model::record_condition::expressions::Type::Conditions(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#type][crate::model::record_condition::Expressions::r#type]
        /// to hold a `Conditions`.
        ///
        /// Note that all the setters affecting `r#type` are
        /// mutually exclusive.
        pub fn set_conditions<
            T: std::convert::Into<std::boxed::Box<crate::model::record_condition::Conditions>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = std::option::Option::Some(
                crate::model::record_condition::expressions::Type::Conditions(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Expressions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RecordCondition.Expressions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Expressions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __logical_operator,
                __conditions,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Expressions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "logicalOperator" => Ok(__FieldTag::__logical_operator),
                                "logical_operator" => Ok(__FieldTag::__logical_operator),
                                "conditions" => Ok(__FieldTag::__conditions),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Expressions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Expressions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__logical_operator => {
                                if !fields.insert(__FieldTag::__logical_operator) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for logical_operator",
                                    ));
                                }
                                result.logical_operator = map.next_value::<std::option::Option<crate::model::record_condition::expressions::LogicalOperator>>()?.unwrap_or_default();
                            }
                            __FieldTag::__conditions => {
                                if !fields.insert(__FieldTag::__conditions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for conditions",
                                    ));
                                }
                                if result.r#type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.RecordCondition.Expressions.conditions, latest field was conditions",
                                    ));
                                }
                                result.r#type = std::option::Option::Some(
                                    crate::model::record_condition::expressions::Type::Conditions(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::record_condition::Conditions,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Expressions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.logical_operator) {
                state.serialize_entry("logicalOperator", &self.logical_operator)?;
            }
            if let Some(value) = self.conditions() {
                state.serialize_entry("conditions", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Expressions].
    pub mod expressions {
        #[allow(unused_imports)]
        use super::*;

        /// Logical operators for conditional checks.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum LogicalOperator {
            /// Unused
            Unspecified,
            /// Conditional AND
            And,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [LogicalOperator::value] or
            /// [LogicalOperator::name].
            UnknownValue(logical_operator::UnknownValue),
        }

        #[doc(hidden)]
        pub mod logical_operator {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl LogicalOperator {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::And => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("LOGICAL_OPERATOR_UNSPECIFIED"),
                    Self::And => std::option::Option::Some("AND"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for LogicalOperator {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for LogicalOperator {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for LogicalOperator {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::And,
                    _ => Self::UnknownValue(logical_operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for LogicalOperator {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LOGICAL_OPERATOR_UNSPECIFIED" => Self::Unspecified,
                    "AND" => Self::And,
                    _ => Self::UnknownValue(logical_operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for LogicalOperator {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::And => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for LogicalOperator {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogicalOperator>::new(
                    ".google.privacy.dlp.v2.RecordCondition.Expressions.LogicalOperator",
                ))
            }
        }

        /// Expression types.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Conditions to apply to the expression.
            Conditions(std::boxed::Box<crate::model::record_condition::Conditions>),
        }
    }
}

/// Overview of the modifications that occurred.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransformationOverview {
    /// Total size in bytes that were transformed in some way.
    pub transformed_bytes: i64,

    /// Transformations applied to the dataset.
    pub transformation_summaries: std::vec::Vec<crate::model::TransformationSummary>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationOverview {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformed_bytes][crate::model::TransformationOverview::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [transformation_summaries][crate::model::TransformationOverview::transformation_summaries].
    pub fn set_transformation_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransformationSummary>,
    {
        use std::iter::Iterator;
        self.transformation_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TransformationOverview {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationOverview"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransformationOverview {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transformed_bytes,
            __transformation_summaries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransformationOverview")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transformedBytes" => Ok(__FieldTag::__transformed_bytes),
                            "transformed_bytes" => Ok(__FieldTag::__transformed_bytes),
                            "transformationSummaries" => Ok(__FieldTag::__transformation_summaries),
                            "transformation_summaries" => {
                                Ok(__FieldTag::__transformation_summaries)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransformationOverview;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransformationOverview")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transformed_bytes => {
                            if !fields.insert(__FieldTag::__transformed_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformed_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transformed_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__transformation_summaries => {
                            if !fields.insert(__FieldTag::__transformation_summaries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformation_summaries",
                                ));
                            }
                            result.transformation_summaries = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TransformationSummary>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransformationOverview {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.transformed_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("transformedBytes", &__With(&self.transformed_bytes))?;
        }
        if !self.transformation_summaries.is_empty() {
            state.serialize_entry("transformationSummaries", &self.transformation_summaries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Summary of a single transformation.
/// Only one of 'transformation', 'field_transformation', or 'record_suppress'
/// will be set.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransformationSummary {
    /// Set if the transformation was limited to a specific InfoType.
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Set if the transformation was limited to a specific FieldId.
    pub field: std::option::Option<crate::model::FieldId>,

    /// The specific transformation these stats apply to.
    pub transformation: std::option::Option<crate::model::PrimitiveTransformation>,

    /// The field transformation that was applied.
    /// If multiple field transformations are requested for a single field,
    /// this list will contain all of them; otherwise, only one is supplied.
    pub field_transformations: std::vec::Vec<crate::model::FieldTransformation>,

    /// The specific suppression option these stats apply to.
    pub record_suppress: std::option::Option<crate::model::RecordSuppression>,

    /// Collection of all transformations that took place or had an error.
    pub results: std::vec::Vec<crate::model::transformation_summary::SummaryResult>,

    /// Total size in bytes that were transformed in some way.
    pub transformed_bytes: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::TransformationSummary::info_type].
    pub fn set_info_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [info_type][crate::model::TransformationSummary::info_type].
    pub fn set_or_clear_info_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field][crate::model::TransformationSummary::field].
    pub fn set_field<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field][crate::model::TransformationSummary::field].
    pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transformation][crate::model::TransformationSummary::transformation].
    pub fn set_transformation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrimitiveTransformation>,
    {
        self.transformation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transformation][crate::model::TransformationSummary::transformation].
    pub fn set_or_clear_transformation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrimitiveTransformation>,
    {
        self.transformation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field_transformations][crate::model::TransformationSummary::field_transformations].
    pub fn set_field_transformations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldTransformation>,
    {
        use std::iter::Iterator;
        self.field_transformations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [record_suppress][crate::model::TransformationSummary::record_suppress].
    pub fn set_record_suppress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecordSuppression>,
    {
        self.record_suppress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [record_suppress][crate::model::TransformationSummary::record_suppress].
    pub fn set_or_clear_record_suppress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecordSuppression>,
    {
        self.record_suppress = v.map(|x| x.into());
        self
    }

    /// Sets the value of [results][crate::model::TransformationSummary::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transformation_summary::SummaryResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [transformed_bytes][crate::model::TransformationSummary::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }
}

impl wkt::message::Message for TransformationSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationSummary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransformationSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_type,
            __field,
            __transformation,
            __field_transformations,
            __record_suppress,
            __results,
            __transformed_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransformationSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            "field" => Ok(__FieldTag::__field),
                            "transformation" => Ok(__FieldTag::__transformation),
                            "fieldTransformations" => Ok(__FieldTag::__field_transformations),
                            "field_transformations" => Ok(__FieldTag::__field_transformations),
                            "recordSuppress" => Ok(__FieldTag::__record_suppress),
                            "record_suppress" => Ok(__FieldTag::__record_suppress),
                            "results" => Ok(__FieldTag::__results),
                            "transformedBytes" => Ok(__FieldTag::__transformed_bytes),
                            "transformed_bytes" => Ok(__FieldTag::__transformed_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransformationSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransformationSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type",
                                ));
                            }
                            result.info_type =
                                map.next_value::<std::option::Option<crate::model::InfoType>>()?;
                        }
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field =
                                map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                        }
                        __FieldTag::__transformation => {
                            if !fields.insert(__FieldTag::__transformation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformation",
                                ));
                            }
                            result.transformation = map.next_value::<std::option::Option<crate::model::PrimitiveTransformation>>()?
                                ;
                        }
                        __FieldTag::__field_transformations => {
                            if !fields.insert(__FieldTag::__field_transformations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_transformations",
                                ));
                            }
                            result.field_transformations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FieldTransformation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__record_suppress => {
                            if !fields.insert(__FieldTag::__record_suppress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for record_suppress",
                                ));
                            }
                            result.record_suppress = map
                                .next_value::<std::option::Option<crate::model::RecordSuppression>>(
                                )?;
                        }
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::transformation_summary::SummaryResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transformed_bytes => {
                            if !fields.insert(__FieldTag::__transformed_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformed_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transformed_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransformationSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.info_type.is_some() {
            state.serialize_entry("infoType", &self.info_type)?;
        }
        if self.field.is_some() {
            state.serialize_entry("field", &self.field)?;
        }
        if self.transformation.is_some() {
            state.serialize_entry("transformation", &self.transformation)?;
        }
        if !self.field_transformations.is_empty() {
            state.serialize_entry("fieldTransformations", &self.field_transformations)?;
        }
        if self.record_suppress.is_some() {
            state.serialize_entry("recordSuppress", &self.record_suppress)?;
        }
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !wkt::internal::is_default(&self.transformed_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("transformedBytes", &__With(&self.transformed_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TransformationSummary].
pub mod transformation_summary {
    #[allow(unused_imports)]
    use super::*;

    /// A collection that informs the user the number of times a particular
    /// `TransformationResultCode` and error details occurred.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SummaryResult {
        /// Number of transformations counted by this result.
        pub count: i64,

        /// Outcome of the transformation.
        pub code: crate::model::transformation_summary::TransformationResultCode,

        /// A place for warnings or errors to show up if a transformation didn't
        /// work as expected.
        pub details: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SummaryResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [count][crate::model::transformation_summary::SummaryResult::count].
        pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }

        /// Sets the value of [code][crate::model::transformation_summary::SummaryResult::code].
        pub fn set_code<
            T: std::convert::Into<crate::model::transformation_summary::TransformationResultCode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.code = v.into();
            self
        }

        /// Sets the value of [details][crate::model::transformation_summary::SummaryResult::details].
        pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.details = v.into();
            self
        }
    }

    impl wkt::message::Message for SummaryResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.TransformationSummary.SummaryResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SummaryResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __count,
                __code,
                __details,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SummaryResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "count" => Ok(__FieldTag::__count),
                                "code" => Ok(__FieldTag::__code),
                                "details" => Ok(__FieldTag::__details),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SummaryResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SummaryResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__count => {
                                if !fields.insert(__FieldTag::__count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__code => {
                                if !fields.insert(__FieldTag::__code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for code",
                                    ));
                                }
                                result.code = map.next_value::<std::option::Option<crate::model::transformation_summary::TransformationResultCode>>()?.unwrap_or_default();
                            }
                            __FieldTag::__details => {
                                if !fields.insert(__FieldTag::__details) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for details",
                                    ));
                                }
                                result.details = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SummaryResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("count", &__With(&self.count))?;
            }
            if !wkt::internal::is_default(&self.code) {
                state.serialize_entry("code", &self.code)?;
            }
            if !self.details.is_empty() {
                state.serialize_entry("details", &self.details)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Possible outcomes of transformations.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TransformationResultCode {
        /// Unused
        Unspecified,
        /// Transformation completed without an error.
        Success,
        /// Transformation had an error.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TransformationResultCode::value] or
        /// [TransformationResultCode::name].
        UnknownValue(transformation_result_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod transformation_result_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TransformationResultCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Success => std::option::Option::Some(1),
                Self::Error => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("TRANSFORMATION_RESULT_CODE_UNSPECIFIED")
                }
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TransformationResultCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TransformationResultCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TransformationResultCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Success,
                2 => Self::Error,
                _ => Self::UnknownValue(transformation_result_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TransformationResultCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRANSFORMATION_RESULT_CODE_UNSPECIFIED" => Self::Unspecified,
                "SUCCESS" => Self::Success,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(transformation_result_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TransformationResultCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Success => serializer.serialize_i32(1),
                Self::Error => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TransformationResultCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<TransformationResultCode>::new(
                    ".google.privacy.dlp.v2.TransformationSummary.TransformationResultCode",
                ),
            )
        }
    }
}

/// A flattened description of a `PrimitiveTransformation` or
/// `RecordSuppression`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransformationDescription {
    /// The transformation type.
    pub r#type: crate::model::TransformationType,

    /// A description of the transformation. This is empty for a
    /// RECORD_SUPPRESSION, or is the output of calling toString() on the
    /// `PrimitiveTransformation` protocol buffer message for any other type of
    /// transformation.
    pub description: std::string::String,

    /// A human-readable string representation of the `RecordCondition`
    /// corresponding to this transformation. Set if a `RecordCondition` was used
    /// to determine whether or not to apply this transformation.
    ///
    /// Examples:
    /// * (age_field > 85)
    /// * (age_field <= 18)
    /// * (zip_field exists)
    /// * (zip_field == 01234) && (city_field != "Springville")
    /// * (zip_field == 01234) && (age_field <= 18) && (city_field exists)
    pub condition: std::string::String,

    /// Set if the transformation was limited to a specific `InfoType`.
    pub info_type: std::option::Option<crate::model::InfoType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationDescription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TransformationDescription::type].
    pub fn set_type<T: std::convert::Into<crate::model::TransformationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TransformationDescription::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::TransformationDescription::condition].
    pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [info_type][crate::model::TransformationDescription::info_type].
    pub fn set_info_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [info_type][crate::model::TransformationDescription::info_type].
    pub fn set_or_clear_info_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TransformationDescription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationDescription"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransformationDescription {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __description,
            __condition,
            __info_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransformationDescription")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "description" => Ok(__FieldTag::__description),
                            "condition" => Ok(__FieldTag::__condition),
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransformationDescription;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransformationDescription")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::TransformationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type",
                                ));
                            }
                            result.info_type =
                                map.next_value::<std::option::Option<crate::model::InfoType>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransformationDescription {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if self.info_type.is_some() {
            state.serialize_entry("infoType", &self.info_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details about a single transformation. This object contains a description of
/// the transformation, information about whether the transformation was
/// successfully applied, and the precise location where the transformation
/// occurred. These details are stored in a user-specified BigQuery table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransformationDetails {
    /// The name of the job that completed the transformation.
    pub resource_name: std::string::String,

    /// The top level name of the container where the transformation is located
    /// (this will be the source file name or table name).
    pub container_name: std::string::String,

    /// Description of transformation. This would only contain more than one
    /// element if there were multiple matching transformations and which one to
    /// apply was ambiguous. Not set for states that contain no transformation,
    /// currently only state that contains no transformation is
    /// TransformationResultStateType.METADATA_UNRETRIEVABLE.
    pub transformation: std::vec::Vec<crate::model::TransformationDescription>,

    /// Status of the transformation, if transformation was not successful, this
    /// will specify what caused it to fail, otherwise it will show that the
    /// transformation was successful.
    pub status_details: std::option::Option<crate::model::TransformationResultStatus>,

    /// The number of bytes that were transformed. If transformation was
    /// unsuccessful or did not take place because there was no content to
    /// transform, this will be zero.
    pub transformed_bytes: i64,

    /// The precise location of the transformed content in the original container.
    pub transformation_location: std::option::Option<crate::model::TransformationLocation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_name][crate::model::TransformationDetails::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [container_name][crate::model::TransformationDetails::container_name].
    pub fn set_container_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_name = v.into();
        self
    }

    /// Sets the value of [transformation][crate::model::TransformationDetails::transformation].
    pub fn set_transformation<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransformationDescription>,
    {
        use std::iter::Iterator;
        self.transformation = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [status_details][crate::model::TransformationDetails::status_details].
    pub fn set_status_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransformationResultStatus>,
    {
        self.status_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status_details][crate::model::TransformationDetails::status_details].
    pub fn set_or_clear_status_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransformationResultStatus>,
    {
        self.status_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transformed_bytes][crate::model::TransformationDetails::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [transformation_location][crate::model::TransformationDetails::transformation_location].
    pub fn set_transformation_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransformationLocation>,
    {
        self.transformation_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transformation_location][crate::model::TransformationDetails::transformation_location].
    pub fn set_or_clear_transformation_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransformationLocation>,
    {
        self.transformation_location = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TransformationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransformationDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_name,
            __container_name,
            __transformation,
            __status_details,
            __transformed_bytes,
            __transformation_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransformationDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceName" => Ok(__FieldTag::__resource_name),
                            "resource_name" => Ok(__FieldTag::__resource_name),
                            "containerName" => Ok(__FieldTag::__container_name),
                            "container_name" => Ok(__FieldTag::__container_name),
                            "transformation" => Ok(__FieldTag::__transformation),
                            "statusDetails" => Ok(__FieldTag::__status_details),
                            "status_details" => Ok(__FieldTag::__status_details),
                            "transformedBytes" => Ok(__FieldTag::__transformed_bytes),
                            "transformed_bytes" => Ok(__FieldTag::__transformed_bytes),
                            "transformationLocation" => Ok(__FieldTag::__transformation_location),
                            "transformation_location" => Ok(__FieldTag::__transformation_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransformationDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransformationDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_name => {
                            if !fields.insert(__FieldTag::__resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_name",
                                ));
                            }
                            result.resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_name => {
                            if !fields.insert(__FieldTag::__container_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_name",
                                ));
                            }
                            result.container_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transformation => {
                            if !fields.insert(__FieldTag::__transformation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformation",
                                ));
                            }
                            result.transformation = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TransformationDescription>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_details => {
                            if !fields.insert(__FieldTag::__status_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_details",
                                ));
                            }
                            result.status_details = map.next_value::<std::option::Option<crate::model::TransformationResultStatus>>()?
                                ;
                        }
                        __FieldTag::__transformed_bytes => {
                            if !fields.insert(__FieldTag::__transformed_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformed_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transformed_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__transformation_location => {
                            if !fields.insert(__FieldTag::__transformation_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformation_location",
                                ));
                            }
                            result.transformation_location = map.next_value::<std::option::Option<crate::model::TransformationLocation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransformationDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_name.is_empty() {
            state.serialize_entry("resourceName", &self.resource_name)?;
        }
        if !self.container_name.is_empty() {
            state.serialize_entry("containerName", &self.container_name)?;
        }
        if !self.transformation.is_empty() {
            state.serialize_entry("transformation", &self.transformation)?;
        }
        if self.status_details.is_some() {
            state.serialize_entry("statusDetails", &self.status_details)?;
        }
        if !wkt::internal::is_default(&self.transformed_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("transformedBytes", &__With(&self.transformed_bytes))?;
        }
        if self.transformation_location.is_some() {
            state.serialize_entry("transformationLocation", &self.transformation_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specifies the location of a transformation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransformationLocation {
    /// Information about the functionality of the container where this finding
    /// occurred, if available.
    pub container_type: crate::model::TransformationContainerType,

    /// Location type.
    pub location_type: std::option::Option<crate::model::transformation_location::LocationType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_type][crate::model::TransformationLocation::container_type].
    pub fn set_container_type<T: std::convert::Into<crate::model::TransformationContainerType>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_type = v.into();
        self
    }

    /// Sets the value of [location_type][crate::model::TransformationLocation::location_type].
    ///
    /// Note that all the setters affecting `location_type` are mutually
    /// exclusive.
    pub fn set_location_type<
        T: std::convert::Into<
                std::option::Option<crate::model::transformation_location::LocationType>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_type = v.into();
        self
    }

    /// The value of [location_type][crate::model::TransformationLocation::location_type]
    /// if it holds a `FindingId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn finding_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.location_type.as_ref().and_then(|v| match v {
            crate::model::transformation_location::LocationType::FindingId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location_type][crate::model::TransformationLocation::location_type]
    /// to hold a `FindingId`.
    ///
    /// Note that all the setters affecting `location_type` are
    /// mutually exclusive.
    pub fn set_finding_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_type = std::option::Option::Some(
            crate::model::transformation_location::LocationType::FindingId(v.into()),
        );
        self
    }

    /// The value of [location_type][crate::model::TransformationLocation::location_type]
    /// if it holds a `RecordTransformation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn record_transformation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecordTransformation>> {
        #[allow(unreachable_patterns)]
        self.location_type.as_ref().and_then(|v| match v {
            crate::model::transformation_location::LocationType::RecordTransformation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location_type][crate::model::TransformationLocation::location_type]
    /// to hold a `RecordTransformation`.
    ///
    /// Note that all the setters affecting `location_type` are
    /// mutually exclusive.
    pub fn set_record_transformation<
        T: std::convert::Into<std::boxed::Box<crate::model::RecordTransformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_type = std::option::Option::Some(
            crate::model::transformation_location::LocationType::RecordTransformation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TransformationLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransformationLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __finding_id,
            __record_transformation,
            __container_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransformationLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "findingId" => Ok(__FieldTag::__finding_id),
                            "finding_id" => Ok(__FieldTag::__finding_id),
                            "recordTransformation" => Ok(__FieldTag::__record_transformation),
                            "record_transformation" => Ok(__FieldTag::__record_transformation),
                            "containerType" => Ok(__FieldTag::__container_type),
                            "container_type" => Ok(__FieldTag::__container_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransformationLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransformationLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__finding_id => {
                            if !fields.insert(__FieldTag::__finding_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding_id",
                                ));
                            }
                            if result.location_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location_type`, a oneof with full ID .google.privacy.dlp.v2.TransformationLocation.finding_id, latest field was findingId",
                                ));
                            }
                            result.location_type = std::option::Option::Some(
                                crate::model::transformation_location::LocationType::FindingId(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__record_transformation => {
                            if !fields.insert(__FieldTag::__record_transformation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for record_transformation",
                                ));
                            }
                            if result.location_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location_type`, a oneof with full ID .google.privacy.dlp.v2.TransformationLocation.record_transformation, latest field was recordTransformation",
                                ));
                            }
                            result.location_type = std::option::Option::Some(
                                crate::model::transformation_location::LocationType::RecordTransformation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::RecordTransformation>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__container_type => {
                            if !fields.insert(__FieldTag::__container_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_type",
                                ));
                            }
                            result.container_type = map.next_value::<std::option::Option<crate::model::TransformationContainerType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransformationLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.finding_id() {
            state.serialize_entry("findingId", value)?;
        }
        if let Some(value) = self.record_transformation() {
            state.serialize_entry("recordTransformation", value)?;
        }
        if !wkt::internal::is_default(&self.container_type) {
            state.serialize_entry("containerType", &self.container_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TransformationLocation].
pub mod transformation_location {
    #[allow(unused_imports)]
    use super::*;

    /// Location type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocationType {
        /// For infotype transformations, link to the corresponding findings ID so
        /// that location information does not need to be duplicated. Each findings
        /// ID correlates to an entry in the findings output table, this table only
        /// gets created when users specify to save findings (add the save findings
        /// action to the request).
        FindingId(std::string::String),
        /// For record transformations, provide a field and container information.
        RecordTransformation(std::boxed::Box<crate::model::RecordTransformation>),
    }
}

/// The field in a record to transform.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecordTransformation {
    /// For record transformations, provide a field.
    pub field_id: std::option::Option<crate::model::FieldId>,

    /// Findings container modification timestamp, if applicable.
    pub container_timestamp: std::option::Option<wkt::Timestamp>,

    /// Container version, if available ("generation" for Cloud Storage).
    pub container_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field_id][crate::model::RecordTransformation::field_id].
    pub fn set_field_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field_id][crate::model::RecordTransformation::field_id].
    pub fn set_or_clear_field_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [container_timestamp][crate::model::RecordTransformation::container_timestamp].
    pub fn set_container_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.container_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [container_timestamp][crate::model::RecordTransformation::container_timestamp].
    pub fn set_or_clear_container_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.container_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [container_version][crate::model::RecordTransformation::container_version].
    pub fn set_container_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_version = v.into();
        self
    }
}

impl wkt::message::Message for RecordTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordTransformation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecordTransformation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field_id,
            __container_timestamp,
            __container_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecordTransformation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fieldId" => Ok(__FieldTag::__field_id),
                            "field_id" => Ok(__FieldTag::__field_id),
                            "containerTimestamp" => Ok(__FieldTag::__container_timestamp),
                            "container_timestamp" => Ok(__FieldTag::__container_timestamp),
                            "containerVersion" => Ok(__FieldTag::__container_version),
                            "container_version" => Ok(__FieldTag::__container_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecordTransformation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecordTransformation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field_id => {
                            if !fields.insert(__FieldTag::__field_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_id",
                                ));
                            }
                            result.field_id =
                                map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                        }
                        __FieldTag::__container_timestamp => {
                            if !fields.insert(__FieldTag::__container_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_timestamp",
                                ));
                            }
                            result.container_timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__container_version => {
                            if !fields.insert(__FieldTag::__container_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_version",
                                ));
                            }
                            result.container_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecordTransformation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.field_id.is_some() {
            state.serialize_entry("fieldId", &self.field_id)?;
        }
        if self.container_timestamp.is_some() {
            state.serialize_entry("containerTimestamp", &self.container_timestamp)?;
        }
        if !self.container_version.is_empty() {
            state.serialize_entry("containerVersion", &self.container_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The outcome of a transformation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransformationResultStatus {
    /// Transformation result status type, this will be either SUCCESS, or it will
    /// be the reason for why the transformation was not completely successful.
    pub result_status_type: crate::model::TransformationResultStatusType,

    /// Detailed error codes and messages
    pub details: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationResultStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result_status_type][crate::model::TransformationResultStatus::result_status_type].
    pub fn set_result_status_type<
        T: std::convert::Into<crate::model::TransformationResultStatusType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result_status_type = v.into();
        self
    }

    /// Sets the value of [details][crate::model::TransformationResultStatus::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::TransformationResultStatus::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TransformationResultStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationResultStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransformationResultStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result_status_type,
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransformationResultStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resultStatusType" => Ok(__FieldTag::__result_status_type),
                            "result_status_type" => Ok(__FieldTag::__result_status_type),
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransformationResultStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransformationResultStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result_status_type => {
                            if !fields.insert(__FieldTag::__result_status_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result_status_type",
                                ));
                            }
                            result.result_status_type =
                                map.next_value::<std::option::Option<
                                    crate::model::TransformationResultStatusType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransformationResultStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.result_status_type) {
            state.serialize_entry("resultStatusType", &self.result_status_type)?;
        }
        if self.details.is_some() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Config for storing transformation details.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransformationDetailsStorageConfig {
    /// Location to store the transformation summary.
    pub r#type: std::option::Option<crate::model::transformation_details_storage_config::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationDetailsStorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TransformationDetailsStorageConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<
                std::option::Option<crate::model::transformation_details_storage_config::Type>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::TransformationDetailsStorageConfig::r#type]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table(&self) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTable>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::transformation_details_storage_config::Type::Table(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::TransformationDetailsStorageConfig::r#type]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTable>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::transformation_details_storage_config::Type::Table(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TransformationDetailsStorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationDetailsStorageConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransformationDetailsStorageConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransformationDetailsStorageConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "table" => Ok(__FieldTag::__table),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransformationDetailsStorageConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransformationDetailsStorageConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.TransformationDetailsStorageConfig.table, latest field was table",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::transformation_details_storage_config::Type::Table(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryTable>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransformationDetailsStorageConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.table() {
            state.serialize_entry("table", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TransformationDetailsStorageConfig].
pub mod transformation_details_storage_config {
    #[allow(unused_imports)]
    use super::*;

    /// Location to store the transformation summary.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The BigQuery table in which to store the output. This may be an existing
        /// table or in a new table in an existing dataset.
        /// If table_id is not set a new one will be generated for you with the
        /// following format:
        /// dlp_googleapis_transformation_details_yyyy_mm_dd_[dlp_job_id]. Pacific
        /// time zone will be used for generating the date details.
        Table(std::boxed::Box<crate::model::BigQueryTable>),
    }
}

/// Schedule for inspect job triggers.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Schedule {
    /// Type of schedule.
    pub option: std::option::Option<crate::model::schedule::Option>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [option][crate::model::Schedule::option].
    ///
    /// Note that all the setters affecting `option` are mutually
    /// exclusive.
    pub fn set_option<
        T: std::convert::Into<std::option::Option<crate::model::schedule::Option>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.option = v.into();
        self
    }

    /// The value of [option][crate::model::Schedule::option]
    /// if it holds a `RecurrencePeriodDuration`, `None` if the field is not set or
    /// holds a different branch.
    pub fn recurrence_period_duration(
        &self,
    ) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.option.as_ref().and_then(|v| match v {
            crate::model::schedule::Option::RecurrencePeriodDuration(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [option][crate::model::Schedule::option]
    /// to hold a `RecurrencePeriodDuration`.
    ///
    /// Note that all the setters affecting `option` are
    /// mutually exclusive.
    pub fn set_recurrence_period_duration<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.option = std::option::Option::Some(
            crate::model::schedule::Option::RecurrencePeriodDuration(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Schedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Schedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Schedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recurrence_period_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Schedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recurrencePeriodDuration" => {
                                Ok(__FieldTag::__recurrence_period_duration)
                            }
                            "recurrence_period_duration" => {
                                Ok(__FieldTag::__recurrence_period_duration)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Schedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Schedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recurrence_period_duration => {
                            if !fields.insert(__FieldTag::__recurrence_period_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurrence_period_duration",
                                ));
                            }
                            if result.option.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `option`, a oneof with full ID .google.privacy.dlp.v2.Schedule.recurrence_period_duration, latest field was recurrencePeriodDuration",
                                ));
                            }
                            result.option = std::option::Option::Some(
                                crate::model::schedule::Option::RecurrencePeriodDuration(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Schedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.recurrence_period_duration() {
            state.serialize_entry("recurrencePeriodDuration", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Schedule].
pub mod schedule {
    #[allow(unused_imports)]
    use super::*;

    /// Type of schedule.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Option {
        /// With this option a job is started on a regular periodic basis. For
        /// example: every day (86400 seconds).
        ///
        /// A scheduled start time will be skipped if the previous
        /// execution has not ended when its scheduled time occurs.
        ///
        /// This value must be set to a time duration greater than or equal
        /// to 1 day and can be no longer than 60 days.
        RecurrencePeriodDuration(std::boxed::Box<wkt::Duration>),
    }
}

/// Job trigger option for hybrid jobs. Jobs must be manually created
/// and finished.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Manual {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Manual {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for Manual {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Manual"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Manual {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Manual")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Manual;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Manual")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Manual {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The inspectTemplate contains a configuration (set of types of sensitive data
/// to be detected) to be used anywhere you otherwise would normally specify
/// InspectConfig. See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-templates> to
/// learn more.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InspectTemplate {
    /// Output only. The template name.
    ///
    /// The template will have one of the following formats:
    /// `projects/PROJECT_ID/inspectTemplates/TEMPLATE_ID` OR
    /// `organizations/ORGANIZATION_ID/inspectTemplates/TEMPLATE_ID`;
    pub name: std::string::String,

    /// Display name (max 256 chars).
    pub display_name: std::string::String,

    /// Short description (max 256 chars).
    pub description: std::string::String,

    /// Output only. The creation timestamp of an inspectTemplate.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of an inspectTemplate.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The core content of the template. Configuration of the scanning process.
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InspectTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InspectTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::InspectTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::InspectTemplate::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::InspectTemplate::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::InspectTemplate::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::InspectTemplate::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_config][crate::model::InspectTemplate::inspect_config].
    pub fn set_inspect_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_config][crate::model::InspectTemplate::inspect_config].
    pub fn set_or_clear_inspect_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InspectTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InspectTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __create_time,
            __update_time,
            __inspect_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InspectTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "inspectConfig" => Ok(__FieldTag::__inspect_config),
                            "inspect_config" => Ok(__FieldTag::__inspect_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InspectTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InspectTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__inspect_config => {
                            if !fields.insert(__FieldTag::__inspect_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_config",
                                ));
                            }
                            result.inspect_config = map
                                .next_value::<std::option::Option<crate::model::InspectConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InspectTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.inspect_config.is_some() {
            state.serialize_entry("inspectConfig", &self.inspect_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// DeidentifyTemplates contains instructions on how to de-identify content.
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-templates> to
/// learn more.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeidentifyTemplate {
    /// Output only. The template name.
    ///
    /// The template will have one of the following formats:
    /// `projects/PROJECT_ID/deidentifyTemplates/TEMPLATE_ID` OR
    /// `organizations/ORGANIZATION_ID/deidentifyTemplates/TEMPLATE_ID`
    pub name: std::string::String,

    /// Display name (max 256 chars).
    pub display_name: std::string::String,

    /// Short description (max 256 chars).
    pub description: std::string::String,

    /// Output only. The creation timestamp of an inspectTemplate.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of an inspectTemplate.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The core content of the template.
    pub deidentify_config: std::option::Option<crate::model::DeidentifyConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeidentifyTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DeidentifyTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DeidentifyTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeidentifyTemplate::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeidentifyTemplate::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeidentifyTemplate::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeidentifyTemplate::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deidentify_config][crate::model::DeidentifyTemplate::deidentify_config].
    pub fn set_deidentify_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyConfig>,
    {
        self.deidentify_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deidentify_config][crate::model::DeidentifyTemplate::deidentify_config].
    pub fn set_or_clear_deidentify_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyConfig>,
    {
        self.deidentify_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeidentifyTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeidentifyTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __create_time,
            __update_time,
            __deidentify_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeidentifyTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deidentifyConfig" => Ok(__FieldTag::__deidentify_config),
                            "deidentify_config" => Ok(__FieldTag::__deidentify_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeidentifyTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeidentifyTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__deidentify_config => {
                            if !fields.insert(__FieldTag::__deidentify_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_config",
                                ));
                            }
                            result.deidentify_config = map
                                .next_value::<std::option::Option<crate::model::DeidentifyConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeidentifyTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.deidentify_config.is_some() {
            state.serialize_entry("deidentifyConfig", &self.deidentify_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details information about an error encountered during job execution or
/// the results of an unsuccessful activation of the JobTrigger.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Error {
    /// Detailed error codes and messages.
    pub details: std::option::Option<rpc::model::Status>,

    /// The times the error occurred. List includes the oldest timestamp and the
    /// last 9 timestamps.
    pub timestamps: std::vec::Vec<wkt::Timestamp>,

    /// Additional information about the error.
    pub extra_info: crate::model::error::ErrorExtraInfo,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Error {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::Error::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::Error::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timestamps][crate::model::Error::timestamps].
    pub fn set_timestamps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Timestamp>,
    {
        use std::iter::Iterator;
        self.timestamps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [extra_info][crate::model::Error::extra_info].
    pub fn set_extra_info<T: std::convert::Into<crate::model::error::ErrorExtraInfo>>(
        mut self,
        v: T,
    ) -> Self {
        self.extra_info = v.into();
        self
    }
}

impl wkt::message::Message for Error {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Error"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Error {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __details,
            __timestamps,
            __extra_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Error")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "details" => Ok(__FieldTag::__details),
                            "timestamps" => Ok(__FieldTag::__timestamps),
                            "extraInfo" => Ok(__FieldTag::__extra_info),
                            "extra_info" => Ok(__FieldTag::__extra_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Error;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Error")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__timestamps => {
                            if !fields.insert(__FieldTag::__timestamps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamps",
                                ));
                            }
                            result.timestamps = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Timestamp>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__extra_info => {
                            if !fields.insert(__FieldTag::__extra_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extra_info",
                                ));
                            }
                            result.extra_info = map.next_value::<std::option::Option<crate::model::error::ErrorExtraInfo>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Error {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.details.is_some() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self.timestamps.is_empty() {
            state.serialize_entry("timestamps", &self.timestamps)?;
        }
        if !wkt::internal::is_default(&self.extra_info) {
            state.serialize_entry("extraInfo", &self.extra_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Error].
pub mod error {
    #[allow(unused_imports)]
    use super::*;

    /// Additional information about the error.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ErrorExtraInfo {
        /// Unused.
        ErrorInfoUnspecified,
        /// Image scan is not available in the region.
        ImageScanUnavailableInRegion,
        /// File store cluster is not supported for profile generation.
        FileStoreClusterUnsupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ErrorExtraInfo::value] or
        /// [ErrorExtraInfo::name].
        UnknownValue(error_extra_info::UnknownValue),
    }

    #[doc(hidden)]
    pub mod error_extra_info {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ErrorExtraInfo {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ErrorInfoUnspecified => std::option::Option::Some(0),
                Self::ImageScanUnavailableInRegion => std::option::Option::Some(1),
                Self::FileStoreClusterUnsupported => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ErrorInfoUnspecified => std::option::Option::Some("ERROR_INFO_UNSPECIFIED"),
                Self::ImageScanUnavailableInRegion => {
                    std::option::Option::Some("IMAGE_SCAN_UNAVAILABLE_IN_REGION")
                }
                Self::FileStoreClusterUnsupported => {
                    std::option::Option::Some("FILE_STORE_CLUSTER_UNSUPPORTED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ErrorExtraInfo {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ErrorExtraInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ErrorExtraInfo {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ErrorInfoUnspecified,
                1 => Self::ImageScanUnavailableInRegion,
                2 => Self::FileStoreClusterUnsupported,
                _ => Self::UnknownValue(error_extra_info::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ErrorExtraInfo {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_INFO_UNSPECIFIED" => Self::ErrorInfoUnspecified,
                "IMAGE_SCAN_UNAVAILABLE_IN_REGION" => Self::ImageScanUnavailableInRegion,
                "FILE_STORE_CLUSTER_UNSUPPORTED" => Self::FileStoreClusterUnsupported,
                _ => Self::UnknownValue(error_extra_info::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ErrorExtraInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ErrorInfoUnspecified => serializer.serialize_i32(0),
                Self::ImageScanUnavailableInRegion => serializer.serialize_i32(1),
                Self::FileStoreClusterUnsupported => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ErrorExtraInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorExtraInfo>::new(
                ".google.privacy.dlp.v2.Error.ErrorExtraInfo",
            ))
        }
    }
}

/// Contains a configuration to make API calls on a repeating basis.
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-job-triggers>
/// to learn more.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct JobTrigger {
    /// Unique resource name for the triggeredJob, assigned by the service when the
    /// triggeredJob is created, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    pub name: std::string::String,

    /// Display name (max 100 chars)
    pub display_name: std::string::String,

    /// User provided description (max 256 chars)
    pub description: std::string::String,

    /// A list of triggers which will be OR'ed together. Only one in the list
    /// needs to trigger for a job to be started. The list may contain only
    /// a single Schedule trigger and must have at least one object.
    pub triggers: std::vec::Vec<crate::model::job_trigger::Trigger>,

    /// Output only. A stream of errors encountered when the trigger was activated.
    /// Repeated errors may result in the JobTrigger automatically being paused.
    /// Will return the last 100 errors. Whenever the JobTrigger is modified
    /// this list will be cleared.
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Output only. The creation timestamp of a triggeredJob.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of a triggeredJob.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the last time this trigger executed.
    pub last_run_time: std::option::Option<wkt::Timestamp>,

    /// Required. A status for this trigger.
    pub status: crate::model::job_trigger::Status,

    /// The configuration details for the specific type of job to run.
    pub job: std::option::Option<crate::model::job_trigger::Job>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobTrigger {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::JobTrigger::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::JobTrigger::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::JobTrigger::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [triggers][crate::model::JobTrigger::triggers].
    pub fn set_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::job_trigger::Trigger>,
    {
        use std::iter::Iterator;
        self.triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors][crate::model::JobTrigger::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::JobTrigger::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::JobTrigger::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::JobTrigger::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::JobTrigger::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_run_time][crate::model::JobTrigger::last_run_time].
    pub fn set_last_run_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_run_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_run_time][crate::model::JobTrigger::last_run_time].
    pub fn set_or_clear_last_run_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_run_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::JobTrigger::status].
    pub fn set_status<T: std::convert::Into<crate::model::job_trigger::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [job][crate::model::JobTrigger::job].
    ///
    /// Note that all the setters affecting `job` are mutually
    /// exclusive.
    pub fn set_job<T: std::convert::Into<std::option::Option<crate::model::job_trigger::Job>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }

    /// The value of [job][crate::model::JobTrigger::job]
    /// if it holds a `InspectJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inspect_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InspectJobConfig>> {
        #[allow(unreachable_patterns)]
        self.job.as_ref().and_then(|v| match v {
            crate::model::job_trigger::Job::InspectJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job][crate::model::JobTrigger::job]
    /// to hold a `InspectJob`.
    ///
    /// Note that all the setters affecting `job` are
    /// mutually exclusive.
    pub fn set_inspect_job<
        T: std::convert::Into<std::boxed::Box<crate::model::InspectJobConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job = std::option::Option::Some(crate::model::job_trigger::Job::InspectJob(v.into()));
        self
    }
}

impl wkt::message::Message for JobTrigger {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.JobTrigger"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobTrigger {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __inspect_job,
            __triggers,
            __errors,
            __create_time,
            __update_time,
            __last_run_time,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobTrigger")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "inspectJob" => Ok(__FieldTag::__inspect_job),
                            "inspect_job" => Ok(__FieldTag::__inspect_job),
                            "triggers" => Ok(__FieldTag::__triggers),
                            "errors" => Ok(__FieldTag::__errors),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "lastRunTime" => Ok(__FieldTag::__last_run_time),
                            "last_run_time" => Ok(__FieldTag::__last_run_time),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobTrigger;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobTrigger")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inspect_job => {
                            if !fields.insert(__FieldTag::__inspect_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_job",
                                ));
                            }
                            if result.job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job`, a oneof with full ID .google.privacy.dlp.v2.JobTrigger.inspect_job, latest field was inspectJob",
                                ));
                            }
                            result.job = std::option::Option::Some(
                                crate::model::job_trigger::Job::InspectJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InspectJobConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__triggers => {
                            if !fields.insert(__FieldTag::__triggers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for triggers",
                                ));
                            }
                            result.triggers = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::job_trigger::Trigger>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Error>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_run_time => {
                            if !fields.insert(__FieldTag::__last_run_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_run_time",
                                ));
                            }
                            result.last_run_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::job_trigger::Status>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobTrigger {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if let Some(value) = self.inspect_job() {
            state.serialize_entry("inspectJob", value)?;
        }
        if !self.triggers.is_empty() {
            state.serialize_entry("triggers", &self.triggers)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.last_run_time.is_some() {
            state.serialize_entry("lastRunTime", &self.last_run_time)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [JobTrigger].
pub mod job_trigger {
    #[allow(unused_imports)]
    use super::*;

    /// What event needs to occur for a new job to be started.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Trigger {
        /// What event needs to occur for a new job to be started.
        pub trigger: std::option::Option<crate::model::job_trigger::trigger::Trigger>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Trigger {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trigger][crate::model::job_trigger::Trigger::trigger].
        ///
        /// Note that all the setters affecting `trigger` are mutually
        /// exclusive.
        pub fn set_trigger<
            T: std::convert::Into<std::option::Option<crate::model::job_trigger::trigger::Trigger>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = v.into();
            self
        }

        /// The value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// if it holds a `Schedule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn schedule(&self) -> std::option::Option<&std::boxed::Box<crate::model::Schedule>> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::job_trigger::trigger::Trigger::Schedule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// to hold a `Schedule`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_schedule<T: std::convert::Into<std::boxed::Box<crate::model::Schedule>>>(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::job_trigger::trigger::Trigger::Schedule(v.into()),
            );
            self
        }

        /// The value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// if it holds a `Manual`, `None` if the field is not set or
        /// holds a different branch.
        pub fn manual(&self) -> std::option::Option<&std::boxed::Box<crate::model::Manual>> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::job_trigger::trigger::Trigger::Manual(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// to hold a `Manual`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_manual<T: std::convert::Into<std::boxed::Box<crate::model::Manual>>>(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::job_trigger::trigger::Trigger::Manual(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Trigger {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.JobTrigger.Trigger"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Trigger {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __schedule,
                __manual,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Trigger")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "schedule" => Ok(__FieldTag::__schedule),
                                "manual" => Ok(__FieldTag::__manual),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Trigger;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Trigger")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__schedule => {
                                if !fields.insert(__FieldTag::__schedule) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schedule",
                                    ));
                                }
                                if result.trigger.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `trigger`, a oneof with full ID .google.privacy.dlp.v2.JobTrigger.Trigger.schedule, latest field was schedule",
                                    ));
                                }
                                result.trigger = std::option::Option::Some(
                                    crate::model::job_trigger::trigger::Trigger::Schedule(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Schedule>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__manual => {
                                if !fields.insert(__FieldTag::__manual) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for manual",
                                    ));
                                }
                                if result.trigger.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `trigger`, a oneof with full ID .google.privacy.dlp.v2.JobTrigger.Trigger.manual, latest field was manual",
                                    ));
                                }
                                result.trigger = std::option::Option::Some(
                                    crate::model::job_trigger::trigger::Trigger::Manual(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Manual>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Trigger {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.schedule() {
                state.serialize_entry("schedule", value)?;
            }
            if let Some(value) = self.manual() {
                state.serialize_entry("manual", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Trigger].
    pub mod trigger {
        #[allow(unused_imports)]
        use super::*;

        /// What event needs to occur for a new job to be started.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Trigger {
            /// Create a job on a repeating basis based on the elapse of time.
            Schedule(std::boxed::Box<crate::model::Schedule>),
            /// For use with hybrid jobs. Jobs must be manually created and finished.
            Manual(std::boxed::Box<crate::model::Manual>),
        }
    }

    /// Whether the trigger is currently active. If PAUSED or CANCELLED, no jobs
    /// will be created with this configuration. The service may automatically
    /// pause triggers experiencing frequent errors. To restart a job, set the
    /// status to HEALTHY after correcting user errors.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Unused.
        Unspecified,
        /// Trigger is healthy.
        Healthy,
        /// Trigger is temporarily paused.
        Paused,
        /// Trigger is cancelled and can not be resumed.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Healthy => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Healthy => std::option::Option::Some("HEALTHY"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Healthy,
                2 => Self::Paused,
                3 => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "HEALTHY" => Self::Healthy,
                "PAUSED" => Self::Paused,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Healthy => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.privacy.dlp.v2.JobTrigger.Status",
            ))
        }
    }

    /// The configuration details for the specific type of job to run.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Job {
        /// For inspect jobs, a snapshot of the configuration.
        InspectJob(std::boxed::Box<crate::model::InspectJobConfig>),
    }
}

/// A task to execute on the completion of a job.
/// See <https://cloud.google.com/sensitive-data-protection/docs/concepts-actions>
/// to learn more.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Action {
    /// Extra events to execute after the job has finished.
    pub action: std::option::Option<crate::model::action::Action>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Action {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::Action::action].
    ///
    /// Note that all the setters affecting `action` are mutually
    /// exclusive.
    pub fn set_action<T: std::convert::Into<std::option::Option<crate::model::action::Action>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `SaveFindings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn save_findings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::SaveFindings>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::SaveFindings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `SaveFindings`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_save_findings<
        T: std::convert::Into<std::boxed::Box<crate::model::action::SaveFindings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::action::Action::SaveFindings(v.into()));
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PubSub`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pub_sub(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::PublishToPubSub>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PubSub(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PubSub`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_pub_sub<
        T: std::convert::Into<std::boxed::Box<crate::model::action::PublishToPubSub>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(crate::model::action::Action::PubSub(v.into()));
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PublishSummaryToCscc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn publish_summary_to_cscc(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::PublishSummaryToCscc>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PublishSummaryToCscc(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PublishSummaryToCscc`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_summary_to_cscc<
        T: std::convert::Into<std::boxed::Box<crate::model::action::PublishSummaryToCscc>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::action::Action::PublishSummaryToCscc(v.into()));
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PublishFindingsToCloudDataCatalog`, `None` if the field is not set or
    /// holds a different branch.
    pub fn publish_findings_to_cloud_data_catalog(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::action::PublishFindingsToCloudDataCatalog>,
    > {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PublishFindingsToCloudDataCatalog(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PublishFindingsToCloudDataCatalog`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_findings_to_cloud_data_catalog<
        T: std::convert::Into<
                std::boxed::Box<crate::model::action::PublishFindingsToCloudDataCatalog>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::action::Action::PublishFindingsToCloudDataCatalog(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `Deidentify`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deidentify(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::Deidentify>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::Deidentify(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `Deidentify`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_deidentify<
        T: std::convert::Into<std::boxed::Box<crate::model::action::Deidentify>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(crate::model::action::Action::Deidentify(v.into()));
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `JobNotificationEmails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn job_notification_emails(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::JobNotificationEmails>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::JobNotificationEmails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `JobNotificationEmails`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_job_notification_emails<
        T: std::convert::Into<std::boxed::Box<crate::model::action::JobNotificationEmails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::action::Action::JobNotificationEmails(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PublishToStackdriver`, `None` if the field is not set or
    /// holds a different branch.
    pub fn publish_to_stackdriver(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::PublishToStackdriver>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PublishToStackdriver(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PublishToStackdriver`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_to_stackdriver<
        T: std::convert::Into<std::boxed::Box<crate::model::action::PublishToStackdriver>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::action::Action::PublishToStackdriver(v.into()));
        self
    }
}

impl wkt::message::Message for Action {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Action"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Action {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __save_findings,
            __pub_sub,
            __publish_summary_to_cscc,
            __publish_findings_to_cloud_data_catalog,
            __deidentify,
            __job_notification_emails,
            __publish_to_stackdriver,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Action")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "saveFindings" => Ok(__FieldTag::__save_findings),
                            "save_findings" => Ok(__FieldTag::__save_findings),
                            "pubSub" => Ok(__FieldTag::__pub_sub),
                            "pub_sub" => Ok(__FieldTag::__pub_sub),
                            "publishSummaryToCscc" => Ok(__FieldTag::__publish_summary_to_cscc),
                            "publish_summary_to_cscc" => Ok(__FieldTag::__publish_summary_to_cscc),
                            "publishFindingsToCloudDataCatalog" => {
                                Ok(__FieldTag::__publish_findings_to_cloud_data_catalog)
                            }
                            "publish_findings_to_cloud_data_catalog" => {
                                Ok(__FieldTag::__publish_findings_to_cloud_data_catalog)
                            }
                            "deidentify" => Ok(__FieldTag::__deidentify),
                            "jobNotificationEmails" => Ok(__FieldTag::__job_notification_emails),
                            "job_notification_emails" => Ok(__FieldTag::__job_notification_emails),
                            "publishToStackdriver" => Ok(__FieldTag::__publish_to_stackdriver),
                            "publish_to_stackdriver" => Ok(__FieldTag::__publish_to_stackdriver),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Action;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Action")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__save_findings => {
                            if !fields.insert(__FieldTag::__save_findings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for save_findings",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.Action.save_findings, latest field was saveFindings",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::action::Action::SaveFindings(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::action::SaveFindings>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__pub_sub => {
                            if !fields.insert(__FieldTag::__pub_sub) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pub_sub",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.Action.pub_sub, latest field was pubSub",
                                ));
                            }
                            result.action =
                                std::option::Option::Some(crate::model::action::Action::PubSub(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::action::PublishToPubSub>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__publish_summary_to_cscc => {
                            if !fields.insert(__FieldTag::__publish_summary_to_cscc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publish_summary_to_cscc",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.Action.publish_summary_to_cscc, latest field was publishSummaryToCscc",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::action::Action::PublishSummaryToCscc(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::action::PublishSummaryToCscc>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__publish_findings_to_cloud_data_catalog => {
                            if !fields.insert(__FieldTag::__publish_findings_to_cloud_data_catalog)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publish_findings_to_cloud_data_catalog",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.Action.publish_findings_to_cloud_data_catalog, latest field was publishFindingsToCloudDataCatalog",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::action::Action::PublishFindingsToCloudDataCatalog(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::action::PublishFindingsToCloudDataCatalog,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__deidentify => {
                            if !fields.insert(__FieldTag::__deidentify) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.Action.deidentify, latest field was deidentify",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::action::Action::Deidentify(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::action::Deidentify>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__job_notification_emails => {
                            if !fields.insert(__FieldTag::__job_notification_emails) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_notification_emails",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.Action.job_notification_emails, latest field was jobNotificationEmails",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::action::Action::JobNotificationEmails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::action::JobNotificationEmails,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__publish_to_stackdriver => {
                            if !fields.insert(__FieldTag::__publish_to_stackdriver) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publish_to_stackdriver",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.Action.publish_to_stackdriver, latest field was publishToStackdriver",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::action::Action::PublishToStackdriver(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::action::PublishToStackdriver>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Action {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.save_findings() {
            state.serialize_entry("saveFindings", value)?;
        }
        if let Some(value) = self.pub_sub() {
            state.serialize_entry("pubSub", value)?;
        }
        if let Some(value) = self.publish_summary_to_cscc() {
            state.serialize_entry("publishSummaryToCscc", value)?;
        }
        if let Some(value) = self.publish_findings_to_cloud_data_catalog() {
            state.serialize_entry("publishFindingsToCloudDataCatalog", value)?;
        }
        if let Some(value) = self.deidentify() {
            state.serialize_entry("deidentify", value)?;
        }
        if let Some(value) = self.job_notification_emails() {
            state.serialize_entry("jobNotificationEmails", value)?;
        }
        if let Some(value) = self.publish_to_stackdriver() {
            state.serialize_entry("publishToStackdriver", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Action].
pub mod action {
    #[allow(unused_imports)]
    use super::*;

    /// If set, the detailed findings will be persisted to the specified
    /// OutputStorageConfig. Only a single instance of this action can be
    /// specified.
    /// Compatible with: Inspect, Risk
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SaveFindings {
        /// Location to store findings outside of DLP.
        pub output_config: std::option::Option<crate::model::OutputStorageConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SaveFindings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [output_config][crate::model::action::SaveFindings::output_config].
        pub fn set_output_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::OutputStorageConfig>,
        {
            self.output_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [output_config][crate::model::action::SaveFindings::output_config].
        pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::OutputStorageConfig>,
        {
            self.output_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SaveFindings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.SaveFindings"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SaveFindings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __output_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SaveFindings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "outputConfig" => Ok(__FieldTag::__output_config),
                                "output_config" => Ok(__FieldTag::__output_config),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SaveFindings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SaveFindings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__output_config => {
                                if !fields.insert(__FieldTag::__output_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for output_config",
                                    ));
                                }
                                result.output_config = map.next_value::<std::option::Option<crate::model::OutputStorageConfig>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SaveFindings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.output_config.is_some() {
                state.serialize_entry("outputConfig", &self.output_config)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Publish a message into a given Pub/Sub topic when DlpJob has completed. The
    /// message contains a single field, `DlpJobName`, which is equal to the
    /// finished job's
    /// [`DlpJob.name`](https://cloud.google.com/sensitive-data-protection/docs/reference/rest/v2/projects.dlpJobs#DlpJob).
    /// Compatible with: Inspect, Risk
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PublishToPubSub {
        /// Cloud Pub/Sub topic to send notifications to. The topic must have given
        /// publishing access rights to the DLP API service account executing
        /// the long running DlpJob sending the notifications.
        /// Format is projects/{project}/topics/{topic}.
        pub topic: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishToPubSub {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [topic][crate::model::action::PublishToPubSub::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }
    }

    impl wkt::message::Message for PublishToPubSub {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishToPubSub"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PublishToPubSub {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __topic,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PublishToPubSub")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "topic" => Ok(__FieldTag::__topic),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PublishToPubSub;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PublishToPubSub")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__topic => {
                                if !fields.insert(__FieldTag::__topic) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for topic",
                                    ));
                                }
                                result.topic = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PublishToPubSub {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.topic.is_empty() {
                state.serialize_entry("topic", &self.topic)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Publish the result summary of a DlpJob to [Security Command
    /// Center](https://cloud.google.com/security-command-center). This action is
    /// available for only projects that belong to an organization. This action
    /// publishes the count of finding instances and their infoTypes. The summary
    /// of findings are persisted in Security Command Center and are governed by
    /// [service-specific policies for Security Command
    /// Center](https://cloud.google.com/terms/service-terms). Only a single
    /// instance of this action can be specified. Compatible with: Inspect
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PublishSummaryToCscc {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishSummaryToCscc {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishSummaryToCscc {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishSummaryToCscc"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PublishSummaryToCscc {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PublishSummaryToCscc")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PublishSummaryToCscc;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PublishSummaryToCscc")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PublishSummaryToCscc {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Publish findings of a DlpJob to Data Catalog. In Data Catalog, tag
    /// templates are applied to the resource that Cloud DLP scanned. Data
    /// Catalog tag templates are stored in the same project and region where the
    /// BigQuery table exists. For Cloud DLP to create and apply the tag template,
    /// the Cloud DLP service agent must have the
    /// `roles/datacatalog.tagTemplateOwner` permission on the project. The tag
    /// template contains fields summarizing the results of the DlpJob. Any field
    /// values previously written by another DlpJob are deleted. [InfoType naming
    /// patterns][google.privacy.dlp.v2.InfoType] are strictly enforced when using
    /// this feature.
    ///
    /// Findings are persisted in Data Catalog storage and are governed by
    /// service-specific policies for Data Catalog. For more information, see
    /// [Service Specific Terms](https://cloud.google.com/terms/service-terms).
    ///
    /// Only a single instance of this action can be specified. This action is
    /// allowed only if all resources being scanned are BigQuery tables.
    /// Compatible with: Inspect
    ///
    /// [google.privacy.dlp.v2.InfoType]: crate::model::InfoType
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PublishFindingsToCloudDataCatalog {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishFindingsToCloudDataCatalog {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishFindingsToCloudDataCatalog {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishFindingsToCloudDataCatalog"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PublishFindingsToCloudDataCatalog {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter
                                .write_str("a field name for PublishFindingsToCloudDataCatalog")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PublishFindingsToCloudDataCatalog;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PublishFindingsToCloudDataCatalog")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PublishFindingsToCloudDataCatalog {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Create a de-identified copy of a storage bucket. Only compatible
    /// with Cloud Storage buckets.
    ///
    /// A TransformationDetail will be created for each transformation.
    ///
    /// Compatible with: Inspection of Cloud Storage
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Deidentify {
        /// User specified deidentify templates and configs for structured,
        /// unstructured, and image files.
        pub transformation_config: std::option::Option<crate::model::TransformationConfig>,

        /// Config for storing transformation details.
        ///
        /// This field specifies the configuration for storing detailed metadata
        /// about each transformation performed during a de-identification process.
        /// The metadata is stored separately from the de-identified content itself
        /// and provides a granular record of both successful transformations and any
        /// failures that occurred.
        ///
        /// Enabling this configuration is essential for users who need to access
        /// comprehensive information about the status, outcome, and specifics of
        /// each transformation. The details are captured in the
        /// [TransformationDetails][google.privacy.dlp.v2.TransformationDetails]
        /// message for each operation.
        ///
        /// Key use cases:
        ///
        /// * **Auditing and compliance**
        ///
        ///   * Provides a verifiable audit trail of de-identification activities,
        ///     which is crucial for meeting regulatory requirements and internal
        ///     data governance policies.
        ///   * Logs what data was transformed, what transformations were applied,
        ///     when they occurred, and their success status. This helps
        ///     demonstrate accountability and due diligence in protecting
        ///     sensitive data.
        /// * **Troubleshooting and debugging**
        ///
        ///   * Offers detailed error messages and context if a transformation
        ///     fails. This information is useful for diagnosing and resolving
        ///     issues in the de-identification pipeline.
        ///   * Helps pinpoint the exact location and nature of failures, speeding
        ///     up the debugging process.
        /// * **Process verification and quality assurance**
        ///
        ///   * Allows users to confirm that de-identification rules and
        ///     transformations were applied correctly and consistently across
        ///     the dataset as intended.
        ///   * Helps in verifying the effectiveness of the chosen
        ///     de-identification strategies.
        /// * **Data lineage and impact analysis**
        ///
        ///   * Creates a record of how data elements were modified, contributing
        ///     to data lineage. This is useful for understanding the provenance
        ///     of de-identified data.
        ///   * Aids in assessing the potential impact of de-identification choices
        ///     on downstream analytical processes or data usability.
        /// * **Reporting and operational insights**
        ///
        ///   * You can analyze the metadata stored in a queryable BigQuery table
        ///     to generate reports on transformation success rates, common
        ///     error types, processing volumes (e.g., transformedBytes), and the
        ///     types of transformations applied.
        ///   * These insights can inform optimization of de-identification
        ///     configurations and resource planning.
        ///
        /// To take advantage of these benefits, set this configuration. The stored
        /// details include a description of the transformation, success or
        /// error codes, error messages, the number of bytes transformed, the
        /// location of the transformed content, and identifiers for the job and
        /// source data.
        ///
        /// [google.privacy.dlp.v2.TransformationDetails]: crate::model::TransformationDetails
        pub transformation_details_storage_config:
            std::option::Option<crate::model::TransformationDetailsStorageConfig>,

        /// List of user-specified file type groups to transform. If specified, only
        /// the files with these file types will be transformed. If empty, all
        /// supported files will be transformed. Supported types may be automatically
        /// added over time. If a file type is set in this field that isn't supported
        /// by the Deidentify action then the job will fail and will not be
        /// successfully created/started. Currently the only file types supported
        /// are: IMAGES, TEXT_FILES, CSV, TSV.
        pub file_types_to_transform: std::vec::Vec<crate::model::FileType>,

        /// Where to store the output.
        pub output: std::option::Option<crate::model::action::deidentify::Output>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Deidentify {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [transformation_config][crate::model::action::Deidentify::transformation_config].
        pub fn set_transformation_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TransformationConfig>,
        {
            self.transformation_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [transformation_config][crate::model::action::Deidentify::transformation_config].
        pub fn set_or_clear_transformation_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TransformationConfig>,
        {
            self.transformation_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [transformation_details_storage_config][crate::model::action::Deidentify::transformation_details_storage_config].
        pub fn set_transformation_details_storage_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TransformationDetailsStorageConfig>,
        {
            self.transformation_details_storage_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [transformation_details_storage_config][crate::model::action::Deidentify::transformation_details_storage_config].
        pub fn set_or_clear_transformation_details_storage_config<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::TransformationDetailsStorageConfig>,
        {
            self.transformation_details_storage_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [file_types_to_transform][crate::model::action::Deidentify::file_types_to_transform].
        pub fn set_file_types_to_transform<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FileType>,
        {
            use std::iter::Iterator;
            self.file_types_to_transform = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [output][crate::model::action::Deidentify::output].
        ///
        /// Note that all the setters affecting `output` are mutually
        /// exclusive.
        pub fn set_output<
            T: std::convert::Into<std::option::Option<crate::model::action::deidentify::Output>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.output = v.into();
            self
        }

        /// The value of [output][crate::model::action::Deidentify::output]
        /// if it holds a `CloudStorageOutput`, `None` if the field is not set or
        /// holds a different branch.
        pub fn cloud_storage_output(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.output.as_ref().and_then(|v| match v {
                crate::model::action::deidentify::Output::CloudStorageOutput(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [output][crate::model::action::Deidentify::output]
        /// to hold a `CloudStorageOutput`.
        ///
        /// Note that all the setters affecting `output` are
        /// mutually exclusive.
        pub fn set_cloud_storage_output<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.output = std::option::Option::Some(
                crate::model::action::deidentify::Output::CloudStorageOutput(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Deidentify {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.Deidentify"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Deidentify {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __transformation_config,
                __transformation_details_storage_config,
                __cloud_storage_output,
                __file_types_to_transform,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Deidentify")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "transformationConfig" => Ok(__FieldTag::__transformation_config),
                                "transformation_config" => Ok(__FieldTag::__transformation_config),
                                "transformationDetailsStorageConfig" => {
                                    Ok(__FieldTag::__transformation_details_storage_config)
                                }
                                "transformation_details_storage_config" => {
                                    Ok(__FieldTag::__transformation_details_storage_config)
                                }
                                "cloudStorageOutput" => Ok(__FieldTag::__cloud_storage_output),
                                "cloud_storage_output" => Ok(__FieldTag::__cloud_storage_output),
                                "fileTypesToTransform" => Ok(__FieldTag::__file_types_to_transform),
                                "file_types_to_transform" => {
                                    Ok(__FieldTag::__file_types_to_transform)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Deidentify;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Deidentify")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__transformation_config => {
                                if !fields.insert(__FieldTag::__transformation_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for transformation_config",
                                    ));
                                }
                                result.transformation_config = map.next_value::<std::option::Option<crate::model::TransformationConfig>>()?
                                    ;
                            }
                            __FieldTag::__transformation_details_storage_config => {
                                if !fields
                                    .insert(__FieldTag::__transformation_details_storage_config)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for transformation_details_storage_config",
                                    ));
                                }
                                result.transformation_details_storage_config =
                                    map.next_value::<std::option::Option<
                                        crate::model::TransformationDetailsStorageConfig,
                                    >>()?;
                            }
                            __FieldTag::__cloud_storage_output => {
                                if !fields.insert(__FieldTag::__cloud_storage_output) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cloud_storage_output",
                                    ));
                                }
                                if result.output.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `output`, a oneof with full ID .google.privacy.dlp.v2.Action.Deidentify.cloud_storage_output, latest field was cloudStorageOutput",
                                    ));
                                }
                                result.output = std::option::Option::Some(
                                    crate::model::action::deidentify::Output::CloudStorageOutput(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__file_types_to_transform => {
                                if !fields.insert(__FieldTag::__file_types_to_transform) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for file_types_to_transform",
                                    ));
                                }
                                result.file_types_to_transform = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FileType>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Deidentify {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.transformation_config.is_some() {
                state.serialize_entry("transformationConfig", &self.transformation_config)?;
            }
            if self.transformation_details_storage_config.is_some() {
                state.serialize_entry(
                    "transformationDetailsStorageConfig",
                    &self.transformation_details_storage_config,
                )?;
            }
            if let Some(value) = self.cloud_storage_output() {
                state.serialize_entry("cloudStorageOutput", value)?;
            }
            if !self.file_types_to_transform.is_empty() {
                state.serialize_entry("fileTypesToTransform", &self.file_types_to_transform)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Deidentify].
    pub mod deidentify {
        #[allow(unused_imports)]
        use super::*;

        /// Where to store the output.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Output {
            /// Required. User settable Cloud Storage bucket and folders to store
            /// de-identified files. This field must be set for Cloud Storage
            /// deidentification. The output Cloud Storage bucket must be different
            /// from the input bucket. De-identified files will overwrite files in the
            /// output path.
            ///
            /// Form of: gs://bucket/folder/ or gs://bucket
            CloudStorageOutput(std::string::String),
        }
    }

    /// Sends an email when the job completes. The email goes to IAM project owners
    /// and technical [Essential
    /// Contacts](https://cloud.google.com/resource-manager/docs/managing-notification-contacts).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct JobNotificationEmails {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl JobNotificationEmails {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for JobNotificationEmails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.JobNotificationEmails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for JobNotificationEmails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for JobNotificationEmails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = JobNotificationEmails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct JobNotificationEmails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for JobNotificationEmails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Enable Stackdriver metric dlp.googleapis.com/finding_count. This
    /// will publish a metric to stack driver on each infotype requested and
    /// how many findings were found for it. CustomDetectors will be bucketed
    /// as 'Custom' under the Stackdriver label 'info_type'.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PublishToStackdriver {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishToStackdriver {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishToStackdriver {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishToStackdriver"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PublishToStackdriver {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PublishToStackdriver")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PublishToStackdriver;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PublishToStackdriver")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PublishToStackdriver {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Extra events to execute after the job has finished.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// Save resulting findings in a provided location.
        SaveFindings(std::boxed::Box<crate::model::action::SaveFindings>),
        /// Publish a notification to a Pub/Sub topic.
        PubSub(std::boxed::Box<crate::model::action::PublishToPubSub>),
        /// Publish summary to Cloud Security Command Center (Alpha).
        PublishSummaryToCscc(std::boxed::Box<crate::model::action::PublishSummaryToCscc>),
        /// Publish findings to Cloud Datahub.
        PublishFindingsToCloudDataCatalog(
            std::boxed::Box<crate::model::action::PublishFindingsToCloudDataCatalog>,
        ),
        /// Create a de-identified copy of the input data.
        Deidentify(std::boxed::Box<crate::model::action::Deidentify>),
        /// Sends an email when the job completes. The email goes to IAM project
        /// owners and technical [Essential
        /// Contacts](https://cloud.google.com/resource-manager/docs/managing-notification-contacts).
        JobNotificationEmails(std::boxed::Box<crate::model::action::JobNotificationEmails>),
        /// Enable Stackdriver metric dlp.googleapis.com/finding_count.
        PublishToStackdriver(std::boxed::Box<crate::model::action::PublishToStackdriver>),
    }
}

/// User specified templates and configs for how to deidentify structured,
/// unstructures, and image files. User must provide either a unstructured
/// deidentify template or at least one redact image config.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransformationConfig {
    /// De-identify template.
    /// If this template is specified, it will serve as the default de-identify
    /// template. This template cannot contain `record_transformations` since it
    /// can be used for unstructured content such as free-form text files. If this
    /// template is not set, a default `ReplaceWithInfoTypeConfig` will be used to
    /// de-identify unstructured content.
    pub deidentify_template: std::string::String,

    /// Structured de-identify template.
    /// If this template is specified, it will serve as the de-identify template
    /// for structured content such as delimited files and tables. If this template
    /// is not set but the `deidentify_template` is set, then `deidentify_template`
    /// will also apply to the structured content. If neither template is set, a
    /// default `ReplaceWithInfoTypeConfig` will be used to de-identify structured
    /// content.
    pub structured_deidentify_template: std::string::String,

    /// Image redact template.
    /// If this template is specified, it will serve as the de-identify template
    /// for images. If this template is not set, all findings in the image will be
    /// redacted with a black box.
    pub image_redact_template: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deidentify_template][crate::model::TransformationConfig::deidentify_template].
    pub fn set_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }

    /// Sets the value of [structured_deidentify_template][crate::model::TransformationConfig::structured_deidentify_template].
    pub fn set_structured_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.structured_deidentify_template = v.into();
        self
    }

    /// Sets the value of [image_redact_template][crate::model::TransformationConfig::image_redact_template].
    pub fn set_image_redact_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.image_redact_template = v.into();
        self
    }
}

impl wkt::message::Message for TransformationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransformationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deidentify_template,
            __structured_deidentify_template,
            __image_redact_template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransformationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deidentifyTemplate" => Ok(__FieldTag::__deidentify_template),
                            "deidentify_template" => Ok(__FieldTag::__deidentify_template),
                            "structuredDeidentifyTemplate" => {
                                Ok(__FieldTag::__structured_deidentify_template)
                            }
                            "structured_deidentify_template" => {
                                Ok(__FieldTag::__structured_deidentify_template)
                            }
                            "imageRedactTemplate" => Ok(__FieldTag::__image_redact_template),
                            "image_redact_template" => Ok(__FieldTag::__image_redact_template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransformationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransformationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deidentify_template => {
                            if !fields.insert(__FieldTag::__deidentify_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_template",
                                ));
                            }
                            result.deidentify_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__structured_deidentify_template => {
                            if !fields.insert(__FieldTag::__structured_deidentify_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for structured_deidentify_template",
                                ));
                            }
                            result.structured_deidentify_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_redact_template => {
                            if !fields.insert(__FieldTag::__image_redact_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_redact_template",
                                ));
                            }
                            result.image_redact_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransformationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.deidentify_template.is_empty() {
            state.serialize_entry("deidentifyTemplate", &self.deidentify_template)?;
        }
        if !self.structured_deidentify_template.is_empty() {
            state.serialize_entry(
                "structuredDeidentifyTemplate",
                &self.structured_deidentify_template,
            )?;
        }
        if !self.image_redact_template.is_empty() {
            state.serialize_entry("imageRedactTemplate", &self.image_redact_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateInspectTemplate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInspectTemplateRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Required. The InspectTemplate to create.
    pub inspect_template: std::option::Option<crate::model::InspectTemplate>,

    /// The template id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    pub template_id: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInspectTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [inspect_template][crate::model::CreateInspectTemplateRequest::inspect_template].
    pub fn set_inspect_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InspectTemplate>,
    {
        self.inspect_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_template][crate::model::CreateInspectTemplateRequest::inspect_template].
    pub fn set_or_clear_inspect_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InspectTemplate>,
    {
        self.inspect_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [template_id][crate::model::CreateInspectTemplateRequest::template_id].
    pub fn set_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateInspectTemplateRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateInspectTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInspectTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __inspect_template,
            __template_id,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInspectTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "inspectTemplate" => Ok(__FieldTag::__inspect_template),
                            "inspect_template" => Ok(__FieldTag::__inspect_template),
                            "templateId" => Ok(__FieldTag::__template_id),
                            "template_id" => Ok(__FieldTag::__template_id),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInspectTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInspectTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inspect_template => {
                            if !fields.insert(__FieldTag::__inspect_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template",
                                ));
                            }
                            result.inspect_template = map
                                .next_value::<std::option::Option<crate::model::InspectTemplate>>(
                                )?;
                        }
                        __FieldTag::__template_id => {
                            if !fields.insert(__FieldTag::__template_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template_id",
                                ));
                            }
                            result.template_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInspectTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.inspect_template.is_some() {
            state.serialize_entry("inspectTemplate", &self.inspect_template)?;
        }
        if !self.template_id.is_empty() {
            state.serialize_entry("templateId", &self.template_id)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateInspectTemplate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInspectTemplateRequest {
    /// Required. Resource name of organization and inspectTemplate to be updated,
    /// for example `organizations/433245324/inspectTemplates/432452342` or
    /// projects/project-id/inspectTemplates/432452342.
    pub name: std::string::String,

    /// New InspectTemplate value.
    pub inspect_template: std::option::Option<crate::model::InspectTemplate>,

    /// Mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateInspectTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [inspect_template][crate::model::UpdateInspectTemplateRequest::inspect_template].
    pub fn set_inspect_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InspectTemplate>,
    {
        self.inspect_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_template][crate::model::UpdateInspectTemplateRequest::inspect_template].
    pub fn set_or_clear_inspect_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InspectTemplate>,
    {
        self.inspect_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInspectTemplateRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInspectTemplateRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateInspectTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInspectTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __inspect_template,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInspectTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "inspectTemplate" => Ok(__FieldTag::__inspect_template),
                            "inspect_template" => Ok(__FieldTag::__inspect_template),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInspectTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInspectTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inspect_template => {
                            if !fields.insert(__FieldTag::__inspect_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template",
                                ));
                            }
                            result.inspect_template = map
                                .next_value::<std::option::Option<crate::model::InspectTemplate>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInspectTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.inspect_template.is_some() {
            state.serialize_entry("inspectTemplate", &self.inspect_template)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetInspectTemplate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInspectTemplateRequest {
    /// Required. Resource name of the organization and inspectTemplate to be read,
    /// for example `organizations/433245324/inspectTemplates/432452342` or
    /// projects/project-id/inspectTemplates/432452342.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInspectTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetInspectTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInspectTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInspectTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInspectTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInspectTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInspectTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListInspectTemplates.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInspectTemplatesRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to `ListInspectTemplates`.
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the template was created.
    /// - `update_time`: corresponds to the time the template was last updated.
    /// - `name`: corresponds to the template's name.
    /// - `display_name`: corresponds to the template's display name.
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInspectTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInspectTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInspectTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInspectTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInspectTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListInspectTemplatesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListInspectTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInspectTemplatesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInspectTemplatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            __order_by,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInspectTemplatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInspectTemplatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInspectTemplatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInspectTemplatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListInspectTemplates.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInspectTemplatesResponse {
    /// List of inspectTemplates, up to page_size in ListInspectTemplatesRequest.
    pub inspect_templates: std::vec::Vec<crate::model::InspectTemplate>,

    /// If the next page is available then the next page token to be used in the
    /// following ListInspectTemplates request.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInspectTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inspect_templates][crate::model::ListInspectTemplatesResponse::inspect_templates].
    pub fn set_inspect_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InspectTemplate>,
    {
        use std::iter::Iterator;
        self.inspect_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInspectTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInspectTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInspectTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInspectTemplatesResponse {
    type PageItem = crate::model::InspectTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.inspect_templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInspectTemplatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inspect_templates,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInspectTemplatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inspectTemplates" => Ok(__FieldTag::__inspect_templates),
                            "inspect_templates" => Ok(__FieldTag::__inspect_templates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInspectTemplatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInspectTemplatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inspect_templates => {
                            if !fields.insert(__FieldTag::__inspect_templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_templates",
                                ));
                            }
                            result.inspect_templates =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InspectTemplate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInspectTemplatesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.inspect_templates.is_empty() {
            state.serialize_entry("inspectTemplates", &self.inspect_templates)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteInspectTemplate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInspectTemplateRequest {
    /// Required. Resource name of the organization and inspectTemplate to be
    /// deleted, for example `organizations/433245324/inspectTemplates/432452342`
    /// or projects/project-id/inspectTemplates/432452342.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInspectTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteInspectTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteInspectTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteInspectTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteInspectTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteInspectTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteInspectTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateJobTrigger.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateJobTriggerRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Required. The JobTrigger to create.
    pub job_trigger: std::option::Option<crate::model::JobTrigger>,

    /// The trigger id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    pub trigger_id: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateJobTriggerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job_trigger][crate::model::CreateJobTriggerRequest::job_trigger].
    pub fn set_job_trigger<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::JobTrigger>,
    {
        self.job_trigger = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job_trigger][crate::model::CreateJobTriggerRequest::job_trigger].
    pub fn set_or_clear_job_trigger<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::JobTrigger>,
    {
        self.job_trigger = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trigger_id][crate::model::CreateJobTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateJobTriggerRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateJobTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateJobTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __job_trigger,
            __trigger_id,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateJobTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "jobTrigger" => Ok(__FieldTag::__job_trigger),
                            "job_trigger" => Ok(__FieldTag::__job_trigger),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateJobTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateJobTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_trigger => {
                            if !fields.insert(__FieldTag::__job_trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_trigger",
                                ));
                            }
                            result.job_trigger =
                                map.next_value::<std::option::Option<crate::model::JobTrigger>>()?;
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateJobTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.job_trigger.is_some() {
            state.serialize_entry("jobTrigger", &self.job_trigger)?;
        }
        if !self.trigger_id.is_empty() {
            state.serialize_entry("triggerId", &self.trigger_id)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ActivateJobTrigger.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ActivateJobTriggerRequest {
    /// Required. Resource name of the trigger to activate, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ActivateJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ActivateJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ActivateJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ActivateJobTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ActivateJobTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ActivateJobTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ActivateJobTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ActivateJobTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ActivateJobTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateJobTrigger.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateJobTriggerRequest {
    /// Required. Resource name of the project and the triggeredJob, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    pub name: std::string::String,

    /// New JobTrigger value.
    pub job_trigger: std::option::Option<crate::model::JobTrigger>,

    /// Mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [job_trigger][crate::model::UpdateJobTriggerRequest::job_trigger].
    pub fn set_job_trigger<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::JobTrigger>,
    {
        self.job_trigger = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job_trigger][crate::model::UpdateJobTriggerRequest::job_trigger].
    pub fn set_or_clear_job_trigger<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::JobTrigger>,
    {
        self.job_trigger = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateJobTriggerRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateJobTriggerRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateJobTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateJobTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __job_trigger,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateJobTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "jobTrigger" => Ok(__FieldTag::__job_trigger),
                            "job_trigger" => Ok(__FieldTag::__job_trigger),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateJobTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateJobTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_trigger => {
                            if !fields.insert(__FieldTag::__job_trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_trigger",
                                ));
                            }
                            result.job_trigger =
                                map.next_value::<std::option::Option<crate::model::JobTrigger>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateJobTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.job_trigger.is_some() {
            state.serialize_entry("jobTrigger", &self.job_trigger)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetJobTrigger.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetJobTriggerRequest {
    /// Required. Resource name of the project and the triggeredJob, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetJobTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetJobTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJobTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetJobTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJobTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetJobTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateDiscoveryConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDiscoveryConfigRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization):
    ///
    /// + Projects scope:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Organizations scope:
    ///   `organizations/{org_id}/locations/{location_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Required. The DiscoveryConfig to create.
    pub discovery_config: std::option::Option<crate::model::DiscoveryConfig>,

    /// The config ID can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    pub config_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDiscoveryConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [discovery_config][crate::model::CreateDiscoveryConfigRequest::discovery_config].
    pub fn set_discovery_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryConfig>,
    {
        self.discovery_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [discovery_config][crate::model::CreateDiscoveryConfigRequest::discovery_config].
    pub fn set_or_clear_discovery_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryConfig>,
    {
        self.discovery_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_id][crate::model::CreateDiscoveryConfigRequest::config_id].
    pub fn set_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateDiscoveryConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDiscoveryConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __discovery_config,
            __config_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDiscoveryConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "discoveryConfig" => Ok(__FieldTag::__discovery_config),
                            "discovery_config" => Ok(__FieldTag::__discovery_config),
                            "configId" => Ok(__FieldTag::__config_id),
                            "config_id" => Ok(__FieldTag::__config_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDiscoveryConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDiscoveryConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__discovery_config => {
                            if !fields.insert(__FieldTag::__discovery_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_config",
                                ));
                            }
                            result.discovery_config = map
                                .next_value::<std::option::Option<crate::model::DiscoveryConfig>>(
                                )?;
                        }
                        __FieldTag::__config_id => {
                            if !fields.insert(__FieldTag::__config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_id",
                                ));
                            }
                            result.config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDiscoveryConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.discovery_config.is_some() {
            state.serialize_entry("discoveryConfig", &self.discovery_config)?;
        }
        if !self.config_id.is_empty() {
            state.serialize_entry("configId", &self.config_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateDiscoveryConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDiscoveryConfigRequest {
    /// Required. Resource name of the project and the configuration, for example
    /// `projects/dlp-test-project/discoveryConfigs/53234423`.
    pub name: std::string::String,

    /// Required. New DiscoveryConfig value.
    pub discovery_config: std::option::Option<crate::model::DiscoveryConfig>,

    /// Mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateDiscoveryConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [discovery_config][crate::model::UpdateDiscoveryConfigRequest::discovery_config].
    pub fn set_discovery_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryConfig>,
    {
        self.discovery_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [discovery_config][crate::model::UpdateDiscoveryConfigRequest::discovery_config].
    pub fn set_or_clear_discovery_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryConfig>,
    {
        self.discovery_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDiscoveryConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDiscoveryConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateDiscoveryConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDiscoveryConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __discovery_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDiscoveryConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "discoveryConfig" => Ok(__FieldTag::__discovery_config),
                            "discovery_config" => Ok(__FieldTag::__discovery_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDiscoveryConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDiscoveryConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__discovery_config => {
                            if !fields.insert(__FieldTag::__discovery_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_config",
                                ));
                            }
                            result.discovery_config = map
                                .next_value::<std::option::Option<crate::model::DiscoveryConfig>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDiscoveryConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.discovery_config.is_some() {
            state.serialize_entry("discoveryConfig", &self.discovery_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetDiscoveryConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDiscoveryConfigRequest {
    /// Required. Resource name of the project and the configuration, for example
    /// `projects/dlp-test-project/discoveryConfigs/53234423`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDiscoveryConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetDiscoveryConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDiscoveryConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDiscoveryConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDiscoveryConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDiscoveryConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDiscoveryConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListDiscoveryConfigs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDiscoveryConfigsRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value is as follows:
    /// `projects/{project_id}/locations/{location_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to ListDiscoveryConfigs. `order_by` field must not
    /// change for subsequent calls.
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by a server.
    pub page_size: i32,

    /// Comma-separated list of config fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `last_run_time`: corresponds to the last time the DiscoveryConfig ran.
    /// - `name`: corresponds to the DiscoveryConfig's name.
    /// - `status`: corresponds to DiscoveryConfig's status.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDiscoveryConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDiscoveryConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDiscoveryConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDiscoveryConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDiscoveryConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDiscoveryConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDiscoveryConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDiscoveryConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDiscoveryConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDiscoveryConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDiscoveryConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDiscoveryConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListDiscoveryConfigs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDiscoveryConfigsResponse {
    /// List of configs, up to page_size in ListDiscoveryConfigsRequest.
    pub discovery_configs: std::vec::Vec<crate::model::DiscoveryConfig>,

    /// If the next page is available then this value is the next page token to be
    /// used in the following ListDiscoveryConfigs request.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDiscoveryConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [discovery_configs][crate::model::ListDiscoveryConfigsResponse::discovery_configs].
    pub fn set_discovery_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveryConfig>,
    {
        use std::iter::Iterator;
        self.discovery_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDiscoveryConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDiscoveryConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDiscoveryConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDiscoveryConfigsResponse {
    type PageItem = crate::model::DiscoveryConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.discovery_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDiscoveryConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __discovery_configs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDiscoveryConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "discoveryConfigs" => Ok(__FieldTag::__discovery_configs),
                            "discovery_configs" => Ok(__FieldTag::__discovery_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDiscoveryConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDiscoveryConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__discovery_configs => {
                            if !fields.insert(__FieldTag::__discovery_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_configs",
                                ));
                            }
                            result.discovery_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DiscoveryConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDiscoveryConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.discovery_configs.is_empty() {
            state.serialize_entry("discoveryConfigs", &self.discovery_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteDiscoveryConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDiscoveryConfigRequest {
    /// Required. Resource name of the project and the config, for example
    /// `projects/dlp-test-project/discoveryConfigs/53234423`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDiscoveryConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteDiscoveryConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDiscoveryConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDiscoveryConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDiscoveryConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDiscoveryConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDiscoveryConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateDlpJobRequest. Used to initiate long running
/// jobs such as calculating risk metrics or inspecting Google Cloud
/// Storage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDlpJobRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// The job id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    pub job_id: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    /// The configuration details for the specific type of job to run.
    pub job: std::option::Option<crate::model::create_dlp_job_request::Job>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDlpJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::CreateDlpJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateDlpJobRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [job][crate::model::CreateDlpJobRequest::job].
    ///
    /// Note that all the setters affecting `job` are mutually
    /// exclusive.
    pub fn set_job<
        T: std::convert::Into<std::option::Option<crate::model::create_dlp_job_request::Job>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }

    /// The value of [job][crate::model::CreateDlpJobRequest::job]
    /// if it holds a `InspectJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inspect_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InspectJobConfig>> {
        #[allow(unreachable_patterns)]
        self.job.as_ref().and_then(|v| match v {
            crate::model::create_dlp_job_request::Job::InspectJob(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job][crate::model::CreateDlpJobRequest::job]
    /// to hold a `InspectJob`.
    ///
    /// Note that all the setters affecting `job` are
    /// mutually exclusive.
    pub fn set_inspect_job<
        T: std::convert::Into<std::boxed::Box<crate::model::InspectJobConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job = std::option::Option::Some(
            crate::model::create_dlp_job_request::Job::InspectJob(v.into()),
        );
        self
    }

    /// The value of [job][crate::model::CreateDlpJobRequest::job]
    /// if it holds a `RiskJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn risk_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RiskAnalysisJobConfig>> {
        #[allow(unreachable_patterns)]
        self.job.as_ref().and_then(|v| match v {
            crate::model::create_dlp_job_request::Job::RiskJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job][crate::model::CreateDlpJobRequest::job]
    /// to hold a `RiskJob`.
    ///
    /// Note that all the setters affecting `job` are
    /// mutually exclusive.
    pub fn set_risk_job<
        T: std::convert::Into<std::boxed::Box<crate::model::RiskAnalysisJobConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job =
            std::option::Option::Some(crate::model::create_dlp_job_request::Job::RiskJob(v.into()));
        self
    }
}

impl wkt::message::Message for CreateDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateDlpJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDlpJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __inspect_job,
            __risk_job,
            __job_id,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDlpJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "inspectJob" => Ok(__FieldTag::__inspect_job),
                            "inspect_job" => Ok(__FieldTag::__inspect_job),
                            "riskJob" => Ok(__FieldTag::__risk_job),
                            "risk_job" => Ok(__FieldTag::__risk_job),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDlpJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDlpJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inspect_job => {
                            if !fields.insert(__FieldTag::__inspect_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_job",
                                ));
                            }
                            if result.job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job`, a oneof with full ID .google.privacy.dlp.v2.CreateDlpJobRequest.inspect_job, latest field was inspectJob",
                                ));
                            }
                            result.job = std::option::Option::Some(
                                crate::model::create_dlp_job_request::Job::InspectJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InspectJobConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__risk_job => {
                            if !fields.insert(__FieldTag::__risk_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for risk_job",
                                ));
                            }
                            if result.job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job`, a oneof with full ID .google.privacy.dlp.v2.CreateDlpJobRequest.risk_job, latest field was riskJob",
                                ));
                            }
                            result.job = std::option::Option::Some(
                                crate::model::create_dlp_job_request::Job::RiskJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RiskAnalysisJobConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDlpJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.inspect_job() {
            state.serialize_entry("inspectJob", value)?;
        }
        if let Some(value) = self.risk_job() {
            state.serialize_entry("riskJob", value)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CreateDlpJobRequest].
pub mod create_dlp_job_request {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration details for the specific type of job to run.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Job {
        /// An inspection job scans a storage repository for InfoTypes.
        InspectJob(std::boxed::Box<crate::model::InspectJobConfig>),
        /// A risk analysis job calculates re-identification risk metrics for a
        /// BigQuery table.
        RiskJob(std::boxed::Box<crate::model::RiskAnalysisJobConfig>),
    }
}

/// Request message for ListJobTriggers.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobTriggersRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to ListJobTriggers. `order_by` field must not
    /// change for subsequent calls.
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by a server.
    pub page_size: i32,

    /// Comma-separated list of triggeredJob fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the JobTrigger was created.
    /// - `update_time`: corresponds to the time the JobTrigger was last updated.
    /// - `last_run_time`: corresponds to the last time the JobTrigger ran.
    /// - `name`: corresponds to the JobTrigger's name.
    /// - `display_name`: corresponds to the JobTrigger's display name.
    /// - `status`: corresponds to JobTrigger's status.
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values for inspect triggers:
    ///   - `status` - HEALTHY|PAUSED|CANCELLED
    ///   - `inspected_storage` - DATASTORE|CLOUD_STORAGE|BIGQUERY
    ///   - 'last_run_time` - RFC 3339 formatted timestamp, surrounded by
    ///     quotation marks. Nanoseconds are ignored.
    ///   - 'error_count' - Number of errors that have occurred while running.
    /// * The operator must be `=` or `!=` for status and inspected_storage.
    ///
    /// Examples:
    ///
    /// * inspected_storage = cloud_storage AND status = HEALTHY
    /// * inspected_storage = cloud_storage OR inspected_storage = bigquery
    /// * inspected_storage = cloud_storage AND (state = PAUSED OR state = HEALTHY)
    /// * last_run_time > \"2017-12-12T00:00:00+00:00\"
    ///
    /// The length of this field should be no more than 500 characters.
    pub filter: std::string::String,

    /// The type of jobs. Will use `DlpJobType.INSPECT` if not set.
    pub r#type: crate::model::DlpJobType,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobTriggersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListJobTriggersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobTriggersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobTriggersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListJobTriggersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListJobTriggersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ListJobTriggersRequest::type].
    pub fn set_type<T: std::convert::Into<crate::model::DlpJobType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListJobTriggersRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListJobTriggersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListJobTriggersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobTriggersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            __order_by,
            __filter,
            __type,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobTriggersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            "type" => Ok(__FieldTag::__type),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobTriggersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobTriggersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::DlpJobType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobTriggersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListJobTriggers.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobTriggersResponse {
    /// List of triggeredJobs, up to page_size in ListJobTriggersRequest.
    pub job_triggers: std::vec::Vec<crate::model::JobTrigger>,

    /// If the next page is available then this value is the next page token to be
    /// used in the following ListJobTriggers request.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobTriggersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_triggers][crate::model::ListJobTriggersResponse::job_triggers].
    pub fn set_job_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobTrigger>,
    {
        use std::iter::Iterator;
        self.job_triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListJobTriggersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListJobTriggersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListJobTriggersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobTriggersResponse {
    type PageItem = crate::model::JobTrigger;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.job_triggers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobTriggersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_triggers,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobTriggersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobTriggers" => Ok(__FieldTag::__job_triggers),
                            "job_triggers" => Ok(__FieldTag::__job_triggers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobTriggersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobTriggersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_triggers => {
                            if !fields.insert(__FieldTag::__job_triggers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_triggers",
                                ));
                            }
                            result.job_triggers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::JobTrigger>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobTriggersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_triggers.is_empty() {
            state.serialize_entry("jobTriggers", &self.job_triggers)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteJobTrigger.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteJobTriggerRequest {
    /// Required. Resource name of the project and the triggeredJob, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteJobTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteJobTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteJobTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteJobTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteJobTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteJobTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Controls what and how to inspect for findings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InspectJobConfig {
    /// The data to scan.
    pub storage_config: std::option::Option<crate::model::StorageConfig>,

    /// How and what to scan for.
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// If provided, will be used as the default for all values in InspectConfig.
    /// `inspect_config` will be merged into the values persisted as part of the
    /// template.
    pub inspect_template_name: std::string::String,

    /// Actions to execute at the completion of the job.
    pub actions: std::vec::Vec<crate::model::Action>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectJobConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_config][crate::model::InspectJobConfig::storage_config].
    pub fn set_storage_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StorageConfig>,
    {
        self.storage_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [storage_config][crate::model::InspectJobConfig::storage_config].
    pub fn set_or_clear_storage_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StorageConfig>,
    {
        self.storage_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_config][crate::model::InspectJobConfig::inspect_config].
    pub fn set_inspect_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_config][crate::model::InspectJobConfig::inspect_config].
    pub fn set_or_clear_inspect_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::InspectJobConfig::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [actions][crate::model::InspectJobConfig::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Action>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InspectJobConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectJobConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InspectJobConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __storage_config,
            __inspect_config,
            __inspect_template_name,
            __actions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InspectJobConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "storageConfig" => Ok(__FieldTag::__storage_config),
                            "storage_config" => Ok(__FieldTag::__storage_config),
                            "inspectConfig" => Ok(__FieldTag::__inspect_config),
                            "inspect_config" => Ok(__FieldTag::__inspect_config),
                            "inspectTemplateName" => Ok(__FieldTag::__inspect_template_name),
                            "inspect_template_name" => Ok(__FieldTag::__inspect_template_name),
                            "actions" => Ok(__FieldTag::__actions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InspectJobConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InspectJobConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__storage_config => {
                            if !fields.insert(__FieldTag::__storage_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_config",
                                ));
                            }
                            result.storage_config = map
                                .next_value::<std::option::Option<crate::model::StorageConfig>>()?;
                        }
                        __FieldTag::__inspect_config => {
                            if !fields.insert(__FieldTag::__inspect_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_config",
                                ));
                            }
                            result.inspect_config = map
                                .next_value::<std::option::Option<crate::model::InspectConfig>>()?;
                        }
                        __FieldTag::__inspect_template_name => {
                            if !fields.insert(__FieldTag::__inspect_template_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template_name",
                                ));
                            }
                            result.inspect_template_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Action>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InspectJobConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.storage_config.is_some() {
            state.serialize_entry("storageConfig", &self.storage_config)?;
        }
        if self.inspect_config.is_some() {
            state.serialize_entry("inspectConfig", &self.inspect_config)?;
        }
        if !self.inspect_template_name.is_empty() {
            state.serialize_entry("inspectTemplateName", &self.inspect_template_name)?;
        }
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A task to execute when a data profile has been generated.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfileAction {
    /// Type of action to execute when a profile is generated.
    pub action: std::option::Option<crate::model::data_profile_action::Action>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action].
    ///
    /// Note that all the setters affecting `action` are mutually
    /// exclusive.
    pub fn set_action<
        T: std::convert::Into<std::option::Option<crate::model::data_profile_action::Action>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `ExportData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn export_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::Export>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::ExportData(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `ExportData`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_export_data<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::Export>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::ExportData(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `PubSubNotification`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pub_sub_notification(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::PubSubNotification>>
    {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::PubSubNotification(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `PubSubNotification`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_pub_sub_notification<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::PubSubNotification>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::PubSubNotification(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `PublishToChronicle`, `None` if the field is not set or
    /// holds a different branch.
    pub fn publish_to_chronicle(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::PublishToChronicle>>
    {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::PublishToChronicle(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `PublishToChronicle`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_to_chronicle<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::PublishToChronicle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::PublishToChronicle(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `PublishToScc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn publish_to_scc(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_profile_action::PublishToSecurityCommandCenter>,
    > {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::PublishToScc(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `PublishToScc`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_to_scc<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_profile_action::PublishToSecurityCommandCenter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::PublishToScc(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `TagResources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tag_resources(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::TagResources>>
    {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::TagResources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `TagResources`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_tag_resources<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::TagResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::TagResources(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `PublishToDataplexCatalog`, `None` if the field is not set or
    /// holds a different branch.
    pub fn publish_to_dataplex_catalog(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_profile_action::PublishToDataplexCatalog>,
    > {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::PublishToDataplexCatalog(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `PublishToDataplexCatalog`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_to_dataplex_catalog<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_profile_action::PublishToDataplexCatalog>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::PublishToDataplexCatalog(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataProfileAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfileAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __export_data,
            __pub_sub_notification,
            __publish_to_chronicle,
            __publish_to_scc,
            __tag_resources,
            __publish_to_dataplex_catalog,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfileAction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "exportData" => Ok(__FieldTag::__export_data),
                            "export_data" => Ok(__FieldTag::__export_data),
                            "pubSubNotification" => Ok(__FieldTag::__pub_sub_notification),
                            "pub_sub_notification" => Ok(__FieldTag::__pub_sub_notification),
                            "publishToChronicle" => Ok(__FieldTag::__publish_to_chronicle),
                            "publish_to_chronicle" => Ok(__FieldTag::__publish_to_chronicle),
                            "publishToScc" => Ok(__FieldTag::__publish_to_scc),
                            "publish_to_scc" => Ok(__FieldTag::__publish_to_scc),
                            "tagResources" => Ok(__FieldTag::__tag_resources),
                            "tag_resources" => Ok(__FieldTag::__tag_resources),
                            "publishToDataplexCatalog" => {
                                Ok(__FieldTag::__publish_to_dataplex_catalog)
                            }
                            "publish_to_dataplex_catalog" => {
                                Ok(__FieldTag::__publish_to_dataplex_catalog)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfileAction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfileAction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__export_data => {
                            if !fields.insert(__FieldTag::__export_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_data",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.DataProfileAction.export_data, latest field was exportData",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::data_profile_action::Action::ExportData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::data_profile_action::Export>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__pub_sub_notification => {
                            if !fields.insert(__FieldTag::__pub_sub_notification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pub_sub_notification",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.DataProfileAction.pub_sub_notification, latest field was pubSubNotification",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::data_profile_action::Action::PubSubNotification(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_profile_action::PubSubNotification,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__publish_to_chronicle => {
                            if !fields.insert(__FieldTag::__publish_to_chronicle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publish_to_chronicle",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.DataProfileAction.publish_to_chronicle, latest field was publishToChronicle",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::data_profile_action::Action::PublishToChronicle(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_profile_action::PublishToChronicle,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__publish_to_scc => {
                            if !fields.insert(__FieldTag::__publish_to_scc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publish_to_scc",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.DataProfileAction.publish_to_scc, latest field was publishToScc",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::data_profile_action::Action::PublishToScc(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::data_profile_action::PublishToSecurityCommandCenter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__tag_resources => {
                            if !fields.insert(__FieldTag::__tag_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_resources",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.DataProfileAction.tag_resources, latest field was tagResources",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::data_profile_action::Action::TagResources(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::data_profile_action::TagResources,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__publish_to_dataplex_catalog => {
                            if !fields.insert(__FieldTag::__publish_to_dataplex_catalog) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publish_to_dataplex_catalog",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.privacy.dlp.v2.DataProfileAction.publish_to_dataplex_catalog, latest field was publishToDataplexCatalog",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::data_profile_action::Action::PublishToDataplexCatalog(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::data_profile_action::PublishToDataplexCatalog>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfileAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.export_data() {
            state.serialize_entry("exportData", value)?;
        }
        if let Some(value) = self.pub_sub_notification() {
            state.serialize_entry("pubSubNotification", value)?;
        }
        if let Some(value) = self.publish_to_chronicle() {
            state.serialize_entry("publishToChronicle", value)?;
        }
        if let Some(value) = self.publish_to_scc() {
            state.serialize_entry("publishToScc", value)?;
        }
        if let Some(value) = self.tag_resources() {
            state.serialize_entry("tagResources", value)?;
        }
        if let Some(value) = self.publish_to_dataplex_catalog() {
            state.serialize_entry("publishToDataplexCatalog", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataProfileAction].
pub mod data_profile_action {
    #[allow(unused_imports)]
    use super::*;

    /// If set, the detailed data profiles will be persisted to the location
    /// of your choice whenever updated.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Export {
        /// Store all profiles to BigQuery.
        ///
        /// * The system will create a new dataset and table for you if none are
        ///   are provided. The dataset will be named
        ///   `sensitive_data_protection_discovery` and table will be named
        ///   `discovery_profiles`. This table will be placed in the same project as
        ///   the container project running the scan. After the first profile is
        ///   generated and the dataset and table are created, the discovery scan
        ///   configuration will be updated with the dataset and table names.
        /// * See [Analyze data profiles stored in
        ///   BigQuery](https://cloud.google.com/sensitive-data-protection/docs/analyze-data-profiles).
        /// * See [Sample queries for your BigQuery
        ///   table](https://cloud.google.com/sensitive-data-protection/docs/analyze-data-profiles#sample_sql_queries).
        /// * Data is inserted using [streaming
        ///   insert](https://cloud.google.com/blog/products/bigquery/life-of-a-bigquery-streaming-insert)
        ///   and so data may be in the buffer for a period of time after the
        ///   profile has finished.
        /// * The Pub/Sub notification is sent before the streaming buffer is
        ///   guaranteed to be written, so data may not be instantly
        ///   visible to queries by the time your topic receives the Pub/Sub
        ///   notification.
        /// * The best practice is to use the same table for an entire organization
        ///   so that you can take advantage of the [provided Looker
        ///   reports](https://cloud.google.com/sensitive-data-protection/docs/analyze-data-profiles#use_a_premade_report).
        ///   If you use VPC Service Controls to define security perimeters, then
        ///   you must use a separate table for each boundary.
        pub profile_table: std::option::Option<crate::model::BigQueryTable>,

        /// Store sample [data profile
        /// findings][google.privacy.dlp.v2.DataProfileFinding] in an existing table
        /// or a new table in an existing dataset. Each regeneration will result in
        /// new rows in BigQuery. Data is inserted using [streaming
        /// insert](https://cloud.google.com/blog/products/bigquery/life-of-a-bigquery-streaming-insert)
        /// and so data may be in the buffer for a period of time after the profile
        /// has finished.
        ///
        /// [google.privacy.dlp.v2.DataProfileFinding]: crate::model::DataProfileFinding
        pub sample_findings_table: std::option::Option<crate::model::BigQueryTable>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Export {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [profile_table][crate::model::data_profile_action::Export::profile_table].
        pub fn set_profile_table<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::BigQueryTable>,
        {
            self.profile_table = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [profile_table][crate::model::data_profile_action::Export::profile_table].
        pub fn set_or_clear_profile_table<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::BigQueryTable>,
        {
            self.profile_table = v.map(|x| x.into());
            self
        }

        /// Sets the value of [sample_findings_table][crate::model::data_profile_action::Export::sample_findings_table].
        pub fn set_sample_findings_table<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::BigQueryTable>,
        {
            self.sample_findings_table = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [sample_findings_table][crate::model::data_profile_action::Export::sample_findings_table].
        pub fn set_or_clear_sample_findings_table<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::BigQueryTable>,
        {
            self.sample_findings_table = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Export {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.Export"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Export {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __profile_table,
                __sample_findings_table,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Export")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "profileTable" => Ok(__FieldTag::__profile_table),
                                "profile_table" => Ok(__FieldTag::__profile_table),
                                "sampleFindingsTable" => Ok(__FieldTag::__sample_findings_table),
                                "sample_findings_table" => Ok(__FieldTag::__sample_findings_table),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Export;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Export")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__profile_table => {
                                if !fields.insert(__FieldTag::__profile_table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for profile_table",
                                    ));
                                }
                                result.profile_table = map
                                    .next_value::<std::option::Option<crate::model::BigQueryTable>>(
                                    )?;
                            }
                            __FieldTag::__sample_findings_table => {
                                if !fields.insert(__FieldTag::__sample_findings_table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sample_findings_table",
                                    ));
                                }
                                result.sample_findings_table = map
                                    .next_value::<std::option::Option<crate::model::BigQueryTable>>(
                                    )?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Export {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.profile_table.is_some() {
                state.serialize_entry("profileTable", &self.profile_table)?;
            }
            if self.sample_findings_table.is_some() {
                state.serialize_entry("sampleFindingsTable", &self.sample_findings_table)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Send a Pub/Sub message into the given Pub/Sub topic to connect other
    /// systems to data profile generation. The message payload data will
    /// be the byte serialization of `DataProfilePubSubMessage`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PubSubNotification {
        /// Cloud Pub/Sub topic to send notifications to.
        /// Format is projects/{project}/topics/{topic}.
        pub topic: std::string::String,

        /// The type of event that triggers a Pub/Sub. At most one
        /// `PubSubNotification` per EventType is permitted.
        pub event: crate::model::data_profile_action::EventType,

        /// Conditions (e.g., data risk or sensitivity level) for triggering a
        /// Pub/Sub.
        pub pubsub_condition: std::option::Option<crate::model::DataProfilePubSubCondition>,

        /// How much data to include in the Pub/Sub message. If the user wishes to
        /// limit the size of the message, they can use resource_name and fetch the
        /// profile fields they wish to. Per table profile (not per column).
        pub detail_of_message: crate::model::data_profile_action::pub_sub_notification::DetailLevel,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PubSubNotification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [topic][crate::model::data_profile_action::PubSubNotification::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }

        /// Sets the value of [event][crate::model::data_profile_action::PubSubNotification::event].
        pub fn set_event<T: std::convert::Into<crate::model::data_profile_action::EventType>>(
            mut self,
            v: T,
        ) -> Self {
            self.event = v.into();
            self
        }

        /// Sets the value of [pubsub_condition][crate::model::data_profile_action::PubSubNotification::pubsub_condition].
        pub fn set_pubsub_condition<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::DataProfilePubSubCondition>,
        {
            self.pubsub_condition = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [pubsub_condition][crate::model::data_profile_action::PubSubNotification::pubsub_condition].
        pub fn set_or_clear_pubsub_condition<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::DataProfilePubSubCondition>,
        {
            self.pubsub_condition = v.map(|x| x.into());
            self
        }

        /// Sets the value of [detail_of_message][crate::model::data_profile_action::PubSubNotification::detail_of_message].
        pub fn set_detail_of_message<
            T: std::convert::Into<
                    crate::model::data_profile_action::pub_sub_notification::DetailLevel,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.detail_of_message = v.into();
            self
        }
    }

    impl wkt::message::Message for PubSubNotification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.PubSubNotification"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PubSubNotification {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __topic,
                __event,
                __pubsub_condition,
                __detail_of_message,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PubSubNotification")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "topic" => Ok(__FieldTag::__topic),
                                "event" => Ok(__FieldTag::__event),
                                "pubsubCondition" => Ok(__FieldTag::__pubsub_condition),
                                "pubsub_condition" => Ok(__FieldTag::__pubsub_condition),
                                "detailOfMessage" => Ok(__FieldTag::__detail_of_message),
                                "detail_of_message" => Ok(__FieldTag::__detail_of_message),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PubSubNotification;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PubSubNotification")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__topic => {
                                if !fields.insert(__FieldTag::__topic) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for topic",
                                    ));
                                }
                                result.topic = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__event => {
                                if !fields.insert(__FieldTag::__event) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for event",
                                    ));
                                }
                                result.event = map
                                    .next_value::<std::option::Option<
                                        crate::model::data_profile_action::EventType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__pubsub_condition => {
                                if !fields.insert(__FieldTag::__pubsub_condition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pubsub_condition",
                                    ));
                                }
                                result.pubsub_condition =
                                    map.next_value::<std::option::Option<
                                        crate::model::DataProfilePubSubCondition,
                                    >>()?;
                            }
                            __FieldTag::__detail_of_message => {
                                if !fields.insert(__FieldTag::__detail_of_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for detail_of_message",
                                    ));
                                }
                                result.detail_of_message = map.next_value::<std::option::Option<crate::model::data_profile_action::pub_sub_notification::DetailLevel>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PubSubNotification {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.topic.is_empty() {
                state.serialize_entry("topic", &self.topic)?;
            }
            if !wkt::internal::is_default(&self.event) {
                state.serialize_entry("event", &self.event)?;
            }
            if self.pubsub_condition.is_some() {
                state.serialize_entry("pubsubCondition", &self.pubsub_condition)?;
            }
            if !wkt::internal::is_default(&self.detail_of_message) {
                state.serialize_entry("detailOfMessage", &self.detail_of_message)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PubSubNotification].
    pub mod pub_sub_notification {
        #[allow(unused_imports)]
        use super::*;

        /// The levels of detail that can be included in the Pub/Sub message.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum DetailLevel {
            /// Unused.
            Unspecified,
            /// The full table data profile.
            TableProfile,
            /// The name of the profiled resource.
            ResourceName,
            /// The full file store data profile.
            FileStoreProfile,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [DetailLevel::value] or
            /// [DetailLevel::name].
            UnknownValue(detail_level::UnknownValue),
        }

        #[doc(hidden)]
        pub mod detail_level {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl DetailLevel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::TableProfile => std::option::Option::Some(1),
                    Self::ResourceName => std::option::Option::Some(2),
                    Self::FileStoreProfile => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("DETAIL_LEVEL_UNSPECIFIED"),
                    Self::TableProfile => std::option::Option::Some("TABLE_PROFILE"),
                    Self::ResourceName => std::option::Option::Some("RESOURCE_NAME"),
                    Self::FileStoreProfile => std::option::Option::Some("FILE_STORE_PROFILE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for DetailLevel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for DetailLevel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for DetailLevel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::TableProfile,
                    2 => Self::ResourceName,
                    3 => Self::FileStoreProfile,
                    _ => Self::UnknownValue(detail_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for DetailLevel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "DETAIL_LEVEL_UNSPECIFIED" => Self::Unspecified,
                    "TABLE_PROFILE" => Self::TableProfile,
                    "RESOURCE_NAME" => Self::ResourceName,
                    "FILE_STORE_PROFILE" => Self::FileStoreProfile,
                    _ => Self::UnknownValue(detail_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for DetailLevel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::TableProfile => serializer.serialize_i32(1),
                    Self::ResourceName => serializer.serialize_i32(2),
                    Self::FileStoreProfile => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for DetailLevel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<DetailLevel>::new(
                    ".google.privacy.dlp.v2.DataProfileAction.PubSubNotification.DetailLevel",
                ))
            }
        }
    }

    /// Message expressing intention to publish to Google Security Operations.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PublishToChronicle {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishToChronicle {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishToChronicle {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.PublishToChronicle"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PublishToChronicle {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PublishToChronicle")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PublishToChronicle;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PublishToChronicle")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PublishToChronicle {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// If set, a summary finding will be created or updated in Security Command
    /// Center for each profile.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PublishToSecurityCommandCenter {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishToSecurityCommandCenter {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishToSecurityCommandCenter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.PublishToSecurityCommandCenter"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PublishToSecurityCommandCenter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PublishToSecurityCommandCenter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PublishToSecurityCommandCenter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PublishToSecurityCommandCenter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PublishToSecurityCommandCenter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Create Dataplex Catalog aspects for profiled resources with the aspect type
    /// Sensitive Data Protection Profile. To learn more about aspects, see
    /// <https://cloud.google.com/sensitive-data-protection/docs/add-aspects>.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PublishToDataplexCatalog {
        /// Whether creating a Dataplex Catalog aspect for a profiled resource should
        /// lower the risk of the profile for that resource. This also lowers the
        /// data risk of resources at the lower levels of the resource hierarchy. For
        /// example, reducing the data risk of a table data profile also reduces the
        /// data risk of the constituent column data profiles.
        pub lower_data_risk_to_low: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishToDataplexCatalog {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [lower_data_risk_to_low][crate::model::data_profile_action::PublishToDataplexCatalog::lower_data_risk_to_low].
        pub fn set_lower_data_risk_to_low<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.lower_data_risk_to_low = v.into();
            self
        }
    }

    impl wkt::message::Message for PublishToDataplexCatalog {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.PublishToDataplexCatalog"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PublishToDataplexCatalog {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __lower_data_risk_to_low,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PublishToDataplexCatalog")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "lowerDataRiskToLow" => Ok(__FieldTag::__lower_data_risk_to_low),
                                "lower_data_risk_to_low" => {
                                    Ok(__FieldTag::__lower_data_risk_to_low)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PublishToDataplexCatalog;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PublishToDataplexCatalog")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__lower_data_risk_to_low => {
                                if !fields.insert(__FieldTag::__lower_data_risk_to_low) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for lower_data_risk_to_low",
                                    ));
                                }
                                result.lower_data_risk_to_low = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PublishToDataplexCatalog {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.lower_data_risk_to_low) {
                state.serialize_entry("lowerDataRiskToLow", &self.lower_data_risk_to_low)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// If set, attaches the [tags]
    /// (<https://cloud.google.com/resource-manager/docs/tags/tags-overview>)
    /// provided to profiled resources. Tags support [access
    /// control](https://cloud.google.com/iam/docs/tags-access-control). You can
    /// conditionally grant or deny access to a resource based on whether the
    /// resource has a specific tag.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TagResources {
        /// The tags to associate with different conditions.
        pub tag_conditions:
            std::vec::Vec<crate::model::data_profile_action::tag_resources::TagCondition>,

        /// The profile generations for which the tag should be attached to
        /// resources. If you attach a tag to only new profiles, then if the
        /// sensitivity score of a profile subsequently changes, its tag doesn't
        /// change. By default, this field includes only new profiles. To include
        /// both new and updated profiles for tagging, this field should explicitly
        /// include both `PROFILE_GENERATION_NEW` and `PROFILE_GENERATION_UPDATE`.
        pub profile_generations_to_tag: std::vec::Vec<crate::model::ProfileGeneration>,

        /// Whether applying a tag to a resource should lower the risk of the profile
        /// for that resource. For example, in conjunction with an [IAM deny
        /// policy](https://cloud.google.com/iam/docs/deny-overview), you can deny
        /// all principals a permission if a tag value is present, mitigating the
        /// risk of the resource. This also lowers the data risk of resources at the
        /// lower levels of the resource hierarchy. For example, reducing the data
        /// risk of a table data profile also reduces the data risk of the
        /// constituent column data profiles.
        pub lower_data_risk_to_low: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TagResources {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tag_conditions][crate::model::data_profile_action::TagResources::tag_conditions].
        pub fn set_tag_conditions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::data_profile_action::tag_resources::TagCondition>,
        {
            use std::iter::Iterator;
            self.tag_conditions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [profile_generations_to_tag][crate::model::data_profile_action::TagResources::profile_generations_to_tag].
        pub fn set_profile_generations_to_tag<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ProfileGeneration>,
        {
            use std::iter::Iterator;
            self.profile_generations_to_tag = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [lower_data_risk_to_low][crate::model::data_profile_action::TagResources::lower_data_risk_to_low].
        pub fn set_lower_data_risk_to_low<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.lower_data_risk_to_low = v.into();
            self
        }
    }

    impl wkt::message::Message for TagResources {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.TagResources"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TagResources {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __tag_conditions,
                __profile_generations_to_tag,
                __lower_data_risk_to_low,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TagResources")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "tagConditions" => Ok(__FieldTag::__tag_conditions),
                                "tag_conditions" => Ok(__FieldTag::__tag_conditions),
                                "profileGenerationsToTag" => {
                                    Ok(__FieldTag::__profile_generations_to_tag)
                                }
                                "profile_generations_to_tag" => {
                                    Ok(__FieldTag::__profile_generations_to_tag)
                                }
                                "lowerDataRiskToLow" => Ok(__FieldTag::__lower_data_risk_to_low),
                                "lower_data_risk_to_low" => {
                                    Ok(__FieldTag::__lower_data_risk_to_low)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TagResources;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TagResources")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__tag_conditions => {
                                if !fields.insert(__FieldTag::__tag_conditions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tag_conditions",
                                    ));
                                }
                                result.tag_conditions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::data_profile_action::tag_resources::TagCondition>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__profile_generations_to_tag => {
                                if !fields.insert(__FieldTag::__profile_generations_to_tag) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for profile_generations_to_tag",
                                    ));
                                }
                                result.profile_generations_to_tag = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::ProfileGeneration>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__lower_data_risk_to_low => {
                                if !fields.insert(__FieldTag::__lower_data_risk_to_low) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for lower_data_risk_to_low",
                                    ));
                                }
                                result.lower_data_risk_to_low = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TagResources {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.tag_conditions.is_empty() {
                state.serialize_entry("tagConditions", &self.tag_conditions)?;
            }
            if !self.profile_generations_to_tag.is_empty() {
                state
                    .serialize_entry("profileGenerationsToTag", &self.profile_generations_to_tag)?;
            }
            if !wkt::internal::is_default(&self.lower_data_risk_to_low) {
                state.serialize_entry("lowerDataRiskToLow", &self.lower_data_risk_to_low)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TagResources].
    pub mod tag_resources {
        #[allow(unused_imports)]
        use super::*;

        /// The tag to attach to profiles matching the condition. At most one
        /// `TagCondition` can be specified per sensitivity level.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TagCondition {
            /// The tag value to attach to resources.
            pub tag:
                std::option::Option<crate::model::data_profile_action::tag_resources::TagValue>,

            /// The type of condition on which attaching the tag will be predicated.
            pub r#type: std::option::Option<
                crate::model::data_profile_action::tag_resources::tag_condition::Type,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TagCondition {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [tag][crate::model::data_profile_action::tag_resources::TagCondition::tag].
            pub fn set_tag<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::data_profile_action::tag_resources::TagValue>,
            {
                self.tag = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [tag][crate::model::data_profile_action::tag_resources::TagCondition::tag].
            pub fn set_or_clear_tag<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::data_profile_action::tag_resources::TagValue>,
            {
                self.tag = v.map(|x| x.into());
                self
            }

            /// Sets the value of [r#type][crate::model::data_profile_action::tag_resources::TagCondition::type].
            ///
            /// Note that all the setters affecting `r#type` are mutually
            /// exclusive.
            pub fn set_type<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::data_profile_action::tag_resources::tag_condition::Type,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// The value of [r#type][crate::model::data_profile_action::tag_resources::TagCondition::r#type]
            /// if it holds a `SensitivityScore`, `None` if the field is not set or
            /// holds a different branch.
            pub fn sensitivity_score(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::SensitivityScore>> {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::data_profile_action::tag_resources::tag_condition::Type::SensitivityScore(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::data_profile_action::tag_resources::TagCondition::r#type]
            /// to hold a `SensitivityScore`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_sensitivity_score<
                T: std::convert::Into<std::boxed::Box<crate::model::SensitivityScore>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::data_profile_action::tag_resources::tag_condition::Type::SensitivityScore(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for TagCondition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.TagResources.TagCondition"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for TagCondition {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __tag,
                    __sensitivity_score,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for TagCondition")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "tag" => Ok(__FieldTag::__tag),
                                    "sensitivityScore" => Ok(__FieldTag::__sensitivity_score),
                                    "sensitivity_score" => Ok(__FieldTag::__sensitivity_score),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = TagCondition;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct TagCondition")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__tag => {
                                    if !fields.insert(__FieldTag::__tag) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for tag"),
                                        );
                                    }
                                    result.tag = map.next_value::<std::option::Option<
                                        crate::model::data_profile_action::tag_resources::TagValue,
                                    >>()?;
                                }
                                __FieldTag::__sensitivity_score => {
                                    if !fields.insert(__FieldTag::__sensitivity_score) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for sensitivity_score",
                                            ),
                                        );
                                    }
                                    if result.r#type.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.DataProfileAction.TagResources.TagCondition.sensitivity_score, latest field was sensitivityScore",
                                            ),
                                        );
                                    }
                                    result.r#type = std::option::Option::Some(
                                        crate::model::data_profile_action::tag_resources::tag_condition::Type::SensitivityScore(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::SensitivityScore>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for TagCondition {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.tag.is_some() {
                    state.serialize_entry("tag", &self.tag)?;
                }
                if let Some(value) = self.sensitivity_score() {
                    state.serialize_entry("sensitivityScore", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [TagCondition].
        pub mod tag_condition {
            #[allow(unused_imports)]
            use super::*;

            /// The type of condition on which attaching the tag will be predicated.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Type {
                /// Conditions attaching the tag to a resource on its profile having this
                /// sensitivity score.
                SensitivityScore(std::boxed::Box<crate::model::SensitivityScore>),
            }
        }

        /// A value of a tag.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TagValue {
            /// The format of the tag value.
            pub format: std::option::Option<
                crate::model::data_profile_action::tag_resources::tag_value::Format,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TagValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [format][crate::model::data_profile_action::tag_resources::TagValue::format].
            ///
            /// Note that all the setters affecting `format` are mutually
            /// exclusive.
            pub fn set_format<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::data_profile_action::tag_resources::tag_value::Format,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.format = v.into();
                self
            }

            /// The value of [format][crate::model::data_profile_action::tag_resources::TagValue::format]
            /// if it holds a `NamespacedValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn namespaced_value(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.format.as_ref().and_then(|v| match v {
                    crate::model::data_profile_action::tag_resources::tag_value::Format::NamespacedValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [format][crate::model::data_profile_action::tag_resources::TagValue::format]
            /// to hold a `NamespacedValue`.
            ///
            /// Note that all the setters affecting `format` are
            /// mutually exclusive.
            pub fn set_namespaced_value<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.format = std::option::Option::Some(
                    crate::model::data_profile_action::tag_resources::tag_value::Format::NamespacedValue(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for TagValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.TagResources.TagValue"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for TagValue {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __namespaced_value,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for TagValue")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "namespacedValue" => Ok(__FieldTag::__namespaced_value),
                                    "namespaced_value" => Ok(__FieldTag::__namespaced_value),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = TagValue;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct TagValue")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__namespaced_value => {
                                    if !fields.insert(__FieldTag::__namespaced_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for namespaced_value",
                                            ),
                                        );
                                    }
                                    if result.format.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `format`, a oneof with full ID .google.privacy.dlp.v2.DataProfileAction.TagResources.TagValue.namespaced_value, latest field was namespacedValue",
                                            ),
                                        );
                                    }
                                    result.format = std::option::Option::Some(
                                        crate::model::data_profile_action::tag_resources::tag_value::Format::NamespacedValue(
                                            map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for TagValue {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.namespaced_value() {
                    state.serialize_entry("namespacedValue", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [TagValue].
        pub mod tag_value {
            #[allow(unused_imports)]
            use super::*;

            /// The format of the tag value.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Format {
                /// The namespaced name for the tag value to attach to resources. Must be
                /// in the format `{parent_id}/{tag_key_short_name}/{short_name}`, for
                /// example, "123456/environment/prod".
                NamespacedValue(std::string::String),
            }
        }
    }

    /// Types of event that can trigger an action.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// Unused.
        Unspecified,
        /// New profile (not a re-profile).
        NewProfile,
        /// One of the following profile metrics changed: Data risk score,
        /// Sensitivity score, Resource visibility, Encryption type, Predicted
        /// infoTypes, Other infoTypes
        ChangedProfile,
        /// Table data risk score or sensitivity score increased.
        ScoreIncreased,
        /// A user (non-internal) error occurred.
        ErrorChanged,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NewProfile => std::option::Option::Some(1),
                Self::ChangedProfile => std::option::Option::Some(2),
                Self::ScoreIncreased => std::option::Option::Some(3),
                Self::ErrorChanged => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::NewProfile => std::option::Option::Some("NEW_PROFILE"),
                Self::ChangedProfile => std::option::Option::Some("CHANGED_PROFILE"),
                Self::ScoreIncreased => std::option::Option::Some("SCORE_INCREASED"),
                Self::ErrorChanged => std::option::Option::Some("ERROR_CHANGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NewProfile,
                2 => Self::ChangedProfile,
                3 => Self::ScoreIncreased,
                4 => Self::ErrorChanged,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NEW_PROFILE" => Self::NewProfile,
                "CHANGED_PROFILE" => Self::ChangedProfile,
                "SCORE_INCREASED" => Self::ScoreIncreased,
                "ERROR_CHANGED" => Self::ErrorChanged,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NewProfile => serializer.serialize_i32(1),
                Self::ChangedProfile => serializer.serialize_i32(2),
                Self::ScoreIncreased => serializer.serialize_i32(3),
                Self::ErrorChanged => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.privacy.dlp.v2.DataProfileAction.EventType",
            ))
        }
    }

    /// Type of action to execute when a profile is generated.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// Export data profiles into a provided location.
        ExportData(std::boxed::Box<crate::model::data_profile_action::Export>),
        /// Publish a message into the Pub/Sub topic.
        PubSubNotification(std::boxed::Box<crate::model::data_profile_action::PubSubNotification>),
        /// Publishes generated data profiles to Google Security Operations.
        /// For more information, see [Use Sensitive Data Protection data in
        /// context-aware
        /// analytics](https://cloud.google.com/chronicle/docs/detection/usecase-dlp-high-risk-user-download).
        PublishToChronicle(std::boxed::Box<crate::model::data_profile_action::PublishToChronicle>),
        /// Publishes findings to Security Command Center for each data profile.
        PublishToScc(
            std::boxed::Box<crate::model::data_profile_action::PublishToSecurityCommandCenter>,
        ),
        /// Tags the profiled resources with the specified tag values.
        TagResources(std::boxed::Box<crate::model::data_profile_action::TagResources>),
        /// Publishes a portion of each profile to Dataplex Catalog with the aspect
        /// type Sensitive Data Protection Profile.
        PublishToDataplexCatalog(
            std::boxed::Box<crate::model::data_profile_action::PublishToDataplexCatalog>,
        ),
    }
}

/// Details about a piece of potentially sensitive information that was detected
/// when the data resource was profiled.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfileFinding {
    /// The content that was found. Even if the content is not textual, it
    /// may be converted to a textual representation here. If the finding exceeds
    /// 4096 bytes in length, the quote may be omitted.
    pub quote: std::string::String,

    /// The [type of
    /// content](https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference)
    /// that might have been found.
    pub infotype: std::option::Option<crate::model::InfoType>,

    /// Contains data parsed from quotes. Currently supported infoTypes: DATE,
    /// DATE_OF_BIRTH, and TIME.
    pub quote_info: std::option::Option<crate::model::QuoteInfo>,

    /// Resource name of the data profile associated with the finding.
    pub data_profile_resource_name: std::string::String,

    /// A unique identifier for the finding.
    pub finding_id: std::string::String,

    /// Timestamp when the finding was detected.
    pub timestamp: std::option::Option<wkt::Timestamp>,

    /// Where the content was found.
    pub location: std::option::Option<crate::model::DataProfileFindingLocation>,

    /// How broadly a resource has been shared.
    pub resource_visibility: crate::model::ResourceVisibility,

    /// The [full resource
    /// name](https://cloud.google.com/apis/design/resource_names#full_resource_name)
    /// of the resource profiled for this finding.
    pub full_resource_name: std::string::String,

    /// The type of the resource that was profiled.
    pub data_source_type: std::option::Option<crate::model::DataSourceType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileFinding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quote][crate::model::DataProfileFinding::quote].
    pub fn set_quote<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.quote = v.into();
        self
    }

    /// Sets the value of [infotype][crate::model::DataProfileFinding::infotype].
    pub fn set_infotype<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.infotype = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [infotype][crate::model::DataProfileFinding::infotype].
    pub fn set_or_clear_infotype<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.infotype = v.map(|x| x.into());
        self
    }

    /// Sets the value of [quote_info][crate::model::DataProfileFinding::quote_info].
    pub fn set_quote_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuoteInfo>,
    {
        self.quote_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quote_info][crate::model::DataProfileFinding::quote_info].
    pub fn set_or_clear_quote_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuoteInfo>,
    {
        self.quote_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_profile_resource_name][crate::model::DataProfileFinding::data_profile_resource_name].
    pub fn set_data_profile_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile_resource_name = v.into();
        self
    }

    /// Sets the value of [finding_id][crate::model::DataProfileFinding::finding_id].
    pub fn set_finding_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_id = v.into();
        self
    }

    /// Sets the value of [timestamp][crate::model::DataProfileFinding::timestamp].
    pub fn set_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timestamp][crate::model::DataProfileFinding::timestamp].
    pub fn set_or_clear_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location][crate::model::DataProfileFinding::location].
    pub fn set_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataProfileFindingLocation>,
    {
        self.location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location][crate::model::DataProfileFinding::location].
    pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataProfileFindingLocation>,
    {
        self.location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_visibility][crate::model::DataProfileFinding::resource_visibility].
    pub fn set_resource_visibility<T: std::convert::Into<crate::model::ResourceVisibility>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_visibility = v.into();
        self
    }

    /// Sets the value of [full_resource_name][crate::model::DataProfileFinding::full_resource_name].
    pub fn set_full_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.full_resource_name = v.into();
        self
    }

    /// Sets the value of [data_source_type][crate::model::DataProfileFinding::data_source_type].
    pub fn set_data_source_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataSourceType>,
    {
        self.data_source_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_source_type][crate::model::DataProfileFinding::data_source_type].
    pub fn set_or_clear_data_source_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataSourceType>,
    {
        self.data_source_type = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataProfileFinding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileFinding"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfileFinding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __quote,
            __infotype,
            __quote_info,
            __data_profile_resource_name,
            __finding_id,
            __timestamp,
            __location,
            __resource_visibility,
            __full_resource_name,
            __data_source_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfileFinding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "quote" => Ok(__FieldTag::__quote),
                            "infotype" => Ok(__FieldTag::__infotype),
                            "quoteInfo" => Ok(__FieldTag::__quote_info),
                            "quote_info" => Ok(__FieldTag::__quote_info),
                            "dataProfileResourceName" => {
                                Ok(__FieldTag::__data_profile_resource_name)
                            }
                            "data_profile_resource_name" => {
                                Ok(__FieldTag::__data_profile_resource_name)
                            }
                            "findingId" => Ok(__FieldTag::__finding_id),
                            "finding_id" => Ok(__FieldTag::__finding_id),
                            "timestamp" => Ok(__FieldTag::__timestamp),
                            "location" => Ok(__FieldTag::__location),
                            "resourceVisibility" => Ok(__FieldTag::__resource_visibility),
                            "resource_visibility" => Ok(__FieldTag::__resource_visibility),
                            "fullResourceName" => Ok(__FieldTag::__full_resource_name),
                            "full_resource_name" => Ok(__FieldTag::__full_resource_name),
                            "dataSourceType" => Ok(__FieldTag::__data_source_type),
                            "data_source_type" => Ok(__FieldTag::__data_source_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfileFinding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfileFinding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__quote => {
                            if !fields.insert(__FieldTag::__quote) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quote",
                                ));
                            }
                            result.quote = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__infotype => {
                            if !fields.insert(__FieldTag::__infotype) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for infotype",
                                ));
                            }
                            result.infotype =
                                map.next_value::<std::option::Option<crate::model::InfoType>>()?;
                        }
                        __FieldTag::__quote_info => {
                            if !fields.insert(__FieldTag::__quote_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quote_info",
                                ));
                            }
                            result.quote_info =
                                map.next_value::<std::option::Option<crate::model::QuoteInfo>>()?;
                        }
                        __FieldTag::__data_profile_resource_name => {
                            if !fields.insert(__FieldTag::__data_profile_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_profile_resource_name",
                                ));
                            }
                            result.data_profile_resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__finding_id => {
                            if !fields.insert(__FieldTag::__finding_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding_id",
                                ));
                            }
                            result.finding_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timestamp => {
                            if !fields.insert(__FieldTag::__timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp",
                                ));
                            }
                            result.timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map.next_value::<std::option::Option<crate::model::DataProfileFindingLocation>>()?
                                ;
                        }
                        __FieldTag::__resource_visibility => {
                            if !fields.insert(__FieldTag::__resource_visibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_visibility",
                                ));
                            }
                            result.resource_visibility = map.next_value::<std::option::Option<crate::model::ResourceVisibility>>()?.unwrap_or_default();
                        }
                        __FieldTag::__full_resource_name => {
                            if !fields.insert(__FieldTag::__full_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_resource_name",
                                ));
                            }
                            result.full_resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source_type => {
                            if !fields.insert(__FieldTag::__data_source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_type",
                                ));
                            }
                            result.data_source_type = map
                                .next_value::<std::option::Option<crate::model::DataSourceType>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfileFinding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.quote.is_empty() {
            state.serialize_entry("quote", &self.quote)?;
        }
        if self.infotype.is_some() {
            state.serialize_entry("infotype", &self.infotype)?;
        }
        if self.quote_info.is_some() {
            state.serialize_entry("quoteInfo", &self.quote_info)?;
        }
        if !self.data_profile_resource_name.is_empty() {
            state.serialize_entry("dataProfileResourceName", &self.data_profile_resource_name)?;
        }
        if !self.finding_id.is_empty() {
            state.serialize_entry("findingId", &self.finding_id)?;
        }
        if self.timestamp.is_some() {
            state.serialize_entry("timestamp", &self.timestamp)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.resource_visibility) {
            state.serialize_entry("resourceVisibility", &self.resource_visibility)?;
        }
        if !self.full_resource_name.is_empty() {
            state.serialize_entry("fullResourceName", &self.full_resource_name)?;
        }
        if self.data_source_type.is_some() {
            state.serialize_entry("dataSourceType", &self.data_source_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Location of a data profile finding within a resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfileFindingLocation {
    /// Name of the container where the finding is located.
    /// The top-level name is the source file name or table name. Names of some
    /// common storage containers are formatted as follows:
    ///
    /// * BigQuery tables:  `{project_id}:{dataset_id}.{table_id}`
    /// * Cloud Storage files: `gs://{bucket}/{path}`
    pub container_name: std::string::String,

    /// Additional location details that may be provided for some types of
    /// profiles. At this time, only findings for table data profiles include such
    /// details.
    pub location_extra_details:
        std::option::Option<crate::model::data_profile_finding_location::LocationExtraDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileFindingLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_name][crate::model::DataProfileFindingLocation::container_name].
    pub fn set_container_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_name = v.into();
        self
    }

    /// Sets the value of [location_extra_details][crate::model::DataProfileFindingLocation::location_extra_details].
    ///
    /// Note that all the setters affecting `location_extra_details` are mutually
    /// exclusive.
    pub fn set_location_extra_details<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::data_profile_finding_location::LocationExtraDetails,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_extra_details = v.into();
        self
    }

    /// The value of [location_extra_details][crate::model::DataProfileFindingLocation::location_extra_details]
    /// if it holds a `DataProfileFindingRecordLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_finding_record_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataProfileFindingRecordLocation>> {
        #[allow(unreachable_patterns)]
        self.location_extra_details.as_ref().and_then(|v| match v {
            crate::model::data_profile_finding_location::LocationExtraDetails::DataProfileFindingRecordLocation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location_extra_details][crate::model::DataProfileFindingLocation::location_extra_details]
    /// to hold a `DataProfileFindingRecordLocation`.
    ///
    /// Note that all the setters affecting `location_extra_details` are
    /// mutually exclusive.
    pub fn set_data_profile_finding_record_location<
        T: std::convert::Into<std::boxed::Box<crate::model::DataProfileFindingRecordLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_extra_details = std::option::Option::Some(
            crate::model::data_profile_finding_location::LocationExtraDetails::DataProfileFindingRecordLocation(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for DataProfileFindingLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileFindingLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfileFindingLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __container_name,
            __data_profile_finding_record_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfileFindingLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "containerName" => Ok(__FieldTag::__container_name),
                            "container_name" => Ok(__FieldTag::__container_name),
                            "dataProfileFindingRecordLocation" => {
                                Ok(__FieldTag::__data_profile_finding_record_location)
                            }
                            "data_profile_finding_record_location" => {
                                Ok(__FieldTag::__data_profile_finding_record_location)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfileFindingLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfileFindingLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__container_name => {
                            if !fields.insert(__FieldTag::__container_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_name",
                                ));
                            }
                            result.container_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_profile_finding_record_location => {
                            if !fields.insert(__FieldTag::__data_profile_finding_record_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_profile_finding_record_location",
                                ));
                            }
                            if result.location_extra_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location_extra_details`, a oneof with full ID .google.privacy.dlp.v2.DataProfileFindingLocation.data_profile_finding_record_location, latest field was dataProfileFindingRecordLocation",
                                ));
                            }
                            result.location_extra_details = std::option::Option::Some(
                                crate::model::data_profile_finding_location::LocationExtraDetails::DataProfileFindingRecordLocation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DataProfileFindingRecordLocation>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfileFindingLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.container_name.is_empty() {
            state.serialize_entry("containerName", &self.container_name)?;
        }
        if let Some(value) = self.data_profile_finding_record_location() {
            state.serialize_entry("dataProfileFindingRecordLocation", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataProfileFindingLocation].
pub mod data_profile_finding_location {
    #[allow(unused_imports)]
    use super::*;

    /// Additional location details that may be provided for some types of
    /// profiles. At this time, only findings for table data profiles include such
    /// details.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocationExtraDetails {
        /// Location of a finding within a resource that produces a table data
        /// profile.
        DataProfileFindingRecordLocation(
            std::boxed::Box<crate::model::DataProfileFindingRecordLocation>,
        ),
    }
}

/// Location of a finding within a resource that produces a table data profile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfileFindingRecordLocation {
    /// Field ID of the column containing the finding.
    pub field: std::option::Option<crate::model::FieldId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileFindingRecordLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::DataProfileFindingRecordLocation::field].
    pub fn set_field<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field][crate::model::DataProfileFindingRecordLocation::field].
    pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataProfileFindingRecordLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileFindingRecordLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfileFindingRecordLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfileFindingRecordLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfileFindingRecordLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfileFindingRecordLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field =
                                map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfileFindingRecordLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.field.is_some() {
            state.serialize_entry("field", &self.field)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for setting up a job to scan resources for profile generation.
/// Only one data profile configuration may exist per organization, folder,
/// or project.
///
/// The generated data profiles are retained according to the
/// [data retention policy]
/// (<https://cloud.google.com/sensitive-data-protection/docs/data-profiles#retention>).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfileJobConfig {
    /// The data to scan.
    pub location: std::option::Option<crate::model::DataProfileLocation>,

    /// The project that will run the scan. The DLP service
    /// account that exists within this project must have access to all resources
    /// that are profiled, and the DLP API must be enabled.
    pub project_id: std::string::String,

    /// Must be set only when scanning other clouds.
    pub other_cloud_starting_location:
        std::option::Option<crate::model::OtherCloudDiscoveryStartingLocation>,

    /// Detection logic for profile generation.
    ///
    /// Not all template features are used by profiles. FindingLimits,
    /// include_quote and exclude_info_types have no impact on
    /// data profiling.
    ///
    /// Multiple templates may be provided if there is data in multiple regions.
    /// At most one template must be specified per-region (including "global").
    /// Each region is scanned using the applicable template. If no region-specific
    /// template is specified, but a "global" template is specified, it will be
    /// copied to that region and used instead. If no global or region-specific
    /// template is provided for a region with data, that region's data will not be
    /// scanned.
    ///
    /// For more information, see
    /// <https://cloud.google.com/sensitive-data-protection/docs/data-profiles#data-residency>.
    pub inspect_templates: std::vec::Vec<std::string::String>,

    /// Actions to execute at the completion of the job.
    pub data_profile_actions: std::vec::Vec<crate::model::DataProfileAction>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileJobConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::DataProfileJobConfig::location].
    pub fn set_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataProfileLocation>,
    {
        self.location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location][crate::model::DataProfileJobConfig::location].
    pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataProfileLocation>,
    {
        self.location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [project_id][crate::model::DataProfileJobConfig::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [other_cloud_starting_location][crate::model::DataProfileJobConfig::other_cloud_starting_location].
    pub fn set_other_cloud_starting_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OtherCloudDiscoveryStartingLocation>,
    {
        self.other_cloud_starting_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [other_cloud_starting_location][crate::model::DataProfileJobConfig::other_cloud_starting_location].
    pub fn set_or_clear_other_cloud_starting_location<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::OtherCloudDiscoveryStartingLocation>,
    {
        self.other_cloud_starting_location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_templates][crate::model::DataProfileJobConfig::inspect_templates].
    pub fn set_inspect_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.inspect_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_profile_actions][crate::model::DataProfileJobConfig::data_profile_actions].
    pub fn set_data_profile_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataProfileAction>,
    {
        use std::iter::Iterator;
        self.data_profile_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DataProfileJobConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileJobConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfileJobConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __project_id,
            __other_cloud_starting_location,
            __inspect_templates,
            __data_profile_actions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfileJobConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "otherCloudStartingLocation" => {
                                Ok(__FieldTag::__other_cloud_starting_location)
                            }
                            "other_cloud_starting_location" => {
                                Ok(__FieldTag::__other_cloud_starting_location)
                            }
                            "inspectTemplates" => Ok(__FieldTag::__inspect_templates),
                            "inspect_templates" => Ok(__FieldTag::__inspect_templates),
                            "dataProfileActions" => Ok(__FieldTag::__data_profile_actions),
                            "data_profile_actions" => Ok(__FieldTag::__data_profile_actions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfileJobConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfileJobConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map.next_value::<std::option::Option<crate::model::DataProfileLocation>>()?
                                ;
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__other_cloud_starting_location => {
                            if !fields.insert(__FieldTag::__other_cloud_starting_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for other_cloud_starting_location",
                                ));
                            }
                            result.other_cloud_starting_location = map
                                .next_value::<std::option::Option<
                                    crate::model::OtherCloudDiscoveryStartingLocation,
                                >>()?;
                        }
                        __FieldTag::__inspect_templates => {
                            if !fields.insert(__FieldTag::__inspect_templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_templates",
                                ));
                            }
                            result.inspect_templates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data_profile_actions => {
                            if !fields.insert(__FieldTag::__data_profile_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_profile_actions",
                                ));
                            }
                            result.data_profile_actions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataProfileAction>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfileJobConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if self.other_cloud_starting_location.is_some() {
            state.serialize_entry(
                "otherCloudStartingLocation",
                &self.other_cloud_starting_location,
            )?;
        }
        if !self.inspect_templates.is_empty() {
            state.serialize_entry("inspectTemplates", &self.inspect_templates)?;
        }
        if !self.data_profile_actions.is_empty() {
            state.serialize_entry("dataProfileActions", &self.data_profile_actions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A pattern to match against one or more tables, datasets, or projects that
/// contain BigQuery tables. At least one pattern must be specified.
/// Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryRegex {
    /// For organizations, if unset, will match all projects. Has no effect
    /// for data profile configurations created within a project.
    pub project_id_regex: std::string::String,

    /// If unset, this property matches all datasets.
    pub dataset_id_regex: std::string::String,

    /// If unset, this property matches all tables.
    pub table_id_regex: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::BigQueryRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }

    /// Sets the value of [dataset_id_regex][crate::model::BigQueryRegex::dataset_id_regex].
    pub fn set_dataset_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_id_regex = v.into();
        self
    }

    /// Sets the value of [table_id_regex][crate::model::BigQueryRegex::table_id_regex].
    pub fn set_table_id_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id_regex = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryRegex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryRegex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id_regex,
            __dataset_id_regex,
            __table_id_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryRegex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectIdRegex" => Ok(__FieldTag::__project_id_regex),
                            "project_id_regex" => Ok(__FieldTag::__project_id_regex),
                            "datasetIdRegex" => Ok(__FieldTag::__dataset_id_regex),
                            "dataset_id_regex" => Ok(__FieldTag::__dataset_id_regex),
                            "tableIdRegex" => Ok(__FieldTag::__table_id_regex),
                            "table_id_regex" => Ok(__FieldTag::__table_id_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryRegex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryRegex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id_regex => {
                            if !fields.insert(__FieldTag::__project_id_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id_regex",
                                ));
                            }
                            result.project_id_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id_regex => {
                            if !fields.insert(__FieldTag::__dataset_id_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id_regex",
                                ));
                            }
                            result.dataset_id_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id_regex => {
                            if !fields.insert(__FieldTag::__table_id_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id_regex",
                                ));
                            }
                            result.table_id_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryRegex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id_regex.is_empty() {
            state.serialize_entry("projectIdRegex", &self.project_id_regex)?;
        }
        if !self.dataset_id_regex.is_empty() {
            state.serialize_entry("datasetIdRegex", &self.dataset_id_regex)?;
        }
        if !self.table_id_regex.is_empty() {
            state.serialize_entry("tableIdRegex", &self.table_id_regex)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A collection of regular expressions to determine what tables to match
/// against.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryRegexes {
    /// A single BigQuery regular expression pattern to match against one or more
    /// tables, datasets, or projects that contain BigQuery tables.
    pub patterns: std::vec::Vec<crate::model::BigQueryRegex>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::BigQueryRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQueryRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryRegexes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryRegexes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patterns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryRegexes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patterns" => Ok(__FieldTag::__patterns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryRegexes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryRegexes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patterns => {
                            if !fields.insert(__FieldTag::__patterns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patterns",
                                ));
                            }
                            result.patterns = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BigQueryRegex>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryRegexes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.patterns.is_empty() {
            state.serialize_entry("patterns", &self.patterns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The types of BigQuery tables supported by Cloud DLP.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryTableTypes {
    /// A set of BigQuery table types.
    pub types: std::vec::Vec<crate::model::BigQueryTableType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryTableTypes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [types][crate::model::BigQueryTableTypes::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQueryTableType>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryTableTypes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryTableTypes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryTableTypes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryTableTypes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "types" => Ok(__FieldTag::__types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryTableTypes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryTableTypes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__types => {
                            if !fields.insert(__FieldTag::__types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for types",
                                ));
                            }
                            result.types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BigQueryTableType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryTableTypes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.types.is_empty() {
            state.serialize_entry("types", &self.types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Do not profile the tables.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Disabled {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Disabled {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for Disabled {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Disabled"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Disabled {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Disabled")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Disabled;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Disabled")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Disabled {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The data that will be profiled.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfileLocation {
    /// The location to be scanned.
    pub location: std::option::Option<crate::model::data_profile_location::Location>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::DataProfileLocation::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::data_profile_location::Location>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::DataProfileLocation::location]
    /// if it holds a `OrganizationId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn organization_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::data_profile_location::Location::OrganizationId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::DataProfileLocation::location]
    /// to hold a `OrganizationId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_organization_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::data_profile_location::Location::OrganizationId(v.into()),
        );
        self
    }

    /// The value of [location][crate::model::DataProfileLocation::location]
    /// if it holds a `FolderId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn folder_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::data_profile_location::Location::FolderId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::DataProfileLocation::location]
    /// to hold a `FolderId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::data_profile_location::Location::FolderId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataProfileLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfileLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __organization_id,
            __folder_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfileLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "organizationId" => Ok(__FieldTag::__organization_id),
                            "organization_id" => Ok(__FieldTag::__organization_id),
                            "folderId" => Ok(__FieldTag::__folder_id),
                            "folder_id" => Ok(__FieldTag::__folder_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfileLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfileLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__organization_id => {
                            if !fields.insert(__FieldTag::__organization_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .google.privacy.dlp.v2.DataProfileLocation.organization_id, latest field was organizationId",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::data_profile_location::Location::OrganizationId(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__folder_id => {
                            if !fields.insert(__FieldTag::__folder_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for folder_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .google.privacy.dlp.v2.DataProfileLocation.folder_id, latest field was folderId",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::data_profile_location::Location::FolderId(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfileLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.organization_id() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("organizationId", &__With(value))?;
        }
        if let Some(value) = self.folder_id() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("folderId", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataProfileLocation].
pub mod data_profile_location {
    #[allow(unused_imports)]
    use super::*;

    /// The location to be scanned.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Location {
        /// The ID of an organization to scan.
        OrganizationId(i64),
        /// The ID of the folder within an organization to scan.
        FolderId(i64),
    }
}

/// Configuration for discovery to scan resources for profile generation.
/// Only one discovery configuration may exist per organization, folder,
/// or project.
///
/// The generated data profiles are retained according to the
/// [data retention policy]
/// (<https://cloud.google.com/sensitive-data-protection/docs/data-profiles#retention>).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryConfig {
    /// Unique resource name for the DiscoveryConfig, assigned by the service when
    /// the DiscoveryConfig is created, for example
    /// `projects/dlp-test-project/locations/global/discoveryConfigs/53234423`.
    pub name: std::string::String,

    /// Display name (max 100 chars)
    pub display_name: std::string::String,

    /// Only set when the parent is an org.
    pub org_config: std::option::Option<crate::model::discovery_config::OrgConfig>,

    /// Must be set only when scanning other clouds.
    pub other_cloud_starting_location:
        std::option::Option<crate::model::OtherCloudDiscoveryStartingLocation>,

    /// Detection logic for profile generation.
    ///
    /// Not all template features are used by Discovery. FindingLimits,
    /// include_quote and exclude_info_types have no impact on
    /// Discovery.
    ///
    /// Multiple templates may be provided if there is data in multiple regions.
    /// At most one template must be specified per-region (including "global").
    /// Each region is scanned using the applicable template. If no region-specific
    /// template is specified, but a "global" template is specified, it will be
    /// copied to that region and used instead. If no global or region-specific
    /// template is provided for a region with data, that region's data will not be
    /// scanned.
    ///
    /// For more information, see
    /// <https://cloud.google.com/sensitive-data-protection/docs/data-profiles#data-residency>.
    pub inspect_templates: std::vec::Vec<std::string::String>,

    /// Actions to execute at the completion of scanning.
    pub actions: std::vec::Vec<crate::model::DataProfileAction>,

    /// Target to match against for determining what to scan and how frequently.
    pub targets: std::vec::Vec<crate::model::DiscoveryTarget>,

    /// Output only. A stream of errors encountered when the config was activated.
    /// Repeated errors may result in the config automatically being paused. Output
    /// only field. Will return the last 100 errors. Whenever the config is
    /// modified this list will be cleared.
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Output only. The creation timestamp of a DiscoveryConfig.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of a DiscoveryConfig.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the last time this config was executed.
    pub last_run_time: std::option::Option<wkt::Timestamp>,

    /// Required. A status for this configuration.
    pub status: crate::model::discovery_config::Status,

    /// Optional. Processing location configuration. Vertex AI dataset scanning
    /// will set processing_location.image_fallback_type to MultiRegionProcessing
    /// by default.
    pub processing_location: std::option::Option<crate::model::ProcessingLocation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiscoveryConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DiscoveryConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [org_config][crate::model::DiscoveryConfig::org_config].
    pub fn set_org_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::discovery_config::OrgConfig>,
    {
        self.org_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [org_config][crate::model::DiscoveryConfig::org_config].
    pub fn set_or_clear_org_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::discovery_config::OrgConfig>,
    {
        self.org_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [other_cloud_starting_location][crate::model::DiscoveryConfig::other_cloud_starting_location].
    pub fn set_other_cloud_starting_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OtherCloudDiscoveryStartingLocation>,
    {
        self.other_cloud_starting_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [other_cloud_starting_location][crate::model::DiscoveryConfig::other_cloud_starting_location].
    pub fn set_or_clear_other_cloud_starting_location<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::OtherCloudDiscoveryStartingLocation>,
    {
        self.other_cloud_starting_location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_templates][crate::model::DiscoveryConfig::inspect_templates].
    pub fn set_inspect_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.inspect_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [actions][crate::model::DiscoveryConfig::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataProfileAction>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [targets][crate::model::DiscoveryConfig::targets].
    pub fn set_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveryTarget>,
    {
        use std::iter::Iterator;
        self.targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors][crate::model::DiscoveryConfig::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::DiscoveryConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DiscoveryConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DiscoveryConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DiscoveryConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_run_time][crate::model::DiscoveryConfig::last_run_time].
    pub fn set_last_run_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_run_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_run_time][crate::model::DiscoveryConfig::last_run_time].
    pub fn set_or_clear_last_run_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_run_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::DiscoveryConfig::status].
    pub fn set_status<T: std::convert::Into<crate::model::discovery_config::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [processing_location][crate::model::DiscoveryConfig::processing_location].
    pub fn set_processing_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProcessingLocation>,
    {
        self.processing_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [processing_location][crate::model::DiscoveryConfig::processing_location].
    pub fn set_or_clear_processing_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProcessingLocation>,
    {
        self.processing_location = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiscoveryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __org_config,
            __other_cloud_starting_location,
            __inspect_templates,
            __actions,
            __targets,
            __errors,
            __create_time,
            __update_time,
            __last_run_time,
            __status,
            __processing_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "orgConfig" => Ok(__FieldTag::__org_config),
                            "org_config" => Ok(__FieldTag::__org_config),
                            "otherCloudStartingLocation" => {
                                Ok(__FieldTag::__other_cloud_starting_location)
                            }
                            "other_cloud_starting_location" => {
                                Ok(__FieldTag::__other_cloud_starting_location)
                            }
                            "inspectTemplates" => Ok(__FieldTag::__inspect_templates),
                            "inspect_templates" => Ok(__FieldTag::__inspect_templates),
                            "actions" => Ok(__FieldTag::__actions),
                            "targets" => Ok(__FieldTag::__targets),
                            "errors" => Ok(__FieldTag::__errors),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "lastRunTime" => Ok(__FieldTag::__last_run_time),
                            "last_run_time" => Ok(__FieldTag::__last_run_time),
                            "status" => Ok(__FieldTag::__status),
                            "processingLocation" => Ok(__FieldTag::__processing_location),
                            "processing_location" => Ok(__FieldTag::__processing_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__org_config => {
                            if !fields.insert(__FieldTag::__org_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for org_config",
                                ));
                            }
                            result.org_config = map.next_value::<std::option::Option<crate::model::discovery_config::OrgConfig>>()?
                                ;
                        }
                        __FieldTag::__other_cloud_starting_location => {
                            if !fields.insert(__FieldTag::__other_cloud_starting_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for other_cloud_starting_location",
                                ));
                            }
                            result.other_cloud_starting_location = map
                                .next_value::<std::option::Option<
                                    crate::model::OtherCloudDiscoveryStartingLocation,
                                >>()?;
                        }
                        __FieldTag::__inspect_templates => {
                            if !fields.insert(__FieldTag::__inspect_templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_templates",
                                ));
                            }
                            result.inspect_templates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataProfileAction>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__targets => {
                            if !fields.insert(__FieldTag::__targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for targets",
                                ));
                            }
                            result.targets =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DiscoveryTarget>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Error>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_run_time => {
                            if !fields.insert(__FieldTag::__last_run_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_run_time",
                                ));
                            }
                            result.last_run_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::discovery_config::Status>>()?.unwrap_or_default();
                        }
                        __FieldTag::__processing_location => {
                            if !fields.insert(__FieldTag::__processing_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processing_location",
                                ));
                            }
                            result.processing_location = map.next_value::<std::option::Option<crate::model::ProcessingLocation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.org_config.is_some() {
            state.serialize_entry("orgConfig", &self.org_config)?;
        }
        if self.other_cloud_starting_location.is_some() {
            state.serialize_entry(
                "otherCloudStartingLocation",
                &self.other_cloud_starting_location,
            )?;
        }
        if !self.inspect_templates.is_empty() {
            state.serialize_entry("inspectTemplates", &self.inspect_templates)?;
        }
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self.targets.is_empty() {
            state.serialize_entry("targets", &self.targets)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.last_run_time.is_some() {
            state.serialize_entry("lastRunTime", &self.last_run_time)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if self.processing_location.is_some() {
            state.serialize_entry("processingLocation", &self.processing_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryConfig].
pub mod discovery_config {
    #[allow(unused_imports)]
    use super::*;

    /// Project and scan location information. Only set when the parent is an org.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OrgConfig {
        /// The data to scan: folder, org, or project
        pub location: std::option::Option<crate::model::DiscoveryStartingLocation>,

        /// The project that will run the scan. The DLP service
        /// account that exists within this project must have access to all resources
        /// that are profiled, and the DLP API must be enabled.
        pub project_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OrgConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [location][crate::model::discovery_config::OrgConfig::location].
        pub fn set_location<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::DiscoveryStartingLocation>,
        {
            self.location = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [location][crate::model::discovery_config::OrgConfig::location].
        pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::DiscoveryStartingLocation>,
        {
            self.location = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project_id][crate::model::discovery_config::OrgConfig::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }
    }

    impl wkt::message::Message for OrgConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryConfig.OrgConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OrgConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __location,
                __project_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OrgConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "location" => Ok(__FieldTag::__location),
                                "projectId" => Ok(__FieldTag::__project_id),
                                "project_id" => Ok(__FieldTag::__project_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OrgConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OrgConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__location => {
                                if !fields.insert(__FieldTag::__location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location",
                                    ));
                                }
                                result.location =
                                    map.next_value::<std::option::Option<
                                        crate::model::DiscoveryStartingLocation,
                                    >>()?;
                            }
                            __FieldTag::__project_id => {
                                if !fields.insert(__FieldTag::__project_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project_id",
                                    ));
                                }
                                result.project_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OrgConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.location.is_some() {
                state.serialize_entry("location", &self.location)?;
            }
            if !self.project_id.is_empty() {
                state.serialize_entry("projectId", &self.project_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Whether the discovery config is currently active. New options may be added
    /// at a later time.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Unused
        Unspecified,
        /// The discovery config is currently active.
        Running,
        /// The discovery config is paused temporarily.
        Paused,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Paused,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.privacy.dlp.v2.DiscoveryConfig.Status",
            ))
        }
    }
}

/// Target used to match against for Discovery.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryTarget {
    /// A target to match against for Discovery.
    pub target: std::option::Option<crate::model::discovery_target::Target>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::discovery_target::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `BigQueryTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::BigQueryTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `BigQueryTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_big_query_target<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::BigQueryTarget(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `CloudSqlTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::CloudSqlTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `CloudSqlTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_cloud_sql_target<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::CloudSqlTarget(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `SecretsTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secrets_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SecretsDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::SecretsTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `SecretsTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_secrets_target<
        T: std::convert::Into<std::boxed::Box<crate::model::SecretsDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::SecretsTarget(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `CloudStorageTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::CloudStorageTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `CloudStorageTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_cloud_storage_target<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::CloudStorageTarget(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `OtherCloudTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn other_cloud_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::OtherCloudTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `OtherCloudTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_other_cloud_target<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::OtherCloudTarget(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `VertexDatasetTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_dataset_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::VertexDatasetTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `VertexDatasetTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_target<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::VertexDatasetTarget(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __big_query_target,
            __cloud_sql_target,
            __secrets_target,
            __cloud_storage_target,
            __other_cloud_target,
            __vertex_dataset_target,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigQueryTarget" => Ok(__FieldTag::__big_query_target),
                            "big_query_target" => Ok(__FieldTag::__big_query_target),
                            "cloudSqlTarget" => Ok(__FieldTag::__cloud_sql_target),
                            "cloud_sql_target" => Ok(__FieldTag::__cloud_sql_target),
                            "secretsTarget" => Ok(__FieldTag::__secrets_target),
                            "secrets_target" => Ok(__FieldTag::__secrets_target),
                            "cloudStorageTarget" => Ok(__FieldTag::__cloud_storage_target),
                            "cloud_storage_target" => Ok(__FieldTag::__cloud_storage_target),
                            "otherCloudTarget" => Ok(__FieldTag::__other_cloud_target),
                            "other_cloud_target" => Ok(__FieldTag::__other_cloud_target),
                            "vertexDatasetTarget" => Ok(__FieldTag::__vertex_dataset_target),
                            "vertex_dataset_target" => Ok(__FieldTag::__vertex_dataset_target),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__big_query_target => {
                            if !fields.insert(__FieldTag::__big_query_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_target",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryTarget.big_query_target, latest field was bigQueryTarget",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::discovery_target::Target::BigQueryTarget(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryDiscoveryTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_sql_target => {
                            if !fields.insert(__FieldTag::__cloud_sql_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql_target",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryTarget.cloud_sql_target, latest field was cloudSqlTarget",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::discovery_target::Target::CloudSqlTarget(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudSqlDiscoveryTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__secrets_target => {
                            if !fields.insert(__FieldTag::__secrets_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secrets_target",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryTarget.secrets_target, latest field was secretsTarget",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::discovery_target::Target::SecretsTarget(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SecretsDiscoveryTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_storage_target => {
                            if !fields.insert(__FieldTag::__cloud_storage_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_target",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryTarget.cloud_storage_target, latest field was cloudStorageTarget",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::discovery_target::Target::CloudStorageTarget(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudStorageDiscoveryTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__other_cloud_target => {
                            if !fields.insert(__FieldTag::__other_cloud_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for other_cloud_target",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryTarget.other_cloud_target, latest field was otherCloudTarget",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::discovery_target::Target::OtherCloudTarget(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OtherCloudDiscoveryTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vertex_dataset_target => {
                            if !fields.insert(__FieldTag::__vertex_dataset_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertex_dataset_target",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryTarget.vertex_dataset_target, latest field was vertexDatasetTarget",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::discovery_target::Target::VertexDatasetTarget(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VertexDatasetDiscoveryTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.big_query_target() {
            state.serialize_entry("bigQueryTarget", value)?;
        }
        if let Some(value) = self.cloud_sql_target() {
            state.serialize_entry("cloudSqlTarget", value)?;
        }
        if let Some(value) = self.secrets_target() {
            state.serialize_entry("secretsTarget", value)?;
        }
        if let Some(value) = self.cloud_storage_target() {
            state.serialize_entry("cloudStorageTarget", value)?;
        }
        if let Some(value) = self.other_cloud_target() {
            state.serialize_entry("otherCloudTarget", value)?;
        }
        if let Some(value) = self.vertex_dataset_target() {
            state.serialize_entry("vertexDatasetTarget", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryTarget].
pub mod discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// A target to match against for Discovery.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// BigQuery target for Discovery. The first target to match a table will be
        /// the one applied.
        BigQueryTarget(std::boxed::Box<crate::model::BigQueryDiscoveryTarget>),
        /// Cloud SQL target for Discovery. The first target to match a table will be
        /// the one applied.
        CloudSqlTarget(std::boxed::Box<crate::model::CloudSqlDiscoveryTarget>),
        /// Discovery target that looks for credentials and secrets stored in cloud
        /// resource metadata and reports them as vulnerabilities to Security Command
        /// Center. Only one target of this type is allowed.
        SecretsTarget(std::boxed::Box<crate::model::SecretsDiscoveryTarget>),
        /// Cloud Storage target for Discovery. The first target to match a table
        /// will be the one applied.
        CloudStorageTarget(std::boxed::Box<crate::model::CloudStorageDiscoveryTarget>),
        /// Other clouds target for discovery. The first target to match a resource
        /// will be the one applied.
        OtherCloudTarget(std::boxed::Box<crate::model::OtherCloudDiscoveryTarget>),
        /// Vertex AI dataset target for Discovery. The first target to match a
        /// dataset will be the one applied. Note that discovery for Vertex AI can
        /// incur Cloud Storage Class B operation charges for storage.objects.get
        /// operations and retrieval fees. For more information, see [Cloud Storage
        /// pricing](https://cloud.google.com/storage/pricing#price-tables).
        /// Note that discovery for Vertex AI dataset will not be able to scan images
        /// unless DiscoveryConfig.processing_location.image_fallback_location has
        /// multi_region_processing or global_processing configured.
        VertexDatasetTarget(std::boxed::Box<crate::model::VertexDatasetDiscoveryTarget>),
    }
}

/// Target used to match against for discovery with BigQuery tables
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryDiscoveryTarget {
    /// Required. The tables the discovery cadence applies to. The first target
    /// with a matching filter will be the one to apply to a table.
    pub filter: std::option::Option<crate::model::DiscoveryBigQueryFilter>,

    /// In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    pub conditions: std::option::Option<crate::model::DiscoveryBigQueryConditions>,

    /// The generation rule includes the logic on how frequently
    /// to update the data profiles. If not specified, discovery will re-run and
    /// update no more than once a month if new columns appear in the table.
    pub frequency: std::option::Option<crate::model::big_query_discovery_target::Frequency>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::BigQueryDiscoveryTarget::filter].
    pub fn set_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryBigQueryFilter>,
    {
        self.filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [filter][crate::model::BigQueryDiscoveryTarget::filter].
    pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryBigQueryFilter>,
    {
        self.filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conditions][crate::model::BigQueryDiscoveryTarget::conditions].
    pub fn set_conditions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryBigQueryConditions>,
    {
        self.conditions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conditions][crate::model::BigQueryDiscoveryTarget::conditions].
    pub fn set_or_clear_conditions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryBigQueryConditions>,
    {
        self.conditions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency].
    ///
    /// Note that all the setters affecting `frequency` are mutually
    /// exclusive.
    pub fn set_frequency<
        T: std::convert::Into<
                std::option::Option<crate::model::big_query_discovery_target::Frequency>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }

    /// The value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// if it holds a `Cadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryGenerationCadence>> {
        #[allow(unreachable_patterns)]
        self.frequency.as_ref().and_then(|v| match v {
            crate::model::big_query_discovery_target::Frequency::Cadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// to hold a `Cadence`.
    ///
    /// Note that all the setters affecting `frequency` are
    /// mutually exclusive.
    pub fn set_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = std::option::Option::Some(
            crate::model::big_query_discovery_target::Frequency::Cadence(v.into()),
        );
        self
    }

    /// The value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.frequency.as_ref().and_then(|v| match v {
            crate::model::big_query_discovery_target::Frequency::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `frequency` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = std::option::Option::Some(
            crate::model::big_query_discovery_target::Frequency::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryDiscoveryTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryDiscoveryTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __conditions,
            __cadence,
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryDiscoveryTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "cadence" => Ok(__FieldTag::__cadence),
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryDiscoveryTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryDiscoveryTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map.next_value::<std::option::Option<crate::model::DiscoveryBigQueryFilter>>()?
                                ;
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<crate::model::DiscoveryBigQueryConditions>>()?
                                ;
                        }
                        __FieldTag::__cadence => {
                            if !fields.insert(__FieldTag::__cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cadence",
                                ));
                            }
                            if result.frequency.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `frequency`, a oneof with full ID .google.privacy.dlp.v2.BigQueryDiscoveryTarget.cadence, latest field was cadence",
                                ));
                            }
                            result.frequency = std::option::Option::Some(
                                crate::model::big_query_discovery_target::Frequency::Cadence(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DiscoveryGenerationCadence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            if result.frequency.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `frequency`, a oneof with full ID .google.privacy.dlp.v2.BigQueryDiscoveryTarget.disabled, latest field was disabled",
                                ));
                            }
                            result.frequency = std::option::Option::Some(
                                crate::model::big_query_discovery_target::Frequency::Disabled(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Disabled>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryDiscoveryTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.conditions.is_some() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if let Some(value) = self.cadence() {
            state.serialize_entry("cadence", value)?;
        }
        if let Some(value) = self.disabled() {
            state.serialize_entry("disabled", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BigQueryDiscoveryTarget].
pub mod big_query_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// The generation rule includes the logic on how frequently
    /// to update the data profiles. If not specified, discovery will re-run and
    /// update no more than once a month if new columns appear in the table.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Frequency {
        /// How often and when to update profiles. New tables that match both the
        /// filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        Cadence(std::boxed::Box<crate::model::DiscoveryGenerationCadence>),
        /// Tables that match this filter will not have profiles created.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines what tables will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID, dataset ID, and table ID.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryBigQueryFilter {
    /// Whether the filter applies to a specific set of tables or all other tables
    /// within the location being profiled. The first filter to match will be
    /// applied, regardless of the condition. If none is set, will default to
    /// `other_tables`.
    pub filter: std::option::Option<crate::model::discovery_big_query_filter::Filter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryBigQueryFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::DiscoveryBigQueryFilter::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::discovery_big_query_filter::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// if it holds a `Tables`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tables(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTableCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_filter::Filter::Tables(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// to hold a `Tables`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_tables<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTableCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_big_query_filter::Filter::Tables(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// if it holds a `OtherTables`, `None` if the field is not set or
    /// holds a different branch.
    pub fn other_tables(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::discovery_big_query_filter::AllOtherBigQueryTables>,
    > {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_filter::Filter::OtherTables(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// to hold a `OtherTables`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_other_tables<
        T: std::convert::Into<
                std::boxed::Box<crate::model::discovery_big_query_filter::AllOtherBigQueryTables>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_big_query_filter::Filter::OtherTables(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// if it holds a `TableReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TableReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_filter::Filter::TableReference(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// to hold a `TableReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_table_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_big_query_filter::Filter::TableReference(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryBigQueryFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryBigQueryFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tables,
            __other_tables,
            __table_reference,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryBigQueryFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tables" => Ok(__FieldTag::__tables),
                            "otherTables" => Ok(__FieldTag::__other_tables),
                            "other_tables" => Ok(__FieldTag::__other_tables),
                            "tableReference" => Ok(__FieldTag::__table_reference),
                            "table_reference" => Ok(__FieldTag::__table_reference),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryBigQueryFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryBigQueryFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tables => {
                            if !fields.insert(__FieldTag::__tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tables",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryBigQueryFilter.tables, latest field was tables",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_big_query_filter::Filter::Tables(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryTableCollection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__other_tables => {
                            if !fields.insert(__FieldTag::__other_tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for other_tables",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryBigQueryFilter.other_tables, latest field was otherTables",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_big_query_filter::Filter::OtherTables(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::discovery_big_query_filter::AllOtherBigQueryTables>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__table_reference => {
                            if !fields.insert(__FieldTag::__table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_reference",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryBigQueryFilter.table_reference, latest field was tableReference",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_big_query_filter::Filter::TableReference(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TableReference>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryBigQueryFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.tables() {
            state.serialize_entry("tables", value)?;
        }
        if let Some(value) = self.other_tables() {
            state.serialize_entry("otherTables", value)?;
        }
        if let Some(value) = self.table_reference() {
            state.serialize_entry("tableReference", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryBigQueryFilter].
pub mod discovery_big_query_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Catch-all for all other tables not specified by other filters. Should
    /// always be last, except for single-table configurations, which will only
    /// have a TableReference target.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AllOtherBigQueryTables {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AllOtherBigQueryTables {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for AllOtherBigQueryTables {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryFilter.AllOtherBigQueryTables"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AllOtherBigQueryTables {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AllOtherBigQueryTables")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AllOtherBigQueryTables;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AllOtherBigQueryTables")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AllOtherBigQueryTables {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Whether the filter applies to a specific set of tables or all other tables
    /// within the location being profiled. The first filter to match will be
    /// applied, regardless of the condition. If none is set, will default to
    /// `other_tables`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Filter {
        /// A specific set of tables for this filter to apply to. A table collection
        /// must be specified in only one filter per config.
        /// If a table id or dataset is empty, Cloud DLP assumes all tables in that
        /// collection must be profiled. Must specify a project ID.
        Tables(std::boxed::Box<crate::model::BigQueryTableCollection>),
        /// Catch-all. This should always be the last filter in the list because
        /// anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        OtherTables(
            std::boxed::Box<crate::model::discovery_big_query_filter::AllOtherBigQueryTables>,
        ),
        /// The table to scan. Discovery configurations including this can only
        /// include one DiscoveryTarget (the DiscoveryTarget with this
        /// TableReference).
        TableReference(std::boxed::Box<crate::model::TableReference>),
    }
}

/// Specifies a collection of BigQuery tables. Used for Discovery.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryTableCollection {
    /// Maximum of 100 entries.
    /// The first filter containing a pattern that matches a table will be used.
    pub pattern: std::option::Option<crate::model::big_query_table_collection::Pattern>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryTableCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pattern][crate::model::BigQueryTableCollection::pattern].
    ///
    /// Note that all the setters affecting `pattern` are mutually
    /// exclusive.
    pub fn set_pattern<
        T: std::convert::Into<std::option::Option<crate::model::big_query_table_collection::Pattern>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::BigQueryTableCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::big_query_table_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::BigQueryTableCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::big_query_table_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryTableCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryTableCollection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryTableCollection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_regexes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryTableCollection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeRegexes" => Ok(__FieldTag::__include_regexes),
                            "include_regexes" => Ok(__FieldTag::__include_regexes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryTableCollection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryTableCollection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_regexes => {
                            if !fields.insert(__FieldTag::__include_regexes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_regexes",
                                ));
                            }
                            if result.pattern.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `pattern`, a oneof with full ID .google.privacy.dlp.v2.BigQueryTableCollection.include_regexes, latest field was includeRegexes",
                                ));
                            }
                            result.pattern = std::option::Option::Some(
                                crate::model::big_query_table_collection::Pattern::IncludeRegexes(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryRegexes>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryTableCollection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.include_regexes() {
            state.serialize_entry("includeRegexes", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BigQueryTableCollection].
pub mod big_query_table_collection {
    #[allow(unused_imports)]
    use super::*;

    /// Maximum of 100 entries.
    /// The first filter containing a pattern that matches a table will be used.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Pattern {
        /// A collection of regular expressions to match a BigQuery table against.
        IncludeRegexes(std::boxed::Box<crate::model::BigQueryRegexes>),
    }
}

/// Requirements that must be true before a table is scanned in discovery for the
/// first time. There is an AND relationship between the top-level attributes.
/// Additionally, minimum conditions with an OR relationship that must be met
/// before Cloud DLP scans a table can be set (like a minimum row count or a
/// minimum table age).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryBigQueryConditions {
    /// BigQuery table must have been created after this date. Used to avoid
    /// backfilling.
    pub created_after: std::option::Option<wkt::Timestamp>,

    /// At least one of the conditions must be true for a table to be scanned.
    pub or_conditions:
        std::option::Option<crate::model::discovery_big_query_conditions::OrConditions>,

    /// The type of BigQuery tables to scan. If nothing is set the default
    /// behavior is to scan only tables of type TABLE and to give errors
    /// for all unsupported tables.
    pub included_types:
        std::option::Option<crate::model::discovery_big_query_conditions::IncludedTypes>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryBigQueryConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_after][crate::model::DiscoveryBigQueryConditions::created_after].
    pub fn set_created_after<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.created_after = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [created_after][crate::model::DiscoveryBigQueryConditions::created_after].
    pub fn set_or_clear_created_after<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.created_after = v.map(|x| x.into());
        self
    }

    /// Sets the value of [or_conditions][crate::model::DiscoveryBigQueryConditions::or_conditions].
    pub fn set_or_conditions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::discovery_big_query_conditions::OrConditions>,
    {
        self.or_conditions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [or_conditions][crate::model::DiscoveryBigQueryConditions::or_conditions].
    pub fn set_or_clear_or_conditions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::discovery_big_query_conditions::OrConditions>,
    {
        self.or_conditions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types].
    ///
    /// Note that all the setters affecting `included_types` are mutually
    /// exclusive.
    pub fn set_included_types<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_big_query_conditions::IncludedTypes>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.included_types = v.into();
        self
    }

    /// The value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// if it holds a `Types`, `None` if the field is not set or
    /// holds a different branch.
    pub fn types(&self) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTableTypes>> {
        #[allow(unreachable_patterns)]
        self.included_types.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_conditions::IncludedTypes::Types(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// to hold a `Types`.
    ///
    /// Note that all the setters affecting `included_types` are
    /// mutually exclusive.
    pub fn set_types<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTableTypes>>>(
        mut self,
        v: T,
    ) -> Self {
        self.included_types = std::option::Option::Some(
            crate::model::discovery_big_query_conditions::IncludedTypes::Types(v.into()),
        );
        self
    }

    /// The value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// if it holds a `TypeCollection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn type_collection(
        &self,
    ) -> std::option::Option<&crate::model::BigQueryTableTypeCollection> {
        #[allow(unreachable_patterns)]
        self.included_types.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_conditions::IncludedTypes::TypeCollection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// to hold a `TypeCollection`.
    ///
    /// Note that all the setters affecting `included_types` are
    /// mutually exclusive.
    pub fn set_type_collection<T: std::convert::Into<crate::model::BigQueryTableTypeCollection>>(
        mut self,
        v: T,
    ) -> Self {
        self.included_types = std::option::Option::Some(
            crate::model::discovery_big_query_conditions::IncludedTypes::TypeCollection(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryBigQueryConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryConditions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryBigQueryConditions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __created_after,
            __types,
            __type_collection,
            __or_conditions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryBigQueryConditions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createdAfter" => Ok(__FieldTag::__created_after),
                            "created_after" => Ok(__FieldTag::__created_after),
                            "types" => Ok(__FieldTag::__types),
                            "typeCollection" => Ok(__FieldTag::__type_collection),
                            "type_collection" => Ok(__FieldTag::__type_collection),
                            "orConditions" => Ok(__FieldTag::__or_conditions),
                            "or_conditions" => Ok(__FieldTag::__or_conditions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryBigQueryConditions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryBigQueryConditions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__created_after => {
                            if !fields.insert(__FieldTag::__created_after) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for created_after",
                                ));
                            }
                            result.created_after =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__types => {
                            if !fields.insert(__FieldTag::__types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for types",
                                ));
                            }
                            if result.included_types.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `included_types`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryBigQueryConditions.types, latest field was types",
                                ));
                            }
                            result.included_types = std::option::Option::Some(
                                crate::model::discovery_big_query_conditions::IncludedTypes::Types(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryTableTypes>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__type_collection => {
                            if !fields.insert(__FieldTag::__type_collection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type_collection",
                                ));
                            }
                            if result.included_types.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `included_types`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryBigQueryConditions.type_collection, latest field was typeCollection",
                                ));
                            }
                            result.included_types = std::option::Option::Some(
                                crate::model::discovery_big_query_conditions::IncludedTypes::TypeCollection(
                                    map.next_value::<std::option::Option<crate::model::BigQueryTableTypeCollection>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__or_conditions => {
                            if !fields.insert(__FieldTag::__or_conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for or_conditions",
                                ));
                            }
                            result.or_conditions = map.next_value::<std::option::Option<
                                crate::model::discovery_big_query_conditions::OrConditions,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryBigQueryConditions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.created_after.is_some() {
            state.serialize_entry("createdAfter", &self.created_after)?;
        }
        if let Some(value) = self.types() {
            state.serialize_entry("types", value)?;
        }
        if let Some(value) = self.type_collection() {
            state.serialize_entry("typeCollection", value)?;
        }
        if self.or_conditions.is_some() {
            state.serialize_entry("orConditions", &self.or_conditions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryBigQueryConditions].
pub mod discovery_big_query_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// There is an OR relationship between these attributes. They are used to
    /// determine if a table should be scanned or not in Discovery.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OrConditions {
        /// Minimum number of rows that should be present before Cloud DLP
        /// profiles a table
        pub min_row_count: i32,

        /// Minimum age a table must have before Cloud DLP can profile it. Value must
        /// be 1 hour or greater.
        pub min_age: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OrConditions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_row_count][crate::model::discovery_big_query_conditions::OrConditions::min_row_count].
        pub fn set_min_row_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_row_count = v.into();
            self
        }

        /// Sets the value of [min_age][crate::model::discovery_big_query_conditions::OrConditions::min_age].
        pub fn set_min_age<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_age = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_age][crate::model::discovery_big_query_conditions::OrConditions::min_age].
        pub fn set_or_clear_min_age<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_age = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for OrConditions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryConditions.OrConditions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OrConditions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __min_row_count,
                __min_age,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OrConditions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "minRowCount" => Ok(__FieldTag::__min_row_count),
                                "min_row_count" => Ok(__FieldTag::__min_row_count),
                                "minAge" => Ok(__FieldTag::__min_age),
                                "min_age" => Ok(__FieldTag::__min_age),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OrConditions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OrConditions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__min_row_count => {
                                if !fields.insert(__FieldTag::__min_row_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_row_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.min_row_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__min_age => {
                                if !fields.insert(__FieldTag::__min_age) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_age",
                                    ));
                                }
                                result.min_age =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OrConditions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.min_row_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("minRowCount", &__With(&self.min_row_count))?;
            }
            if self.min_age.is_some() {
                state.serialize_entry("minAge", &self.min_age)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The type of BigQuery tables to scan. If nothing is set the default
    /// behavior is to scan only tables of type TABLE and to give errors
    /// for all unsupported tables.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IncludedTypes {
        /// Restrict discovery to specific table types.
        Types(std::boxed::Box<crate::model::BigQueryTableTypes>),
        /// Restrict discovery to categories of table types.
        TypeCollection(crate::model::BigQueryTableTypeCollection),
    }
}

/// What must take place for a profile to be updated and how
/// frequently it should occur.
/// New tables are scanned as quickly as possible depending on system
/// capacity.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryGenerationCadence {
    /// Governs when to update data profiles when a schema is modified.
    pub schema_modified_cadence: std::option::Option<crate::model::DiscoverySchemaModifiedCadence>,

    /// Governs when to update data profiles when a table is modified.
    pub table_modified_cadence: std::option::Option<crate::model::DiscoveryTableModifiedCadence>,

    /// Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,

    /// Frequency at which profiles should be updated, regardless of whether the
    /// underlying resource has changed. Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_modified_cadence][crate::model::DiscoveryGenerationCadence::schema_modified_cadence].
    pub fn set_schema_modified_cadence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoverySchemaModifiedCadence>,
    {
        self.schema_modified_cadence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_modified_cadence][crate::model::DiscoveryGenerationCadence::schema_modified_cadence].
    pub fn set_or_clear_schema_modified_cadence<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoverySchemaModifiedCadence>,
    {
        self.schema_modified_cadence = v.map(|x| x.into());
        self
    }

    /// Sets the value of [table_modified_cadence][crate::model::DiscoveryGenerationCadence::table_modified_cadence].
    pub fn set_table_modified_cadence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryTableModifiedCadence>,
    {
        self.table_modified_cadence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table_modified_cadence][crate::model::DiscoveryGenerationCadence::table_modified_cadence].
    pub fn set_or_clear_table_modified_cadence<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryTableModifiedCadence>,
    {
        self.table_modified_cadence = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryInspectTemplateModifiedCadence>,
    {
        self.inspect_template_modified_cadence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_template_modified_cadence][crate::model::DiscoveryGenerationCadence::inspect_template_modified_cadence].
    pub fn set_or_clear_inspect_template_modified_cadence<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryInspectTemplateModifiedCadence>,
    {
        self.inspect_template_modified_cadence = v.map(|x| x.into());
        self
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryGenerationCadence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryGenerationCadence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schema_modified_cadence,
            __table_modified_cadence,
            __inspect_template_modified_cadence,
            __refresh_frequency,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryGenerationCadence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schemaModifiedCadence" => Ok(__FieldTag::__schema_modified_cadence),
                            "schema_modified_cadence" => Ok(__FieldTag::__schema_modified_cadence),
                            "tableModifiedCadence" => Ok(__FieldTag::__table_modified_cadence),
                            "table_modified_cadence" => Ok(__FieldTag::__table_modified_cadence),
                            "inspectTemplateModifiedCadence" => {
                                Ok(__FieldTag::__inspect_template_modified_cadence)
                            }
                            "inspect_template_modified_cadence" => {
                                Ok(__FieldTag::__inspect_template_modified_cadence)
                            }
                            "refreshFrequency" => Ok(__FieldTag::__refresh_frequency),
                            "refresh_frequency" => Ok(__FieldTag::__refresh_frequency),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryGenerationCadence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryGenerationCadence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schema_modified_cadence => {
                            if !fields.insert(__FieldTag::__schema_modified_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_modified_cadence",
                                ));
                            }
                            result.schema_modified_cadence =
                                map.next_value::<std::option::Option<
                                    crate::model::DiscoverySchemaModifiedCadence,
                                >>()?;
                        }
                        __FieldTag::__table_modified_cadence => {
                            if !fields.insert(__FieldTag::__table_modified_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_modified_cadence",
                                ));
                            }
                            result.table_modified_cadence =
                                map.next_value::<std::option::Option<
                                    crate::model::DiscoveryTableModifiedCadence,
                                >>()?;
                        }
                        __FieldTag::__inspect_template_modified_cadence => {
                            if !fields.insert(__FieldTag::__inspect_template_modified_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template_modified_cadence",
                                ));
                            }
                            result.inspect_template_modified_cadence = map
                                .next_value::<std::option::Option<
                                    crate::model::DiscoveryInspectTemplateModifiedCadence,
                                >>()?;
                        }
                        __FieldTag::__refresh_frequency => {
                            if !fields.insert(__FieldTag::__refresh_frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_frequency",
                                ));
                            }
                            result.refresh_frequency = map.next_value::<std::option::Option<crate::model::DataProfileUpdateFrequency>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryGenerationCadence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.schema_modified_cadence.is_some() {
            state.serialize_entry("schemaModifiedCadence", &self.schema_modified_cadence)?;
        }
        if self.table_modified_cadence.is_some() {
            state.serialize_entry("tableModifiedCadence", &self.table_modified_cadence)?;
        }
        if self.inspect_template_modified_cadence.is_some() {
            state.serialize_entry(
                "inspectTemplateModifiedCadence",
                &self.inspect_template_modified_cadence,
            )?;
        }
        if !wkt::internal::is_default(&self.refresh_frequency) {
            state.serialize_entry("refreshFrequency", &self.refresh_frequency)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The cadence at which to update data profiles when a table is modified.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryTableModifiedCadence {
    /// The type of events to consider when deciding if the table has been
    /// modified and should have the profile updated. Defaults to
    /// MODIFIED_TIMESTAMP.
    pub types: std::vec::Vec<crate::model::BigQueryTableModification>,

    /// How frequently data profiles can be updated when tables are modified.
    /// Defaults to never.
    pub frequency: crate::model::DataProfileUpdateFrequency,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryTableModifiedCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [types][crate::model::DiscoveryTableModifiedCadence::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQueryTableModification>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [frequency][crate::model::DiscoveryTableModifiedCadence::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryTableModifiedCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryTableModifiedCadence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryTableModifiedCadence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __types,
            __frequency,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryTableModifiedCadence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "types" => Ok(__FieldTag::__types),
                            "frequency" => Ok(__FieldTag::__frequency),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryTableModifiedCadence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryTableModifiedCadence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__types => {
                            if !fields.insert(__FieldTag::__types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for types",
                                ));
                            }
                            result.types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BigQueryTableModification>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__frequency => {
                            if !fields.insert(__FieldTag::__frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency",
                                ));
                            }
                            result.frequency = map.next_value::<std::option::Option<crate::model::DataProfileUpdateFrequency>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryTableModifiedCadence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.types.is_empty() {
            state.serialize_entry("types", &self.types)?;
        }
        if !wkt::internal::is_default(&self.frequency) {
            state.serialize_entry("frequency", &self.frequency)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The cadence at which to update data profiles when a schema is modified.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoverySchemaModifiedCadence {
    /// The type of events to consider when deciding if the table's schema
    /// has been modified and should have the profile updated. Defaults to
    /// NEW_COLUMNS.
    pub types: std::vec::Vec<crate::model::BigQuerySchemaModification>,

    /// How frequently profiles may be updated when schemas are
    /// modified. Defaults to monthly.
    pub frequency: crate::model::DataProfileUpdateFrequency,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoverySchemaModifiedCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [types][crate::model::DiscoverySchemaModifiedCadence::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQuerySchemaModification>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [frequency][crate::model::DiscoverySchemaModifiedCadence::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }
}

impl wkt::message::Message for DiscoverySchemaModifiedCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoverySchemaModifiedCadence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoverySchemaModifiedCadence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __types,
            __frequency,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoverySchemaModifiedCadence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "types" => Ok(__FieldTag::__types),
                            "frequency" => Ok(__FieldTag::__frequency),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoverySchemaModifiedCadence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoverySchemaModifiedCadence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__types => {
                            if !fields.insert(__FieldTag::__types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for types",
                                ));
                            }
                            result.types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BigQuerySchemaModification>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__frequency => {
                            if !fields.insert(__FieldTag::__frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency",
                                ));
                            }
                            result.frequency = map.next_value::<std::option::Option<crate::model::DataProfileUpdateFrequency>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoverySchemaModifiedCadence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.types.is_empty() {
            state.serialize_entry("types", &self.types)?;
        }
        if !wkt::internal::is_default(&self.frequency) {
            state.serialize_entry("frequency", &self.frequency)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The cadence at which to update data profiles when the inspection rules
/// defined by the `InspectTemplate` change.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryInspectTemplateModifiedCadence {
    /// How frequently data profiles can be updated when the template is modified.
    /// Defaults to never.
    pub frequency: crate::model::DataProfileUpdateFrequency,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryInspectTemplateModifiedCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [frequency][crate::model::DiscoveryInspectTemplateModifiedCadence::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryInspectTemplateModifiedCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryInspectTemplateModifiedCadence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryInspectTemplateModifiedCadence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __frequency,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DiscoveryInspectTemplateModifiedCadence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "frequency" => Ok(__FieldTag::__frequency),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryInspectTemplateModifiedCadence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryInspectTemplateModifiedCadence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__frequency => {
                            if !fields.insert(__FieldTag::__frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency",
                                ));
                            }
                            result.frequency = map.next_value::<std::option::Option<crate::model::DataProfileUpdateFrequency>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryInspectTemplateModifiedCadence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.frequency) {
            state.serialize_entry("frequency", &self.frequency)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Target used to match against for discovery with Cloud SQL tables.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSqlDiscoveryTarget {
    /// Required. The tables the discovery cadence applies to. The first target
    /// with a matching filter will be the one to apply to a table.
    pub filter: std::option::Option<crate::model::DiscoveryCloudSqlFilter>,

    /// In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    pub conditions: std::option::Option<crate::model::DiscoveryCloudSqlConditions>,

    /// Type of schedule.
    pub cadence: std::option::Option<crate::model::cloud_sql_discovery_target::Cadence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::CloudSqlDiscoveryTarget::filter].
    pub fn set_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryCloudSqlFilter>,
    {
        self.filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [filter][crate::model::CloudSqlDiscoveryTarget::filter].
    pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryCloudSqlFilter>,
    {
        self.filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conditions][crate::model::CloudSqlDiscoveryTarget::conditions].
    pub fn set_conditions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryCloudSqlConditions>,
    {
        self.conditions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conditions][crate::model::CloudSqlDiscoveryTarget::conditions].
    pub fn set_or_clear_conditions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryCloudSqlConditions>,
    {
        self.conditions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence].
    ///
    /// Note that all the setters affecting `cadence` are mutually
    /// exclusive.
    pub fn set_cadence<
        T: std::convert::Into<std::option::Option<crate::model::cloud_sql_discovery_target::Cadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryCloudSqlGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryCloudSqlGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_sql_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// The value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_sql_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudSqlDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudSqlDiscoveryTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSqlDiscoveryTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __conditions,
            __generation_cadence,
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSqlDiscoveryTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "generationCadence" => Ok(__FieldTag::__generation_cadence),
                            "generation_cadence" => Ok(__FieldTag::__generation_cadence),
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSqlDiscoveryTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSqlDiscoveryTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map.next_value::<std::option::Option<crate::model::DiscoveryCloudSqlFilter>>()?
                                ;
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<crate::model::DiscoveryCloudSqlConditions>>()?
                                ;
                        }
                        __FieldTag::__generation_cadence => {
                            if !fields.insert(__FieldTag::__generation_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation_cadence",
                                ));
                            }
                            if result.cadence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cadence`, a oneof with full ID .google.privacy.dlp.v2.CloudSqlDiscoveryTarget.generation_cadence, latest field was generationCadence",
                                ));
                            }
                            result.cadence = std::option::Option::Some(
                                crate::model::cloud_sql_discovery_target::Cadence::GenerationCadence(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DiscoveryCloudSqlGenerationCadence>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            if result.cadence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cadence`, a oneof with full ID .google.privacy.dlp.v2.CloudSqlDiscoveryTarget.disabled, latest field was disabled",
                                ));
                            }
                            result.cadence = std::option::Option::Some(
                                crate::model::cloud_sql_discovery_target::Cadence::Disabled(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Disabled>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSqlDiscoveryTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.conditions.is_some() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if let Some(value) = self.generation_cadence() {
            state.serialize_entry("generationCadence", value)?;
        }
        if let Some(value) = self.disabled() {
            state.serialize_entry("disabled", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CloudSqlDiscoveryTarget].
pub mod cloud_sql_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// Type of schedule.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Cadence {
        /// How often and when to update profiles. New tables that match both the
        /// filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryCloudSqlGenerationCadence>),
        /// Disable profiling for database resources that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines what tables will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID, location, instance, database, and database resource name.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryCloudSqlFilter {
    /// Whether the filter applies to a specific set of database resources or all
    /// other database resources within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    pub filter: std::option::Option<crate::model::discovery_cloud_sql_filter::Filter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudSqlFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudSqlFilter::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::discovery_cloud_sql_filter::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseResourceCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_sql_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseResourceCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_sql_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn others(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherDatabaseResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_sql_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<
        T: std::convert::Into<std::boxed::Box<crate::model::AllOtherDatabaseResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_sql_filter::Filter::Others(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// if it holds a `DatabaseResourceReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn database_resource_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseResourceReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_sql_filter::Filter::DatabaseResourceReference(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// to hold a `DatabaseResourceReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_database_resource_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_sql_filter::Filter::DatabaseResourceReference(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryCloudSqlFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryCloudSqlFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __collection,
            __others,
            __database_resource_reference,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryCloudSqlFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "collection" => Ok(__FieldTag::__collection),
                            "others" => Ok(__FieldTag::__others),
                            "databaseResourceReference" => {
                                Ok(__FieldTag::__database_resource_reference)
                            }
                            "database_resource_reference" => {
                                Ok(__FieldTag::__database_resource_reference)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryCloudSqlFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryCloudSqlFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__collection => {
                            if !fields.insert(__FieldTag::__collection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryCloudSqlFilter.collection, latest field was collection",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_cloud_sql_filter::Filter::Collection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DatabaseResourceCollection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__others => {
                            if !fields.insert(__FieldTag::__others) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for others",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryCloudSqlFilter.others, latest field was others",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_cloud_sql_filter::Filter::Others(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AllOtherDatabaseResources>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__database_resource_reference => {
                            if !fields.insert(__FieldTag::__database_resource_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_resource_reference",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryCloudSqlFilter.database_resource_reference, latest field was databaseResourceReference",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_cloud_sql_filter::Filter::DatabaseResourceReference(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DatabaseResourceReference>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryCloudSqlFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.collection() {
            state.serialize_entry("collection", value)?;
        }
        if let Some(value) = self.others() {
            state.serialize_entry("others", value)?;
        }
        if let Some(value) = self.database_resource_reference() {
            state.serialize_entry("databaseResourceReference", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryCloudSqlFilter].
pub mod discovery_cloud_sql_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of database resources or all
    /// other database resources within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Filter {
        /// A specific set of database resources for this filter to apply to.
        Collection(std::boxed::Box<crate::model::DatabaseResourceCollection>),
        /// Catch-all. This should always be the last target in the list because
        /// anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherDatabaseResources>),
        /// The database resource to scan. Targets including this can only include
        /// one target (the target with this database resource reference).
        DatabaseResourceReference(std::boxed::Box<crate::model::DatabaseResourceReference>),
    }
}

/// Match database resources using regex filters. Examples of database
/// resources are tables, views, and stored procedures.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseResourceCollection {
    /// The first filter containing a pattern that matches a database resource will
    /// be used.
    pub pattern: std::option::Option<crate::model::database_resource_collection::Pattern>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseResourceCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pattern][crate::model::DatabaseResourceCollection::pattern].
    ///
    /// Note that all the setters affecting `pattern` are mutually
    /// exclusive.
    pub fn set_pattern<
        T: std::convert::Into<
                std::option::Option<crate::model::database_resource_collection::Pattern>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::DatabaseResourceCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseResourceRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::database_resource_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::DatabaseResourceCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseResourceRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::database_resource_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DatabaseResourceCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceCollection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseResourceCollection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_regexes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseResourceCollection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeRegexes" => Ok(__FieldTag::__include_regexes),
                            "include_regexes" => Ok(__FieldTag::__include_regexes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseResourceCollection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseResourceCollection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_regexes => {
                            if !fields.insert(__FieldTag::__include_regexes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_regexes",
                                ));
                            }
                            if result.pattern.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `pattern`, a oneof with full ID .google.privacy.dlp.v2.DatabaseResourceCollection.include_regexes, latest field was includeRegexes",
                                ));
                            }
                            result.pattern = std::option::Option::Some(
                                crate::model::database_resource_collection::Pattern::IncludeRegexes(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DatabaseResourceRegexes>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseResourceCollection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.include_regexes() {
            state.serialize_entry("includeRegexes", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DatabaseResourceCollection].
pub mod database_resource_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The first filter containing a pattern that matches a database resource will
    /// be used.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Pattern {
        /// A collection of regular expressions to match a database resource against.
        IncludeRegexes(std::boxed::Box<crate::model::DatabaseResourceRegexes>),
    }
}

/// A collection of regular expressions to determine what database resources to
/// match against.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseResourceRegexes {
    /// A group of regular expression patterns to match against one or more
    /// database resources.
    /// Maximum of 100 entries. The sum of all regular expression's length can't
    /// exceed 10 KiB.
    pub patterns: std::vec::Vec<crate::model::DatabaseResourceRegex>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseResourceRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::DatabaseResourceRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseResourceRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatabaseResourceRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceRegexes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseResourceRegexes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patterns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseResourceRegexes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patterns" => Ok(__FieldTag::__patterns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseResourceRegexes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseResourceRegexes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patterns => {
                            if !fields.insert(__FieldTag::__patterns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patterns",
                                ));
                            }
                            result.patterns = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DatabaseResourceRegex>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseResourceRegexes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.patterns.is_empty() {
            state.serialize_entry("patterns", &self.patterns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A pattern to match against one or more database resources. At least one
/// pattern must be specified. Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseResourceRegex {
    /// For organizations, if unset, will match all projects. Has no effect
    /// for configurations created within a project.
    pub project_id_regex: std::string::String,

    /// Regex to test the instance name against. If empty, all instances match.
    pub instance_regex: std::string::String,

    /// Regex to test the database name against. If empty, all databases match.
    pub database_regex: std::string::String,

    /// Regex to test the database resource's name against. An example of a
    /// database resource name is a table's name. Other database resource names
    /// like view names could be included in the future. If empty, all database
    /// resources match.
    pub database_resource_name_regex: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseResourceRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::DatabaseResourceRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }

    /// Sets the value of [instance_regex][crate::model::DatabaseResourceRegex::instance_regex].
    pub fn set_instance_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_regex = v.into();
        self
    }

    /// Sets the value of [database_regex][crate::model::DatabaseResourceRegex::database_regex].
    pub fn set_database_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_regex = v.into();
        self
    }

    /// Sets the value of [database_resource_name_regex][crate::model::DatabaseResourceRegex::database_resource_name_regex].
    pub fn set_database_resource_name_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_resource_name_regex = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseResourceRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceRegex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseResourceRegex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id_regex,
            __instance_regex,
            __database_regex,
            __database_resource_name_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseResourceRegex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectIdRegex" => Ok(__FieldTag::__project_id_regex),
                            "project_id_regex" => Ok(__FieldTag::__project_id_regex),
                            "instanceRegex" => Ok(__FieldTag::__instance_regex),
                            "instance_regex" => Ok(__FieldTag::__instance_regex),
                            "databaseRegex" => Ok(__FieldTag::__database_regex),
                            "database_regex" => Ok(__FieldTag::__database_regex),
                            "databaseResourceNameRegex" => {
                                Ok(__FieldTag::__database_resource_name_regex)
                            }
                            "database_resource_name_regex" => {
                                Ok(__FieldTag::__database_resource_name_regex)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseResourceRegex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseResourceRegex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id_regex => {
                            if !fields.insert(__FieldTag::__project_id_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id_regex",
                                ));
                            }
                            result.project_id_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_regex => {
                            if !fields.insert(__FieldTag::__instance_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_regex",
                                ));
                            }
                            result.instance_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_regex => {
                            if !fields.insert(__FieldTag::__database_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_regex",
                                ));
                            }
                            result.database_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_resource_name_regex => {
                            if !fields.insert(__FieldTag::__database_resource_name_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_resource_name_regex",
                                ));
                            }
                            result.database_resource_name_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseResourceRegex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id_regex.is_empty() {
            state.serialize_entry("projectIdRegex", &self.project_id_regex)?;
        }
        if !self.instance_regex.is_empty() {
            state.serialize_entry("instanceRegex", &self.instance_regex)?;
        }
        if !self.database_regex.is_empty() {
            state.serialize_entry("databaseRegex", &self.database_regex)?;
        }
        if !self.database_resource_name_regex.is_empty() {
            state.serialize_entry(
                "databaseResourceNameRegex",
                &self.database_resource_name_regex,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Match database resources not covered by any other filter.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AllOtherDatabaseResources {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllOtherDatabaseResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AllOtherDatabaseResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AllOtherDatabaseResources"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AllOtherDatabaseResources {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllOtherDatabaseResources")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AllOtherDatabaseResources;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllOtherDatabaseResources")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AllOtherDatabaseResources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identifies a single database resource, like a table within a database.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseResourceReference {
    /// Required. If within a project-level config, then this must match the
    /// config's project ID.
    pub project_id: std::string::String,

    /// Required. The instance where this resource is located. For example: Cloud
    /// SQL instance ID.
    pub instance: std::string::String,

    /// Required. Name of a database within the instance.
    pub database: std::string::String,

    /// Required. Name of a database resource, for example, a table within the
    /// database.
    pub database_resource: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DatabaseResourceReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::DatabaseResourceReference::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [database][crate::model::DatabaseResourceReference::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [database_resource][crate::model::DatabaseResourceReference::database_resource].
    pub fn set_database_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_resource = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseResourceReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __instance,
            __database,
            __database_resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseResourceReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "instance" => Ok(__FieldTag::__instance),
                            "database" => Ok(__FieldTag::__database),
                            "databaseResource" => Ok(__FieldTag::__database_resource),
                            "database_resource" => Ok(__FieldTag::__database_resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseResourceReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseResourceReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_resource => {
                            if !fields.insert(__FieldTag::__database_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_resource",
                                ));
                            }
                            result.database_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseResourceReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.database_resource.is_empty() {
            state.serialize_entry("databaseResource", &self.database_resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Requirements that must be true before a table is profiled for the
/// first time.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryCloudSqlConditions {
    /// Optional. Database engines that should be profiled.
    /// Optional. Defaults to ALL_SUPPORTED_DATABASE_ENGINES if unspecified.
    pub database_engines:
        std::vec::Vec<crate::model::discovery_cloud_sql_conditions::DatabaseEngine>,

    /// Data profiles will only be generated for the database resource types
    /// specified in this field.
    /// If not specified, defaults to [DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES].
    pub types: std::vec::Vec<crate::model::discovery_cloud_sql_conditions::DatabaseResourceType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudSqlConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_engines][crate::model::DiscoveryCloudSqlConditions::database_engines].
    pub fn set_database_engines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::discovery_cloud_sql_conditions::DatabaseEngine>,
    {
        use std::iter::Iterator;
        self.database_engines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [types][crate::model::DiscoveryCloudSqlConditions::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::discovery_cloud_sql_conditions::DatabaseResourceType>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiscoveryCloudSqlConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlConditions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryCloudSqlConditions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database_engines,
            __types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryCloudSqlConditions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "databaseEngines" => Ok(__FieldTag::__database_engines),
                            "database_engines" => Ok(__FieldTag::__database_engines),
                            "types" => Ok(__FieldTag::__types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryCloudSqlConditions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryCloudSqlConditions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database_engines => {
                            if !fields.insert(__FieldTag::__database_engines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_engines",
                                ));
                            }
                            result.database_engines = map.next_value::<std::option::Option<std::vec::Vec<crate::model::discovery_cloud_sql_conditions::DatabaseEngine>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__types => {
                            if !fields.insert(__FieldTag::__types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for types",
                                ));
                            }
                            result.types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::discovery_cloud_sql_conditions::DatabaseResourceType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryCloudSqlConditions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.database_engines.is_empty() {
            state.serialize_entry("databaseEngines", &self.database_engines)?;
        }
        if !self.types.is_empty() {
            state.serialize_entry("types", &self.types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryCloudSqlConditions].
pub mod discovery_cloud_sql_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// The database engines that should be profiled.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseEngine {
        /// Unused.
        Unspecified,
        /// Include all supported database engines.
        AllSupportedDatabaseEngines,
        /// MySQL database.
        Mysql,
        /// PostgreSQL database.
        Postgres,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseEngine::value] or
        /// [DatabaseEngine::name].
        UnknownValue(database_engine::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_engine {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseEngine {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllSupportedDatabaseEngines => std::option::Option::Some(1),
                Self::Mysql => std::option::Option::Some(2),
                Self::Postgres => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_ENGINE_UNSPECIFIED"),
                Self::AllSupportedDatabaseEngines => {
                    std::option::Option::Some("ALL_SUPPORTED_DATABASE_ENGINES")
                }
                Self::Mysql => std::option::Option::Some("MYSQL"),
                Self::Postgres => std::option::Option::Some("POSTGRES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseEngine {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseEngine {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseEngine {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllSupportedDatabaseEngines,
                2 => Self::Mysql,
                3 => Self::Postgres,
                _ => Self::UnknownValue(database_engine::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseEngine {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_ENGINE_UNSPECIFIED" => Self::Unspecified,
                "ALL_SUPPORTED_DATABASE_ENGINES" => Self::AllSupportedDatabaseEngines,
                "MYSQL" => Self::Mysql,
                "POSTGRES" => Self::Postgres,
                _ => Self::UnknownValue(database_engine::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseEngine {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllSupportedDatabaseEngines => serializer.serialize_i32(1),
                Self::Mysql => serializer.serialize_i32(2),
                Self::Postgres => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseEngine {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEngine>::new(
                ".google.privacy.dlp.v2.DiscoveryCloudSqlConditions.DatabaseEngine",
            ))
        }
    }

    /// Cloud SQL database resource types. New values can be added at a later time.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseResourceType {
        /// Unused.
        Unspecified,
        /// Includes database resource types that become supported at a later time.
        AllSupportedTypes,
        /// Tables.
        Table,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseResourceType::value] or
        /// [DatabaseResourceType::name].
        UnknownValue(database_resource_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_resource_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseResourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllSupportedTypes => std::option::Option::Some(1),
                Self::Table => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DATABASE_RESOURCE_TYPE_UNSPECIFIED")
                }
                Self::AllSupportedTypes => {
                    std::option::Option::Some("DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES")
                }
                Self::Table => std::option::Option::Some("DATABASE_RESOURCE_TYPE_TABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseResourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseResourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseResourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllSupportedTypes,
                2 => Self::Table,
                _ => Self::UnknownValue(database_resource_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseResourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_RESOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES" => Self::AllSupportedTypes,
                "DATABASE_RESOURCE_TYPE_TABLE" => Self::Table,
                _ => Self::UnknownValue(database_resource_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseResourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllSupportedTypes => serializer.serialize_i32(1),
                Self::Table => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseResourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseResourceType>::new(
                ".google.privacy.dlp.v2.DiscoveryCloudSqlConditions.DatabaseResourceType",
            ))
        }
    }
}

/// How often existing tables should have their profiles refreshed.
/// New tables are scanned as quickly as possible depending on system
/// capacity.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryCloudSqlGenerationCadence {
    /// When to reprofile if the schema has changed.
    pub schema_modified_cadence: std::option::Option<
        crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence,
    >,

    /// Data changes (non-schema changes) in Cloud SQL tables can't trigger
    /// reprofiling. If you set this field, profiles are refreshed at this
    /// frequency regardless of whether the underlying tables have changed.
    /// Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudSqlGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_modified_cadence][crate::model::DiscoveryCloudSqlGenerationCadence::schema_modified_cadence].
    pub fn set_schema_modified_cadence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence,
            >,
    {
        self.schema_modified_cadence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_modified_cadence][crate::model::DiscoveryCloudSqlGenerationCadence::schema_modified_cadence].
    pub fn set_or_clear_schema_modified_cadence<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence,
            >,
    {
        self.schema_modified_cadence = v.map(|x| x.into());
        self
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryCloudSqlGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryCloudSqlGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryInspectTemplateModifiedCadence>,
    {
        self.inspect_template_modified_cadence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_template_modified_cadence][crate::model::DiscoveryCloudSqlGenerationCadence::inspect_template_modified_cadence].
    pub fn set_or_clear_inspect_template_modified_cadence<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryInspectTemplateModifiedCadence>,
    {
        self.inspect_template_modified_cadence = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiscoveryCloudSqlGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlGenerationCadence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryCloudSqlGenerationCadence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schema_modified_cadence,
            __refresh_frequency,
            __inspect_template_modified_cadence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryCloudSqlGenerationCadence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schemaModifiedCadence" => Ok(__FieldTag::__schema_modified_cadence),
                            "schema_modified_cadence" => Ok(__FieldTag::__schema_modified_cadence),
                            "refreshFrequency" => Ok(__FieldTag::__refresh_frequency),
                            "refresh_frequency" => Ok(__FieldTag::__refresh_frequency),
                            "inspectTemplateModifiedCadence" => {
                                Ok(__FieldTag::__inspect_template_modified_cadence)
                            }
                            "inspect_template_modified_cadence" => {
                                Ok(__FieldTag::__inspect_template_modified_cadence)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryCloudSqlGenerationCadence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryCloudSqlGenerationCadence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schema_modified_cadence => {
                            if !fields.insert(__FieldTag::__schema_modified_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_modified_cadence",
                                ));
                            }
                            result.schema_modified_cadence = map.next_value::<std::option::Option<crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence>>()?
                                ;
                        }
                        __FieldTag::__refresh_frequency => {
                            if !fields.insert(__FieldTag::__refresh_frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_frequency",
                                ));
                            }
                            result.refresh_frequency = map.next_value::<std::option::Option<crate::model::DataProfileUpdateFrequency>>()?.unwrap_or_default();
                        }
                        __FieldTag::__inspect_template_modified_cadence => {
                            if !fields.insert(__FieldTag::__inspect_template_modified_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template_modified_cadence",
                                ));
                            }
                            result.inspect_template_modified_cadence = map
                                .next_value::<std::option::Option<
                                    crate::model::DiscoveryInspectTemplateModifiedCadence,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryCloudSqlGenerationCadence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.schema_modified_cadence.is_some() {
            state.serialize_entry("schemaModifiedCadence", &self.schema_modified_cadence)?;
        }
        if !wkt::internal::is_default(&self.refresh_frequency) {
            state.serialize_entry("refreshFrequency", &self.refresh_frequency)?;
        }
        if self.inspect_template_modified_cadence.is_some() {
            state.serialize_entry(
                "inspectTemplateModifiedCadence",
                &self.inspect_template_modified_cadence,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryCloudSqlGenerationCadence].
pub mod discovery_cloud_sql_generation_cadence {
    #[allow(unused_imports)]
    use super::*;

    /// How frequently to modify the profile when the table's schema is modified.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SchemaModifiedCadence {

        /// The types of schema modifications to consider.
        /// Defaults to NEW_COLUMNS.
        pub types: std::vec::Vec<crate::model::discovery_cloud_sql_generation_cadence::schema_modified_cadence::CloudSqlSchemaModification>,

        /// Frequency to regenerate data profiles when the schema is modified.
        /// Defaults to monthly.
        pub frequency: crate::model::DataProfileUpdateFrequency,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SchemaModifiedCadence {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [types][crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence::types].
        pub fn set_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::discovery_cloud_sql_generation_cadence::schema_modified_cadence::CloudSqlSchemaModification>
        {
            use std::iter::Iterator;
            self.types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [frequency][crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence::frequency].
        pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
            mut self,
            v: T,
        ) -> Self {
            self.frequency = v.into();
            self
        }
    }

    impl wkt::message::Message for SchemaModifiedCadence {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlGenerationCadence.SchemaModifiedCadence"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SchemaModifiedCadence {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __types,
                __frequency,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SchemaModifiedCadence")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "types" => Ok(__FieldTag::__types),
                                "frequency" => Ok(__FieldTag::__frequency),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SchemaModifiedCadence;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SchemaModifiedCadence")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__types => {
                                if !fields.insert(__FieldTag::__types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for types",
                                    ));
                                }
                                result.types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::discovery_cloud_sql_generation_cadence::schema_modified_cadence::CloudSqlSchemaModification>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__frequency => {
                                if !fields.insert(__FieldTag::__frequency) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for frequency",
                                    ));
                                }
                                result.frequency =
                                    map.next_value::<std::option::Option<
                                        crate::model::DataProfileUpdateFrequency,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SchemaModifiedCadence {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.types.is_empty() {
                state.serialize_entry("types", &self.types)?;
            }
            if !wkt::internal::is_default(&self.frequency) {
                state.serialize_entry("frequency", &self.frequency)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SchemaModifiedCadence].
    pub mod schema_modified_cadence {
        #[allow(unused_imports)]
        use super::*;

        /// The type of modification that causes a profile update.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum CloudSqlSchemaModification {
            /// Unused.
            SqlSchemaModificationUnspecified,
            /// New columns have appeared.
            NewColumns,
            /// Columns have been removed from the table.
            RemovedColumns,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [CloudSqlSchemaModification::value] or
            /// [CloudSqlSchemaModification::name].
            UnknownValue(cloud_sql_schema_modification::UnknownValue),
        }

        #[doc(hidden)]
        pub mod cloud_sql_schema_modification {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl CloudSqlSchemaModification {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::SqlSchemaModificationUnspecified => std::option::Option::Some(0),
                    Self::NewColumns => std::option::Option::Some(1),
                    Self::RemovedColumns => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::SqlSchemaModificationUnspecified => {
                        std::option::Option::Some("SQL_SCHEMA_MODIFICATION_UNSPECIFIED")
                    }
                    Self::NewColumns => std::option::Option::Some("NEW_COLUMNS"),
                    Self::RemovedColumns => std::option::Option::Some("REMOVED_COLUMNS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for CloudSqlSchemaModification {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for CloudSqlSchemaModification {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for CloudSqlSchemaModification {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::SqlSchemaModificationUnspecified,
                    1 => Self::NewColumns,
                    2 => Self::RemovedColumns,
                    _ => Self::UnknownValue(cloud_sql_schema_modification::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for CloudSqlSchemaModification {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SQL_SCHEMA_MODIFICATION_UNSPECIFIED" => Self::SqlSchemaModificationUnspecified,
                    "NEW_COLUMNS" => Self::NewColumns,
                    "REMOVED_COLUMNS" => Self::RemovedColumns,
                    _ => Self::UnknownValue(cloud_sql_schema_modification::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for CloudSqlSchemaModification {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::SqlSchemaModificationUnspecified => serializer.serialize_i32(0),
                    Self::NewColumns => serializer.serialize_i32(1),
                    Self::RemovedColumns => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for CloudSqlSchemaModification {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudSqlSchemaModification>::new(
                    ".google.privacy.dlp.v2.DiscoveryCloudSqlGenerationCadence.SchemaModifiedCadence.CloudSqlSchemaModification"))
            }
        }
    }
}

/// Discovery target for credentials and secrets in cloud resource metadata.
///
/// This target does not include any filtering or frequency controls. Cloud
/// DLP will scan cloud resource metadata for secrets daily.
///
/// No inspect template should be included in the discovery config for a
/// security benchmarks scan. Instead, the built-in list of secrets and
/// credentials infoTypes will be used (see
/// <https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference#credentials_and_secrets>).
///
/// Credentials and secrets discovered will be reported as vulnerabilities to
/// Security Command Center.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretsDiscoveryTarget {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretsDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SecretsDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SecretsDiscoveryTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretsDiscoveryTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretsDiscoveryTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretsDiscoveryTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretsDiscoveryTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretsDiscoveryTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Target used to match against for discovery with Cloud Storage buckets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStorageDiscoveryTarget {
    /// Required. The buckets the generation_cadence applies to. The first target
    /// with a matching filter will be the one to apply to a bucket.
    pub filter: std::option::Option<crate::model::DiscoveryCloudStorageFilter>,

    /// Optional. In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    pub conditions: std::option::Option<crate::model::DiscoveryFileStoreConditions>,

    /// How often and when to update profiles.
    pub cadence: std::option::Option<crate::model::cloud_storage_discovery_target::Cadence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::CloudStorageDiscoveryTarget::filter].
    pub fn set_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryCloudStorageFilter>,
    {
        self.filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [filter][crate::model::CloudStorageDiscoveryTarget::filter].
    pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryCloudStorageFilter>,
    {
        self.filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conditions][crate::model::CloudStorageDiscoveryTarget::conditions].
    pub fn set_conditions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryFileStoreConditions>,
    {
        self.conditions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conditions][crate::model::CloudStorageDiscoveryTarget::conditions].
    pub fn set_or_clear_conditions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryFileStoreConditions>,
    {
        self.conditions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence].
    ///
    /// Note that all the setters affecting `cadence` are mutually
    /// exclusive.
    pub fn set_cadence<
        T: std::convert::Into<
                std::option::Option<crate::model::cloud_storage_discovery_target::Cadence>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryCloudStorageGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_storage_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryCloudStorageGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_storage_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// The value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_storage_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_storage_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudStorageDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageDiscoveryTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudStorageDiscoveryTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __conditions,
            __generation_cadence,
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudStorageDiscoveryTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "generationCadence" => Ok(__FieldTag::__generation_cadence),
                            "generation_cadence" => Ok(__FieldTag::__generation_cadence),
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudStorageDiscoveryTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudStorageDiscoveryTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map.next_value::<std::option::Option<crate::model::DiscoveryCloudStorageFilter>>()?
                                ;
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<crate::model::DiscoveryFileStoreConditions>>()?
                                ;
                        }
                        __FieldTag::__generation_cadence => {
                            if !fields.insert(__FieldTag::__generation_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation_cadence",
                                ));
                            }
                            if result.cadence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cadence`, a oneof with full ID .google.privacy.dlp.v2.CloudStorageDiscoveryTarget.generation_cadence, latest field was generationCadence",
                                ));
                            }
                            result.cadence = std::option::Option::Some(
                                crate::model::cloud_storage_discovery_target::Cadence::GenerationCadence(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DiscoveryCloudStorageGenerationCadence>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            if result.cadence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cadence`, a oneof with full ID .google.privacy.dlp.v2.CloudStorageDiscoveryTarget.disabled, latest field was disabled",
                                ));
                            }
                            result.cadence = std::option::Option::Some(
                                crate::model::cloud_storage_discovery_target::Cadence::Disabled(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Disabled>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudStorageDiscoveryTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.conditions.is_some() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if let Some(value) = self.generation_cadence() {
            state.serialize_entry("generationCadence", value)?;
        }
        if let Some(value) = self.disabled() {
            state.serialize_entry("disabled", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CloudStorageDiscoveryTarget].
pub mod cloud_storage_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// How often and when to update profiles.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Cadence {
        /// Optional. How often and when to update profiles. New buckets that match
        /// both the filter and conditions are scanned as quickly as possible
        /// depending on system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryCloudStorageGenerationCadence>),
        /// Optional. Disable profiling for buckets that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines which buckets will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID and bucket name.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryCloudStorageFilter {
    /// Whether the filter applies to a specific set of buckets or all
    /// other buckets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    pub filter: std::option::Option<crate::model::discovery_cloud_storage_filter::Filter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudStorageFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudStorageFilter::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_cloud_storage_filter::Filter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileStoreCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_storage_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::FileStoreCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_storage_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// if it holds a `CloudStorageResourceReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_resource_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageResourceReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_storage_filter::Filter::CloudStorageResourceReference(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// to hold a `CloudStorageResourceReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_cloud_storage_resource_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_storage_filter::Filter::CloudStorageResourceReference(
                v.into(),
            ),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn others(&self) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_storage_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<T: std::convert::Into<std::boxed::Box<crate::model::AllOtherResources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_storage_filter::Filter::Others(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryCloudStorageFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudStorageFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryCloudStorageFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __collection,
            __cloud_storage_resource_reference,
            __others,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryCloudStorageFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "collection" => Ok(__FieldTag::__collection),
                            "cloudStorageResourceReference" => {
                                Ok(__FieldTag::__cloud_storage_resource_reference)
                            }
                            "cloud_storage_resource_reference" => {
                                Ok(__FieldTag::__cloud_storage_resource_reference)
                            }
                            "others" => Ok(__FieldTag::__others),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryCloudStorageFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryCloudStorageFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__collection => {
                            if !fields.insert(__FieldTag::__collection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryCloudStorageFilter.collection, latest field was collection",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_cloud_storage_filter::Filter::Collection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FileStoreCollection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_storage_resource_reference => {
                            if !fields.insert(__FieldTag::__cloud_storage_resource_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_resource_reference",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryCloudStorageFilter.cloud_storage_resource_reference, latest field was cloudStorageResourceReference",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_cloud_storage_filter::Filter::CloudStorageResourceReference(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CloudStorageResourceReference>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__others => {
                            if !fields.insert(__FieldTag::__others) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for others",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryCloudStorageFilter.others, latest field was others",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_cloud_storage_filter::Filter::Others(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AllOtherResources>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryCloudStorageFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.collection() {
            state.serialize_entry("collection", value)?;
        }
        if let Some(value) = self.cloud_storage_resource_reference() {
            state.serialize_entry("cloudStorageResourceReference", value)?;
        }
        if let Some(value) = self.others() {
            state.serialize_entry("others", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryCloudStorageFilter].
pub mod discovery_cloud_storage_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of buckets or all
    /// other buckets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Filter {
        /// Optional. A specific set of buckets for this filter to apply to.
        Collection(std::boxed::Box<crate::model::FileStoreCollection>),
        /// Optional. The bucket to scan. Targets including this can only include one
        /// target (the target with this bucket). This enables profiling the contents
        /// of a single bucket, while the other options allow for easy profiling of
        /// many bucets within a project or an organization.
        CloudStorageResourceReference(std::boxed::Box<crate::model::CloudStorageResourceReference>),
        /// Optional. Catch-all. This should always be the last target in the list
        /// because anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherResources>),
    }
}

/// Match file stores (e.g. buckets) using filters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileStoreCollection {
    /// The first filter containing a pattern that matches a file store will be
    /// used.
    pub pattern: std::option::Option<crate::model::file_store_collection::Pattern>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileStoreCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pattern][crate::model::FileStoreCollection::pattern].
    ///
    /// Note that all the setters affecting `pattern` are mutually
    /// exclusive.
    pub fn set_pattern<
        T: std::convert::Into<std::option::Option<crate::model::file_store_collection::Pattern>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::FileStoreCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileStoreRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::file_store_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::FileStoreCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::FileStoreRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::file_store_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileStoreCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreCollection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileStoreCollection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_regexes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileStoreCollection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeRegexes" => Ok(__FieldTag::__include_regexes),
                            "include_regexes" => Ok(__FieldTag::__include_regexes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileStoreCollection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileStoreCollection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_regexes => {
                            if !fields.insert(__FieldTag::__include_regexes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_regexes",
                                ));
                            }
                            if result.pattern.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `pattern`, a oneof with full ID .google.privacy.dlp.v2.FileStoreCollection.include_regexes, latest field was includeRegexes",
                                ));
                            }
                            result.pattern = std::option::Option::Some(
                                crate::model::file_store_collection::Pattern::IncludeRegexes(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FileStoreRegexes>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileStoreCollection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.include_regexes() {
            state.serialize_entry("includeRegexes", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FileStoreCollection].
pub mod file_store_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The first filter containing a pattern that matches a file store will be
    /// used.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Pattern {
        /// Optional. A collection of regular expressions to match a file store
        /// against.
        IncludeRegexes(std::boxed::Box<crate::model::FileStoreRegexes>),
    }
}

/// A collection of regular expressions to determine what file store to match
/// against.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileStoreRegexes {
    /// Required. The group of regular expression patterns to match against one or
    /// more file stores. Maximum of 100 entries. The sum of all regular
    /// expression's length can't exceed 10 KiB.
    pub patterns: std::vec::Vec<crate::model::FileStoreRegex>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileStoreRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::FileStoreRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileStoreRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreRegexes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileStoreRegexes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patterns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileStoreRegexes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patterns" => Ok(__FieldTag::__patterns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileStoreRegexes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileStoreRegexes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patterns => {
                            if !fields.insert(__FieldTag::__patterns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patterns",
                                ));
                            }
                            result.patterns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FileStoreRegex>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileStoreRegexes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.patterns.is_empty() {
            state.serialize_entry("patterns", &self.patterns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A pattern to match against one or more file stores.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileStoreRegex {
    /// The type of resource regex to use.
    pub resource_regex: std::option::Option<crate::model::file_store_regex::ResourceRegex>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileStoreRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_regex][crate::model::FileStoreRegex::resource_regex].
    ///
    /// Note that all the setters affecting `resource_regex` are mutually
    /// exclusive.
    pub fn set_resource_regex<
        T: std::convert::Into<std::option::Option<crate::model::file_store_regex::ResourceRegex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = v.into();
        self
    }

    /// The value of [resource_regex][crate::model::FileStoreRegex::resource_regex]
    /// if it holds a `CloudStorageRegex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageRegex>> {
        #[allow(unreachable_patterns)]
        self.resource_regex.as_ref().and_then(|v| match v {
            crate::model::file_store_regex::ResourceRegex::CloudStorageRegex(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_regex][crate::model::FileStoreRegex::resource_regex]
    /// to hold a `CloudStorageRegex`.
    ///
    /// Note that all the setters affecting `resource_regex` are
    /// mutually exclusive.
    pub fn set_cloud_storage_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageRegex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = std::option::Option::Some(
            crate::model::file_store_regex::ResourceRegex::CloudStorageRegex(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileStoreRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreRegex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileStoreRegex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_storage_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileStoreRegex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudStorageRegex" => Ok(__FieldTag::__cloud_storage_regex),
                            "cloud_storage_regex" => Ok(__FieldTag::__cloud_storage_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileStoreRegex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileStoreRegex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_storage_regex => {
                            if !fields.insert(__FieldTag::__cloud_storage_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_regex",
                                ));
                            }
                            if result.resource_regex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_regex`, a oneof with full ID .google.privacy.dlp.v2.FileStoreRegex.cloud_storage_regex, latest field was cloudStorageRegex",
                                ));
                            }
                            result.resource_regex = std::option::Option::Some(
                                crate::model::file_store_regex::ResourceRegex::CloudStorageRegex(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudStorageRegex>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileStoreRegex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cloud_storage_regex() {
            state.serialize_entry("cloudStorageRegex", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FileStoreRegex].
pub mod file_store_regex {
    #[allow(unused_imports)]
    use super::*;

    /// The type of resource regex to use.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResourceRegex {
        /// Optional. Regex for Cloud Storage.
        CloudStorageRegex(std::boxed::Box<crate::model::CloudStorageRegex>),
    }
}

/// A pattern to match against one or more file stores. At least one
/// pattern must be specified. Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStorageRegex {
    /// Optional. For organizations, if unset, will match all projects.
    pub project_id_regex: std::string::String,

    /// Optional. Regex to test the bucket name against. If empty, all buckets
    /// match. Example: "marketing2021" or "(marketing)\d{4}" will both match the
    /// bucket gs://marketing2021
    pub bucket_name_regex: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::CloudStorageRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }

    /// Sets the value of [bucket_name_regex][crate::model::CloudStorageRegex::bucket_name_regex].
    pub fn set_bucket_name_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_name_regex = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageRegex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudStorageRegex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id_regex,
            __bucket_name_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudStorageRegex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectIdRegex" => Ok(__FieldTag::__project_id_regex),
                            "project_id_regex" => Ok(__FieldTag::__project_id_regex),
                            "bucketNameRegex" => Ok(__FieldTag::__bucket_name_regex),
                            "bucket_name_regex" => Ok(__FieldTag::__bucket_name_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudStorageRegex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudStorageRegex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id_regex => {
                            if !fields.insert(__FieldTag::__project_id_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id_regex",
                                ));
                            }
                            result.project_id_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket_name_regex => {
                            if !fields.insert(__FieldTag::__bucket_name_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name_regex",
                                ));
                            }
                            result.bucket_name_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudStorageRegex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id_regex.is_empty() {
            state.serialize_entry("projectIdRegex", &self.project_id_regex)?;
        }
        if !self.bucket_name_regex.is_empty() {
            state.serialize_entry("bucketNameRegex", &self.bucket_name_regex)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identifies a single Cloud Storage bucket.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStorageResourceReference {
    /// Required. The bucket to scan.
    pub bucket_name: std::string::String,

    /// Required. If within a project-level config, then this must match the
    /// config's project id.
    pub project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::CloudStorageResourceReference::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CloudStorageResourceReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageResourceReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudStorageResourceReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket_name,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudStorageResourceReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucketName" => Ok(__FieldTag::__bucket_name),
                            "bucket_name" => Ok(__FieldTag::__bucket_name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudStorageResourceReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudStorageResourceReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket_name => {
                            if !fields.insert(__FieldTag::__bucket_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name",
                                ));
                            }
                            result.bucket_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudStorageResourceReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket_name.is_empty() {
            state.serialize_entry("bucketName", &self.bucket_name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// How often existing buckets should have their profiles refreshed.
/// New buckets are scanned as quickly as possible depending on system
/// capacity.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryCloudStorageGenerationCadence {
    /// Optional. Data changes in Cloud Storage can't trigger reprofiling. If you
    /// set this field, profiles are refreshed at this frequency regardless of
    /// whether the underlying buckets have changed. Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Optional. Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudStorageGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryCloudStorageGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryCloudStorageGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryInspectTemplateModifiedCadence>,
    {
        self.inspect_template_modified_cadence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_template_modified_cadence][crate::model::DiscoveryCloudStorageGenerationCadence::inspect_template_modified_cadence].
    pub fn set_or_clear_inspect_template_modified_cadence<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryInspectTemplateModifiedCadence>,
    {
        self.inspect_template_modified_cadence = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiscoveryCloudStorageGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudStorageGenerationCadence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryCloudStorageGenerationCadence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __refresh_frequency,
            __inspect_template_modified_cadence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DiscoveryCloudStorageGenerationCadence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "refreshFrequency" => Ok(__FieldTag::__refresh_frequency),
                            "refresh_frequency" => Ok(__FieldTag::__refresh_frequency),
                            "inspectTemplateModifiedCadence" => {
                                Ok(__FieldTag::__inspect_template_modified_cadence)
                            }
                            "inspect_template_modified_cadence" => {
                                Ok(__FieldTag::__inspect_template_modified_cadence)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryCloudStorageGenerationCadence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryCloudStorageGenerationCadence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__refresh_frequency => {
                            if !fields.insert(__FieldTag::__refresh_frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_frequency",
                                ));
                            }
                            result.refresh_frequency = map.next_value::<std::option::Option<crate::model::DataProfileUpdateFrequency>>()?.unwrap_or_default();
                        }
                        __FieldTag::__inspect_template_modified_cadence => {
                            if !fields.insert(__FieldTag::__inspect_template_modified_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template_modified_cadence",
                                ));
                            }
                            result.inspect_template_modified_cadence = map
                                .next_value::<std::option::Option<
                                    crate::model::DiscoveryInspectTemplateModifiedCadence,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryCloudStorageGenerationCadence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.refresh_frequency) {
            state.serialize_entry("refreshFrequency", &self.refresh_frequency)?;
        }
        if self.inspect_template_modified_cadence.is_some() {
            state.serialize_entry(
                "inspectTemplateModifiedCadence",
                &self.inspect_template_modified_cadence,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Requirements that must be true before a Cloud Storage bucket or object is
/// scanned in discovery for the first time. There is an AND relationship between
/// the top-level attributes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryCloudStorageConditions {
    /// Required. Only objects with the specified attributes will be scanned. If an
    /// object has one of the specified attributes but is inside an excluded
    /// bucket, it will not be scanned. Defaults to [ALL_SUPPORTED_OBJECTS]. A
    /// profile will be created even if no objects match the
    /// included_object_attributes.
    pub included_object_attributes: std::vec::Vec<
        crate::model::discovery_cloud_storage_conditions::CloudStorageObjectAttribute,
    >,

    /// Required. Only objects with the specified attributes will be scanned.
    /// Defaults to [ALL_SUPPORTED_BUCKETS] if unset.
    pub included_bucket_attributes: std::vec::Vec<
        crate::model::discovery_cloud_storage_conditions::CloudStorageBucketAttribute,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudStorageConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [included_object_attributes][crate::model::DiscoveryCloudStorageConditions::included_object_attributes].
    pub fn set_included_object_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::discovery_cloud_storage_conditions::CloudStorageObjectAttribute,
            >,
    {
        use std::iter::Iterator;
        self.included_object_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [included_bucket_attributes][crate::model::DiscoveryCloudStorageConditions::included_bucket_attributes].
    pub fn set_included_bucket_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::discovery_cloud_storage_conditions::CloudStorageBucketAttribute,
            >,
    {
        use std::iter::Iterator;
        self.included_bucket_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiscoveryCloudStorageConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudStorageConditions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryCloudStorageConditions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __included_object_attributes,
            __included_bucket_attributes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryCloudStorageConditions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includedObjectAttributes" => {
                                Ok(__FieldTag::__included_object_attributes)
                            }
                            "included_object_attributes" => {
                                Ok(__FieldTag::__included_object_attributes)
                            }
                            "includedBucketAttributes" => {
                                Ok(__FieldTag::__included_bucket_attributes)
                            }
                            "included_bucket_attributes" => {
                                Ok(__FieldTag::__included_bucket_attributes)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryCloudStorageConditions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryCloudStorageConditions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__included_object_attributes => {
                            if !fields.insert(__FieldTag::__included_object_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for included_object_attributes",
                                ));
                            }
                            result.included_object_attributes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::discovery_cloud_storage_conditions::CloudStorageObjectAttribute>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__included_bucket_attributes => {
                            if !fields.insert(__FieldTag::__included_bucket_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for included_bucket_attributes",
                                ));
                            }
                            result.included_bucket_attributes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::discovery_cloud_storage_conditions::CloudStorageBucketAttribute>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryCloudStorageConditions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.included_object_attributes.is_empty() {
            state.serialize_entry("includedObjectAttributes", &self.included_object_attributes)?;
        }
        if !self.included_bucket_attributes.is_empty() {
            state.serialize_entry("includedBucketAttributes", &self.included_bucket_attributes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryCloudStorageConditions].
pub mod discovery_cloud_storage_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// The attribute of an object. See
    /// <https://cloud.google.com/storage/docs/storage-classes> for more information
    /// on storage classes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CloudStorageObjectAttribute {
        /// Unused.
        Unspecified,
        /// Scan objects regardless of the attribute.
        AllSupportedObjects,
        /// Scan objects with the standard storage class.
        Standard,
        /// Scan objects with the nearline storage class. This will incur retrieval
        /// fees.
        Nearline,
        /// Scan objects with the coldline storage class. This will incur retrieval
        /// fees.
        Coldline,
        /// Scan objects with the archive storage class. This will incur retrieval
        /// fees.
        Archive,
        /// Scan objects with the regional storage class.
        Regional,
        /// Scan objects with the multi-regional storage class.
        MultiRegional,
        /// Scan objects with the dual-regional storage class. This will incur
        /// retrieval fees.
        DurableReducedAvailability,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CloudStorageObjectAttribute::value] or
        /// [CloudStorageObjectAttribute::name].
        UnknownValue(cloud_storage_object_attribute::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cloud_storage_object_attribute {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CloudStorageObjectAttribute {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllSupportedObjects => std::option::Option::Some(1),
                Self::Standard => std::option::Option::Some(2),
                Self::Nearline => std::option::Option::Some(3),
                Self::Coldline => std::option::Option::Some(4),
                Self::Archive => std::option::Option::Some(5),
                Self::Regional => std::option::Option::Some(6),
                Self::MultiRegional => std::option::Option::Some(7),
                Self::DurableReducedAvailability => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CLOUD_STORAGE_OBJECT_ATTRIBUTE_UNSPECIFIED")
                }
                Self::AllSupportedObjects => std::option::Option::Some("ALL_SUPPORTED_OBJECTS"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Nearline => std::option::Option::Some("NEARLINE"),
                Self::Coldline => std::option::Option::Some("COLDLINE"),
                Self::Archive => std::option::Option::Some("ARCHIVE"),
                Self::Regional => std::option::Option::Some("REGIONAL"),
                Self::MultiRegional => std::option::Option::Some("MULTI_REGIONAL"),
                Self::DurableReducedAvailability => {
                    std::option::Option::Some("DURABLE_REDUCED_AVAILABILITY")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CloudStorageObjectAttribute {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CloudStorageObjectAttribute {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CloudStorageObjectAttribute {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllSupportedObjects,
                2 => Self::Standard,
                3 => Self::Nearline,
                4 => Self::Coldline,
                5 => Self::Archive,
                6 => Self::Regional,
                7 => Self::MultiRegional,
                8 => Self::DurableReducedAvailability,
                _ => Self::UnknownValue(cloud_storage_object_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CloudStorageObjectAttribute {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLOUD_STORAGE_OBJECT_ATTRIBUTE_UNSPECIFIED" => Self::Unspecified,
                "ALL_SUPPORTED_OBJECTS" => Self::AllSupportedObjects,
                "STANDARD" => Self::Standard,
                "NEARLINE" => Self::Nearline,
                "COLDLINE" => Self::Coldline,
                "ARCHIVE" => Self::Archive,
                "REGIONAL" => Self::Regional,
                "MULTI_REGIONAL" => Self::MultiRegional,
                "DURABLE_REDUCED_AVAILABILITY" => Self::DurableReducedAvailability,
                _ => Self::UnknownValue(cloud_storage_object_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CloudStorageObjectAttribute {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllSupportedObjects => serializer.serialize_i32(1),
                Self::Standard => serializer.serialize_i32(2),
                Self::Nearline => serializer.serialize_i32(3),
                Self::Coldline => serializer.serialize_i32(4),
                Self::Archive => serializer.serialize_i32(5),
                Self::Regional => serializer.serialize_i32(6),
                Self::MultiRegional => serializer.serialize_i32(7),
                Self::DurableReducedAvailability => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CloudStorageObjectAttribute {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudStorageObjectAttribute>::new(
                ".google.privacy.dlp.v2.DiscoveryCloudStorageConditions.CloudStorageObjectAttribute"))
        }
    }

    /// The attribute of a bucket.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CloudStorageBucketAttribute {
        /// Unused.
        Unspecified,
        /// Scan buckets regardless of the attribute.
        AllSupportedBuckets,
        /// Buckets with [Autoclass](https://cloud.google.com/storage/docs/autoclass)
        /// disabled. Only one of
        /// AUTOCLASS_DISABLED or AUTOCLASS_ENABLED should be set.
        AutoclassDisabled,
        /// Buckets with [Autoclass](https://cloud.google.com/storage/docs/autoclass)
        /// enabled. Only one of
        /// AUTOCLASS_DISABLED or AUTOCLASS_ENABLED should be set. Scanning
        /// Autoclass-enabled buckets can affect object storage classes.
        AutoclassEnabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CloudStorageBucketAttribute::value] or
        /// [CloudStorageBucketAttribute::name].
        UnknownValue(cloud_storage_bucket_attribute::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cloud_storage_bucket_attribute {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CloudStorageBucketAttribute {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllSupportedBuckets => std::option::Option::Some(1),
                Self::AutoclassDisabled => std::option::Option::Some(2),
                Self::AutoclassEnabled => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CLOUD_STORAGE_BUCKET_ATTRIBUTE_UNSPECIFIED")
                }
                Self::AllSupportedBuckets => std::option::Option::Some("ALL_SUPPORTED_BUCKETS"),
                Self::AutoclassDisabled => std::option::Option::Some("AUTOCLASS_DISABLED"),
                Self::AutoclassEnabled => std::option::Option::Some("AUTOCLASS_ENABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CloudStorageBucketAttribute {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CloudStorageBucketAttribute {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CloudStorageBucketAttribute {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllSupportedBuckets,
                2 => Self::AutoclassDisabled,
                3 => Self::AutoclassEnabled,
                _ => Self::UnknownValue(cloud_storage_bucket_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CloudStorageBucketAttribute {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLOUD_STORAGE_BUCKET_ATTRIBUTE_UNSPECIFIED" => Self::Unspecified,
                "ALL_SUPPORTED_BUCKETS" => Self::AllSupportedBuckets,
                "AUTOCLASS_DISABLED" => Self::AutoclassDisabled,
                "AUTOCLASS_ENABLED" => Self::AutoclassEnabled,
                _ => Self::UnknownValue(cloud_storage_bucket_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CloudStorageBucketAttribute {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllSupportedBuckets => serializer.serialize_i32(1),
                Self::AutoclassDisabled => serializer.serialize_i32(2),
                Self::AutoclassEnabled => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CloudStorageBucketAttribute {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudStorageBucketAttribute>::new(
                ".google.privacy.dlp.v2.DiscoveryCloudStorageConditions.CloudStorageBucketAttribute"))
        }
    }
}

/// Requirements that must be true before a file store is scanned in discovery
/// for the first time. There is an AND relationship between the top-level
/// attributes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryFileStoreConditions {
    /// Optional. File store must have been created after this date. Used to avoid
    /// backfilling.
    pub created_after: std::option::Option<wkt::Timestamp>,

    /// Optional. Minimum age a file store must have. If set, the value must be 1
    /// hour or greater.
    pub min_age: std::option::Option<wkt::Duration>,

    /// File store specific conditions.
    pub conditions: std::option::Option<crate::model::discovery_file_store_conditions::Conditions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryFileStoreConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_after][crate::model::DiscoveryFileStoreConditions::created_after].
    pub fn set_created_after<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.created_after = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [created_after][crate::model::DiscoveryFileStoreConditions::created_after].
    pub fn set_or_clear_created_after<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.created_after = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_age][crate::model::DiscoveryFileStoreConditions::min_age].
    pub fn set_min_age<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_age = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_age][crate::model::DiscoveryFileStoreConditions::min_age].
    pub fn set_or_clear_min_age<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_age = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conditions][crate::model::DiscoveryFileStoreConditions::conditions].
    ///
    /// Note that all the setters affecting `conditions` are mutually
    /// exclusive.
    pub fn set_conditions<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_file_store_conditions::Conditions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// The value of [conditions][crate::model::DiscoveryFileStoreConditions::conditions]
    /// if it holds a `CloudStorageConditions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_conditions(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryCloudStorageConditions>> {
        #[allow(unreachable_patterns)]
        self.conditions.as_ref().and_then(|v| match v {
            crate::model::discovery_file_store_conditions::Conditions::CloudStorageConditions(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [conditions][crate::model::DiscoveryFileStoreConditions::conditions]
    /// to hold a `CloudStorageConditions`.
    ///
    /// Note that all the setters affecting `conditions` are
    /// mutually exclusive.
    pub fn set_cloud_storage_conditions<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryCloudStorageConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = std::option::Option::Some(
            crate::model::discovery_file_store_conditions::Conditions::CloudStorageConditions(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryFileStoreConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryFileStoreConditions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryFileStoreConditions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __created_after,
            __min_age,
            __cloud_storage_conditions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryFileStoreConditions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createdAfter" => Ok(__FieldTag::__created_after),
                            "created_after" => Ok(__FieldTag::__created_after),
                            "minAge" => Ok(__FieldTag::__min_age),
                            "min_age" => Ok(__FieldTag::__min_age),
                            "cloudStorageConditions" => Ok(__FieldTag::__cloud_storage_conditions),
                            "cloud_storage_conditions" => {
                                Ok(__FieldTag::__cloud_storage_conditions)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryFileStoreConditions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryFileStoreConditions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__created_after => {
                            if !fields.insert(__FieldTag::__created_after) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for created_after",
                                ));
                            }
                            result.created_after =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__min_age => {
                            if !fields.insert(__FieldTag::__min_age) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_age",
                                ));
                            }
                            result.min_age =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__cloud_storage_conditions => {
                            if !fields.insert(__FieldTag::__cloud_storage_conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_conditions",
                                ));
                            }
                            if result.conditions.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `conditions`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryFileStoreConditions.cloud_storage_conditions, latest field was cloudStorageConditions",
                                ));
                            }
                            result.conditions = std::option::Option::Some(
                                crate::model::discovery_file_store_conditions::Conditions::CloudStorageConditions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DiscoveryCloudStorageConditions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryFileStoreConditions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.created_after.is_some() {
            state.serialize_entry("createdAfter", &self.created_after)?;
        }
        if self.min_age.is_some() {
            state.serialize_entry("minAge", &self.min_age)?;
        }
        if let Some(value) = self.cloud_storage_conditions() {
            state.serialize_entry("cloudStorageConditions", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryFileStoreConditions].
pub mod discovery_file_store_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// File store specific conditions.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Conditions {
        /// Optional. Cloud Storage conditions.
        CloudStorageConditions(std::boxed::Box<crate::model::DiscoveryCloudStorageConditions>),
    }
}

/// Target used to match against for discovery of resources from other clouds.
/// An [AWS connector in Security Command Center
/// (Enterprise](https://cloud.google.com/security-command-center/docs/connect-scc-to-aws)
/// is required to use this feature.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OtherCloudDiscoveryTarget {
    /// Required. The type of data profiles generated by this discovery target.
    /// Supported values are:
    ///
    /// * aws/s3/bucket
    pub data_source_type: std::option::Option<crate::model::DataSourceType>,

    /// Required. The resources that the discovery cadence applies to. The
    /// first target with a matching filter will be the one to apply to a resource.
    pub filter: std::option::Option<crate::model::DiscoveryOtherCloudFilter>,

    /// Optional. In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    pub conditions: std::option::Option<crate::model::DiscoveryOtherCloudConditions>,

    /// Type of cadence.
    pub cadence: std::option::Option<crate::model::other_cloud_discovery_target::Cadence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_source_type][crate::model::OtherCloudDiscoveryTarget::data_source_type].
    pub fn set_data_source_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataSourceType>,
    {
        self.data_source_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_source_type][crate::model::OtherCloudDiscoveryTarget::data_source_type].
    pub fn set_or_clear_data_source_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataSourceType>,
    {
        self.data_source_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter][crate::model::OtherCloudDiscoveryTarget::filter].
    pub fn set_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryOtherCloudFilter>,
    {
        self.filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [filter][crate::model::OtherCloudDiscoveryTarget::filter].
    pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryOtherCloudFilter>,
    {
        self.filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conditions][crate::model::OtherCloudDiscoveryTarget::conditions].
    pub fn set_conditions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryOtherCloudConditions>,
    {
        self.conditions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conditions][crate::model::OtherCloudDiscoveryTarget::conditions].
    pub fn set_or_clear_conditions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryOtherCloudConditions>,
    {
        self.conditions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence].
    ///
    /// Note that all the setters affecting `cadence` are mutually
    /// exclusive.
    pub fn set_cadence<
        T: std::convert::Into<
                std::option::Option<crate::model::other_cloud_discovery_target::Cadence>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryOtherCloudGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::other_cloud_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryOtherCloudGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::other_cloud_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// The value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::other_cloud_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::other_cloud_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudDiscoveryTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OtherCloudDiscoveryTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_source_type,
            __filter,
            __conditions,
            __generation_cadence,
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OtherCloudDiscoveryTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataSourceType" => Ok(__FieldTag::__data_source_type),
                            "data_source_type" => Ok(__FieldTag::__data_source_type),
                            "filter" => Ok(__FieldTag::__filter),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "generationCadence" => Ok(__FieldTag::__generation_cadence),
                            "generation_cadence" => Ok(__FieldTag::__generation_cadence),
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OtherCloudDiscoveryTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OtherCloudDiscoveryTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_source_type => {
                            if !fields.insert(__FieldTag::__data_source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_type",
                                ));
                            }
                            result.data_source_type = map
                                .next_value::<std::option::Option<crate::model::DataSourceType>>(
                                )?;
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map.next_value::<std::option::Option<crate::model::DiscoveryOtherCloudFilter>>()?
                                ;
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions =
                                map.next_value::<std::option::Option<
                                    crate::model::DiscoveryOtherCloudConditions,
                                >>()?;
                        }
                        __FieldTag::__generation_cadence => {
                            if !fields.insert(__FieldTag::__generation_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation_cadence",
                                ));
                            }
                            if result.cadence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cadence`, a oneof with full ID .google.privacy.dlp.v2.OtherCloudDiscoveryTarget.generation_cadence, latest field was generationCadence",
                                ));
                            }
                            result.cadence = std::option::Option::Some(
                                crate::model::other_cloud_discovery_target::Cadence::GenerationCadence(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DiscoveryOtherCloudGenerationCadence>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            if result.cadence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cadence`, a oneof with full ID .google.privacy.dlp.v2.OtherCloudDiscoveryTarget.disabled, latest field was disabled",
                                ));
                            }
                            result.cadence = std::option::Option::Some(
                                crate::model::other_cloud_discovery_target::Cadence::Disabled(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Disabled>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OtherCloudDiscoveryTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.data_source_type.is_some() {
            state.serialize_entry("dataSourceType", &self.data_source_type)?;
        }
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.conditions.is_some() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if let Some(value) = self.generation_cadence() {
            state.serialize_entry("generationCadence", value)?;
        }
        if let Some(value) = self.disabled() {
            state.serialize_entry("disabled", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [OtherCloudDiscoveryTarget].
pub mod other_cloud_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// Type of cadence.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Cadence {
        /// How often and when to update data profiles. New resources that match both
        /// the filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryOtherCloudGenerationCadence>),
        /// Disable profiling for resources that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines which resources from the other cloud will have profiles generated.
/// Includes the ability to filter by resource names.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryOtherCloudFilter {
    /// Whether the filter applies to a specific set of resources or all
    /// other resources. The first filter to match will be applied, regardless of
    /// the condition. Defaults to `others` if none is set.
    pub filter: std::option::Option<crate::model::discovery_other_cloud_filter::Filter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryOtherCloudFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::DiscoveryOtherCloudFilter::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::discovery_other_cloud_filter::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudResourceCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudResourceCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_other_cloud_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// if it holds a `SingleResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudSingleResourceReference>>
    {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_filter::Filter::SingleResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// to hold a `SingleResource`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_single_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudSingleResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_other_cloud_filter::Filter::SingleResource(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn others(&self) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<T: std::convert::Into<std::boxed::Box<crate::model::AllOtherResources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_other_cloud_filter::Filter::Others(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryOtherCloudFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryOtherCloudFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryOtherCloudFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __collection,
            __single_resource,
            __others,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryOtherCloudFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "collection" => Ok(__FieldTag::__collection),
                            "singleResource" => Ok(__FieldTag::__single_resource),
                            "single_resource" => Ok(__FieldTag::__single_resource),
                            "others" => Ok(__FieldTag::__others),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryOtherCloudFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryOtherCloudFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__collection => {
                            if !fields.insert(__FieldTag::__collection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryOtherCloudFilter.collection, latest field was collection",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_other_cloud_filter::Filter::Collection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OtherCloudResourceCollection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__single_resource => {
                            if !fields.insert(__FieldTag::__single_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_resource",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryOtherCloudFilter.single_resource, latest field was singleResource",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_other_cloud_filter::Filter::SingleResource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::OtherCloudSingleResourceReference,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__others => {
                            if !fields.insert(__FieldTag::__others) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for others",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryOtherCloudFilter.others, latest field was others",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_other_cloud_filter::Filter::Others(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AllOtherResources>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryOtherCloudFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.collection() {
            state.serialize_entry("collection", value)?;
        }
        if let Some(value) = self.single_resource() {
            state.serialize_entry("singleResource", value)?;
        }
        if let Some(value) = self.others() {
            state.serialize_entry("others", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryOtherCloudFilter].
pub mod discovery_other_cloud_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of resources or all
    /// other resources. The first filter to match will be applied, regardless of
    /// the condition. Defaults to `others` if none is set.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Filter {
        /// A collection of resources for this filter to apply to.
        Collection(std::boxed::Box<crate::model::OtherCloudResourceCollection>),
        /// The resource to scan. Configs using this filter can only have one target
        /// (the target with this single resource reference).
        SingleResource(std::boxed::Box<crate::model::OtherCloudSingleResourceReference>),
        /// Optional. Catch-all. This should always be the last target in the list
        /// because anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherResources>),
    }
}

/// Match resources using regex filters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OtherCloudResourceCollection {
    /// The first filter containing a pattern that matches a resource will be used.
    pub pattern: std::option::Option<crate::model::other_cloud_resource_collection::Pattern>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudResourceCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pattern][crate::model::OtherCloudResourceCollection::pattern].
    ///
    /// Note that all the setters affecting `pattern` are mutually
    /// exclusive.
    pub fn set_pattern<
        T: std::convert::Into<
                std::option::Option<crate::model::other_cloud_resource_collection::Pattern>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::OtherCloudResourceCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudResourceRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::other_cloud_resource_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::OtherCloudResourceCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudResourceRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::other_cloud_resource_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudResourceCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudResourceCollection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OtherCloudResourceCollection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_regexes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OtherCloudResourceCollection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeRegexes" => Ok(__FieldTag::__include_regexes),
                            "include_regexes" => Ok(__FieldTag::__include_regexes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OtherCloudResourceCollection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OtherCloudResourceCollection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_regexes => {
                            if !fields.insert(__FieldTag::__include_regexes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_regexes",
                                ));
                            }
                            if result.pattern.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `pattern`, a oneof with full ID .google.privacy.dlp.v2.OtherCloudResourceCollection.include_regexes, latest field was includeRegexes",
                                ));
                            }
                            result.pattern = std::option::Option::Some(
                                crate::model::other_cloud_resource_collection::Pattern::IncludeRegexes(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::OtherCloudResourceRegexes>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OtherCloudResourceCollection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.include_regexes() {
            state.serialize_entry("includeRegexes", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [OtherCloudResourceCollection].
pub mod other_cloud_resource_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The first filter containing a pattern that matches a resource will be used.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Pattern {
        /// A collection of regular expressions to match a resource against.
        IncludeRegexes(std::boxed::Box<crate::model::OtherCloudResourceRegexes>),
    }
}

/// A collection of regular expressions to determine what resources to match
/// against.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OtherCloudResourceRegexes {
    /// A group of regular expression patterns to match against one or more
    /// resources.
    /// Maximum of 100 entries. The sum of all regular expression's length can't
    /// exceed 10 KiB.
    pub patterns: std::vec::Vec<crate::model::OtherCloudResourceRegex>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudResourceRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::OtherCloudResourceRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OtherCloudResourceRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OtherCloudResourceRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudResourceRegexes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OtherCloudResourceRegexes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patterns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OtherCloudResourceRegexes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patterns" => Ok(__FieldTag::__patterns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OtherCloudResourceRegexes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OtherCloudResourceRegexes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patterns => {
                            if !fields.insert(__FieldTag::__patterns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patterns",
                                ));
                            }
                            result.patterns = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OtherCloudResourceRegex>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OtherCloudResourceRegexes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.patterns.is_empty() {
            state.serialize_entry("patterns", &self.patterns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A pattern to match against one or more resources. At least one pattern must
/// be specified. Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OtherCloudResourceRegex {
    /// The type of resource regex to use.
    pub resource_regex:
        std::option::Option<crate::model::other_cloud_resource_regex::ResourceRegex>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudResourceRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_regex][crate::model::OtherCloudResourceRegex::resource_regex].
    ///
    /// Note that all the setters affecting `resource_regex` are mutually
    /// exclusive.
    pub fn set_resource_regex<
        T: std::convert::Into<
                std::option::Option<crate::model::other_cloud_resource_regex::ResourceRegex>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = v.into();
        self
    }

    /// The value of [resource_regex][crate::model::OtherCloudResourceRegex::resource_regex]
    /// if it holds a `AmazonS3BucketRegex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn amazon_s3_bucket_regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AmazonS3BucketRegex>> {
        #[allow(unreachable_patterns)]
        self.resource_regex.as_ref().and_then(|v| match v {
            crate::model::other_cloud_resource_regex::ResourceRegex::AmazonS3BucketRegex(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_regex][crate::model::OtherCloudResourceRegex::resource_regex]
    /// to hold a `AmazonS3BucketRegex`.
    ///
    /// Note that all the setters affecting `resource_regex` are
    /// mutually exclusive.
    pub fn set_amazon_s3_bucket_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::AmazonS3BucketRegex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = std::option::Option::Some(
            crate::model::other_cloud_resource_regex::ResourceRegex::AmazonS3BucketRegex(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudResourceRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudResourceRegex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OtherCloudResourceRegex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __amazon_s3_bucket_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OtherCloudResourceRegex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "amazonS3BucketRegex" => Ok(__FieldTag::__amazon_s3_bucket_regex),
                            "amazon_s3_bucket_regex" => Ok(__FieldTag::__amazon_s3_bucket_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OtherCloudResourceRegex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OtherCloudResourceRegex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__amazon_s3_bucket_regex => {
                            if !fields.insert(__FieldTag::__amazon_s3_bucket_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for amazon_s3_bucket_regex",
                                ));
                            }
                            if result.resource_regex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_regex`, a oneof with full ID .google.privacy.dlp.v2.OtherCloudResourceRegex.amazon_s3_bucket_regex, latest field was amazonS3BucketRegex",
                                ));
                            }
                            result.resource_regex = std::option::Option::Some(
                                crate::model::other_cloud_resource_regex::ResourceRegex::AmazonS3BucketRegex(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AmazonS3BucketRegex>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OtherCloudResourceRegex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.amazon_s3_bucket_regex() {
            state.serialize_entry("amazonS3BucketRegex", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [OtherCloudResourceRegex].
pub mod other_cloud_resource_regex {
    #[allow(unused_imports)]
    use super::*;

    /// The type of resource regex to use.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResourceRegex {
        /// Regex for Amazon S3 buckets.
        AmazonS3BucketRegex(std::boxed::Box<crate::model::AmazonS3BucketRegex>),
    }
}

/// AWS account regex.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsAccountRegex {
    /// Optional. Regex to test the AWS account ID against.
    /// If empty, all accounts match.
    pub account_id_regex: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsAccountRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [account_id_regex][crate::model::AwsAccountRegex::account_id_regex].
    pub fn set_account_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.account_id_regex = v.into();
        self
    }
}

impl wkt::message::Message for AwsAccountRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AwsAccountRegex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsAccountRegex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __account_id_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsAccountRegex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accountIdRegex" => Ok(__FieldTag::__account_id_regex),
                            "account_id_regex" => Ok(__FieldTag::__account_id_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsAccountRegex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsAccountRegex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__account_id_regex => {
                            if !fields.insert(__FieldTag::__account_id_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_id_regex",
                                ));
                            }
                            result.account_id_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsAccountRegex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.account_id_regex.is_empty() {
            state.serialize_entry("accountIdRegex", &self.account_id_regex)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Amazon S3 bucket regex.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AmazonS3BucketRegex {
    /// The AWS account regex.
    pub aws_account_regex: std::option::Option<crate::model::AwsAccountRegex>,

    /// Optional. Regex to test the bucket name against.
    /// If empty, all buckets match.
    pub bucket_name_regex: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AmazonS3BucketRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_account_regex][crate::model::AmazonS3BucketRegex::aws_account_regex].
    pub fn set_aws_account_regex<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsAccountRegex>,
    {
        self.aws_account_regex = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aws_account_regex][crate::model::AmazonS3BucketRegex::aws_account_regex].
    pub fn set_or_clear_aws_account_regex<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsAccountRegex>,
    {
        self.aws_account_regex = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bucket_name_regex][crate::model::AmazonS3BucketRegex::bucket_name_regex].
    pub fn set_bucket_name_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_name_regex = v.into();
        self
    }
}

impl wkt::message::Message for AmazonS3BucketRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AmazonS3BucketRegex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AmazonS3BucketRegex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_account_regex,
            __bucket_name_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AmazonS3BucketRegex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsAccountRegex" => Ok(__FieldTag::__aws_account_regex),
                            "aws_account_regex" => Ok(__FieldTag::__aws_account_regex),
                            "bucketNameRegex" => Ok(__FieldTag::__bucket_name_regex),
                            "bucket_name_regex" => Ok(__FieldTag::__bucket_name_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AmazonS3BucketRegex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AmazonS3BucketRegex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_account_regex => {
                            if !fields.insert(__FieldTag::__aws_account_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_account_regex",
                                ));
                            }
                            result.aws_account_regex = map
                                .next_value::<std::option::Option<crate::model::AwsAccountRegex>>(
                                )?;
                        }
                        __FieldTag::__bucket_name_regex => {
                            if !fields.insert(__FieldTag::__bucket_name_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name_regex",
                                ));
                            }
                            result.bucket_name_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AmazonS3BucketRegex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.aws_account_regex.is_some() {
            state.serialize_entry("awsAccountRegex", &self.aws_account_regex)?;
        }
        if !self.bucket_name_regex.is_empty() {
            state.serialize_entry("bucketNameRegex", &self.bucket_name_regex)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identifies a single resource, like a single Amazon S3 bucket.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OtherCloudSingleResourceReference {
    /// The resource to scan.
    pub resource:
        std::option::Option<crate::model::other_cloud_single_resource_reference::Resource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudSingleResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource][crate::model::OtherCloudSingleResourceReference::resource].
    ///
    /// Note that all the setters affecting `resource` are mutually
    /// exclusive.
    pub fn set_resource<
        T: std::convert::Into<
                std::option::Option<crate::model::other_cloud_single_resource_reference::Resource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// The value of [resource][crate::model::OtherCloudSingleResourceReference::resource]
    /// if it holds a `AmazonS3Bucket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn amazon_s3_bucket(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AmazonS3Bucket>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::other_cloud_single_resource_reference::Resource::AmazonS3Bucket(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::OtherCloudSingleResourceReference::resource]
    /// to hold a `AmazonS3Bucket`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_amazon_s3_bucket<
        T: std::convert::Into<std::boxed::Box<crate::model::AmazonS3Bucket>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::other_cloud_single_resource_reference::Resource::AmazonS3Bucket(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudSingleResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudSingleResourceReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OtherCloudSingleResourceReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __amazon_s3_bucket,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OtherCloudSingleResourceReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "amazonS3Bucket" => Ok(__FieldTag::__amazon_s3_bucket),
                            "amazon_s3_bucket" => Ok(__FieldTag::__amazon_s3_bucket),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OtherCloudSingleResourceReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OtherCloudSingleResourceReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__amazon_s3_bucket => {
                            if !fields.insert(__FieldTag::__amazon_s3_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for amazon_s3_bucket",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.privacy.dlp.v2.OtherCloudSingleResourceReference.amazon_s3_bucket, latest field was amazonS3Bucket",
                                ));
                            }
                            result.resource = std::option::Option::Some(
                                crate::model::other_cloud_single_resource_reference::Resource::AmazonS3Bucket(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AmazonS3Bucket>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OtherCloudSingleResourceReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.amazon_s3_bucket() {
            state.serialize_entry("amazonS3Bucket", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [OtherCloudSingleResourceReference].
pub mod other_cloud_single_resource_reference {
    #[allow(unused_imports)]
    use super::*;

    /// The resource to scan.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Resource {
        /// Amazon S3 bucket.
        AmazonS3Bucket(std::boxed::Box<crate::model::AmazonS3Bucket>),
    }
}

/// AWS account.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsAccount {
    /// Required. AWS account ID.
    pub account_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [account_id][crate::model::AwsAccount::account_id].
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }
}

impl wkt::message::Message for AwsAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AwsAccount"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsAccount {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __account_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsAccount")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accountId" => Ok(__FieldTag::__account_id),
                            "account_id" => Ok(__FieldTag::__account_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsAccount;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsAccount")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__account_id => {
                            if !fields.insert(__FieldTag::__account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_id",
                                ));
                            }
                            result.account_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsAccount {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.account_id.is_empty() {
            state.serialize_entry("accountId", &self.account_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Amazon S3 bucket.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AmazonS3Bucket {
    /// The AWS account.
    pub aws_account: std::option::Option<crate::model::AwsAccount>,

    /// Required. The bucket name.
    pub bucket_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AmazonS3Bucket {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_account][crate::model::AmazonS3Bucket::aws_account].
    pub fn set_aws_account<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsAccount>,
    {
        self.aws_account = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aws_account][crate::model::AmazonS3Bucket::aws_account].
    pub fn set_or_clear_aws_account<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsAccount>,
    {
        self.aws_account = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bucket_name][crate::model::AmazonS3Bucket::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }
}

impl wkt::message::Message for AmazonS3Bucket {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AmazonS3Bucket"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AmazonS3Bucket {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_account,
            __bucket_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AmazonS3Bucket")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsAccount" => Ok(__FieldTag::__aws_account),
                            "aws_account" => Ok(__FieldTag::__aws_account),
                            "bucketName" => Ok(__FieldTag::__bucket_name),
                            "bucket_name" => Ok(__FieldTag::__bucket_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AmazonS3Bucket;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AmazonS3Bucket")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_account => {
                            if !fields.insert(__FieldTag::__aws_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_account",
                                ));
                            }
                            result.aws_account =
                                map.next_value::<std::option::Option<crate::model::AwsAccount>>()?;
                        }
                        __FieldTag::__bucket_name => {
                            if !fields.insert(__FieldTag::__bucket_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name",
                                ));
                            }
                            result.bucket_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AmazonS3Bucket {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.aws_account.is_some() {
            state.serialize_entry("awsAccount", &self.aws_account)?;
        }
        if !self.bucket_name.is_empty() {
            state.serialize_entry("bucketName", &self.bucket_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Requirements that must be true before a resource is profiled for the first
/// time.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryOtherCloudConditions {
    /// Minimum age a resource must be before Cloud DLP can profile it. Value must
    /// be 1 hour or greater.
    pub min_age: std::option::Option<wkt::Duration>,

    /// The conditions to apply.
    pub conditions: std::option::Option<crate::model::discovery_other_cloud_conditions::Conditions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryOtherCloudConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_age][crate::model::DiscoveryOtherCloudConditions::min_age].
    pub fn set_min_age<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_age = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_age][crate::model::DiscoveryOtherCloudConditions::min_age].
    pub fn set_or_clear_min_age<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_age = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conditions][crate::model::DiscoveryOtherCloudConditions::conditions].
    ///
    /// Note that all the setters affecting `conditions` are mutually
    /// exclusive.
    pub fn set_conditions<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_other_cloud_conditions::Conditions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// The value of [conditions][crate::model::DiscoveryOtherCloudConditions::conditions]
    /// if it holds a `AmazonS3BucketConditions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn amazon_s3_bucket_conditions(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AmazonS3BucketConditions>> {
        #[allow(unreachable_patterns)]
        self.conditions.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_conditions::Conditions::AmazonS3BucketConditions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [conditions][crate::model::DiscoveryOtherCloudConditions::conditions]
    /// to hold a `AmazonS3BucketConditions`.
    ///
    /// Note that all the setters affecting `conditions` are
    /// mutually exclusive.
    pub fn set_amazon_s3_bucket_conditions<
        T: std::convert::Into<std::boxed::Box<crate::model::AmazonS3BucketConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = std::option::Option::Some(
            crate::model::discovery_other_cloud_conditions::Conditions::AmazonS3BucketConditions(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryOtherCloudConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryOtherCloudConditions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryOtherCloudConditions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_age,
            __amazon_s3_bucket_conditions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryOtherCloudConditions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minAge" => Ok(__FieldTag::__min_age),
                            "min_age" => Ok(__FieldTag::__min_age),
                            "amazonS3BucketConditions" => {
                                Ok(__FieldTag::__amazon_s3_bucket_conditions)
                            }
                            "amazon_s3_bucket_conditions" => {
                                Ok(__FieldTag::__amazon_s3_bucket_conditions)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryOtherCloudConditions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryOtherCloudConditions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_age => {
                            if !fields.insert(__FieldTag::__min_age) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_age",
                                ));
                            }
                            result.min_age =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__amazon_s3_bucket_conditions => {
                            if !fields.insert(__FieldTag::__amazon_s3_bucket_conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for amazon_s3_bucket_conditions",
                                ));
                            }
                            if result.conditions.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `conditions`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryOtherCloudConditions.amazon_s3_bucket_conditions, latest field was amazonS3BucketConditions",
                                ));
                            }
                            result.conditions = std::option::Option::Some(
                                crate::model::discovery_other_cloud_conditions::Conditions::AmazonS3BucketConditions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AmazonS3BucketConditions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryOtherCloudConditions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.min_age.is_some() {
            state.serialize_entry("minAge", &self.min_age)?;
        }
        if let Some(value) = self.amazon_s3_bucket_conditions() {
            state.serialize_entry("amazonS3BucketConditions", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryOtherCloudConditions].
pub mod discovery_other_cloud_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// The conditions to apply.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Conditions {
        /// Amazon S3 bucket conditions.
        AmazonS3BucketConditions(std::boxed::Box<crate::model::AmazonS3BucketConditions>),
    }
}

/// Amazon S3 bucket conditions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AmazonS3BucketConditions {
    /// Optional. Bucket types that should be profiled.
    /// Optional. Defaults to TYPE_ALL_SUPPORTED if unspecified.
    pub bucket_types: std::vec::Vec<crate::model::amazon_s_3_bucket_conditions::BucketType>,

    /// Optional. Object classes that should be profiled.
    /// Optional. Defaults to ALL_SUPPORTED_CLASSES if unspecified.
    pub object_storage_classes:
        std::vec::Vec<crate::model::amazon_s_3_bucket_conditions::ObjectStorageClass>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AmazonS3BucketConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_types][crate::model::AmazonS3BucketConditions::bucket_types].
    pub fn set_bucket_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::amazon_s_3_bucket_conditions::BucketType>,
    {
        use std::iter::Iterator;
        self.bucket_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [object_storage_classes][crate::model::AmazonS3BucketConditions::object_storage_classes].
    pub fn set_object_storage_classes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::amazon_s_3_bucket_conditions::ObjectStorageClass>,
    {
        use std::iter::Iterator;
        self.object_storage_classes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AmazonS3BucketConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AmazonS3BucketConditions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AmazonS3BucketConditions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket_types,
            __object_storage_classes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AmazonS3BucketConditions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucketTypes" => Ok(__FieldTag::__bucket_types),
                            "bucket_types" => Ok(__FieldTag::__bucket_types),
                            "objectStorageClasses" => Ok(__FieldTag::__object_storage_classes),
                            "object_storage_classes" => Ok(__FieldTag::__object_storage_classes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AmazonS3BucketConditions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AmazonS3BucketConditions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket_types => {
                            if !fields.insert(__FieldTag::__bucket_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_types",
                                ));
                            }
                            result.bucket_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::amazon_s_3_bucket_conditions::BucketType,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object_storage_classes => {
                            if !fields.insert(__FieldTag::__object_storage_classes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_storage_classes",
                                ));
                            }
                            result.object_storage_classes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::amazon_s_3_bucket_conditions::ObjectStorageClass>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AmazonS3BucketConditions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket_types.is_empty() {
            state.serialize_entry("bucketTypes", &self.bucket_types)?;
        }
        if !self.object_storage_classes.is_empty() {
            state.serialize_entry("objectStorageClasses", &self.object_storage_classes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AmazonS3BucketConditions].
pub mod amazon_s_3_bucket_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Amazon S3 bucket types.
    /// Defaults to TYPE_ALL_SUPPORTED.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BucketType {
        /// Unused.
        TypeUnspecified,
        /// All supported classes.
        TypeAllSupported,
        /// A general purpose Amazon S3 bucket.
        TypeGeneralPurpose,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BucketType::value] or
        /// [BucketType::name].
        UnknownValue(bucket_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod bucket_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BucketType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some(0),
                Self::TypeAllSupported => std::option::Option::Some(1),
                Self::TypeGeneralPurpose => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::TypeAllSupported => std::option::Option::Some("TYPE_ALL_SUPPORTED"),
                Self::TypeGeneralPurpose => std::option::Option::Some("TYPE_GENERAL_PURPOSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BucketType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BucketType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BucketType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::TypeUnspecified,
                1 => Self::TypeAllSupported,
                2 => Self::TypeGeneralPurpose,
                _ => Self::UnknownValue(bucket_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BucketType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::TypeUnspecified,
                "TYPE_ALL_SUPPORTED" => Self::TypeAllSupported,
                "TYPE_GENERAL_PURPOSE" => Self::TypeGeneralPurpose,
                _ => Self::UnknownValue(bucket_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BucketType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::TypeUnspecified => serializer.serialize_i32(0),
                Self::TypeAllSupported => serializer.serialize_i32(1),
                Self::TypeGeneralPurpose => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BucketType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BucketType>::new(
                ".google.privacy.dlp.v2.AmazonS3BucketConditions.BucketType",
            ))
        }
    }

    /// Supported Amazon S3 object storage classes.
    /// Defaults to ALL_SUPPORTED_CLASSES.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ObjectStorageClass {
        /// Unused.
        Unspecified,
        /// All supported classes.
        AllSupportedClasses,
        /// Standard object class.
        Standard,
        /// Standard - infrequent access object class.
        StandardInfrequentAccess,
        /// Glacier - instant retrieval object class.
        GlacierInstantRetrieval,
        /// Objects in the S3 Intelligent-Tiering access tiers.
        IntelligentTiering,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ObjectStorageClass::value] or
        /// [ObjectStorageClass::name].
        UnknownValue(object_storage_class::UnknownValue),
    }

    #[doc(hidden)]
    pub mod object_storage_class {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ObjectStorageClass {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllSupportedClasses => std::option::Option::Some(1),
                Self::Standard => std::option::Option::Some(2),
                Self::StandardInfrequentAccess => std::option::Option::Some(4),
                Self::GlacierInstantRetrieval => std::option::Option::Some(6),
                Self::IntelligentTiering => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::AllSupportedClasses => std::option::Option::Some("ALL_SUPPORTED_CLASSES"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::StandardInfrequentAccess => {
                    std::option::Option::Some("STANDARD_INFREQUENT_ACCESS")
                }
                Self::GlacierInstantRetrieval => {
                    std::option::Option::Some("GLACIER_INSTANT_RETRIEVAL")
                }
                Self::IntelligentTiering => std::option::Option::Some("INTELLIGENT_TIERING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ObjectStorageClass {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ObjectStorageClass {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ObjectStorageClass {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllSupportedClasses,
                2 => Self::Standard,
                4 => Self::StandardInfrequentAccess,
                6 => Self::GlacierInstantRetrieval,
                7 => Self::IntelligentTiering,
                _ => Self::UnknownValue(object_storage_class::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ObjectStorageClass {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "ALL_SUPPORTED_CLASSES" => Self::AllSupportedClasses,
                "STANDARD" => Self::Standard,
                "STANDARD_INFREQUENT_ACCESS" => Self::StandardInfrequentAccess,
                "GLACIER_INSTANT_RETRIEVAL" => Self::GlacierInstantRetrieval,
                "INTELLIGENT_TIERING" => Self::IntelligentTiering,
                _ => Self::UnknownValue(object_storage_class::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ObjectStorageClass {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllSupportedClasses => serializer.serialize_i32(1),
                Self::Standard => serializer.serialize_i32(2),
                Self::StandardInfrequentAccess => serializer.serialize_i32(4),
                Self::GlacierInstantRetrieval => serializer.serialize_i32(6),
                Self::IntelligentTiering => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ObjectStorageClass {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ObjectStorageClass>::new(
                ".google.privacy.dlp.v2.AmazonS3BucketConditions.ObjectStorageClass",
            ))
        }
    }
}

/// How often existing resources should have their profiles refreshed.
/// New resources are scanned as quickly as possible depending on system
/// capacity.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryOtherCloudGenerationCadence {
    /// Optional. Frequency to update profiles regardless of whether the underlying
    /// resource has changes. Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Optional. Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryOtherCloudGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryOtherCloudGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryOtherCloudGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryInspectTemplateModifiedCadence>,
    {
        self.inspect_template_modified_cadence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_template_modified_cadence][crate::model::DiscoveryOtherCloudGenerationCadence::inspect_template_modified_cadence].
    pub fn set_or_clear_inspect_template_modified_cadence<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryInspectTemplateModifiedCadence>,
    {
        self.inspect_template_modified_cadence = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiscoveryOtherCloudGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryOtherCloudGenerationCadence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryOtherCloudGenerationCadence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __refresh_frequency,
            __inspect_template_modified_cadence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryOtherCloudGenerationCadence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "refreshFrequency" => Ok(__FieldTag::__refresh_frequency),
                            "refresh_frequency" => Ok(__FieldTag::__refresh_frequency),
                            "inspectTemplateModifiedCadence" => {
                                Ok(__FieldTag::__inspect_template_modified_cadence)
                            }
                            "inspect_template_modified_cadence" => {
                                Ok(__FieldTag::__inspect_template_modified_cadence)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryOtherCloudGenerationCadence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryOtherCloudGenerationCadence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__refresh_frequency => {
                            if !fields.insert(__FieldTag::__refresh_frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_frequency",
                                ));
                            }
                            result.refresh_frequency = map.next_value::<std::option::Option<crate::model::DataProfileUpdateFrequency>>()?.unwrap_or_default();
                        }
                        __FieldTag::__inspect_template_modified_cadence => {
                            if !fields.insert(__FieldTag::__inspect_template_modified_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template_modified_cadence",
                                ));
                            }
                            result.inspect_template_modified_cadence = map
                                .next_value::<std::option::Option<
                                    crate::model::DiscoveryInspectTemplateModifiedCadence,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryOtherCloudGenerationCadence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.refresh_frequency) {
            state.serialize_entry("refreshFrequency", &self.refresh_frequency)?;
        }
        if self.inspect_template_modified_cadence.is_some() {
            state.serialize_entry(
                "inspectTemplateModifiedCadence",
                &self.inspect_template_modified_cadence,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The location to begin a discovery scan. Denotes an organization ID or folder
/// ID within an organization.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryStartingLocation {
    /// The location to be scanned.
    pub location: std::option::Option<crate::model::discovery_starting_location::Location>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryStartingLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::DiscoveryStartingLocation::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    pub fn set_location<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_starting_location::Location>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::DiscoveryStartingLocation::location]
    /// if it holds a `OrganizationId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn organization_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::discovery_starting_location::Location::OrganizationId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::DiscoveryStartingLocation::location]
    /// to hold a `OrganizationId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_organization_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::discovery_starting_location::Location::OrganizationId(v.into()),
        );
        self
    }

    /// The value of [location][crate::model::DiscoveryStartingLocation::location]
    /// if it holds a `FolderId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn folder_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::discovery_starting_location::Location::FolderId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::DiscoveryStartingLocation::location]
    /// to hold a `FolderId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::discovery_starting_location::Location::FolderId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryStartingLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryStartingLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryStartingLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __organization_id,
            __folder_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryStartingLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "organizationId" => Ok(__FieldTag::__organization_id),
                            "organization_id" => Ok(__FieldTag::__organization_id),
                            "folderId" => Ok(__FieldTag::__folder_id),
                            "folder_id" => Ok(__FieldTag::__folder_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryStartingLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryStartingLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__organization_id => {
                            if !fields.insert(__FieldTag::__organization_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryStartingLocation.organization_id, latest field was organizationId",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::discovery_starting_location::Location::OrganizationId(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__folder_id => {
                            if !fields.insert(__FieldTag::__folder_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for folder_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryStartingLocation.folder_id, latest field was folderId",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::discovery_starting_location::Location::FolderId(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryStartingLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.organization_id() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("organizationId", &__With(value))?;
        }
        if let Some(value) = self.folder_id() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("folderId", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryStartingLocation].
pub mod discovery_starting_location {
    #[allow(unused_imports)]
    use super::*;

    /// The location to be scanned.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Location {
        /// The ID of an organization to scan.
        OrganizationId(i64),
        /// The ID of the folder within an organization to be scanned.
        FolderId(i64),
    }
}

/// The other cloud starting location for discovery.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OtherCloudDiscoveryStartingLocation {
    /// The other cloud starting location for discovery.
    pub location:
        std::option::Option<crate::model::other_cloud_discovery_starting_location::Location>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudDiscoveryStartingLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::OtherCloudDiscoveryStartingLocation::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    pub fn set_location<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::other_cloud_discovery_starting_location::Location,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::OtherCloudDiscoveryStartingLocation::location]
    /// if it holds a `AwsLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_location(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<
            crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation,
        >,
    > {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::other_cloud_discovery_starting_location::Location::AwsLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::OtherCloudDiscoveryStartingLocation::location]
    /// to hold a `AwsLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_aws_location<T: std::convert::Into<std::boxed::Box<crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation>>>(mut self, v: T) -> Self{
        self.location = std::option::Option::Some(
            crate::model::other_cloud_discovery_starting_location::Location::AwsLocation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudDiscoveryStartingLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudDiscoveryStartingLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OtherCloudDiscoveryStartingLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OtherCloudDiscoveryStartingLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsLocation" => Ok(__FieldTag::__aws_location),
                            "aws_location" => Ok(__FieldTag::__aws_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OtherCloudDiscoveryStartingLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OtherCloudDiscoveryStartingLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_location => {
                            if !fields.insert(__FieldTag::__aws_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_location",
                                ));
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .google.privacy.dlp.v2.OtherCloudDiscoveryStartingLocation.aws_location, latest field was awsLocation",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::other_cloud_discovery_starting_location::Location::AwsLocation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OtherCloudDiscoveryStartingLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.aws_location() {
            state.serialize_entry("awsLocation", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [OtherCloudDiscoveryStartingLocation].
pub mod other_cloud_discovery_starting_location {
    #[allow(unused_imports)]
    use super::*;

    /// The AWS starting location for discovery.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AwsDiscoveryStartingLocation {

        /// The scope of this starting location.
        pub scope: std::option::Option<crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AwsDiscoveryStartingLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope].
        ///
        /// Note that all the setters affecting `scope` are mutually
        /// exclusive.
        pub fn set_scope<T: std::convert::Into<std::option::Option<crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope>>>(mut self, v: T) -> Self
        {
            self.scope = v.into();
            self
        }

        /// The value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// if it holds a `AccountId`, `None` if the field is not set or
        /// holds a different branch.
        pub fn account_id(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.scope.as_ref().and_then(|v| match v {
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AccountId(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// to hold a `AccountId`.
        ///
        /// Note that all the setters affecting `scope` are
        /// mutually exclusive.
        pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.scope = std::option::Option::Some(
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AccountId(
                    v.into()
                )
            );
            self
        }

        /// The value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// if it holds a `AllAssetInventoryAssets`, `None` if the field is not set or
        /// holds a different branch.
        pub fn all_asset_inventory_assets(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.scope.as_ref().and_then(|v| match v {
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AllAssetInventoryAssets(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// to hold a `AllAssetInventoryAssets`.
        ///
        /// Note that all the setters affecting `scope` are
        /// mutually exclusive.
        pub fn set_all_asset_inventory_assets<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.scope = std::option::Option::Some(
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AllAssetInventoryAssets(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for AwsDiscoveryStartingLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.OtherCloudDiscoveryStartingLocation.AwsDiscoveryStartingLocation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AwsDiscoveryStartingLocation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __account_id,
                __all_asset_inventory_assets,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AwsDiscoveryStartingLocation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "accountId" => Ok(__FieldTag::__account_id),
                                "account_id" => Ok(__FieldTag::__account_id),
                                "allAssetInventoryAssets" => {
                                    Ok(__FieldTag::__all_asset_inventory_assets)
                                }
                                "all_asset_inventory_assets" => {
                                    Ok(__FieldTag::__all_asset_inventory_assets)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AwsDiscoveryStartingLocation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AwsDiscoveryStartingLocation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__account_id => {
                                if !fields.insert(__FieldTag::__account_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for account_id",
                                    ));
                                }
                                if result.scope.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `scope`, a oneof with full ID .google.privacy.dlp.v2.OtherCloudDiscoveryStartingLocation.AwsDiscoveryStartingLocation.account_id, latest field was accountId",
                                    ));
                                }
                                result.scope = std::option::Option::Some(
                                    crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AccountId(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__all_asset_inventory_assets => {
                                if !fields.insert(__FieldTag::__all_asset_inventory_assets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for all_asset_inventory_assets",
                                    ));
                                }
                                if result.scope.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `scope`, a oneof with full ID .google.privacy.dlp.v2.OtherCloudDiscoveryStartingLocation.AwsDiscoveryStartingLocation.all_asset_inventory_assets, latest field was allAssetInventoryAssets",
                                    ));
                                }
                                result.scope = std::option::Option::Some(
                                    crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AllAssetInventoryAssets(
                                        map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AwsDiscoveryStartingLocation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.account_id() {
                state.serialize_entry("accountId", value)?;
            }
            if let Some(value) = self.all_asset_inventory_assets() {
                state.serialize_entry("allAssetInventoryAssets", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [AwsDiscoveryStartingLocation].
    pub mod aws_discovery_starting_location {
        #[allow(unused_imports)]
        use super::*;

        /// The scope of this starting location.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Scope {
            /// The AWS account ID that this discovery config applies to.
            /// Within an AWS organization, you can find the AWS account ID inside an
            /// AWS account ARN. Example:
            /// arn:{partition}:organizations::{management_account_id}:account/{org_id}/{account_id}
            AccountId(std::string::String),
            /// All AWS assets stored in Asset Inventory that didn't match other AWS
            /// discovery configs.
            AllAssetInventoryAssets(bool),
        }
    }

    /// The other cloud starting location for discovery.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Location {
        /// The AWS starting location for discovery.
        AwsLocation(
            std::boxed::Box<
                crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation,
            >,
        ),
    }
}

/// Match discovery resources not covered by any other filter.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AllOtherResources {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllOtherResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AllOtherResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AllOtherResources"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AllOtherResources {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllOtherResources")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AllOtherResources;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllOtherResources")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AllOtherResources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Target used to match against for discovery with Vertex AI datasets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexDatasetDiscoveryTarget {
    /// Required. The datasets the discovery cadence applies to. The first target
    /// with a matching filter will be the one to apply to a dataset.
    pub filter: std::option::Option<crate::model::DiscoveryVertexDatasetFilter>,

    /// In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    pub conditions: std::option::Option<crate::model::DiscoveryVertexDatasetConditions>,

    /// Type of schedule.
    pub cadence: std::option::Option<crate::model::vertex_dataset_discovery_target::Cadence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::VertexDatasetDiscoveryTarget::filter].
    pub fn set_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryVertexDatasetFilter>,
    {
        self.filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [filter][crate::model::VertexDatasetDiscoveryTarget::filter].
    pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryVertexDatasetFilter>,
    {
        self.filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conditions][crate::model::VertexDatasetDiscoveryTarget::conditions].
    pub fn set_conditions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryVertexDatasetConditions>,
    {
        self.conditions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conditions][crate::model::VertexDatasetDiscoveryTarget::conditions].
    pub fn set_or_clear_conditions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryVertexDatasetConditions>,
    {
        self.conditions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence].
    ///
    /// Note that all the setters affecting `cadence` are mutually
    /// exclusive.
    pub fn set_cadence<
        T: std::convert::Into<
                std::option::Option<crate::model::vertex_dataset_discovery_target::Cadence>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryVertexDatasetGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::vertex_dataset_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryVertexDatasetGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::vertex_dataset_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// The value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::vertex_dataset_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::vertex_dataset_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VertexDatasetDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetDiscoveryTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VertexDatasetDiscoveryTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __conditions,
            __generation_cadence,
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VertexDatasetDiscoveryTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "generationCadence" => Ok(__FieldTag::__generation_cadence),
                            "generation_cadence" => Ok(__FieldTag::__generation_cadence),
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VertexDatasetDiscoveryTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VertexDatasetDiscoveryTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map.next_value::<std::option::Option<crate::model::DiscoveryVertexDatasetFilter>>()?
                                ;
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<
                                crate::model::DiscoveryVertexDatasetConditions,
                            >>()?;
                        }
                        __FieldTag::__generation_cadence => {
                            if !fields.insert(__FieldTag::__generation_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation_cadence",
                                ));
                            }
                            if result.cadence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cadence`, a oneof with full ID .google.privacy.dlp.v2.VertexDatasetDiscoveryTarget.generation_cadence, latest field was generationCadence",
                                ));
                            }
                            result.cadence = std::option::Option::Some(
                                crate::model::vertex_dataset_discovery_target::Cadence::GenerationCadence(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DiscoveryVertexDatasetGenerationCadence>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            if result.cadence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cadence`, a oneof with full ID .google.privacy.dlp.v2.VertexDatasetDiscoveryTarget.disabled, latest field was disabled",
                                ));
                            }
                            result.cadence = std::option::Option::Some(
                                crate::model::vertex_dataset_discovery_target::Cadence::Disabled(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Disabled>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VertexDatasetDiscoveryTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.conditions.is_some() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if let Some(value) = self.generation_cadence() {
            state.serialize_entry("generationCadence", value)?;
        }
        if let Some(value) = self.disabled() {
            state.serialize_entry("disabled", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VertexDatasetDiscoveryTarget].
pub mod vertex_dataset_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// Type of schedule.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Cadence {
        /// How often and when to update profiles. New datasets that match both the
        /// filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryVertexDatasetGenerationCadence>),
        /// Disable profiling for datasets that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines what datasets will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID or dataset regex.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryVertexDatasetFilter {
    /// Whether the filter applies to a specific set of datasets or all
    /// other datasets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, this field defaults to `others`.
    pub filter: std::option::Option<crate::model::discovery_vertex_dataset_filter::Filter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryVertexDatasetFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_vertex_dataset_filter::Filter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_vertex_dataset_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_vertex_dataset_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// if it holds a `VertexDatasetResourceReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_dataset_resource_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetResourceReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_vertex_dataset_filter::Filter::VertexDatasetResourceReference(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// to hold a `VertexDatasetResourceReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_resource_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_vertex_dataset_filter::Filter::VertexDatasetResourceReference(
                v.into(),
            ),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn others(&self) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_vertex_dataset_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<T: std::convert::Into<std::boxed::Box<crate::model::AllOtherResources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_vertex_dataset_filter::Filter::Others(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryVertexDatasetFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryVertexDatasetFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryVertexDatasetFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __collection,
            __vertex_dataset_resource_reference,
            __others,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryVertexDatasetFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "collection" => Ok(__FieldTag::__collection),
                            "vertexDatasetResourceReference" => {
                                Ok(__FieldTag::__vertex_dataset_resource_reference)
                            }
                            "vertex_dataset_resource_reference" => {
                                Ok(__FieldTag::__vertex_dataset_resource_reference)
                            }
                            "others" => Ok(__FieldTag::__others),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryVertexDatasetFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryVertexDatasetFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__collection => {
                            if !fields.insert(__FieldTag::__collection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryVertexDatasetFilter.collection, latest field was collection",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_vertex_dataset_filter::Filter::Collection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VertexDatasetCollection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vertex_dataset_resource_reference => {
                            if !fields.insert(__FieldTag::__vertex_dataset_resource_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertex_dataset_resource_reference",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryVertexDatasetFilter.vertex_dataset_resource_reference, latest field was vertexDatasetResourceReference",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_vertex_dataset_filter::Filter::VertexDatasetResourceReference(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::VertexDatasetResourceReference>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__others => {
                            if !fields.insert(__FieldTag::__others) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for others",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.privacy.dlp.v2.DiscoveryVertexDatasetFilter.others, latest field was others",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::discovery_vertex_dataset_filter::Filter::Others(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AllOtherResources>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryVertexDatasetFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.collection() {
            state.serialize_entry("collection", value)?;
        }
        if let Some(value) = self.vertex_dataset_resource_reference() {
            state.serialize_entry("vertexDatasetResourceReference", value)?;
        }
        if let Some(value) = self.others() {
            state.serialize_entry("others", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiscoveryVertexDatasetFilter].
pub mod discovery_vertex_dataset_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of datasets or all
    /// other datasets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, this field defaults to `others`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Filter {
        /// A specific set of Vertex AI datasets for this filter to apply to.
        Collection(std::boxed::Box<crate::model::VertexDatasetCollection>),
        /// The dataset resource to scan. Targets including this can only include
        /// one target (the target with this dataset resource reference).
        VertexDatasetResourceReference(
            std::boxed::Box<crate::model::VertexDatasetResourceReference>,
        ),
        /// Catch-all. This should always be the last target in the list because
        /// anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherResources>),
    }
}

/// Match dataset resources using regex filters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexDatasetCollection {
    /// The pattern used to filter dataset resources.
    pub pattern: std::option::Option<crate::model::vertex_dataset_collection::Pattern>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pattern][crate::model::VertexDatasetCollection::pattern].
    ///
    /// Note that all the setters affecting `pattern` are mutually
    /// exclusive.
    pub fn set_pattern<
        T: std::convert::Into<std::option::Option<crate::model::vertex_dataset_collection::Pattern>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::VertexDatasetCollection::pattern]
    /// if it holds a `VertexDatasetRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_dataset_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::vertex_dataset_collection::Pattern::VertexDatasetRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::VertexDatasetCollection::pattern]
    /// to hold a `VertexDatasetRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::vertex_dataset_collection::Pattern::VertexDatasetRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VertexDatasetCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetCollection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VertexDatasetCollection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vertex_dataset_regexes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VertexDatasetCollection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vertexDatasetRegexes" => Ok(__FieldTag::__vertex_dataset_regexes),
                            "vertex_dataset_regexes" => Ok(__FieldTag::__vertex_dataset_regexes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VertexDatasetCollection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VertexDatasetCollection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vertex_dataset_regexes => {
                            if !fields.insert(__FieldTag::__vertex_dataset_regexes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertex_dataset_regexes",
                                ));
                            }
                            if result.pattern.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `pattern`, a oneof with full ID .google.privacy.dlp.v2.VertexDatasetCollection.vertex_dataset_regexes, latest field was vertexDatasetRegexes",
                                ));
                            }
                            result.pattern = std::option::Option::Some(
                                crate::model::vertex_dataset_collection::Pattern::VertexDatasetRegexes(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::VertexDatasetRegexes>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VertexDatasetCollection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.vertex_dataset_regexes() {
            state.serialize_entry("vertexDatasetRegexes", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VertexDatasetCollection].
pub mod vertex_dataset_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The pattern used to filter dataset resources.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Pattern {
        /// The regex used to filter dataset resources.
        VertexDatasetRegexes(std::boxed::Box<crate::model::VertexDatasetRegexes>),
    }
}

/// A collection of regular expressions to determine what datasets to match
/// against.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexDatasetRegexes {
    /// Required. The group of regular expression patterns to match against one or
    /// more datasets. Maximum of 100 entries. The sum of the lengths of all
    /// regular expressions can't exceed 10 KiB.
    pub patterns: std::vec::Vec<crate::model::VertexDatasetRegex>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::VertexDatasetRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VertexDatasetRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VertexDatasetRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetRegexes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VertexDatasetRegexes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patterns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VertexDatasetRegexes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patterns" => Ok(__FieldTag::__patterns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VertexDatasetRegexes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VertexDatasetRegexes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patterns => {
                            if !fields.insert(__FieldTag::__patterns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patterns",
                                ));
                            }
                            result.patterns = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VertexDatasetRegex>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VertexDatasetRegexes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.patterns.is_empty() {
            state.serialize_entry("patterns", &self.patterns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A pattern to match against one or more dataset resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexDatasetRegex {
    /// For organizations, if unset, will match all projects. Has no effect
    /// for configurations created within a project.
    pub project_id_regex: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::VertexDatasetRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }
}

impl wkt::message::Message for VertexDatasetRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetRegex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VertexDatasetRegex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VertexDatasetRegex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectIdRegex" => Ok(__FieldTag::__project_id_regex),
                            "project_id_regex" => Ok(__FieldTag::__project_id_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VertexDatasetRegex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VertexDatasetRegex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id_regex => {
                            if !fields.insert(__FieldTag::__project_id_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id_regex",
                                ));
                            }
                            result.project_id_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VertexDatasetRegex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id_regex.is_empty() {
            state.serialize_entry("projectIdRegex", &self.project_id_regex)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identifies a single Vertex AI dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexDatasetResourceReference {
    /// Required. The name of the dataset resource. If set within a project-level
    /// configuration, the specified resource must be within the project.
    pub dataset_resource_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_resource_name][crate::model::VertexDatasetResourceReference::dataset_resource_name].
    pub fn set_dataset_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_resource_name = v.into();
        self
    }
}

impl wkt::message::Message for VertexDatasetResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetResourceReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VertexDatasetResourceReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset_resource_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VertexDatasetResourceReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasetResourceName" => Ok(__FieldTag::__dataset_resource_name),
                            "dataset_resource_name" => Ok(__FieldTag::__dataset_resource_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VertexDatasetResourceReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VertexDatasetResourceReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset_resource_name => {
                            if !fields.insert(__FieldTag::__dataset_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_resource_name",
                                ));
                            }
                            result.dataset_resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VertexDatasetResourceReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset_resource_name.is_empty() {
            state.serialize_entry("datasetResourceName", &self.dataset_resource_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Requirements that must be true before a dataset is profiled for the
/// first time.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryVertexDatasetConditions {
    /// Vertex AI dataset must have been created after this date. Used to avoid
    /// backfilling.
    pub created_after: std::option::Option<wkt::Timestamp>,

    /// Minimum age a Vertex AI dataset must have. If set, the value must be 1 hour
    /// or greater.
    pub min_age: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryVertexDatasetConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_after][crate::model::DiscoveryVertexDatasetConditions::created_after].
    pub fn set_created_after<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.created_after = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [created_after][crate::model::DiscoveryVertexDatasetConditions::created_after].
    pub fn set_or_clear_created_after<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.created_after = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_age][crate::model::DiscoveryVertexDatasetConditions::min_age].
    pub fn set_min_age<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_age = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_age][crate::model::DiscoveryVertexDatasetConditions::min_age].
    pub fn set_or_clear_min_age<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_age = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiscoveryVertexDatasetConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryVertexDatasetConditions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryVertexDatasetConditions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __created_after,
            __min_age,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryVertexDatasetConditions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createdAfter" => Ok(__FieldTag::__created_after),
                            "created_after" => Ok(__FieldTag::__created_after),
                            "minAge" => Ok(__FieldTag::__min_age),
                            "min_age" => Ok(__FieldTag::__min_age),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryVertexDatasetConditions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryVertexDatasetConditions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__created_after => {
                            if !fields.insert(__FieldTag::__created_after) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for created_after",
                                ));
                            }
                            result.created_after =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__min_age => {
                            if !fields.insert(__FieldTag::__min_age) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_age",
                                ));
                            }
                            result.min_age =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryVertexDatasetConditions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.created_after.is_some() {
            state.serialize_entry("createdAfter", &self.created_after)?;
        }
        if self.min_age.is_some() {
            state.serialize_entry("minAge", &self.min_age)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// How often existing datasets should have their profiles refreshed.
/// New datasets are scanned as quickly as possible depending on system
/// capacity.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryVertexDatasetGenerationCadence {
    /// If you set this field, profiles are refreshed at this
    /// frequency regardless of whether the underlying datasets have changed.
    /// Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to be
    /// updated.
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryVertexDatasetGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryVertexDatasetGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryVertexDatasetGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryInspectTemplateModifiedCadence>,
    {
        self.inspect_template_modified_cadence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_template_modified_cadence][crate::model::DiscoveryVertexDatasetGenerationCadence::inspect_template_modified_cadence].
    pub fn set_or_clear_inspect_template_modified_cadence<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryInspectTemplateModifiedCadence>,
    {
        self.inspect_template_modified_cadence = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiscoveryVertexDatasetGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryVertexDatasetGenerationCadence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryVertexDatasetGenerationCadence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __refresh_frequency,
            __inspect_template_modified_cadence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DiscoveryVertexDatasetGenerationCadence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "refreshFrequency" => Ok(__FieldTag::__refresh_frequency),
                            "refresh_frequency" => Ok(__FieldTag::__refresh_frequency),
                            "inspectTemplateModifiedCadence" => {
                                Ok(__FieldTag::__inspect_template_modified_cadence)
                            }
                            "inspect_template_modified_cadence" => {
                                Ok(__FieldTag::__inspect_template_modified_cadence)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryVertexDatasetGenerationCadence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryVertexDatasetGenerationCadence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__refresh_frequency => {
                            if !fields.insert(__FieldTag::__refresh_frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_frequency",
                                ));
                            }
                            result.refresh_frequency = map.next_value::<std::option::Option<crate::model::DataProfileUpdateFrequency>>()?.unwrap_or_default();
                        }
                        __FieldTag::__inspect_template_modified_cadence => {
                            if !fields.insert(__FieldTag::__inspect_template_modified_cadence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template_modified_cadence",
                                ));
                            }
                            result.inspect_template_modified_cadence = map
                                .next_value::<std::option::Option<
                                    crate::model::DiscoveryInspectTemplateModifiedCadence,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryVertexDatasetGenerationCadence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.refresh_frequency) {
            state.serialize_entry("refreshFrequency", &self.refresh_frequency)?;
        }
        if self.inspect_template_modified_cadence.is_some() {
            state.serialize_entry(
                "inspectTemplateModifiedCadence",
                &self.inspect_template_modified_cadence,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Combines all of the information about a DLP job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DlpJob {
    /// The server-assigned name.
    pub name: std::string::String,

    /// The type of job.
    pub r#type: crate::model::DlpJobType,

    /// State of a job.
    pub state: crate::model::dlp_job::JobState,

    /// Time when the job was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time when the job started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Time when the job finished.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Time when the job was last modified by the system.
    pub last_modified: std::option::Option<wkt::Timestamp>,

    /// If created by a job trigger, the resource name of the trigger that
    /// instantiated the job.
    pub job_trigger_name: std::string::String,

    /// A stream of errors encountered running the job.
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Events that should occur after the job has completed.
    pub action_details: std::vec::Vec<crate::model::ActionDetails>,

    /// Job details.
    pub details: std::option::Option<crate::model::dlp_job::Details>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DlpJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DlpJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DlpJob::type].
    pub fn set_type<T: std::convert::Into<crate::model::DlpJobType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DlpJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::dlp_job::JobState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DlpJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DlpJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::DlpJob::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::DlpJob::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::DlpJob::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::DlpJob::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_modified][crate::model::DlpJob::last_modified].
    pub fn set_last_modified<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_modified][crate::model::DlpJob::last_modified].
    pub fn set_or_clear_last_modified<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified = v.map(|x| x.into());
        self
    }

    /// Sets the value of [job_trigger_name][crate::model::DlpJob::job_trigger_name].
    pub fn set_job_trigger_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_trigger_name = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::DlpJob::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [action_details][crate::model::DlpJob::action_details].
    pub fn set_action_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ActionDetails>,
    {
        use std::iter::Iterator;
        self.action_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [details][crate::model::DlpJob::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::dlp_job::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::DlpJob::details]
    /// if it holds a `RiskDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn risk_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AnalyzeDataSourceRiskDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::dlp_job::Details::RiskDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DlpJob::details]
    /// to hold a `RiskDetails`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_risk_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AnalyzeDataSourceRiskDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::dlp_job::Details::RiskDetails(v.into()));
        self
    }

    /// The value of [details][crate::model::DlpJob::details]
    /// if it holds a `InspectDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inspect_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InspectDataSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::dlp_job::Details::InspectDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DlpJob::details]
    /// to hold a `InspectDetails`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_inspect_details<
        T: std::convert::Into<std::boxed::Box<crate::model::InspectDataSourceDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::dlp_job::Details::InspectDetails(v.into()));
        self
    }
}

impl wkt::message::Message for DlpJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DlpJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DlpJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __state,
            __risk_details,
            __inspect_details,
            __create_time,
            __start_time,
            __end_time,
            __last_modified,
            __job_trigger_name,
            __errors,
            __action_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DlpJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "state" => Ok(__FieldTag::__state),
                            "riskDetails" => Ok(__FieldTag::__risk_details),
                            "risk_details" => Ok(__FieldTag::__risk_details),
                            "inspectDetails" => Ok(__FieldTag::__inspect_details),
                            "inspect_details" => Ok(__FieldTag::__inspect_details),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "lastModified" => Ok(__FieldTag::__last_modified),
                            "last_modified" => Ok(__FieldTag::__last_modified),
                            "jobTriggerName" => Ok(__FieldTag::__job_trigger_name),
                            "job_trigger_name" => Ok(__FieldTag::__job_trigger_name),
                            "errors" => Ok(__FieldTag::__errors),
                            "actionDetails" => Ok(__FieldTag::__action_details),
                            "action_details" => Ok(__FieldTag::__action_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DlpJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DlpJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::DlpJobType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::dlp_job::JobState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__risk_details => {
                            if !fields.insert(__FieldTag::__risk_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for risk_details",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.privacy.dlp.v2.DlpJob.risk_details, latest field was riskDetails",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::dlp_job::Details::RiskDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AnalyzeDataSourceRiskDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__inspect_details => {
                            if !fields.insert(__FieldTag::__inspect_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_details",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.privacy.dlp.v2.DlpJob.inspect_details, latest field was inspectDetails",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::dlp_job::Details::InspectDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InspectDataSourceDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_modified => {
                            if !fields.insert(__FieldTag::__last_modified) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified",
                                ));
                            }
                            result.last_modified =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__job_trigger_name => {
                            if !fields.insert(__FieldTag::__job_trigger_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_trigger_name",
                                ));
                            }
                            result.job_trigger_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Error>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__action_details => {
                            if !fields.insert(__FieldTag::__action_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_details",
                                ));
                            }
                            result.action_details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ActionDetails>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DlpJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if let Some(value) = self.risk_details() {
            state.serialize_entry("riskDetails", value)?;
        }
        if let Some(value) = self.inspect_details() {
            state.serialize_entry("inspectDetails", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.last_modified.is_some() {
            state.serialize_entry("lastModified", &self.last_modified)?;
        }
        if !self.job_trigger_name.is_empty() {
            state.serialize_entry("jobTriggerName", &self.job_trigger_name)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self.action_details.is_empty() {
            state.serialize_entry("actionDetails", &self.action_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DlpJob].
pub mod dlp_job {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a job. New items may be added.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobState {
        /// Unused.
        Unspecified,
        /// The job has not yet started.
        Pending,
        /// The job is currently running. Once a job has finished it will transition
        /// to FAILED or DONE.
        Running,
        /// The job is no longer running.
        Done,
        /// The job was canceled before it could be completed.
        Canceled,
        /// The job had an error and did not complete.
        Failed,
        /// The job is currently accepting findings via hybridInspect.
        /// A hybrid job in ACTIVE state may continue to have findings added to it
        /// through the calling of hybridInspect. After the job has finished no more
        /// calls to hybridInspect may be made. ACTIVE jobs can transition to DONE.
        Active,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [JobState::value] or
        /// [JobState::name].
        UnknownValue(job_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod job_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl JobState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::Canceled => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Active => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("JOB_STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::Canceled => std::option::Option::Some("CANCELED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for JobState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for JobState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for JobState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Done,
                4 => Self::Canceled,
                5 => Self::Failed,
                6 => Self::Active,
                _ => Self::UnknownValue(job_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for JobState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "JOB_STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                "CANCELED" => Self::Canceled,
                "FAILED" => Self::Failed,
                "ACTIVE" => Self::Active,
                _ => Self::UnknownValue(job_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for JobState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::Canceled => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Active => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for JobState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobState>::new(
                ".google.privacy.dlp.v2.DlpJob.JobState",
            ))
        }
    }

    /// Job details.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Details {
        /// Results from analyzing risk of a data source.
        RiskDetails(std::boxed::Box<crate::model::AnalyzeDataSourceRiskDetails>),
        /// Results from inspecting a data source.
        InspectDetails(std::boxed::Box<crate::model::InspectDataSourceDetails>),
    }
}

/// The request message for
/// [GetDlpJob][google.privacy.dlp.v2.DlpService.GetDlpJob].
///
/// [google.privacy.dlp.v2.DlpService.GetDlpJob]: crate::client::DlpService::get_dlp_job
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDlpJobRequest {
    /// Required. The name of the DlpJob resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetDlpJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDlpJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDlpJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDlpJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDlpJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDlpJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for listing DLP jobs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDlpJobsRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values for inspect jobs:
    ///   - `state` - PENDING|RUNNING|CANCELED|FINISHED|FAILED
    ///   - `inspected_storage` - DATASTORE|CLOUD_STORAGE|BIGQUERY
    ///   - `trigger_name` - The name of the trigger that created the job.
    ///   - 'end_time` - Corresponds to the time the job finished.
    ///   - 'start_time` - Corresponds to the time the job finished.
    /// * Supported fields for risk analysis jobs:
    ///   - `state` - RUNNING|CANCELED|FINISHED|FAILED
    ///   - 'end_time` - Corresponds to the time the job finished.
    ///   - 'start_time` - Corresponds to the time the job finished.
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * inspected_storage = cloud_storage AND state = done
    /// * inspected_storage = cloud_storage OR inspected_storage = bigquery
    /// * inspected_storage = cloud_storage AND (state = done OR state = canceled)
    /// * end_time > \"2017-12-12T00:00:00+00:00\"
    ///
    /// The length of this field should be no more than 500 characters.
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    pub page_token: std::string::String,

    /// The type of job. Defaults to `DlpJobType.INSPECT`
    pub r#type: crate::model::DlpJobType,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc, end_time asc, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the job was created.
    /// - `end_time`: corresponds to the time the job ended.
    /// - `name`: corresponds to the job's name.
    /// - `state`: corresponds to `state`
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDlpJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDlpJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDlpJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDlpJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDlpJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ListDlpJobsRequest::type].
    pub fn set_type<T: std::convert::Into<crate::model::DlpJobType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDlpJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListDlpJobsRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListDlpJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDlpJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDlpJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            __type,
            __order_by,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDlpJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "type" => Ok(__FieldTag::__type),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDlpJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDlpJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::DlpJobType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDlpJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for listing DLP jobs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDlpJobsResponse {
    /// A list of DlpJobs that matches the specified filter in the request.
    pub jobs: std::vec::Vec<crate::model::DlpJob>,

    /// The standard List next-page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDlpJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::ListDlpJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DlpJob>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDlpJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDlpJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDlpJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDlpJobsResponse {
    type PageItem = crate::model::DlpJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDlpJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __jobs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDlpJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobs" => Ok(__FieldTag::__jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDlpJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDlpJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DlpJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDlpJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for canceling a DLP job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelDlpJobRequest {
    /// Required. The name of the DlpJob resource to be cancelled.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CancelDlpJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelDlpJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelDlpJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelDlpJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelDlpJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelDlpJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for finishing a DLP hybrid job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FinishDlpJobRequest {
    /// Required. The name of the DlpJob resource to be finished.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FinishDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FinishDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for FinishDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FinishDlpJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FinishDlpJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FinishDlpJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FinishDlpJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FinishDlpJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FinishDlpJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for deleting a DLP job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDlpJobRequest {
    /// Required. The name of the DlpJob resource to be deleted.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteDlpJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDlpJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDlpJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDlpJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDlpJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDlpJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateDeidentifyTemplate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDeidentifyTemplateRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Required. The DeidentifyTemplate to create.
    pub deidentify_template: std::option::Option<crate::model::DeidentifyTemplate>,

    /// The template id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    pub template_id: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeidentifyTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deidentify_template][crate::model::CreateDeidentifyTemplateRequest::deidentify_template].
    pub fn set_deidentify_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyTemplate>,
    {
        self.deidentify_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deidentify_template][crate::model::CreateDeidentifyTemplateRequest::deidentify_template].
    pub fn set_or_clear_deidentify_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyTemplate>,
    {
        self.deidentify_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [template_id][crate::model::CreateDeidentifyTemplateRequest::template_id].
    pub fn set_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateDeidentifyTemplateRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateDeidentifyTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDeidentifyTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __deidentify_template,
            __template_id,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDeidentifyTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "deidentifyTemplate" => Ok(__FieldTag::__deidentify_template),
                            "deidentify_template" => Ok(__FieldTag::__deidentify_template),
                            "templateId" => Ok(__FieldTag::__template_id),
                            "template_id" => Ok(__FieldTag::__template_id),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDeidentifyTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDeidentifyTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deidentify_template => {
                            if !fields.insert(__FieldTag::__deidentify_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_template",
                                ));
                            }
                            result.deidentify_template = map.next_value::<std::option::Option<crate::model::DeidentifyTemplate>>()?
                                ;
                        }
                        __FieldTag::__template_id => {
                            if !fields.insert(__FieldTag::__template_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template_id",
                                ));
                            }
                            result.template_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDeidentifyTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.deidentify_template.is_some() {
            state.serialize_entry("deidentifyTemplate", &self.deidentify_template)?;
        }
        if !self.template_id.is_empty() {
            state.serialize_entry("templateId", &self.template_id)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateDeidentifyTemplate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDeidentifyTemplateRequest {
    /// Required. Resource name of organization and deidentify template to be
    /// updated, for example
    /// `organizations/433245324/deidentifyTemplates/432452342` or
    /// projects/project-id/deidentifyTemplates/432452342.
    pub name: std::string::String,

    /// New DeidentifyTemplate value.
    pub deidentify_template: std::option::Option<crate::model::DeidentifyTemplate>,

    /// Mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateDeidentifyTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [deidentify_template][crate::model::UpdateDeidentifyTemplateRequest::deidentify_template].
    pub fn set_deidentify_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyTemplate>,
    {
        self.deidentify_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deidentify_template][crate::model::UpdateDeidentifyTemplateRequest::deidentify_template].
    pub fn set_or_clear_deidentify_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeidentifyTemplate>,
    {
        self.deidentify_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeidentifyTemplateRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDeidentifyTemplateRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDeidentifyTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __deidentify_template,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDeidentifyTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "deidentifyTemplate" => Ok(__FieldTag::__deidentify_template),
                            "deidentify_template" => Ok(__FieldTag::__deidentify_template),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDeidentifyTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDeidentifyTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deidentify_template => {
                            if !fields.insert(__FieldTag::__deidentify_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_template",
                                ));
                            }
                            result.deidentify_template = map.next_value::<std::option::Option<crate::model::DeidentifyTemplate>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDeidentifyTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.deidentify_template.is_some() {
            state.serialize_entry("deidentifyTemplate", &self.deidentify_template)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetDeidentifyTemplate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDeidentifyTemplateRequest {
    /// Required. Resource name of the organization and deidentify template to be
    /// read, for example `organizations/433245324/deidentifyTemplates/432452342`
    /// or projects/project-id/deidentifyTemplates/432452342.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeidentifyTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetDeidentifyTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDeidentifyTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDeidentifyTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDeidentifyTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDeidentifyTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDeidentifyTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListDeidentifyTemplates.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeidentifyTemplatesRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to `ListDeidentifyTemplates`.
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the template was created.
    /// - `update_time`: corresponds to the time the template was last updated.
    /// - `name`: corresponds to the template's name.
    /// - `display_name`: corresponds to the template's display name.
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeidentifyTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeidentifyTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeidentifyTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeidentifyTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDeidentifyTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListDeidentifyTemplatesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListDeidentifyTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDeidentifyTemplatesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeidentifyTemplatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            __order_by,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeidentifyTemplatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeidentifyTemplatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeidentifyTemplatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDeidentifyTemplatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListDeidentifyTemplates.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeidentifyTemplatesResponse {
    /// List of deidentify templates, up to page_size in
    /// ListDeidentifyTemplatesRequest.
    pub deidentify_templates: std::vec::Vec<crate::model::DeidentifyTemplate>,

    /// If the next page is available then the next page token to be used in the
    /// following ListDeidentifyTemplates request.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeidentifyTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deidentify_templates][crate::model::ListDeidentifyTemplatesResponse::deidentify_templates].
    pub fn set_deidentify_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeidentifyTemplate>,
    {
        use std::iter::Iterator;
        self.deidentify_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDeidentifyTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeidentifyTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDeidentifyTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeidentifyTemplatesResponse {
    type PageItem = crate::model::DeidentifyTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deidentify_templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeidentifyTemplatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deidentify_templates,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeidentifyTemplatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deidentifyTemplates" => Ok(__FieldTag::__deidentify_templates),
                            "deidentify_templates" => Ok(__FieldTag::__deidentify_templates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeidentifyTemplatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeidentifyTemplatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deidentify_templates => {
                            if !fields.insert(__FieldTag::__deidentify_templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_templates",
                                ));
                            }
                            result.deidentify_templates = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DeidentifyTemplate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDeidentifyTemplatesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.deidentify_templates.is_empty() {
            state.serialize_entry("deidentifyTemplates", &self.deidentify_templates)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteDeidentifyTemplate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDeidentifyTemplateRequest {
    /// Required. Resource name of the organization and deidentify template to be
    /// deleted, for example
    /// `organizations/433245324/deidentifyTemplates/432452342` or
    /// projects/project-id/deidentifyTemplates/432452342.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDeidentifyTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDeidentifyTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDeidentifyTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDeidentifyTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDeidentifyTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDeidentifyTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for a custom dictionary created from a data source of any size
/// up to the maximum size defined in the
/// [limits](https://cloud.google.com/sensitive-data-protection/limits) page. The
/// artifacts of dictionary creation are stored in the specified Cloud Storage
/// location. Consider using `CustomInfoType.Dictionary` for smaller dictionaries
/// that satisfy the size requirements.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LargeCustomDictionaryConfig {
    /// Location to store dictionary artifacts in Cloud Storage. These files
    /// will only be accessible by project owners and the DLP API. If any of these
    /// artifacts are modified, the dictionary is considered invalid and can no
    /// longer be used.
    pub output_path: std::option::Option<crate::model::CloudStoragePath>,

    /// Source of the dictionary.
    pub source: std::option::Option<crate::model::large_custom_dictionary_config::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LargeCustomDictionaryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_path][crate::model::LargeCustomDictionaryConfig::output_path].
    pub fn set_output_path<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudStoragePath>,
    {
        self.output_path = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_path][crate::model::LargeCustomDictionaryConfig::output_path].
    pub fn set_or_clear_output_path<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudStoragePath>,
    {
        self.output_path = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::LargeCustomDictionaryConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::large_custom_dictionary_config::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// if it holds a `CloudStorageFileSet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_file_set(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageFileSet>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::large_custom_dictionary_config::Source::CloudStorageFileSet(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// to hold a `CloudStorageFileSet`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cloud_storage_file_set<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageFileSet>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::large_custom_dictionary_config::Source::CloudStorageFileSet(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// if it holds a `BigQueryField`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_field(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryField>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::large_custom_dictionary_config::Source::BigQueryField(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// to hold a `BigQueryField`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_big_query_field<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryField>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::large_custom_dictionary_config::Source::BigQueryField(v.into()),
        );
        self
    }
}

impl wkt::message::Message for LargeCustomDictionaryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.LargeCustomDictionaryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LargeCustomDictionaryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __output_path,
            __cloud_storage_file_set,
            __big_query_field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LargeCustomDictionaryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "outputPath" => Ok(__FieldTag::__output_path),
                            "output_path" => Ok(__FieldTag::__output_path),
                            "cloudStorageFileSet" => Ok(__FieldTag::__cloud_storage_file_set),
                            "cloud_storage_file_set" => Ok(__FieldTag::__cloud_storage_file_set),
                            "bigQueryField" => Ok(__FieldTag::__big_query_field),
                            "big_query_field" => Ok(__FieldTag::__big_query_field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LargeCustomDictionaryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LargeCustomDictionaryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__output_path => {
                            if !fields.insert(__FieldTag::__output_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_path",
                                ));
                            }
                            result.output_path = map
                                .next_value::<std::option::Option<crate::model::CloudStoragePath>>(
                                )?;
                        }
                        __FieldTag::__cloud_storage_file_set => {
                            if !fields.insert(__FieldTag::__cloud_storage_file_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_file_set",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.privacy.dlp.v2.LargeCustomDictionaryConfig.cloud_storage_file_set, latest field was cloudStorageFileSet",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::large_custom_dictionary_config::Source::CloudStorageFileSet(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CloudStorageFileSet>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__big_query_field => {
                            if !fields.insert(__FieldTag::__big_query_field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_field",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.privacy.dlp.v2.LargeCustomDictionaryConfig.big_query_field, latest field was bigQueryField",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::large_custom_dictionary_config::Source::BigQueryField(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryField>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LargeCustomDictionaryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.output_path.is_some() {
            state.serialize_entry("outputPath", &self.output_path)?;
        }
        if let Some(value) = self.cloud_storage_file_set() {
            state.serialize_entry("cloudStorageFileSet", value)?;
        }
        if let Some(value) = self.big_query_field() {
            state.serialize_entry("bigQueryField", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LargeCustomDictionaryConfig].
pub mod large_custom_dictionary_config {
    #[allow(unused_imports)]
    use super::*;

    /// Source of the dictionary.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Set of files containing newline-delimited lists of dictionary phrases.
        CloudStorageFileSet(std::boxed::Box<crate::model::CloudStorageFileSet>),
        /// Field in a BigQuery table where each cell represents a dictionary phrase.
        BigQueryField(std::boxed::Box<crate::model::BigQueryField>),
    }
}

/// Summary statistics of a custom dictionary.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LargeCustomDictionaryStats {
    /// Approximate number of distinct phrases in the dictionary.
    pub approx_num_phrases: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LargeCustomDictionaryStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approx_num_phrases][crate::model::LargeCustomDictionaryStats::approx_num_phrases].
    pub fn set_approx_num_phrases<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.approx_num_phrases = v.into();
        self
    }
}

impl wkt::message::Message for LargeCustomDictionaryStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.LargeCustomDictionaryStats"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LargeCustomDictionaryStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __approx_num_phrases,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LargeCustomDictionaryStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "approxNumPhrases" => Ok(__FieldTag::__approx_num_phrases),
                            "approx_num_phrases" => Ok(__FieldTag::__approx_num_phrases),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LargeCustomDictionaryStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LargeCustomDictionaryStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__approx_num_phrases => {
                            if !fields.insert(__FieldTag::__approx_num_phrases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approx_num_phrases",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.approx_num_phrases =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LargeCustomDictionaryStats {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.approx_num_phrases) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("approxNumPhrases", &__With(&self.approx_num_phrases))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for stored infoTypes. All fields and subfield are provided
/// by the user. For more information, see
/// <https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes>.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StoredInfoTypeConfig {
    /// Display name of the StoredInfoType (max 256 characters).
    pub display_name: std::string::String,

    /// Description of the StoredInfoType (max 256 characters).
    pub description: std::string::String,

    /// Stored infotype types.
    pub r#type: std::option::Option<crate::model::stored_info_type_config::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredInfoTypeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::StoredInfoTypeConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::StoredInfoTypeConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::stored_info_type_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// if it holds a `LargeCustomDictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn large_custom_dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LargeCustomDictionaryConfig>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_config::Type::LargeCustomDictionary(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// to hold a `LargeCustomDictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_large_custom_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::LargeCustomDictionaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::stored_info_type_config::Type::LargeCustomDictionary(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// if it holds a `Dictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Dictionary>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_config::Type::Dictionary(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// to hold a `Dictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Dictionary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::stored_info_type_config::Type::Dictionary(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// if it holds a `Regex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Regex>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_config::Type::Regex(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// to hold a `Regex`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Regex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::stored_info_type_config::Type::Regex(v.into()));
        self
    }
}

impl wkt::message::Message for StoredInfoTypeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoTypeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StoredInfoTypeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __description,
            __large_custom_dictionary,
            __dictionary,
            __regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StoredInfoTypeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "largeCustomDictionary" => Ok(__FieldTag::__large_custom_dictionary),
                            "large_custom_dictionary" => Ok(__FieldTag::__large_custom_dictionary),
                            "dictionary" => Ok(__FieldTag::__dictionary),
                            "regex" => Ok(__FieldTag::__regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StoredInfoTypeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StoredInfoTypeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__large_custom_dictionary => {
                            if !fields.insert(__FieldTag::__large_custom_dictionary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for large_custom_dictionary",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.StoredInfoTypeConfig.large_custom_dictionary, latest field was largeCustomDictionary",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::stored_info_type_config::Type::LargeCustomDictionary(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::LargeCustomDictionaryConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dictionary => {
                            if !fields.insert(__FieldTag::__dictionary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dictionary",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.StoredInfoTypeConfig.dictionary, latest field was dictionary",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::stored_info_type_config::Type::Dictionary(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::custom_info_type::Dictionary>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__regex => {
                            if !fields.insert(__FieldTag::__regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for regex",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.StoredInfoTypeConfig.regex, latest field was regex",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::stored_info_type_config::Type::Regex(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::custom_info_type::Regex>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StoredInfoTypeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if let Some(value) = self.large_custom_dictionary() {
            state.serialize_entry("largeCustomDictionary", value)?;
        }
        if let Some(value) = self.dictionary() {
            state.serialize_entry("dictionary", value)?;
        }
        if let Some(value) = self.regex() {
            state.serialize_entry("regex", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StoredInfoTypeConfig].
pub mod stored_info_type_config {
    #[allow(unused_imports)]
    use super::*;

    /// Stored infotype types.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// StoredInfoType where findings are defined by a dictionary of phrases.
        LargeCustomDictionary(std::boxed::Box<crate::model::LargeCustomDictionaryConfig>),
        /// Store dictionary-based CustomInfoType.
        Dictionary(std::boxed::Box<crate::model::custom_info_type::Dictionary>),
        /// Store regular expression-based StoredInfoType.
        Regex(std::boxed::Box<crate::model::custom_info_type::Regex>),
    }
}

/// Statistics for a StoredInfoType.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StoredInfoTypeStats {
    /// Stat types
    pub r#type: std::option::Option<crate::model::stored_info_type_stats::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredInfoTypeStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeStats::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::stored_info_type_stats::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::StoredInfoTypeStats::r#type]
    /// if it holds a `LargeCustomDictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn large_custom_dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LargeCustomDictionaryStats>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_stats::Type::LargeCustomDictionary(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeStats::r#type]
    /// to hold a `LargeCustomDictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_large_custom_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::LargeCustomDictionaryStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::stored_info_type_stats::Type::LargeCustomDictionary(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StoredInfoTypeStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoTypeStats"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StoredInfoTypeStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __large_custom_dictionary,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StoredInfoTypeStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "largeCustomDictionary" => Ok(__FieldTag::__large_custom_dictionary),
                            "large_custom_dictionary" => Ok(__FieldTag::__large_custom_dictionary),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StoredInfoTypeStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StoredInfoTypeStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__large_custom_dictionary => {
                            if !fields.insert(__FieldTag::__large_custom_dictionary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for large_custom_dictionary",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.StoredInfoTypeStats.large_custom_dictionary, latest field was largeCustomDictionary",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::stored_info_type_stats::Type::LargeCustomDictionary(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::LargeCustomDictionaryStats>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StoredInfoTypeStats {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.large_custom_dictionary() {
            state.serialize_entry("largeCustomDictionary", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StoredInfoTypeStats].
pub mod stored_info_type_stats {
    #[allow(unused_imports)]
    use super::*;

    /// Stat types
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// StoredInfoType where findings are defined by a dictionary of phrases.
        LargeCustomDictionary(std::boxed::Box<crate::model::LargeCustomDictionaryStats>),
    }
}

/// Version of a StoredInfoType, including the configuration used to build it,
/// create timestamp, and current state.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StoredInfoTypeVersion {
    /// StoredInfoType configuration.
    pub config: std::option::Option<crate::model::StoredInfoTypeConfig>,

    /// Create timestamp of the version. Read-only, determined by the system
    /// when the version is created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Stored info type version state. Read-only, updated by the system
    /// during dictionary creation.
    pub state: crate::model::StoredInfoTypeState,

    /// Errors that occurred when creating this storedInfoType version, or
    /// anomalies detected in the storedInfoType data that render it unusable. Only
    /// the five most recent errors will be displayed, with the most recent error
    /// appearing first.
    ///
    /// For example, some of the data for stored custom dictionaries is put in
    /// the user's Cloud Storage bucket, and if this data is modified or
    /// deleted by the user or another system, the dictionary becomes invalid.
    ///
    /// If any errors occur, fix the problem indicated by the error message and
    /// use the UpdateStoredInfoType API method to create another version of the
    /// storedInfoType to continue using it, reusing the same `config` if it was
    /// not the source of the error.
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Statistics about this storedInfoType version.
    pub stats: std::option::Option<crate::model::StoredInfoTypeStats>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredInfoTypeVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::StoredInfoTypeVersion::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StoredInfoTypeConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::StoredInfoTypeVersion::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StoredInfoTypeConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::StoredInfoTypeVersion::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::StoredInfoTypeVersion::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::StoredInfoTypeVersion::state].
    pub fn set_state<T: std::convert::Into<crate::model::StoredInfoTypeState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::StoredInfoTypeVersion::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [stats][crate::model::StoredInfoTypeVersion::stats].
    pub fn set_stats<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StoredInfoTypeStats>,
    {
        self.stats = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stats][crate::model::StoredInfoTypeVersion::stats].
    pub fn set_or_clear_stats<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StoredInfoTypeStats>,
    {
        self.stats = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StoredInfoTypeVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoTypeVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StoredInfoTypeVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            __create_time,
            __state,
            __errors,
            __stats,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StoredInfoTypeVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "state" => Ok(__FieldTag::__state),
                            "errors" => Ok(__FieldTag::__errors),
                            "stats" => Ok(__FieldTag::__stats),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StoredInfoTypeVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StoredInfoTypeVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map.next_value::<std::option::Option<crate::model::StoredInfoTypeConfig>>()?
                                ;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::StoredInfoTypeState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Error>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__stats => {
                            if !fields.insert(__FieldTag::__stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stats",
                                ));
                            }
                            result.stats = map.next_value::<std::option::Option<crate::model::StoredInfoTypeStats>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StoredInfoTypeVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if self.stats.is_some() {
            state.serialize_entry("stats", &self.stats)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// StoredInfoType resource message that contains information about the current
/// version and any pending updates.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StoredInfoType {
    /// Resource name.
    pub name: std::string::String,

    /// Current version of the stored info type.
    pub current_version: std::option::Option<crate::model::StoredInfoTypeVersion>,

    /// Pending versions of the stored info type. Empty if no versions are
    /// pending.
    pub pending_versions: std::vec::Vec<crate::model::StoredInfoTypeVersion>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredInfoType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StoredInfoType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [current_version][crate::model::StoredInfoType::current_version].
    pub fn set_current_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StoredInfoTypeVersion>,
    {
        self.current_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_version][crate::model::StoredInfoType::current_version].
    pub fn set_or_clear_current_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StoredInfoTypeVersion>,
    {
        self.current_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pending_versions][crate::model::StoredInfoType::pending_versions].
    pub fn set_pending_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StoredInfoTypeVersion>,
    {
        use std::iter::Iterator;
        self.pending_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StoredInfoType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StoredInfoType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __current_version,
            __pending_versions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StoredInfoType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "currentVersion" => Ok(__FieldTag::__current_version),
                            "current_version" => Ok(__FieldTag::__current_version),
                            "pendingVersions" => Ok(__FieldTag::__pending_versions),
                            "pending_versions" => Ok(__FieldTag::__pending_versions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StoredInfoType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StoredInfoType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__current_version => {
                            if !fields.insert(__FieldTag::__current_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_version",
                                ));
                            }
                            result.current_version = map.next_value::<std::option::Option<crate::model::StoredInfoTypeVersion>>()?
                                ;
                        }
                        __FieldTag::__pending_versions => {
                            if !fields.insert(__FieldTag::__pending_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pending_versions",
                                ));
                            }
                            result.pending_versions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StoredInfoTypeVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StoredInfoType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.current_version.is_some() {
            state.serialize_entry("currentVersion", &self.current_version)?;
        }
        if !self.pending_versions.is_empty() {
            state.serialize_entry("pendingVersions", &self.pending_versions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateStoredInfoType.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateStoredInfoTypeRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Required. Configuration of the storedInfoType to create.
    pub config: std::option::Option<crate::model::StoredInfoTypeConfig>,

    /// The storedInfoType ID can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    pub stored_info_type_id: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateStoredInfoTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [config][crate::model::CreateStoredInfoTypeRequest::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StoredInfoTypeConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::CreateStoredInfoTypeRequest::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StoredInfoTypeConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stored_info_type_id][crate::model::CreateStoredInfoTypeRequest::stored_info_type_id].
    pub fn set_stored_info_type_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.stored_info_type_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateStoredInfoTypeRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateStoredInfoTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateStoredInfoTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __config,
            __stored_info_type_id,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateStoredInfoTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "config" => Ok(__FieldTag::__config),
                            "storedInfoTypeId" => Ok(__FieldTag::__stored_info_type_id),
                            "stored_info_type_id" => Ok(__FieldTag::__stored_info_type_id),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateStoredInfoTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateStoredInfoTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map.next_value::<std::option::Option<crate::model::StoredInfoTypeConfig>>()?
                                ;
                        }
                        __FieldTag::__stored_info_type_id => {
                            if !fields.insert(__FieldTag::__stored_info_type_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stored_info_type_id",
                                ));
                            }
                            result.stored_info_type_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateStoredInfoTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.stored_info_type_id.is_empty() {
            state.serialize_entry("storedInfoTypeId", &self.stored_info_type_id)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateStoredInfoType.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateStoredInfoTypeRequest {
    /// Required. Resource name of organization and storedInfoType to be updated,
    /// for example `organizations/433245324/storedInfoTypes/432452342` or
    /// projects/project-id/storedInfoTypes/432452342.
    pub name: std::string::String,

    /// Updated configuration for the storedInfoType. If not provided, a new
    /// version of the storedInfoType will be created with the existing
    /// configuration.
    pub config: std::option::Option<crate::model::StoredInfoTypeConfig>,

    /// Mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateStoredInfoTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::UpdateStoredInfoTypeRequest::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StoredInfoTypeConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::UpdateStoredInfoTypeRequest::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StoredInfoTypeConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateStoredInfoTypeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateStoredInfoTypeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateStoredInfoTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateStoredInfoTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateStoredInfoTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "config" => Ok(__FieldTag::__config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateStoredInfoTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateStoredInfoTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map.next_value::<std::option::Option<crate::model::StoredInfoTypeConfig>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateStoredInfoTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetStoredInfoType.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetStoredInfoTypeRequest {
    /// Required. Resource name of the organization and storedInfoType to be read,
    /// for example `organizations/433245324/storedInfoTypes/432452342` or
    /// projects/project-id/storedInfoTypes/432452342.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStoredInfoTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetStoredInfoTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetStoredInfoTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetStoredInfoTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetStoredInfoTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetStoredInfoTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetStoredInfoTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListStoredInfoTypes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListStoredInfoTypesRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to `ListStoredInfoTypes`.
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc, display_name, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the most recent version of the
    ///   resource was created.
    /// - `state`: corresponds to the state of the resource.
    /// - `name`: corresponds to resource name.
    /// - `display_name`: corresponds to info type's display name.
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    pub location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStoredInfoTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListStoredInfoTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListStoredInfoTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListStoredInfoTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListStoredInfoTypesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListStoredInfoTypesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListStoredInfoTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListStoredInfoTypesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListStoredInfoTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            __order_by,
            __location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListStoredInfoTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListStoredInfoTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListStoredInfoTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListStoredInfoTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListStoredInfoTypes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListStoredInfoTypesResponse {
    /// List of storedInfoTypes, up to page_size in ListStoredInfoTypesRequest.
    pub stored_info_types: std::vec::Vec<crate::model::StoredInfoType>,

    /// If the next page is available then the next page token to be used
    /// in the following ListStoredInfoTypes request.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStoredInfoTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stored_info_types][crate::model::ListStoredInfoTypesResponse::stored_info_types].
    pub fn set_stored_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StoredInfoType>,
    {
        use std::iter::Iterator;
        self.stored_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListStoredInfoTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListStoredInfoTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListStoredInfoTypesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListStoredInfoTypesResponse {
    type PageItem = crate::model::StoredInfoType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.stored_info_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListStoredInfoTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stored_info_types,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListStoredInfoTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "storedInfoTypes" => Ok(__FieldTag::__stored_info_types),
                            "stored_info_types" => Ok(__FieldTag::__stored_info_types),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListStoredInfoTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListStoredInfoTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stored_info_types => {
                            if !fields.insert(__FieldTag::__stored_info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stored_info_types",
                                ));
                            }
                            result.stored_info_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StoredInfoType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListStoredInfoTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.stored_info_types.is_empty() {
            state.serialize_entry("storedInfoTypes", &self.stored_info_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteStoredInfoType.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteStoredInfoTypeRequest {
    /// Required. Resource name of the organization and storedInfoType to be
    /// deleted, for example `organizations/433245324/storedInfoTypes/432452342` or
    /// projects/project-id/storedInfoTypes/432452342.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteStoredInfoTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteStoredInfoTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteStoredInfoTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteStoredInfoTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteStoredInfoTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteStoredInfoTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteStoredInfoTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to search for potentially sensitive info in a custom location.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HybridInspectJobTriggerRequest {
    /// Required. Resource name of the trigger to execute a hybrid inspect on, for
    /// example `projects/dlp-test-project/jobTriggers/53234423`.
    pub name: std::string::String,

    /// The item to inspect.
    pub hybrid_item: std::option::Option<crate::model::HybridContentItem>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridInspectJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HybridInspectJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [hybrid_item][crate::model::HybridInspectJobTriggerRequest::hybrid_item].
    pub fn set_hybrid_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HybridContentItem>,
    {
        self.hybrid_item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hybrid_item][crate::model::HybridInspectJobTriggerRequest::hybrid_item].
    pub fn set_or_clear_hybrid_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HybridContentItem>,
    {
        self.hybrid_item = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for HybridInspectJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectJobTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HybridInspectJobTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __hybrid_item,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HybridInspectJobTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "hybridItem" => Ok(__FieldTag::__hybrid_item),
                            "hybrid_item" => Ok(__FieldTag::__hybrid_item),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HybridInspectJobTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HybridInspectJobTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hybrid_item => {
                            if !fields.insert(__FieldTag::__hybrid_item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hybrid_item",
                                ));
                            }
                            result.hybrid_item = map
                                .next_value::<std::option::Option<crate::model::HybridContentItem>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HybridInspectJobTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.hybrid_item.is_some() {
            state.serialize_entry("hybridItem", &self.hybrid_item)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to search for potentially sensitive info in a custom location.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HybridInspectDlpJobRequest {
    /// Required. Resource name of the job to execute a hybrid inspect on, for
    /// example `projects/dlp-test-project/dlpJob/53234423`.
    pub name: std::string::String,

    /// The item to inspect.
    pub hybrid_item: std::option::Option<crate::model::HybridContentItem>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridInspectDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HybridInspectDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [hybrid_item][crate::model::HybridInspectDlpJobRequest::hybrid_item].
    pub fn set_hybrid_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HybridContentItem>,
    {
        self.hybrid_item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hybrid_item][crate::model::HybridInspectDlpJobRequest::hybrid_item].
    pub fn set_or_clear_hybrid_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HybridContentItem>,
    {
        self.hybrid_item = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for HybridInspectDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectDlpJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HybridInspectDlpJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __hybrid_item,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HybridInspectDlpJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "hybridItem" => Ok(__FieldTag::__hybrid_item),
                            "hybrid_item" => Ok(__FieldTag::__hybrid_item),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HybridInspectDlpJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HybridInspectDlpJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hybrid_item => {
                            if !fields.insert(__FieldTag::__hybrid_item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hybrid_item",
                                ));
                            }
                            result.hybrid_item = map
                                .next_value::<std::option::Option<crate::model::HybridContentItem>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HybridInspectDlpJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.hybrid_item.is_some() {
            state.serialize_entry("hybridItem", &self.hybrid_item)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An individual hybrid item to inspect. Will be stored temporarily during
/// processing.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HybridContentItem {
    /// The item to inspect.
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Supplementary information that will be added to each finding.
    pub finding_details: std::option::Option<crate::model::HybridFindingDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridContentItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [item][crate::model::HybridContentItem::item].
    pub fn set_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [item][crate::model::HybridContentItem::item].
    pub fn set_or_clear_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContentItem>,
    {
        self.item = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finding_details][crate::model::HybridContentItem::finding_details].
    pub fn set_finding_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HybridFindingDetails>,
    {
        self.finding_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finding_details][crate::model::HybridContentItem::finding_details].
    pub fn set_or_clear_finding_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HybridFindingDetails>,
    {
        self.finding_details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for HybridContentItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridContentItem"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HybridContentItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __item,
            __finding_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HybridContentItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "item" => Ok(__FieldTag::__item),
                            "findingDetails" => Ok(__FieldTag::__finding_details),
                            "finding_details" => Ok(__FieldTag::__finding_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HybridContentItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HybridContentItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__item => {
                            if !fields.insert(__FieldTag::__item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for item",
                                ));
                            }
                            result.item =
                                map.next_value::<std::option::Option<crate::model::ContentItem>>()?;
                        }
                        __FieldTag::__finding_details => {
                            if !fields.insert(__FieldTag::__finding_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding_details",
                                ));
                            }
                            result.finding_details = map.next_value::<std::option::Option<crate::model::HybridFindingDetails>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HybridContentItem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.item.is_some() {
            state.serialize_entry("item", &self.item)?;
        }
        if self.finding_details.is_some() {
            state.serialize_entry("findingDetails", &self.finding_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Populate to associate additional data with each finding.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HybridFindingDetails {
    /// Details about the container where the content being inspected is from.
    pub container_details: std::option::Option<crate::model::Container>,

    /// Offset in bytes of the line, from the beginning of the file, where the
    /// finding  is located. Populate if the item being scanned is only part of a
    /// bigger item, such as a shard of a file and you want to track the absolute
    /// position of the finding.
    pub file_offset: i64,

    /// Offset of the row for tables. Populate if the row(s) being scanned are
    /// part of a bigger dataset and you want to keep track of their absolute
    /// position.
    pub row_offset: i64,

    /// If the container is a table, additional information to make findings
    /// meaningful such as the columns that are primary keys. If not known ahead
    /// of time, can also be set within each inspect hybrid call and the two
    /// will be merged. Note that identifying_fields will only be stored to
    /// BigQuery, and only if the BigQuery action has been included.
    pub table_options: std::option::Option<crate::model::TableOptions>,

    /// Labels to represent user provided metadata about the data being inspected.
    /// If configured by the job, some key values may be required.
    /// The labels associated with `Finding`'s produced by hybrid
    /// inspection.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// Label values must be between 0 and 63 characters long and must conform
    /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
    ///
    /// No more than 10 labels can be associated with a given finding.
    ///
    /// Examples:
    ///
    /// * `"environment" : "production"`
    /// * `"pipeline" : "etl"`
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridFindingDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_details][crate::model::HybridFindingDetails::container_details].
    pub fn set_container_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Container>,
    {
        self.container_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [container_details][crate::model::HybridFindingDetails::container_details].
    pub fn set_or_clear_container_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Container>,
    {
        self.container_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_offset][crate::model::HybridFindingDetails::file_offset].
    pub fn set_file_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.file_offset = v.into();
        self
    }

    /// Sets the value of [row_offset][crate::model::HybridFindingDetails::row_offset].
    pub fn set_row_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_offset = v.into();
        self
    }

    /// Sets the value of [table_options][crate::model::HybridFindingDetails::table_options].
    pub fn set_table_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableOptions>,
    {
        self.table_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table_options][crate::model::HybridFindingDetails::table_options].
    pub fn set_or_clear_table_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableOptions>,
    {
        self.table_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::HybridFindingDetails::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for HybridFindingDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridFindingDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HybridFindingDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __container_details,
            __file_offset,
            __row_offset,
            __table_options,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HybridFindingDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "containerDetails" => Ok(__FieldTag::__container_details),
                            "container_details" => Ok(__FieldTag::__container_details),
                            "fileOffset" => Ok(__FieldTag::__file_offset),
                            "file_offset" => Ok(__FieldTag::__file_offset),
                            "rowOffset" => Ok(__FieldTag::__row_offset),
                            "row_offset" => Ok(__FieldTag::__row_offset),
                            "tableOptions" => Ok(__FieldTag::__table_options),
                            "table_options" => Ok(__FieldTag::__table_options),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HybridFindingDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HybridFindingDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__container_details => {
                            if !fields.insert(__FieldTag::__container_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_details",
                                ));
                            }
                            result.container_details =
                                map.next_value::<std::option::Option<crate::model::Container>>()?;
                        }
                        __FieldTag::__file_offset => {
                            if !fields.insert(__FieldTag::__file_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_offset",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.file_offset = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__row_offset => {
                            if !fields.insert(__FieldTag::__row_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_offset",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.row_offset = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__table_options => {
                            if !fields.insert(__FieldTag::__table_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_options",
                                ));
                            }
                            result.table_options = map
                                .next_value::<std::option::Option<crate::model::TableOptions>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HybridFindingDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.container_details.is_some() {
            state.serialize_entry("containerDetails", &self.container_details)?;
        }
        if !wkt::internal::is_default(&self.file_offset) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fileOffset", &__With(&self.file_offset))?;
        }
        if !wkt::internal::is_default(&self.row_offset) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rowOffset", &__With(&self.row_offset))?;
        }
        if self.table_options.is_some() {
            state.serialize_entry("tableOptions", &self.table_options)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Quota exceeded errors will be thrown once quota has been met.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HybridInspectResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridInspectResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for HybridInspectResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HybridInspectResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HybridInspectResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HybridInspectResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HybridInspectResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HybridInspectResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to list the profiles generated for a given organization or project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProjectDataProfilesRequest {
    /// Required. organizations/{org_id}/locations/{loc_id}
    pub parent: std::string::String,

    /// Page token to continue retrieval.
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero, server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by, followed by `asc` or `desc`
    /// postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: Google Cloud project ID
    /// - `sensitivity_level`: How sensitive the data in a project is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `sensitivity_level` - HIGH|MODERATE|LOW
    ///   - `data_risk_level` - HIGH|MODERATE|LOW
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * `project_id = 12345 AND status_code = 1`
    /// * `project_id = 12345 AND sensitivity_level = HIGH`
    ///
    /// The length of this field should be no more than 500 characters.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProjectDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProjectDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProjectDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProjectDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListProjectDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListProjectDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListProjectDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListProjectDataProfilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProjectDataProfilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProjectDataProfilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProjectDataProfilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProjectDataProfilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProjectDataProfilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List of profiles generated for a given organization or project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProjectDataProfilesResponse {
    /// List of data profiles.
    pub project_data_profiles: std::vec::Vec<crate::model::ProjectDataProfile>,

    /// The next page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProjectDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_data_profiles][crate::model::ListProjectDataProfilesResponse::project_data_profiles].
    pub fn set_project_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProjectDataProfile>,
    {
        use std::iter::Iterator;
        self.project_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProjectDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProjectDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListProjectDataProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProjectDataProfilesResponse {
    type PageItem = crate::model::ProjectDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.project_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProjectDataProfilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_data_profiles,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProjectDataProfilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectDataProfiles" => Ok(__FieldTag::__project_data_profiles),
                            "project_data_profiles" => Ok(__FieldTag::__project_data_profiles),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProjectDataProfilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProjectDataProfilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_data_profiles => {
                            if !fields.insert(__FieldTag::__project_data_profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_data_profiles",
                                ));
                            }
                            result.project_data_profiles = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ProjectDataProfile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProjectDataProfilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_data_profiles.is_empty() {
            state.serialize_entry("projectDataProfiles", &self.project_data_profiles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to list the profiles generated for a given organization or project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTableDataProfilesRequest {
    /// Required. Resource name of the organization or project, for
    /// example `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    pub parent: std::string::String,

    /// Page token to continue retrieval.
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero, server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by, followed by `asc` or `desc`
    /// postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id asc`
    /// * `table_id`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: The Google Cloud project ID.
    /// - `dataset_id`: The ID of a BigQuery dataset.
    /// - `table_id`: The ID of a BigQuery table.
    /// - `sensitivity_level`: How sensitive the data in a table is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    /// - `last_modified`: The last time the resource was modified.
    /// - `resource_visibility`: Visibility restriction for this resource.
    /// - `row_count`: Number of rows in this resource.
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `project_id` - The Google Cloud project ID.
    ///   - `dataset_id` - The BigQuery dataset ID.
    ///   - `table_id` - The ID of the BigQuery table.
    ///   - `sensitivity_level` - HIGH|MODERATE|LOW
    ///   - `data_risk_level` - HIGH|MODERATE|LOW
    ///   - `resource_visibility`: PUBLIC|RESTRICTED
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * `project_id = 12345 AND status_code = 1`
    /// * `project_id = 12345 AND sensitivity_level = HIGH`
    /// * `project_id = 12345 AND resource_visibility = PUBLIC`
    ///
    /// The length of this field should be no more than 500 characters.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTableDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTableDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTableDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTableDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTableDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTableDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListTableDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListTableDataProfilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTableDataProfilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTableDataProfilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTableDataProfilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTableDataProfilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTableDataProfilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List of profiles generated for a given organization or project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTableDataProfilesResponse {
    /// List of data profiles.
    pub table_data_profiles: std::vec::Vec<crate::model::TableDataProfile>,

    /// The next page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTableDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_data_profiles][crate::model::ListTableDataProfilesResponse::table_data_profiles].
    pub fn set_table_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableDataProfile>,
    {
        use std::iter::Iterator;
        self.table_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTableDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTableDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListTableDataProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTableDataProfilesResponse {
    type PageItem = crate::model::TableDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.table_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTableDataProfilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table_data_profiles,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTableDataProfilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tableDataProfiles" => Ok(__FieldTag::__table_data_profiles),
                            "table_data_profiles" => Ok(__FieldTag::__table_data_profiles),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTableDataProfilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTableDataProfilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table_data_profiles => {
                            if !fields.insert(__FieldTag::__table_data_profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_data_profiles",
                                ));
                            }
                            result.table_data_profiles =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableDataProfile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTableDataProfilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.table_data_profiles.is_empty() {
            state.serialize_entry("tableDataProfiles", &self.table_data_profiles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to list the profiles generated for a given organization or project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListColumnDataProfilesRequest {
    /// Required. Resource name of the organization or project, for
    /// example `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    pub parent: std::string::String,

    /// Page token to continue retrieval.
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero, server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by, followed by `asc` or `desc`
    /// postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id asc`
    /// * `table_id`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: The Google Cloud project ID.
    /// - `dataset_id`: The ID of a BigQuery dataset.
    /// - `table_id`: The ID of a BigQuery table.
    /// - `sensitivity_level`: How sensitive the data in a column is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `table_data_profile_name` - The name of the related table data
    ///     profile.
    ///   - `project_id` - The Google Cloud project ID. (REQUIRED)
    ///   - `dataset_id` - The BigQuery dataset ID. (REQUIRED)
    ///   - `table_id` - The BigQuery table ID. (REQUIRED)
    ///   - `field_id` - The ID of the BigQuery field.
    ///   - `info_type` - The infotype detected in the resource.
    ///   - `sensitivity_level` - HIGH|MEDIUM|LOW
    ///   - `data_risk_level`: How much risk is associated with this data.
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` for project_id, dataset_id, and table_id. Other
    ///   filters also support `!=`.
    ///
    /// Examples:
    ///
    /// * project_id = 12345 AND status_code = 1
    /// * project_id = 12345 AND sensitivity_level = HIGH
    /// * project_id = 12345 AND info_type = STREET_ADDRESS
    ///
    /// The length of this field should be no more than 500 characters.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListColumnDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListColumnDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListColumnDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListColumnDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListColumnDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListColumnDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListColumnDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListColumnDataProfilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListColumnDataProfilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListColumnDataProfilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListColumnDataProfilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListColumnDataProfilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListColumnDataProfilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List of profiles generated for a given organization or project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListColumnDataProfilesResponse {
    /// List of data profiles.
    pub column_data_profiles: std::vec::Vec<crate::model::ColumnDataProfile>,

    /// The next page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListColumnDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column_data_profiles][crate::model::ListColumnDataProfilesResponse::column_data_profiles].
    pub fn set_column_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnDataProfile>,
    {
        use std::iter::Iterator;
        self.column_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListColumnDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListColumnDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListColumnDataProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListColumnDataProfilesResponse {
    type PageItem = crate::model::ColumnDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.column_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListColumnDataProfilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __column_data_profiles,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListColumnDataProfilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columnDataProfiles" => Ok(__FieldTag::__column_data_profiles),
                            "column_data_profiles" => Ok(__FieldTag::__column_data_profiles),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListColumnDataProfilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListColumnDataProfilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__column_data_profiles => {
                            if !fields.insert(__FieldTag::__column_data_profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_data_profiles",
                                ));
                            }
                            result.column_data_profiles =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ColumnDataProfile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListColumnDataProfilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.column_data_profiles.is_empty() {
            state.serialize_entry("columnDataProfiles", &self.column_data_profiles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Score is a summary of all elements in the data profile.
/// A higher number means more risk.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataRiskLevel {
    /// The score applied to the resource.
    pub score: crate::model::data_risk_level::DataRiskLevelScore,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataRiskLevel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::DataRiskLevel::score].
    pub fn set_score<T: std::convert::Into<crate::model::data_risk_level::DataRiskLevelScore>>(
        mut self,
        v: T,
    ) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for DataRiskLevel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataRiskLevel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataRiskLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataRiskLevel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "score" => Ok(__FieldTag::__score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataRiskLevel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataRiskLevel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            result.score = map
                                .next_value::<std::option::Option<
                                    crate::model::data_risk_level::DataRiskLevelScore,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataRiskLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.score) {
            state.serialize_entry("score", &self.score)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataRiskLevel].
pub mod data_risk_level {
    #[allow(unused_imports)]
    use super::*;

    /// Various score levels for resources.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataRiskLevelScore {
        /// Unused.
        RiskScoreUnspecified,
        /// Low risk - Lower indication of sensitive data that appears to have
        /// additional access restrictions in place or no indication of sensitive
        /// data found.
        RiskLow,
        /// Unable to determine risk.
        RiskUnknown,
        /// Medium risk - Sensitive data may be present but additional access or fine
        /// grain access restrictions appear to be present.  Consider limiting
        /// access even further or transform data to mask.
        RiskModerate,
        /// High risk – SPII may be present. Access controls may include public
        /// ACLs. Exfiltration of data may lead to user data loss. Re-identification
        /// of users may be possible. Consider limiting usage and or removing SPII.
        RiskHigh,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataRiskLevelScore::value] or
        /// [DataRiskLevelScore::name].
        UnknownValue(data_risk_level_score::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_risk_level_score {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataRiskLevelScore {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::RiskScoreUnspecified => std::option::Option::Some(0),
                Self::RiskLow => std::option::Option::Some(10),
                Self::RiskUnknown => std::option::Option::Some(12),
                Self::RiskModerate => std::option::Option::Some(20),
                Self::RiskHigh => std::option::Option::Some(30),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::RiskScoreUnspecified => std::option::Option::Some("RISK_SCORE_UNSPECIFIED"),
                Self::RiskLow => std::option::Option::Some("RISK_LOW"),
                Self::RiskUnknown => std::option::Option::Some("RISK_UNKNOWN"),
                Self::RiskModerate => std::option::Option::Some("RISK_MODERATE"),
                Self::RiskHigh => std::option::Option::Some("RISK_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataRiskLevelScore {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataRiskLevelScore {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataRiskLevelScore {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::RiskScoreUnspecified,
                10 => Self::RiskLow,
                12 => Self::RiskUnknown,
                20 => Self::RiskModerate,
                30 => Self::RiskHigh,
                _ => Self::UnknownValue(data_risk_level_score::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataRiskLevelScore {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RISK_SCORE_UNSPECIFIED" => Self::RiskScoreUnspecified,
                "RISK_LOW" => Self::RiskLow,
                "RISK_UNKNOWN" => Self::RiskUnknown,
                "RISK_MODERATE" => Self::RiskModerate,
                "RISK_HIGH" => Self::RiskHigh,
                _ => Self::UnknownValue(data_risk_level_score::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataRiskLevelScore {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::RiskScoreUnspecified => serializer.serialize_i32(0),
                Self::RiskLow => serializer.serialize_i32(10),
                Self::RiskUnknown => serializer.serialize_i32(12),
                Self::RiskModerate => serializer.serialize_i32(20),
                Self::RiskHigh => serializer.serialize_i32(30),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataRiskLevelScore {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataRiskLevelScore>::new(
                ".google.privacy.dlp.v2.DataRiskLevel.DataRiskLevelScore",
            ))
        }
    }
}

/// An aggregated profile for this project, based on the resources profiled
/// within it.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ProjectDataProfile {
    /// The resource name of the profile.
    pub name: std::string::String,

    /// Project ID or account that was profiled.
    pub project_id: std::string::String,

    /// The last time the profile was generated.
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// The sensitivity score of this project.
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this project.
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// Success or error status of the last attempt to profile the project.
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// The number of table data profiles generated for this project.
    pub table_data_profile_count: i64,

    /// The number of file store data profiles generated for this project.
    pub file_store_data_profile_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProjectDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProjectDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::ProjectDataProfile::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::ProjectDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.profile_last_generated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [profile_last_generated][crate::model::ProjectDataProfile::profile_last_generated].
    pub fn set_or_clear_profile_last_generated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.profile_last_generated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::ProjectDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sensitivity_score][crate::model::ProjectDataProfile::sensitivity_score].
    pub fn set_or_clear_sensitivity_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_risk_level][crate::model::ProjectDataProfile::data_risk_level].
    pub fn set_data_risk_level<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataRiskLevel>,
    {
        self.data_risk_level = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_risk_level][crate::model::ProjectDataProfile::data_risk_level].
    pub fn set_or_clear_data_risk_level<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataRiskLevel>,
    {
        self.data_risk_level = v.map(|x| x.into());
        self
    }

    /// Sets the value of [profile_status][crate::model::ProjectDataProfile::profile_status].
    pub fn set_profile_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProfileStatus>,
    {
        self.profile_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [profile_status][crate::model::ProjectDataProfile::profile_status].
    pub fn set_or_clear_profile_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProfileStatus>,
    {
        self.profile_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [table_data_profile_count][crate::model::ProjectDataProfile::table_data_profile_count].
    pub fn set_table_data_profile_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.table_data_profile_count = v.into();
        self
    }

    /// Sets the value of [file_store_data_profile_count][crate::model::ProjectDataProfile::file_store_data_profile_count].
    pub fn set_file_store_data_profile_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.file_store_data_profile_count = v.into();
        self
    }
}

impl wkt::message::Message for ProjectDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ProjectDataProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProjectDataProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __profile_last_generated,
            __sensitivity_score,
            __data_risk_level,
            __profile_status,
            __table_data_profile_count,
            __file_store_data_profile_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProjectDataProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "profileLastGenerated" => Ok(__FieldTag::__profile_last_generated),
                            "profile_last_generated" => Ok(__FieldTag::__profile_last_generated),
                            "sensitivityScore" => Ok(__FieldTag::__sensitivity_score),
                            "sensitivity_score" => Ok(__FieldTag::__sensitivity_score),
                            "dataRiskLevel" => Ok(__FieldTag::__data_risk_level),
                            "data_risk_level" => Ok(__FieldTag::__data_risk_level),
                            "profileStatus" => Ok(__FieldTag::__profile_status),
                            "profile_status" => Ok(__FieldTag::__profile_status),
                            "tableDataProfileCount" => Ok(__FieldTag::__table_data_profile_count),
                            "table_data_profile_count" => {
                                Ok(__FieldTag::__table_data_profile_count)
                            }
                            "fileStoreDataProfileCount" => {
                                Ok(__FieldTag::__file_store_data_profile_count)
                            }
                            "file_store_data_profile_count" => {
                                Ok(__FieldTag::__file_store_data_profile_count)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProjectDataProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProjectDataProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__profile_last_generated => {
                            if !fields.insert(__FieldTag::__profile_last_generated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile_last_generated",
                                ));
                            }
                            result.profile_last_generated =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__sensitivity_score => {
                            if !fields.insert(__FieldTag::__sensitivity_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sensitivity_score",
                                ));
                            }
                            result.sensitivity_score = map
                                .next_value::<std::option::Option<crate::model::SensitivityScore>>(
                                )?;
                        }
                        __FieldTag::__data_risk_level => {
                            if !fields.insert(__FieldTag::__data_risk_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_risk_level",
                                ));
                            }
                            result.data_risk_level = map
                                .next_value::<std::option::Option<crate::model::DataRiskLevel>>()?;
                        }
                        __FieldTag::__profile_status => {
                            if !fields.insert(__FieldTag::__profile_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile_status",
                                ));
                            }
                            result.profile_status = map
                                .next_value::<std::option::Option<crate::model::ProfileStatus>>()?;
                        }
                        __FieldTag::__table_data_profile_count => {
                            if !fields.insert(__FieldTag::__table_data_profile_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_data_profile_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.table_data_profile_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__file_store_data_profile_count => {
                            if !fields.insert(__FieldTag::__file_store_data_profile_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_store_data_profile_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.file_store_data_profile_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProjectDataProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if self.profile_last_generated.is_some() {
            state.serialize_entry("profileLastGenerated", &self.profile_last_generated)?;
        }
        if self.sensitivity_score.is_some() {
            state.serialize_entry("sensitivityScore", &self.sensitivity_score)?;
        }
        if self.data_risk_level.is_some() {
            state.serialize_entry("dataRiskLevel", &self.data_risk_level)?;
        }
        if self.profile_status.is_some() {
            state.serialize_entry("profileStatus", &self.profile_status)?;
        }
        if !wkt::internal::is_default(&self.table_data_profile_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "tableDataProfileCount",
                &__With(&self.table_data_profile_count),
            )?;
        }
        if !wkt::internal::is_default(&self.file_store_data_profile_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "fileStoreDataProfileCount",
                &__With(&self.file_store_data_profile_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Snapshot of the configurations used to generate the profile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfileConfigSnapshot {
    /// A copy of the inspection config used to generate this profile. This
    /// is a copy of the inspect_template specified in `DataProfileJobConfig`.
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// A copy of the configuration used to generate this profile. This is
    /// deprecated, and the DiscoveryConfig field is preferred moving forward.
    /// DataProfileJobConfig will still be written here for Discovery in BigQuery
    /// for backwards compatibility, but will not be updated with new fields, while
    /// DiscoveryConfig will.
    #[deprecated]
    pub data_profile_job: std::option::Option<crate::model::DataProfileJobConfig>,

    /// A copy of the configuration used to generate this profile.
    pub discovery_config: std::option::Option<crate::model::DiscoveryConfig>,

    /// Name of the inspection template used to generate this profile
    pub inspect_template_name: std::string::String,

    /// Timestamp when the template was modified
    pub inspect_template_modified_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileConfigSnapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inspect_config][crate::model::DataProfileConfigSnapshot::inspect_config].
    pub fn set_inspect_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_config][crate::model::DataProfileConfigSnapshot::inspect_config].
    pub fn set_or_clear_inspect_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InspectConfig>,
    {
        self.inspect_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_profile_job][crate::model::DataProfileConfigSnapshot::data_profile_job].
    #[deprecated]
    pub fn set_data_profile_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataProfileJobConfig>,
    {
        self.data_profile_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_profile_job][crate::model::DataProfileConfigSnapshot::data_profile_job].
    #[deprecated]
    pub fn set_or_clear_data_profile_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataProfileJobConfig>,
    {
        self.data_profile_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [discovery_config][crate::model::DataProfileConfigSnapshot::discovery_config].
    pub fn set_discovery_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryConfig>,
    {
        self.discovery_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [discovery_config][crate::model::DataProfileConfigSnapshot::discovery_config].
    pub fn set_or_clear_discovery_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiscoveryConfig>,
    {
        self.discovery_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::DataProfileConfigSnapshot::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_time][crate::model::DataProfileConfigSnapshot::inspect_template_modified_time].
    pub fn set_inspect_template_modified_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.inspect_template_modified_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inspect_template_modified_time][crate::model::DataProfileConfigSnapshot::inspect_template_modified_time].
    pub fn set_or_clear_inspect_template_modified_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.inspect_template_modified_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataProfileConfigSnapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileConfigSnapshot"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfileConfigSnapshot {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inspect_config,
            __data_profile_job,
            __discovery_config,
            __inspect_template_name,
            __inspect_template_modified_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfileConfigSnapshot")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inspectConfig" => Ok(__FieldTag::__inspect_config),
                            "inspect_config" => Ok(__FieldTag::__inspect_config),
                            "dataProfileJob" => Ok(__FieldTag::__data_profile_job),
                            "data_profile_job" => Ok(__FieldTag::__data_profile_job),
                            "discoveryConfig" => Ok(__FieldTag::__discovery_config),
                            "discovery_config" => Ok(__FieldTag::__discovery_config),
                            "inspectTemplateName" => Ok(__FieldTag::__inspect_template_name),
                            "inspect_template_name" => Ok(__FieldTag::__inspect_template_name),
                            "inspectTemplateModifiedTime" => {
                                Ok(__FieldTag::__inspect_template_modified_time)
                            }
                            "inspect_template_modified_time" => {
                                Ok(__FieldTag::__inspect_template_modified_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfileConfigSnapshot;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfileConfigSnapshot")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inspect_config => {
                            if !fields.insert(__FieldTag::__inspect_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_config",
                                ));
                            }
                            result.inspect_config = map
                                .next_value::<std::option::Option<crate::model::InspectConfig>>()?;
                        }
                        __FieldTag::__data_profile_job => {
                            if !fields.insert(__FieldTag::__data_profile_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_profile_job",
                                ));
                            }
                            result.data_profile_job = map.next_value::<std::option::Option<crate::model::DataProfileJobConfig>>()?
                                ;
                        }
                        __FieldTag::__discovery_config => {
                            if !fields.insert(__FieldTag::__discovery_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_config",
                                ));
                            }
                            result.discovery_config = map
                                .next_value::<std::option::Option<crate::model::DiscoveryConfig>>(
                                )?;
                        }
                        __FieldTag::__inspect_template_name => {
                            if !fields.insert(__FieldTag::__inspect_template_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template_name",
                                ));
                            }
                            result.inspect_template_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inspect_template_modified_time => {
                            if !fields.insert(__FieldTag::__inspect_template_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template_modified_time",
                                ));
                            }
                            result.inspect_template_modified_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfileConfigSnapshot {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.inspect_config.is_some() {
            state.serialize_entry("inspectConfig", &self.inspect_config)?;
        }
        if self.data_profile_job.is_some() {
            state.serialize_entry("dataProfileJob", &self.data_profile_job)?;
        }
        if self.discovery_config.is_some() {
            state.serialize_entry("discoveryConfig", &self.discovery_config)?;
        }
        if !self.inspect_template_name.is_empty() {
            state.serialize_entry("inspectTemplateName", &self.inspect_template_name)?;
        }
        if self.inspect_template_modified_time.is_some() {
            state.serialize_entry(
                "inspectTemplateModifiedTime",
                &self.inspect_template_modified_time,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The profile for a scanned table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TableDataProfile {
    /// The name of the profile.
    pub name: std::string::String,

    /// The resource type that was profiled.
    pub data_source_type: std::option::Option<crate::model::DataSourceType>,

    /// The resource name of the project data profile for this table.
    pub project_data_profile: std::string::String,

    /// The Google Cloud project ID that owns the resource.
    pub dataset_project_id: std::string::String,

    /// If supported, the location where the dataset's data is stored.
    /// See <https://cloud.google.com/bigquery/docs/locations> for supported
    /// locations.
    pub dataset_location: std::string::String,

    /// If the resource is BigQuery, the dataset ID.
    pub dataset_id: std::string::String,

    /// The table ID.
    pub table_id: std::string::String,

    /// The Cloud Asset Inventory resource that was profiled in order to generate
    /// this TableDataProfile.
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    pub full_resource: std::string::String,

    /// Success or error status from the most recent profile generation attempt.
    /// May be empty if the profile is still being generated.
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// State of a profile.
    pub state: crate::model::table_data_profile::State,

    /// The sensitivity score of this table.
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this table.
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// The infoTypes predicted from this table's data.
    pub predicted_info_types: std::vec::Vec<crate::model::InfoTypeSummary>,

    /// Other infoTypes found in this table's data.
    pub other_info_types: std::vec::Vec<crate::model::OtherInfoTypeSummary>,

    /// The snapshot of the configurations used to generate the profile.
    pub config_snapshot: std::option::Option<crate::model::DataProfileConfigSnapshot>,

    /// The time when this table was last modified
    pub last_modified_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The time when this table expires.
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// The number of columns profiled in the table.
    pub scanned_column_count: i64,

    /// The number of columns skipped in the table because of an error.
    pub failed_column_count: i64,

    /// The size of the table when the profile was generated.
    pub table_size_bytes: i64,

    /// Number of rows in the table when the profile was generated.
    /// This will not be populated for BigLake tables.
    pub row_count: i64,

    /// How the table is encrypted.
    pub encryption_status: crate::model::EncryptionStatus,

    /// How broadly a resource has been shared.
    pub resource_visibility: crate::model::ResourceVisibility,

    /// The last time the profile was generated.
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// The labels applied to the resource at the time the profile was generated.
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The time at which the table was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The BigQuery table to which the sample findings are written.
    pub sample_findings_table: std::option::Option<crate::model::BigQueryTable>,

    /// The tags attached to the table, including any tags attached during
    /// profiling. Because tags are attached to Cloud SQL instances rather than
    /// Cloud SQL tables, this field is empty for Cloud SQL table profiles.
    pub tags: std::vec::Vec<crate::model::Tag>,

    /// Resources related to this profile.
    pub related_resources: std::vec::Vec<crate::model::RelatedResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TableDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_source_type][crate::model::TableDataProfile::data_source_type].
    pub fn set_data_source_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataSourceType>,
    {
        self.data_source_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_source_type][crate::model::TableDataProfile::data_source_type].
    pub fn set_or_clear_data_source_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataSourceType>,
    {
        self.data_source_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [project_data_profile][crate::model::TableDataProfile::project_data_profile].
    pub fn set_project_data_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_data_profile = v.into();
        self
    }

    /// Sets the value of [dataset_project_id][crate::model::TableDataProfile::dataset_project_id].
    pub fn set_dataset_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_project_id = v.into();
        self
    }

    /// Sets the value of [dataset_location][crate::model::TableDataProfile::dataset_location].
    pub fn set_dataset_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_location = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::TableDataProfile::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::TableDataProfile::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [full_resource][crate::model::TableDataProfile::full_resource].
    pub fn set_full_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_resource = v.into();
        self
    }

    /// Sets the value of [profile_status][crate::model::TableDataProfile::profile_status].
    pub fn set_profile_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProfileStatus>,
    {
        self.profile_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [profile_status][crate::model::TableDataProfile::profile_status].
    pub fn set_or_clear_profile_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProfileStatus>,
    {
        self.profile_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::TableDataProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::table_data_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::TableDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sensitivity_score][crate::model::TableDataProfile::sensitivity_score].
    pub fn set_or_clear_sensitivity_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_risk_level][crate::model::TableDataProfile::data_risk_level].
    pub fn set_data_risk_level<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataRiskLevel>,
    {
        self.data_risk_level = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_risk_level][crate::model::TableDataProfile::data_risk_level].
    pub fn set_or_clear_data_risk_level<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataRiskLevel>,
    {
        self.data_risk_level = v.map(|x| x.into());
        self
    }

    /// Sets the value of [predicted_info_types][crate::model::TableDataProfile::predicted_info_types].
    pub fn set_predicted_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.predicted_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [other_info_types][crate::model::TableDataProfile::other_info_types].
    pub fn set_other_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OtherInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.other_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [config_snapshot][crate::model::TableDataProfile::config_snapshot].
    pub fn set_config_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataProfileConfigSnapshot>,
    {
        self.config_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_snapshot][crate::model::TableDataProfile::config_snapshot].
    pub fn set_or_clear_config_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataProfileConfigSnapshot>,
    {
        self.config_snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_modified_time][crate::model::TableDataProfile::last_modified_time].
    pub fn set_last_modified_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_modified_time][crate::model::TableDataProfile::last_modified_time].
    pub fn set_or_clear_last_modified_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expiration_time][crate::model::TableDataProfile::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::TableDataProfile::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scanned_column_count][crate::model::TableDataProfile::scanned_column_count].
    pub fn set_scanned_column_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.scanned_column_count = v.into();
        self
    }

    /// Sets the value of [failed_column_count][crate::model::TableDataProfile::failed_column_count].
    pub fn set_failed_column_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_column_count = v.into();
        self
    }

    /// Sets the value of [table_size_bytes][crate::model::TableDataProfile::table_size_bytes].
    pub fn set_table_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.table_size_bytes = v.into();
        self
    }

    /// Sets the value of [row_count][crate::model::TableDataProfile::row_count].
    pub fn set_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_count = v.into();
        self
    }

    /// Sets the value of [encryption_status][crate::model::TableDataProfile::encryption_status].
    pub fn set_encryption_status<T: std::convert::Into<crate::model::EncryptionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_status = v.into();
        self
    }

    /// Sets the value of [resource_visibility][crate::model::TableDataProfile::resource_visibility].
    pub fn set_resource_visibility<T: std::convert::Into<crate::model::ResourceVisibility>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_visibility = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::TableDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.profile_last_generated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [profile_last_generated][crate::model::TableDataProfile::profile_last_generated].
    pub fn set_or_clear_profile_last_generated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.profile_last_generated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_labels][crate::model::TableDataProfile::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::TableDataProfile::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::TableDataProfile::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sample_findings_table][crate::model::TableDataProfile::sample_findings_table].
    pub fn set_sample_findings_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.sample_findings_table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sample_findings_table][crate::model::TableDataProfile::sample_findings_table].
    pub fn set_or_clear_sample_findings_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.sample_findings_table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::TableDataProfile::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [related_resources][crate::model::TableDataProfile::related_resources].
    pub fn set_related_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedResource>,
    {
        use std::iter::Iterator;
        self.related_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableDataProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableDataProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data_source_type,
            __project_data_profile,
            __dataset_project_id,
            __dataset_location,
            __dataset_id,
            __table_id,
            __full_resource,
            __profile_status,
            __state,
            __sensitivity_score,
            __data_risk_level,
            __predicted_info_types,
            __other_info_types,
            __config_snapshot,
            __last_modified_time,
            __expiration_time,
            __scanned_column_count,
            __failed_column_count,
            __table_size_bytes,
            __row_count,
            __encryption_status,
            __resource_visibility,
            __profile_last_generated,
            __resource_labels,
            __create_time,
            __sample_findings_table,
            __tags,
            __related_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableDataProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "dataSourceType" => Ok(__FieldTag::__data_source_type),
                            "data_source_type" => Ok(__FieldTag::__data_source_type),
                            "projectDataProfile" => Ok(__FieldTag::__project_data_profile),
                            "project_data_profile" => Ok(__FieldTag::__project_data_profile),
                            "datasetProjectId" => Ok(__FieldTag::__dataset_project_id),
                            "dataset_project_id" => Ok(__FieldTag::__dataset_project_id),
                            "datasetLocation" => Ok(__FieldTag::__dataset_location),
                            "dataset_location" => Ok(__FieldTag::__dataset_location),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "fullResource" => Ok(__FieldTag::__full_resource),
                            "full_resource" => Ok(__FieldTag::__full_resource),
                            "profileStatus" => Ok(__FieldTag::__profile_status),
                            "profile_status" => Ok(__FieldTag::__profile_status),
                            "state" => Ok(__FieldTag::__state),
                            "sensitivityScore" => Ok(__FieldTag::__sensitivity_score),
                            "sensitivity_score" => Ok(__FieldTag::__sensitivity_score),
                            "dataRiskLevel" => Ok(__FieldTag::__data_risk_level),
                            "data_risk_level" => Ok(__FieldTag::__data_risk_level),
                            "predictedInfoTypes" => Ok(__FieldTag::__predicted_info_types),
                            "predicted_info_types" => Ok(__FieldTag::__predicted_info_types),
                            "otherInfoTypes" => Ok(__FieldTag::__other_info_types),
                            "other_info_types" => Ok(__FieldTag::__other_info_types),
                            "configSnapshot" => Ok(__FieldTag::__config_snapshot),
                            "config_snapshot" => Ok(__FieldTag::__config_snapshot),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "scannedColumnCount" => Ok(__FieldTag::__scanned_column_count),
                            "scanned_column_count" => Ok(__FieldTag::__scanned_column_count),
                            "failedColumnCount" => Ok(__FieldTag::__failed_column_count),
                            "failed_column_count" => Ok(__FieldTag::__failed_column_count),
                            "tableSizeBytes" => Ok(__FieldTag::__table_size_bytes),
                            "table_size_bytes" => Ok(__FieldTag::__table_size_bytes),
                            "rowCount" => Ok(__FieldTag::__row_count),
                            "row_count" => Ok(__FieldTag::__row_count),
                            "encryptionStatus" => Ok(__FieldTag::__encryption_status),
                            "encryption_status" => Ok(__FieldTag::__encryption_status),
                            "resourceVisibility" => Ok(__FieldTag::__resource_visibility),
                            "resource_visibility" => Ok(__FieldTag::__resource_visibility),
                            "profileLastGenerated" => Ok(__FieldTag::__profile_last_generated),
                            "profile_last_generated" => Ok(__FieldTag::__profile_last_generated),
                            "resourceLabels" => Ok(__FieldTag::__resource_labels),
                            "resource_labels" => Ok(__FieldTag::__resource_labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "sampleFindingsTable" => Ok(__FieldTag::__sample_findings_table),
                            "sample_findings_table" => Ok(__FieldTag::__sample_findings_table),
                            "tags" => Ok(__FieldTag::__tags),
                            "relatedResources" => Ok(__FieldTag::__related_resources),
                            "related_resources" => Ok(__FieldTag::__related_resources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableDataProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableDataProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source_type => {
                            if !fields.insert(__FieldTag::__data_source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_type",
                                ));
                            }
                            result.data_source_type = map
                                .next_value::<std::option::Option<crate::model::DataSourceType>>(
                                )?;
                        }
                        __FieldTag::__project_data_profile => {
                            if !fields.insert(__FieldTag::__project_data_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_data_profile",
                                ));
                            }
                            result.project_data_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_project_id => {
                            if !fields.insert(__FieldTag::__dataset_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_project_id",
                                ));
                            }
                            result.dataset_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_location => {
                            if !fields.insert(__FieldTag::__dataset_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_location",
                                ));
                            }
                            result.dataset_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__full_resource => {
                            if !fields.insert(__FieldTag::__full_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_resource",
                                ));
                            }
                            result.full_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__profile_status => {
                            if !fields.insert(__FieldTag::__profile_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile_status",
                                ));
                            }
                            result.profile_status = map
                                .next_value::<std::option::Option<crate::model::ProfileStatus>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::table_data_profile::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sensitivity_score => {
                            if !fields.insert(__FieldTag::__sensitivity_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sensitivity_score",
                                ));
                            }
                            result.sensitivity_score = map
                                .next_value::<std::option::Option<crate::model::SensitivityScore>>(
                                )?;
                        }
                        __FieldTag::__data_risk_level => {
                            if !fields.insert(__FieldTag::__data_risk_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_risk_level",
                                ));
                            }
                            result.data_risk_level = map
                                .next_value::<std::option::Option<crate::model::DataRiskLevel>>()?;
                        }
                        __FieldTag::__predicted_info_types => {
                            if !fields.insert(__FieldTag::__predicted_info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicted_info_types",
                                ));
                            }
                            result.predicted_info_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InfoTypeSummary>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__other_info_types => {
                            if !fields.insert(__FieldTag::__other_info_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for other_info_types",
                                ));
                            }
                            result.other_info_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OtherInfoTypeSummary>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_snapshot => {
                            if !fields.insert(__FieldTag::__config_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_snapshot",
                                ));
                            }
                            result.config_snapshot = map.next_value::<std::option::Option<crate::model::DataProfileConfigSnapshot>>()?
                                ;
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            result.last_modified_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            result.expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__scanned_column_count => {
                            if !fields.insert(__FieldTag::__scanned_column_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scanned_column_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scanned_column_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_column_count => {
                            if !fields.insert(__FieldTag::__failed_column_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_column_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_column_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__table_size_bytes => {
                            if !fields.insert(__FieldTag::__table_size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.table_size_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__row_count => {
                            if !fields.insert(__FieldTag::__row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.row_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__encryption_status => {
                            if !fields.insert(__FieldTag::__encryption_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_status",
                                ));
                            }
                            result.encryption_status = map
                                .next_value::<std::option::Option<crate::model::EncryptionStatus>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_visibility => {
                            if !fields.insert(__FieldTag::__resource_visibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_visibility",
                                ));
                            }
                            result.resource_visibility = map.next_value::<std::option::Option<crate::model::ResourceVisibility>>()?.unwrap_or_default();
                        }
                        __FieldTag::__profile_last_generated => {
                            if !fields.insert(__FieldTag::__profile_last_generated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile_last_generated",
                                ));
                            }
                            result.profile_last_generated =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__resource_labels => {
                            if !fields.insert(__FieldTag::__resource_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_labels",
                                ));
                            }
                            result.resource_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__sample_findings_table => {
                            if !fields.insert(__FieldTag::__sample_findings_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_findings_table",
                                ));
                            }
                            result.sample_findings_table = map
                                .next_value::<std::option::Option<crate::model::BigQueryTable>>()?;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__related_resources => {
                            if !fields.insert(__FieldTag::__related_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_resources",
                                ));
                            }
                            result.related_resources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RelatedResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableDataProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.data_source_type.is_some() {
            state.serialize_entry("dataSourceType", &self.data_source_type)?;
        }
        if !self.project_data_profile.is_empty() {
            state.serialize_entry("projectDataProfile", &self.project_data_profile)?;
        }
        if !self.dataset_project_id.is_empty() {
            state.serialize_entry("datasetProjectId", &self.dataset_project_id)?;
        }
        if !self.dataset_location.is_empty() {
            state.serialize_entry("datasetLocation", &self.dataset_location)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.full_resource.is_empty() {
            state.serialize_entry("fullResource", &self.full_resource)?;
        }
        if self.profile_status.is_some() {
            state.serialize_entry("profileStatus", &self.profile_status)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.sensitivity_score.is_some() {
            state.serialize_entry("sensitivityScore", &self.sensitivity_score)?;
        }
        if self.data_risk_level.is_some() {
            state.serialize_entry("dataRiskLevel", &self.data_risk_level)?;
        }
        if !self.predicted_info_types.is_empty() {
            state.serialize_entry("predictedInfoTypes", &self.predicted_info_types)?;
        }
        if !self.other_info_types.is_empty() {
            state.serialize_entry("otherInfoTypes", &self.other_info_types)?;
        }
        if self.config_snapshot.is_some() {
            state.serialize_entry("configSnapshot", &self.config_snapshot)?;
        }
        if self.last_modified_time.is_some() {
            state.serialize_entry("lastModifiedTime", &self.last_modified_time)?;
        }
        if self.expiration_time.is_some() {
            state.serialize_entry("expirationTime", &self.expiration_time)?;
        }
        if !wkt::internal::is_default(&self.scanned_column_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scannedColumnCount", &__With(&self.scanned_column_count))?;
        }
        if !wkt::internal::is_default(&self.failed_column_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedColumnCount", &__With(&self.failed_column_count))?;
        }
        if !wkt::internal::is_default(&self.table_size_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("tableSizeBytes", &__With(&self.table_size_bytes))?;
        }
        if !wkt::internal::is_default(&self.row_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rowCount", &__With(&self.row_count))?;
        }
        if !wkt::internal::is_default(&self.encryption_status) {
            state.serialize_entry("encryptionStatus", &self.encryption_status)?;
        }
        if !wkt::internal::is_default(&self.resource_visibility) {
            state.serialize_entry("resourceVisibility", &self.resource_visibility)?;
        }
        if self.profile_last_generated.is_some() {
            state.serialize_entry("profileLastGenerated", &self.profile_last_generated)?;
        }
        if !self.resource_labels.is_empty() {
            state.serialize_entry("resourceLabels", &self.resource_labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.sample_findings_table.is_some() {
            state.serialize_entry("sampleFindingsTable", &self.sample_findings_table)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.related_resources.is_empty() {
            state.serialize_entry("relatedResources", &self.related_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TableDataProfile].
pub mod table_data_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a profile. New items may be added.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unspecified,
        /// The profile is currently running. Once a profile has finished it will
        /// transition to DONE.
        Running,
        /// The profile is no longer generating.
        /// If profile_status.status.code is 0, the profile succeeded, otherwise, it
        /// failed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Done => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Done => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.privacy.dlp.v2.TableDataProfile.State",
            ))
        }
    }
}

/// Success or errors for the profile generation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ProfileStatus {
    /// Profiling status code and optional message. The `status.code` value is 0
    /// (default value) for OK.
    pub status: std::option::Option<rpc::model::Status>,

    /// Time when the profile generation status was updated
    pub timestamp: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProfileStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::ProfileStatus::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::ProfileStatus::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timestamp][crate::model::ProfileStatus::timestamp].
    pub fn set_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timestamp][crate::model::ProfileStatus::timestamp].
    pub fn set_or_clear_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ProfileStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ProfileStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProfileStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __status,
            __timestamp,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProfileStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "status" => Ok(__FieldTag::__status),
                            "timestamp" => Ok(__FieldTag::__timestamp),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProfileStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProfileStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__timestamp => {
                            if !fields.insert(__FieldTag::__timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp",
                                ));
                            }
                            result.timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProfileStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.timestamp.is_some() {
            state.serialize_entry("timestamp", &self.timestamp)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The infoType details for this column.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InfoTypeSummary {
    /// The infoType.
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Not populated for predicted infotypes.
    #[deprecated]
    pub estimated_prevalence: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoTypeSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::InfoTypeSummary::info_type].
    pub fn set_info_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [info_type][crate::model::InfoTypeSummary::info_type].
    pub fn set_or_clear_info_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [estimated_prevalence][crate::model::InfoTypeSummary::estimated_prevalence].
    #[deprecated]
    pub fn set_estimated_prevalence<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.estimated_prevalence = v.into();
        self
    }
}

impl wkt::message::Message for InfoTypeSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeSummary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InfoTypeSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_type,
            __estimated_prevalence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InfoTypeSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            "estimatedPrevalence" => Ok(__FieldTag::__estimated_prevalence),
                            "estimated_prevalence" => Ok(__FieldTag::__estimated_prevalence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InfoTypeSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InfoTypeSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type",
                                ));
                            }
                            result.info_type =
                                map.next_value::<std::option::Option<crate::model::InfoType>>()?;
                        }
                        __FieldTag::__estimated_prevalence => {
                            if !fields.insert(__FieldTag::__estimated_prevalence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_prevalence",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.estimated_prevalence =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InfoTypeSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.info_type.is_some() {
            state.serialize_entry("infoType", &self.info_type)?;
        }
        if !wkt::internal::is_default(&self.estimated_prevalence) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("estimatedPrevalence", &__With(&self.estimated_prevalence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Infotype details for other infoTypes found within a column.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OtherInfoTypeSummary {
    /// The other infoType.
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Approximate percentage of non-null rows that contained data detected by
    /// this infotype.
    pub estimated_prevalence: i32,

    /// Whether this infoType was excluded from sensitivity and risk analysis due
    /// to factors such as low prevalence (subject to change).
    pub excluded_from_analysis: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherInfoTypeSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::OtherInfoTypeSummary::info_type].
    pub fn set_info_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [info_type][crate::model::OtherInfoTypeSummary::info_type].
    pub fn set_or_clear_info_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [estimated_prevalence][crate::model::OtherInfoTypeSummary::estimated_prevalence].
    pub fn set_estimated_prevalence<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.estimated_prevalence = v.into();
        self
    }

    /// Sets the value of [excluded_from_analysis][crate::model::OtherInfoTypeSummary::excluded_from_analysis].
    pub fn set_excluded_from_analysis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.excluded_from_analysis = v.into();
        self
    }
}

impl wkt::message::Message for OtherInfoTypeSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherInfoTypeSummary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OtherInfoTypeSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_type,
            __estimated_prevalence,
            __excluded_from_analysis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OtherInfoTypeSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            "estimatedPrevalence" => Ok(__FieldTag::__estimated_prevalence),
                            "estimated_prevalence" => Ok(__FieldTag::__estimated_prevalence),
                            "excludedFromAnalysis" => Ok(__FieldTag::__excluded_from_analysis),
                            "excluded_from_analysis" => Ok(__FieldTag::__excluded_from_analysis),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OtherInfoTypeSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OtherInfoTypeSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type",
                                ));
                            }
                            result.info_type =
                                map.next_value::<std::option::Option<crate::model::InfoType>>()?;
                        }
                        __FieldTag::__estimated_prevalence => {
                            if !fields.insert(__FieldTag::__estimated_prevalence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_prevalence",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.estimated_prevalence =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__excluded_from_analysis => {
                            if !fields.insert(__FieldTag::__excluded_from_analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excluded_from_analysis",
                                ));
                            }
                            result.excluded_from_analysis = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OtherInfoTypeSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.info_type.is_some() {
            state.serialize_entry("infoType", &self.info_type)?;
        }
        if !wkt::internal::is_default(&self.estimated_prevalence) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("estimatedPrevalence", &__With(&self.estimated_prevalence))?;
        }
        if !wkt::internal::is_default(&self.excluded_from_analysis) {
            state.serialize_entry("excludedFromAnalysis", &self.excluded_from_analysis)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The profile for a scanned column within a table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ColumnDataProfile {
    /// The name of the profile.
    pub name: std::string::String,

    /// Success or error status from the most recent profile generation attempt.
    /// May be empty if the profile is still being generated.
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// State of a profile.
    pub state: crate::model::column_data_profile::State,

    /// The last time the profile was generated.
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// The resource name of the table data profile.
    pub table_data_profile: std::string::String,

    /// The resource name of the resource this column is within.
    pub table_full_resource: std::string::String,

    /// The Google Cloud project ID that owns the profiled resource.
    pub dataset_project_id: std::string::String,

    /// If supported, the location where the dataset's data is stored.
    /// See <https://cloud.google.com/bigquery/docs/locations> for supported
    /// BigQuery locations.
    pub dataset_location: std::string::String,

    /// The BigQuery dataset ID, if the resource profiled is a BigQuery table.
    pub dataset_id: std::string::String,

    /// The table ID.
    pub table_id: std::string::String,

    /// The name of the column.
    pub column: std::string::String,

    /// The sensitivity of this column.
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level for this column.
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// If it's been determined this column can be identified as a single type,
    /// this will be set. Otherwise the column either has unidentifiable content
    /// or mixed types.
    pub column_info_type: std::option::Option<crate::model::InfoTypeSummary>,

    /// Other types found within this column. List will be unordered.
    pub other_matches: std::vec::Vec<crate::model::OtherInfoTypeSummary>,

    /// Approximate percentage of entries being null in the column.
    pub estimated_null_percentage: crate::model::NullPercentageLevel,

    /// Approximate uniqueness of the column.
    pub estimated_uniqueness_score: crate::model::UniquenessScoreLevel,

    /// The likelihood that this column contains free-form text.
    /// A value close to 1 may indicate the column is likely to contain
    /// free-form or natural language text.
    /// Range in 0-1.
    pub free_text_score: f64,

    /// The data type of a given column.
    pub column_type: crate::model::column_data_profile::ColumnDataType,

    /// Indicates if a policy tag has been applied to the column.
    pub policy_state: crate::model::column_data_profile::ColumnPolicyState,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColumnDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ColumnDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [profile_status][crate::model::ColumnDataProfile::profile_status].
    pub fn set_profile_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProfileStatus>,
    {
        self.profile_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [profile_status][crate::model::ColumnDataProfile::profile_status].
    pub fn set_or_clear_profile_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProfileStatus>,
    {
        self.profile_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ColumnDataProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::column_data_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::ColumnDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.profile_last_generated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [profile_last_generated][crate::model::ColumnDataProfile::profile_last_generated].
    pub fn set_or_clear_profile_last_generated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.profile_last_generated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [table_data_profile][crate::model::ColumnDataProfile::table_data_profile].
    pub fn set_table_data_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.table_data_profile = v.into();
        self
    }

    /// Sets the value of [table_full_resource][crate::model::ColumnDataProfile::table_full_resource].
    pub fn set_table_full_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.table_full_resource = v.into();
        self
    }

    /// Sets the value of [dataset_project_id][crate::model::ColumnDataProfile::dataset_project_id].
    pub fn set_dataset_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_project_id = v.into();
        self
    }

    /// Sets the value of [dataset_location][crate::model::ColumnDataProfile::dataset_location].
    pub fn set_dataset_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_location = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ColumnDataProfile::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::ColumnDataProfile::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [column][crate::model::ColumnDataProfile::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::ColumnDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sensitivity_score][crate::model::ColumnDataProfile::sensitivity_score].
    pub fn set_or_clear_sensitivity_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_risk_level][crate::model::ColumnDataProfile::data_risk_level].
    pub fn set_data_risk_level<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataRiskLevel>,
    {
        self.data_risk_level = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_risk_level][crate::model::ColumnDataProfile::data_risk_level].
    pub fn set_or_clear_data_risk_level<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataRiskLevel>,
    {
        self.data_risk_level = v.map(|x| x.into());
        self
    }

    /// Sets the value of [column_info_type][crate::model::ColumnDataProfile::column_info_type].
    pub fn set_column_info_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoTypeSummary>,
    {
        self.column_info_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [column_info_type][crate::model::ColumnDataProfile::column_info_type].
    pub fn set_or_clear_column_info_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoTypeSummary>,
    {
        self.column_info_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [other_matches][crate::model::ColumnDataProfile::other_matches].
    pub fn set_other_matches<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OtherInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.other_matches = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [estimated_null_percentage][crate::model::ColumnDataProfile::estimated_null_percentage].
    pub fn set_estimated_null_percentage<
        T: std::convert::Into<crate::model::NullPercentageLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.estimated_null_percentage = v.into();
        self
    }

    /// Sets the value of [estimated_uniqueness_score][crate::model::ColumnDataProfile::estimated_uniqueness_score].
    pub fn set_estimated_uniqueness_score<
        T: std::convert::Into<crate::model::UniquenessScoreLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.estimated_uniqueness_score = v.into();
        self
    }

    /// Sets the value of [free_text_score][crate::model::ColumnDataProfile::free_text_score].
    pub fn set_free_text_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.free_text_score = v.into();
        self
    }

    /// Sets the value of [column_type][crate::model::ColumnDataProfile::column_type].
    pub fn set_column_type<
        T: std::convert::Into<crate::model::column_data_profile::ColumnDataType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.column_type = v.into();
        self
    }

    /// Sets the value of [policy_state][crate::model::ColumnDataProfile::policy_state].
    pub fn set_policy_state<
        T: std::convert::Into<crate::model::column_data_profile::ColumnPolicyState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy_state = v.into();
        self
    }
}

impl wkt::message::Message for ColumnDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ColumnDataProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ColumnDataProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __profile_status,
            __state,
            __profile_last_generated,
            __table_data_profile,
            __table_full_resource,
            __dataset_project_id,
            __dataset_location,
            __dataset_id,
            __table_id,
            __column,
            __sensitivity_score,
            __data_risk_level,
            __column_info_type,
            __other_matches,
            __estimated_null_percentage,
            __estimated_uniqueness_score,
            __free_text_score,
            __column_type,
            __policy_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColumnDataProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "profileStatus" => Ok(__FieldTag::__profile_status),
                            "profile_status" => Ok(__FieldTag::__profile_status),
                            "state" => Ok(__FieldTag::__state),
                            "profileLastGenerated" => Ok(__FieldTag::__profile_last_generated),
                            "profile_last_generated" => Ok(__FieldTag::__profile_last_generated),
                            "tableDataProfile" => Ok(__FieldTag::__table_data_profile),
                            "table_data_profile" => Ok(__FieldTag::__table_data_profile),
                            "tableFullResource" => Ok(__FieldTag::__table_full_resource),
                            "table_full_resource" => Ok(__FieldTag::__table_full_resource),
                            "datasetProjectId" => Ok(__FieldTag::__dataset_project_id),
                            "dataset_project_id" => Ok(__FieldTag::__dataset_project_id),
                            "datasetLocation" => Ok(__FieldTag::__dataset_location),
                            "dataset_location" => Ok(__FieldTag::__dataset_location),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "column" => Ok(__FieldTag::__column),
                            "sensitivityScore" => Ok(__FieldTag::__sensitivity_score),
                            "sensitivity_score" => Ok(__FieldTag::__sensitivity_score),
                            "dataRiskLevel" => Ok(__FieldTag::__data_risk_level),
                            "data_risk_level" => Ok(__FieldTag::__data_risk_level),
                            "columnInfoType" => Ok(__FieldTag::__column_info_type),
                            "column_info_type" => Ok(__FieldTag::__column_info_type),
                            "otherMatches" => Ok(__FieldTag::__other_matches),
                            "other_matches" => Ok(__FieldTag::__other_matches),
                            "estimatedNullPercentage" => {
                                Ok(__FieldTag::__estimated_null_percentage)
                            }
                            "estimated_null_percentage" => {
                                Ok(__FieldTag::__estimated_null_percentage)
                            }
                            "estimatedUniquenessScore" => {
                                Ok(__FieldTag::__estimated_uniqueness_score)
                            }
                            "estimated_uniqueness_score" => {
                                Ok(__FieldTag::__estimated_uniqueness_score)
                            }
                            "freeTextScore" => Ok(__FieldTag::__free_text_score),
                            "free_text_score" => Ok(__FieldTag::__free_text_score),
                            "columnType" => Ok(__FieldTag::__column_type),
                            "column_type" => Ok(__FieldTag::__column_type),
                            "policyState" => Ok(__FieldTag::__policy_state),
                            "policy_state" => Ok(__FieldTag::__policy_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ColumnDataProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColumnDataProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__profile_status => {
                            if !fields.insert(__FieldTag::__profile_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile_status",
                                ));
                            }
                            result.profile_status = map
                                .next_value::<std::option::Option<crate::model::ProfileStatus>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::column_data_profile::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__profile_last_generated => {
                            if !fields.insert(__FieldTag::__profile_last_generated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile_last_generated",
                                ));
                            }
                            result.profile_last_generated =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__table_data_profile => {
                            if !fields.insert(__FieldTag::__table_data_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_data_profile",
                                ));
                            }
                            result.table_data_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_full_resource => {
                            if !fields.insert(__FieldTag::__table_full_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_full_resource",
                                ));
                            }
                            result.table_full_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_project_id => {
                            if !fields.insert(__FieldTag::__dataset_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_project_id",
                                ));
                            }
                            result.dataset_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_location => {
                            if !fields.insert(__FieldTag::__dataset_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_location",
                                ));
                            }
                            result.dataset_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            result.column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sensitivity_score => {
                            if !fields.insert(__FieldTag::__sensitivity_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sensitivity_score",
                                ));
                            }
                            result.sensitivity_score = map
                                .next_value::<std::option::Option<crate::model::SensitivityScore>>(
                                )?;
                        }
                        __FieldTag::__data_risk_level => {
                            if !fields.insert(__FieldTag::__data_risk_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_risk_level",
                                ));
                            }
                            result.data_risk_level = map
                                .next_value::<std::option::Option<crate::model::DataRiskLevel>>()?;
                        }
                        __FieldTag::__column_info_type => {
                            if !fields.insert(__FieldTag::__column_info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_info_type",
                                ));
                            }
                            result.column_info_type = map
                                .next_value::<std::option::Option<crate::model::InfoTypeSummary>>(
                                )?;
                        }
                        __FieldTag::__other_matches => {
                            if !fields.insert(__FieldTag::__other_matches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for other_matches",
                                ));
                            }
                            result.other_matches = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OtherInfoTypeSummary>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__estimated_null_percentage => {
                            if !fields.insert(__FieldTag::__estimated_null_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_null_percentage",
                                ));
                            }
                            result.estimated_null_percentage = map.next_value::<std::option::Option<crate::model::NullPercentageLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__estimated_uniqueness_score => {
                            if !fields.insert(__FieldTag::__estimated_uniqueness_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_uniqueness_score",
                                ));
                            }
                            result.estimated_uniqueness_score = map.next_value::<std::option::Option<crate::model::UniquenessScoreLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__free_text_score => {
                            if !fields.insert(__FieldTag::__free_text_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for free_text_score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.free_text_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__column_type => {
                            if !fields.insert(__FieldTag::__column_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_type",
                                ));
                            }
                            result.column_type = map
                                .next_value::<std::option::Option<
                                    crate::model::column_data_profile::ColumnDataType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_state => {
                            if !fields.insert(__FieldTag::__policy_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_state",
                                ));
                            }
                            result.policy_state = map
                                .next_value::<std::option::Option<
                                    crate::model::column_data_profile::ColumnPolicyState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ColumnDataProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.profile_status.is_some() {
            state.serialize_entry("profileStatus", &self.profile_status)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.profile_last_generated.is_some() {
            state.serialize_entry("profileLastGenerated", &self.profile_last_generated)?;
        }
        if !self.table_data_profile.is_empty() {
            state.serialize_entry("tableDataProfile", &self.table_data_profile)?;
        }
        if !self.table_full_resource.is_empty() {
            state.serialize_entry("tableFullResource", &self.table_full_resource)?;
        }
        if !self.dataset_project_id.is_empty() {
            state.serialize_entry("datasetProjectId", &self.dataset_project_id)?;
        }
        if !self.dataset_location.is_empty() {
            state.serialize_entry("datasetLocation", &self.dataset_location)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.column.is_empty() {
            state.serialize_entry("column", &self.column)?;
        }
        if self.sensitivity_score.is_some() {
            state.serialize_entry("sensitivityScore", &self.sensitivity_score)?;
        }
        if self.data_risk_level.is_some() {
            state.serialize_entry("dataRiskLevel", &self.data_risk_level)?;
        }
        if self.column_info_type.is_some() {
            state.serialize_entry("columnInfoType", &self.column_info_type)?;
        }
        if !self.other_matches.is_empty() {
            state.serialize_entry("otherMatches", &self.other_matches)?;
        }
        if !wkt::internal::is_default(&self.estimated_null_percentage) {
            state.serialize_entry("estimatedNullPercentage", &self.estimated_null_percentage)?;
        }
        if !wkt::internal::is_default(&self.estimated_uniqueness_score) {
            state.serialize_entry("estimatedUniquenessScore", &self.estimated_uniqueness_score)?;
        }
        if !wkt::internal::is_default(&self.free_text_score) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("freeTextScore", &__With(&self.free_text_score))?;
        }
        if !wkt::internal::is_default(&self.column_type) {
            state.serialize_entry("columnType", &self.column_type)?;
        }
        if !wkt::internal::is_default(&self.policy_state) {
            state.serialize_entry("policyState", &self.policy_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ColumnDataProfile].
pub mod column_data_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a profile. New items may be added.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unspecified,
        /// The profile is currently running. Once a profile has finished it will
        /// transition to DONE.
        Running,
        /// The profile is no longer generating.
        /// If profile_status.status.code is 0, the profile succeeded, otherwise, it
        /// failed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Done => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Done => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.privacy.dlp.v2.ColumnDataProfile.State",
            ))
        }
    }

    /// Data types of the data in a column. Types may be added over time.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ColumnDataType {
        /// Invalid type.
        Unspecified,
        /// Encoded as a string in decimal format.
        TypeInt64,
        /// Encoded as a boolean "false" or "true".
        TypeBool,
        /// Encoded as a number, or string "NaN", "Infinity" or "-Infinity".
        TypeFloat64,
        /// Encoded as a string value.
        TypeString,
        /// Encoded as a base64 string per RFC 4648, section 4.
        TypeBytes,
        /// Encoded as an RFC 3339 timestamp with mandatory "Z" time zone string:
        /// 1985-04-12T23:20:50.52Z
        TypeTimestamp,
        /// Encoded as RFC 3339 full-date format string: 1985-04-12
        TypeDate,
        /// Encoded as RFC 3339 partial-time format string: 23:20:50.52
        TypeTime,
        /// Encoded as RFC 3339 full-date "T" partial-time: 1985-04-12T23:20:50.52
        TypeDatetime,
        /// Encoded as WKT
        TypeGeography,
        /// Encoded as a decimal string.
        TypeNumeric,
        /// Container of ordered fields, each with a type and field name.
        TypeRecord,
        /// Decimal type.
        TypeBignumeric,
        /// Json type.
        TypeJson,
        /// Interval type.
        TypeInterval,
        /// `Range<Date>` type.
        TypeRangeDate,
        /// `Range<Datetime>` type.
        TypeRangeDatetime,
        /// `Range<Timestamp>` type.
        TypeRangeTimestamp,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ColumnDataType::value] or
        /// [ColumnDataType::name].
        UnknownValue(column_data_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod column_data_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ColumnDataType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TypeInt64 => std::option::Option::Some(1),
                Self::TypeBool => std::option::Option::Some(2),
                Self::TypeFloat64 => std::option::Option::Some(3),
                Self::TypeString => std::option::Option::Some(4),
                Self::TypeBytes => std::option::Option::Some(5),
                Self::TypeTimestamp => std::option::Option::Some(6),
                Self::TypeDate => std::option::Option::Some(7),
                Self::TypeTime => std::option::Option::Some(8),
                Self::TypeDatetime => std::option::Option::Some(9),
                Self::TypeGeography => std::option::Option::Some(10),
                Self::TypeNumeric => std::option::Option::Some(11),
                Self::TypeRecord => std::option::Option::Some(12),
                Self::TypeBignumeric => std::option::Option::Some(13),
                Self::TypeJson => std::option::Option::Some(14),
                Self::TypeInterval => std::option::Option::Some(15),
                Self::TypeRangeDate => std::option::Option::Some(16),
                Self::TypeRangeDatetime => std::option::Option::Some(17),
                Self::TypeRangeTimestamp => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COLUMN_DATA_TYPE_UNSPECIFIED"),
                Self::TypeInt64 => std::option::Option::Some("TYPE_INT64"),
                Self::TypeBool => std::option::Option::Some("TYPE_BOOL"),
                Self::TypeFloat64 => std::option::Option::Some("TYPE_FLOAT64"),
                Self::TypeString => std::option::Option::Some("TYPE_STRING"),
                Self::TypeBytes => std::option::Option::Some("TYPE_BYTES"),
                Self::TypeTimestamp => std::option::Option::Some("TYPE_TIMESTAMP"),
                Self::TypeDate => std::option::Option::Some("TYPE_DATE"),
                Self::TypeTime => std::option::Option::Some("TYPE_TIME"),
                Self::TypeDatetime => std::option::Option::Some("TYPE_DATETIME"),
                Self::TypeGeography => std::option::Option::Some("TYPE_GEOGRAPHY"),
                Self::TypeNumeric => std::option::Option::Some("TYPE_NUMERIC"),
                Self::TypeRecord => std::option::Option::Some("TYPE_RECORD"),
                Self::TypeBignumeric => std::option::Option::Some("TYPE_BIGNUMERIC"),
                Self::TypeJson => std::option::Option::Some("TYPE_JSON"),
                Self::TypeInterval => std::option::Option::Some("TYPE_INTERVAL"),
                Self::TypeRangeDate => std::option::Option::Some("TYPE_RANGE_DATE"),
                Self::TypeRangeDatetime => std::option::Option::Some("TYPE_RANGE_DATETIME"),
                Self::TypeRangeTimestamp => std::option::Option::Some("TYPE_RANGE_TIMESTAMP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ColumnDataType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ColumnDataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ColumnDataType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TypeInt64,
                2 => Self::TypeBool,
                3 => Self::TypeFloat64,
                4 => Self::TypeString,
                5 => Self::TypeBytes,
                6 => Self::TypeTimestamp,
                7 => Self::TypeDate,
                8 => Self::TypeTime,
                9 => Self::TypeDatetime,
                10 => Self::TypeGeography,
                11 => Self::TypeNumeric,
                12 => Self::TypeRecord,
                13 => Self::TypeBignumeric,
                14 => Self::TypeJson,
                15 => Self::TypeInterval,
                16 => Self::TypeRangeDate,
                17 => Self::TypeRangeDatetime,
                18 => Self::TypeRangeTimestamp,
                _ => Self::UnknownValue(column_data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ColumnDataType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COLUMN_DATA_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TYPE_INT64" => Self::TypeInt64,
                "TYPE_BOOL" => Self::TypeBool,
                "TYPE_FLOAT64" => Self::TypeFloat64,
                "TYPE_STRING" => Self::TypeString,
                "TYPE_BYTES" => Self::TypeBytes,
                "TYPE_TIMESTAMP" => Self::TypeTimestamp,
                "TYPE_DATE" => Self::TypeDate,
                "TYPE_TIME" => Self::TypeTime,
                "TYPE_DATETIME" => Self::TypeDatetime,
                "TYPE_GEOGRAPHY" => Self::TypeGeography,
                "TYPE_NUMERIC" => Self::TypeNumeric,
                "TYPE_RECORD" => Self::TypeRecord,
                "TYPE_BIGNUMERIC" => Self::TypeBignumeric,
                "TYPE_JSON" => Self::TypeJson,
                "TYPE_INTERVAL" => Self::TypeInterval,
                "TYPE_RANGE_DATE" => Self::TypeRangeDate,
                "TYPE_RANGE_DATETIME" => Self::TypeRangeDatetime,
                "TYPE_RANGE_TIMESTAMP" => Self::TypeRangeTimestamp,
                _ => Self::UnknownValue(column_data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ColumnDataType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TypeInt64 => serializer.serialize_i32(1),
                Self::TypeBool => serializer.serialize_i32(2),
                Self::TypeFloat64 => serializer.serialize_i32(3),
                Self::TypeString => serializer.serialize_i32(4),
                Self::TypeBytes => serializer.serialize_i32(5),
                Self::TypeTimestamp => serializer.serialize_i32(6),
                Self::TypeDate => serializer.serialize_i32(7),
                Self::TypeTime => serializer.serialize_i32(8),
                Self::TypeDatetime => serializer.serialize_i32(9),
                Self::TypeGeography => serializer.serialize_i32(10),
                Self::TypeNumeric => serializer.serialize_i32(11),
                Self::TypeRecord => serializer.serialize_i32(12),
                Self::TypeBignumeric => serializer.serialize_i32(13),
                Self::TypeJson => serializer.serialize_i32(14),
                Self::TypeInterval => serializer.serialize_i32(15),
                Self::TypeRangeDate => serializer.serialize_i32(16),
                Self::TypeRangeDatetime => serializer.serialize_i32(17),
                Self::TypeRangeTimestamp => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ColumnDataType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ColumnDataType>::new(
                ".google.privacy.dlp.v2.ColumnDataProfile.ColumnDataType",
            ))
        }
    }

    /// The possible policy states for a column.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ColumnPolicyState {
        /// No policy tags.
        Unspecified,
        /// Column has policy tag applied.
        ColumnPolicyTagged,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ColumnPolicyState::value] or
        /// [ColumnPolicyState::name].
        UnknownValue(column_policy_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod column_policy_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ColumnPolicyState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ColumnPolicyTagged => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COLUMN_POLICY_STATE_UNSPECIFIED"),
                Self::ColumnPolicyTagged => std::option::Option::Some("COLUMN_POLICY_TAGGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ColumnPolicyState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ColumnPolicyState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ColumnPolicyState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ColumnPolicyTagged,
                _ => Self::UnknownValue(column_policy_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ColumnPolicyState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COLUMN_POLICY_STATE_UNSPECIFIED" => Self::Unspecified,
                "COLUMN_POLICY_TAGGED" => Self::ColumnPolicyTagged,
                _ => Self::UnknownValue(column_policy_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ColumnPolicyState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ColumnPolicyTagged => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ColumnPolicyState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ColumnPolicyState>::new(
                ".google.privacy.dlp.v2.ColumnDataProfile.ColumnPolicyState",
            ))
        }
    }
}

/// The profile for a file store.
///
/// * Cloud Storage: maps 1:1 with a bucket.
/// * Amazon S3: maps 1:1 with a bucket.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileStoreDataProfile {
    /// The name of the profile.
    pub name: std::string::String,

    /// The resource type that was profiled.
    pub data_source_type: std::option::Option<crate::model::DataSourceType>,

    /// The resource name of the project data profile for this file store.
    pub project_data_profile: std::string::String,

    /// The Google Cloud project ID that owns the resource.
    /// For Amazon S3 buckets, this is the AWS Account Id.
    pub project_id: std::string::String,

    /// The location of the file store.
    ///
    /// * Cloud Storage:
    ///   <https://cloud.google.com/storage/docs/locations#available-locations>
    /// * Amazon S3:
    ///   <https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints>
    pub file_store_location: std::string::String,

    /// For resources that have multiple storage locations, these are those
    /// regions. For Cloud Storage this is the list of regions chosen for
    /// dual-region storage. `file_store_location` will normally be the
    /// corresponding multi-region for the list of individual locations. The first
    /// region is always picked as the processing and storage location for the data
    /// profile.
    pub data_storage_locations: std::vec::Vec<std::string::String>,

    /// The location type of the file store (region, dual-region, multi-region,
    /// etc). If dual-region, expect data_storage_locations to be populated.
    pub location_type: std::string::String,

    /// The file store path.
    ///
    /// * Cloud Storage: `gs://{bucket}`
    /// * Amazon S3: `s3://{bucket}`
    /// * Vertex AI dataset:
    ///   `projects/{project_number}/locations/{location}/datasets/{dataset_id}`
    pub file_store_path: std::string::String,

    /// The resource name of the resource profiled.
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    ///
    /// Example format of an S3 bucket full resource name:
    /// `//cloudasset.googleapis.com/organizations/{org_id}/otherCloudConnections/aws/arn:aws:s3:::{bucket_name}`
    pub full_resource: std::string::String,

    /// The snapshot of the configurations used to generate the profile.
    pub config_snapshot: std::option::Option<crate::model::DataProfileConfigSnapshot>,

    /// Success or error status from the most recent profile generation attempt.
    /// May be empty if the profile is still being generated.
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// State of a profile.
    pub state: crate::model::file_store_data_profile::State,

    /// The last time the profile was generated.
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// How broadly a resource has been shared.
    pub resource_visibility: crate::model::ResourceVisibility,

    /// The sensitivity score of this resource.
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this resource.
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// The time the file store was first created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the file store was last modified.
    pub last_modified_time: std::option::Option<wkt::Timestamp>,

    /// FileClusterSummary per each cluster.
    pub file_cluster_summaries: std::vec::Vec<crate::model::FileClusterSummary>,

    /// Attributes of the resource being profiled.
    /// Currently used attributes:
    ///
    /// * customer_managed_encryption: boolean
    ///   - true: the resource is encrypted with a customer-managed key.
    ///   - false: the resource is encrypted with a provider-managed key.
    pub resource_attributes: std::collections::HashMap<std::string::String, crate::model::Value>,

    /// The labels applied to the resource at the time the profile was generated.
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// InfoTypes detected in this file store.
    pub file_store_info_type_summaries: std::vec::Vec<crate::model::FileStoreInfoTypeSummary>,

    /// The BigQuery table to which the sample findings are written.
    pub sample_findings_table: std::option::Option<crate::model::BigQueryTable>,

    /// The file store does not have any files. If the profiling operation failed,
    /// this is false.
    pub file_store_is_empty: bool,

    /// The tags attached to the resource, including any tags attached during
    /// profiling.
    pub tags: std::vec::Vec<crate::model::Tag>,

    /// Resources related to this profile.
    pub related_resources: std::vec::Vec<crate::model::RelatedResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileStoreDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FileStoreDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_source_type][crate::model::FileStoreDataProfile::data_source_type].
    pub fn set_data_source_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataSourceType>,
    {
        self.data_source_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_source_type][crate::model::FileStoreDataProfile::data_source_type].
    pub fn set_or_clear_data_source_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataSourceType>,
    {
        self.data_source_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [project_data_profile][crate::model::FileStoreDataProfile::project_data_profile].
    pub fn set_project_data_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_data_profile = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::FileStoreDataProfile::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [file_store_location][crate::model::FileStoreDataProfile::file_store_location].
    pub fn set_file_store_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_store_location = v.into();
        self
    }

    /// Sets the value of [data_storage_locations][crate::model::FileStoreDataProfile::data_storage_locations].
    pub fn set_data_storage_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_storage_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [location_type][crate::model::FileStoreDataProfile::location_type].
    pub fn set_location_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_type = v.into();
        self
    }

    /// Sets the value of [file_store_path][crate::model::FileStoreDataProfile::file_store_path].
    pub fn set_file_store_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_store_path = v.into();
        self
    }

    /// Sets the value of [full_resource][crate::model::FileStoreDataProfile::full_resource].
    pub fn set_full_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_resource = v.into();
        self
    }

    /// Sets the value of [config_snapshot][crate::model::FileStoreDataProfile::config_snapshot].
    pub fn set_config_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataProfileConfigSnapshot>,
    {
        self.config_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_snapshot][crate::model::FileStoreDataProfile::config_snapshot].
    pub fn set_or_clear_config_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataProfileConfigSnapshot>,
    {
        self.config_snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [profile_status][crate::model::FileStoreDataProfile::profile_status].
    pub fn set_profile_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProfileStatus>,
    {
        self.profile_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [profile_status][crate::model::FileStoreDataProfile::profile_status].
    pub fn set_or_clear_profile_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProfileStatus>,
    {
        self.profile_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::FileStoreDataProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::file_store_data_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::FileStoreDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.profile_last_generated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [profile_last_generated][crate::model::FileStoreDataProfile::profile_last_generated].
    pub fn set_or_clear_profile_last_generated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.profile_last_generated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_visibility][crate::model::FileStoreDataProfile::resource_visibility].
    pub fn set_resource_visibility<T: std::convert::Into<crate::model::ResourceVisibility>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_visibility = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::FileStoreDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sensitivity_score][crate::model::FileStoreDataProfile::sensitivity_score].
    pub fn set_or_clear_sensitivity_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_risk_level][crate::model::FileStoreDataProfile::data_risk_level].
    pub fn set_data_risk_level<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataRiskLevel>,
    {
        self.data_risk_level = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_risk_level][crate::model::FileStoreDataProfile::data_risk_level].
    pub fn set_or_clear_data_risk_level<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataRiskLevel>,
    {
        self.data_risk_level = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::FileStoreDataProfile::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::FileStoreDataProfile::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_modified_time][crate::model::FileStoreDataProfile::last_modified_time].
    pub fn set_last_modified_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_modified_time][crate::model::FileStoreDataProfile::last_modified_time].
    pub fn set_or_clear_last_modified_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_cluster_summaries][crate::model::FileStoreDataProfile::file_cluster_summaries].
    pub fn set_file_cluster_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileClusterSummary>,
    {
        use std::iter::Iterator;
        self.file_cluster_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_attributes][crate::model::FileStoreDataProfile::resource_attributes].
    pub fn set_resource_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Value>,
    {
        use std::iter::Iterator;
        self.resource_attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [resource_labels][crate::model::FileStoreDataProfile::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [file_store_info_type_summaries][crate::model::FileStoreDataProfile::file_store_info_type_summaries].
    pub fn set_file_store_info_type_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.file_store_info_type_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sample_findings_table][crate::model::FileStoreDataProfile::sample_findings_table].
    pub fn set_sample_findings_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.sample_findings_table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sample_findings_table][crate::model::FileStoreDataProfile::sample_findings_table].
    pub fn set_or_clear_sample_findings_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.sample_findings_table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_store_is_empty][crate::model::FileStoreDataProfile::file_store_is_empty].
    pub fn set_file_store_is_empty<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.file_store_is_empty = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::FileStoreDataProfile::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [related_resources][crate::model::FileStoreDataProfile::related_resources].
    pub fn set_related_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedResource>,
    {
        use std::iter::Iterator;
        self.related_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileStoreDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreDataProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileStoreDataProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data_source_type,
            __project_data_profile,
            __project_id,
            __file_store_location,
            __data_storage_locations,
            __location_type,
            __file_store_path,
            __full_resource,
            __config_snapshot,
            __profile_status,
            __state,
            __profile_last_generated,
            __resource_visibility,
            __sensitivity_score,
            __data_risk_level,
            __create_time,
            __last_modified_time,
            __file_cluster_summaries,
            __resource_attributes,
            __resource_labels,
            __file_store_info_type_summaries,
            __sample_findings_table,
            __file_store_is_empty,
            __tags,
            __related_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileStoreDataProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "dataSourceType" => Ok(__FieldTag::__data_source_type),
                            "data_source_type" => Ok(__FieldTag::__data_source_type),
                            "projectDataProfile" => Ok(__FieldTag::__project_data_profile),
                            "project_data_profile" => Ok(__FieldTag::__project_data_profile),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "fileStoreLocation" => Ok(__FieldTag::__file_store_location),
                            "file_store_location" => Ok(__FieldTag::__file_store_location),
                            "dataStorageLocations" => Ok(__FieldTag::__data_storage_locations),
                            "data_storage_locations" => Ok(__FieldTag::__data_storage_locations),
                            "locationType" => Ok(__FieldTag::__location_type),
                            "location_type" => Ok(__FieldTag::__location_type),
                            "fileStorePath" => Ok(__FieldTag::__file_store_path),
                            "file_store_path" => Ok(__FieldTag::__file_store_path),
                            "fullResource" => Ok(__FieldTag::__full_resource),
                            "full_resource" => Ok(__FieldTag::__full_resource),
                            "configSnapshot" => Ok(__FieldTag::__config_snapshot),
                            "config_snapshot" => Ok(__FieldTag::__config_snapshot),
                            "profileStatus" => Ok(__FieldTag::__profile_status),
                            "profile_status" => Ok(__FieldTag::__profile_status),
                            "state" => Ok(__FieldTag::__state),
                            "profileLastGenerated" => Ok(__FieldTag::__profile_last_generated),
                            "profile_last_generated" => Ok(__FieldTag::__profile_last_generated),
                            "resourceVisibility" => Ok(__FieldTag::__resource_visibility),
                            "resource_visibility" => Ok(__FieldTag::__resource_visibility),
                            "sensitivityScore" => Ok(__FieldTag::__sensitivity_score),
                            "sensitivity_score" => Ok(__FieldTag::__sensitivity_score),
                            "dataRiskLevel" => Ok(__FieldTag::__data_risk_level),
                            "data_risk_level" => Ok(__FieldTag::__data_risk_level),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "fileClusterSummaries" => Ok(__FieldTag::__file_cluster_summaries),
                            "file_cluster_summaries" => Ok(__FieldTag::__file_cluster_summaries),
                            "resourceAttributes" => Ok(__FieldTag::__resource_attributes),
                            "resource_attributes" => Ok(__FieldTag::__resource_attributes),
                            "resourceLabels" => Ok(__FieldTag::__resource_labels),
                            "resource_labels" => Ok(__FieldTag::__resource_labels),
                            "fileStoreInfoTypeSummaries" => {
                                Ok(__FieldTag::__file_store_info_type_summaries)
                            }
                            "file_store_info_type_summaries" => {
                                Ok(__FieldTag::__file_store_info_type_summaries)
                            }
                            "sampleFindingsTable" => Ok(__FieldTag::__sample_findings_table),
                            "sample_findings_table" => Ok(__FieldTag::__sample_findings_table),
                            "fileStoreIsEmpty" => Ok(__FieldTag::__file_store_is_empty),
                            "file_store_is_empty" => Ok(__FieldTag::__file_store_is_empty),
                            "tags" => Ok(__FieldTag::__tags),
                            "relatedResources" => Ok(__FieldTag::__related_resources),
                            "related_resources" => Ok(__FieldTag::__related_resources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileStoreDataProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileStoreDataProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source_type => {
                            if !fields.insert(__FieldTag::__data_source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_type",
                                ));
                            }
                            result.data_source_type = map
                                .next_value::<std::option::Option<crate::model::DataSourceType>>(
                                )?;
                        }
                        __FieldTag::__project_data_profile => {
                            if !fields.insert(__FieldTag::__project_data_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_data_profile",
                                ));
                            }
                            result.project_data_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_store_location => {
                            if !fields.insert(__FieldTag::__file_store_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_store_location",
                                ));
                            }
                            result.file_store_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_storage_locations => {
                            if !fields.insert(__FieldTag::__data_storage_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_storage_locations",
                                ));
                            }
                            result.data_storage_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__location_type => {
                            if !fields.insert(__FieldTag::__location_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_type",
                                ));
                            }
                            result.location_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_store_path => {
                            if !fields.insert(__FieldTag::__file_store_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_store_path",
                                ));
                            }
                            result.file_store_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__full_resource => {
                            if !fields.insert(__FieldTag::__full_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_resource",
                                ));
                            }
                            result.full_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_snapshot => {
                            if !fields.insert(__FieldTag::__config_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_snapshot",
                                ));
                            }
                            result.config_snapshot = map.next_value::<std::option::Option<crate::model::DataProfileConfigSnapshot>>()?
                                ;
                        }
                        __FieldTag::__profile_status => {
                            if !fields.insert(__FieldTag::__profile_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile_status",
                                ));
                            }
                            result.profile_status = map
                                .next_value::<std::option::Option<crate::model::ProfileStatus>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::file_store_data_profile::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__profile_last_generated => {
                            if !fields.insert(__FieldTag::__profile_last_generated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile_last_generated",
                                ));
                            }
                            result.profile_last_generated =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__resource_visibility => {
                            if !fields.insert(__FieldTag::__resource_visibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_visibility",
                                ));
                            }
                            result.resource_visibility = map.next_value::<std::option::Option<crate::model::ResourceVisibility>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sensitivity_score => {
                            if !fields.insert(__FieldTag::__sensitivity_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sensitivity_score",
                                ));
                            }
                            result.sensitivity_score = map
                                .next_value::<std::option::Option<crate::model::SensitivityScore>>(
                                )?;
                        }
                        __FieldTag::__data_risk_level => {
                            if !fields.insert(__FieldTag::__data_risk_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_risk_level",
                                ));
                            }
                            result.data_risk_level = map
                                .next_value::<std::option::Option<crate::model::DataRiskLevel>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            result.last_modified_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__file_cluster_summaries => {
                            if !fields.insert(__FieldTag::__file_cluster_summaries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_cluster_summaries",
                                ));
                            }
                            result.file_cluster_summaries = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FileClusterSummary>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_attributes => {
                            if !fields.insert(__FieldTag::__resource_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_attributes",
                                ));
                            }
                            result.resource_attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::Value,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_labels => {
                            if !fields.insert(__FieldTag::__resource_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_labels",
                                ));
                            }
                            result.resource_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_store_info_type_summaries => {
                            if !fields.insert(__FieldTag::__file_store_info_type_summaries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_store_info_type_summaries",
                                ));
                            }
                            result.file_store_info_type_summaries = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FileStoreInfoTypeSummary>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sample_findings_table => {
                            if !fields.insert(__FieldTag::__sample_findings_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_findings_table",
                                ));
                            }
                            result.sample_findings_table = map
                                .next_value::<std::option::Option<crate::model::BigQueryTable>>()?;
                        }
                        __FieldTag::__file_store_is_empty => {
                            if !fields.insert(__FieldTag::__file_store_is_empty) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_store_is_empty",
                                ));
                            }
                            result.file_store_is_empty = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__related_resources => {
                            if !fields.insert(__FieldTag::__related_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_resources",
                                ));
                            }
                            result.related_resources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RelatedResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileStoreDataProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.data_source_type.is_some() {
            state.serialize_entry("dataSourceType", &self.data_source_type)?;
        }
        if !self.project_data_profile.is_empty() {
            state.serialize_entry("projectDataProfile", &self.project_data_profile)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.file_store_location.is_empty() {
            state.serialize_entry("fileStoreLocation", &self.file_store_location)?;
        }
        if !self.data_storage_locations.is_empty() {
            state.serialize_entry("dataStorageLocations", &self.data_storage_locations)?;
        }
        if !self.location_type.is_empty() {
            state.serialize_entry("locationType", &self.location_type)?;
        }
        if !self.file_store_path.is_empty() {
            state.serialize_entry("fileStorePath", &self.file_store_path)?;
        }
        if !self.full_resource.is_empty() {
            state.serialize_entry("fullResource", &self.full_resource)?;
        }
        if self.config_snapshot.is_some() {
            state.serialize_entry("configSnapshot", &self.config_snapshot)?;
        }
        if self.profile_status.is_some() {
            state.serialize_entry("profileStatus", &self.profile_status)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.profile_last_generated.is_some() {
            state.serialize_entry("profileLastGenerated", &self.profile_last_generated)?;
        }
        if !wkt::internal::is_default(&self.resource_visibility) {
            state.serialize_entry("resourceVisibility", &self.resource_visibility)?;
        }
        if self.sensitivity_score.is_some() {
            state.serialize_entry("sensitivityScore", &self.sensitivity_score)?;
        }
        if self.data_risk_level.is_some() {
            state.serialize_entry("dataRiskLevel", &self.data_risk_level)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.last_modified_time.is_some() {
            state.serialize_entry("lastModifiedTime", &self.last_modified_time)?;
        }
        if !self.file_cluster_summaries.is_empty() {
            state.serialize_entry("fileClusterSummaries", &self.file_cluster_summaries)?;
        }
        if !self.resource_attributes.is_empty() {
            state.serialize_entry("resourceAttributes", &self.resource_attributes)?;
        }
        if !self.resource_labels.is_empty() {
            state.serialize_entry("resourceLabels", &self.resource_labels)?;
        }
        if !self.file_store_info_type_summaries.is_empty() {
            state.serialize_entry(
                "fileStoreInfoTypeSummaries",
                &self.file_store_info_type_summaries,
            )?;
        }
        if self.sample_findings_table.is_some() {
            state.serialize_entry("sampleFindingsTable", &self.sample_findings_table)?;
        }
        if !wkt::internal::is_default(&self.file_store_is_empty) {
            state.serialize_entry("fileStoreIsEmpty", &self.file_store_is_empty)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.related_resources.is_empty() {
            state.serialize_entry("relatedResources", &self.related_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FileStoreDataProfile].
pub mod file_store_data_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a profile. New items may be added.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unspecified,
        /// The profile is currently running. Once a profile has finished it will
        /// transition to DONE.
        Running,
        /// The profile is no longer generating.
        /// If profile_status.status.code is 0, the profile succeeded, otherwise, it
        /// failed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Done => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Done => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.privacy.dlp.v2.FileStoreDataProfile.State",
            ))
        }
    }
}

/// A tag associated with a resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Tag {
    /// The namespaced name for the tag value to attach to Google Cloud resources.
    /// Must be in the format `{parent_id}/{tag_key_short_name}/{short_name}`, for
    /// example, "123456/environment/prod". This is only set for Google Cloud
    /// resources.
    pub namespaced_tag_value: std::string::String,

    /// The key of a tag key-value pair. For Google Cloud resources, this is the
    /// resource name of the key, for example, "tagKeys/123456".
    pub key: std::string::String,

    /// The value of a tag key-value pair. For Google Cloud resources, this is the
    /// resource name of the value, for example, "tagValues/123456".
    pub value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [namespaced_tag_value][crate::model::Tag::namespaced_tag_value].
    pub fn set_namespaced_tag_value<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.namespaced_tag_value = v.into();
        self
    }

    /// Sets the value of [key][crate::model::Tag::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Tag::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Tag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Tag"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Tag {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __namespaced_tag_value,
            __key,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Tag")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "namespacedTagValue" => Ok(__FieldTag::__namespaced_tag_value),
                            "namespaced_tag_value" => Ok(__FieldTag::__namespaced_tag_value),
                            "key" => Ok(__FieldTag::__key),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Tag;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Tag")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__namespaced_tag_value => {
                            if !fields.insert(__FieldTag::__namespaced_tag_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespaced_tag_value",
                                ));
                            }
                            result.namespaced_tag_value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Tag {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.namespaced_tag_value.is_empty() {
            state.serialize_entry("namespacedTagValue", &self.namespaced_tag_value)?;
        }
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A related resource.
/// Examples:
///
/// * The source BigQuery table for a Vertex AI dataset.
/// * The source Cloud Storage bucket for a Vertex AI dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RelatedResource {
    /// The full resource name of the related resource.
    pub full_resource: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [full_resource][crate::model::RelatedResource::full_resource].
    pub fn set_full_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_resource = v.into();
        self
    }
}

impl wkt::message::Message for RelatedResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RelatedResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RelatedResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __full_resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelatedResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fullResource" => Ok(__FieldTag::__full_resource),
                            "full_resource" => Ok(__FieldTag::__full_resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RelatedResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelatedResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__full_resource => {
                            if !fields.insert(__FieldTag::__full_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_resource",
                                ));
                            }
                            result.full_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RelatedResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.full_resource.is_empty() {
            state.serialize_entry("fullResource", &self.full_resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information regarding the discovered InfoType.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileStoreInfoTypeSummary {
    /// The InfoType seen.
    pub info_type: std::option::Option<crate::model::InfoType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileStoreInfoTypeSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::FileStoreInfoTypeSummary::info_type].
    pub fn set_info_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [info_type][crate::model::FileStoreInfoTypeSummary::info_type].
    pub fn set_or_clear_info_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FileStoreInfoTypeSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreInfoTypeSummary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileStoreInfoTypeSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileStoreInfoTypeSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileStoreInfoTypeSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileStoreInfoTypeSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type",
                                ));
                            }
                            result.info_type =
                                map.next_value::<std::option::Option<crate::model::InfoType>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileStoreInfoTypeSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.info_type.is_some() {
            state.serialize_entry("infoType", &self.info_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information regarding the discovered file extension.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileExtensionInfo {
    /// The file extension if set. (aka .pdf, .jpg, .txt)
    pub file_extension: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileExtensionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_extension][crate::model::FileExtensionInfo::file_extension].
    pub fn set_file_extension<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_extension = v.into();
        self
    }
}

impl wkt::message::Message for FileExtensionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileExtensionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileExtensionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_extension,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileExtensionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileExtension" => Ok(__FieldTag::__file_extension),
                            "file_extension" => Ok(__FieldTag::__file_extension),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileExtensionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileExtensionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_extension => {
                            if !fields.insert(__FieldTag::__file_extension) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_extension",
                                ));
                            }
                            result.file_extension = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileExtensionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_extension.is_empty() {
            state.serialize_entry("fileExtension", &self.file_extension)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The file cluster summary.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileClusterSummary {
    /// The file cluster type.
    pub file_cluster_type: std::option::Option<crate::model::FileClusterType>,

    /// InfoTypes detected in this cluster.
    pub file_store_info_type_summaries: std::vec::Vec<crate::model::FileStoreInfoTypeSummary>,

    /// The sensitivity score of this cluster. The score will be SENSITIVITY_LOW
    /// if nothing has been scanned.
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this cluster. RISK_LOW if nothing has been
    /// scanned.
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// A list of errors detected while scanning this cluster. The list is
    /// truncated to 10 per cluster.
    pub errors: std::vec::Vec<crate::model::Error>,

    /// A sample of file types scanned in this cluster. Empty if no files were
    /// scanned. File extensions can be derived from the file name or the file
    /// content.
    pub file_extensions_scanned: std::vec::Vec<crate::model::FileExtensionInfo>,

    /// A sample of file types seen in this cluster. Empty if no files were seen.
    /// File extensions can be derived from the file name or the file content.
    pub file_extensions_seen: std::vec::Vec<crate::model::FileExtensionInfo>,

    /// True if no files exist in this cluster. If the file store had more files
    /// than could be listed, this will be false even if no files for this cluster
    /// were seen and file_extensions_seen is empty.
    pub no_files_exist: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileClusterSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_cluster_type][crate::model::FileClusterSummary::file_cluster_type].
    pub fn set_file_cluster_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileClusterType>,
    {
        self.file_cluster_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_cluster_type][crate::model::FileClusterSummary::file_cluster_type].
    pub fn set_or_clear_file_cluster_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileClusterType>,
    {
        self.file_cluster_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_store_info_type_summaries][crate::model::FileClusterSummary::file_store_info_type_summaries].
    pub fn set_file_store_info_type_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.file_store_info_type_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::FileClusterSummary::sensitivity_score].
    pub fn set_sensitivity_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sensitivity_score][crate::model::FileClusterSummary::sensitivity_score].
    pub fn set_or_clear_sensitivity_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_risk_level][crate::model::FileClusterSummary::data_risk_level].
    pub fn set_data_risk_level<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataRiskLevel>,
    {
        self.data_risk_level = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_risk_level][crate::model::FileClusterSummary::data_risk_level].
    pub fn set_or_clear_data_risk_level<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataRiskLevel>,
    {
        self.data_risk_level = v.map(|x| x.into());
        self
    }

    /// Sets the value of [errors][crate::model::FileClusterSummary::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_extensions_scanned][crate::model::FileClusterSummary::file_extensions_scanned].
    pub fn set_file_extensions_scanned<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileExtensionInfo>,
    {
        use std::iter::Iterator;
        self.file_extensions_scanned = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_extensions_seen][crate::model::FileClusterSummary::file_extensions_seen].
    pub fn set_file_extensions_seen<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileExtensionInfo>,
    {
        use std::iter::Iterator;
        self.file_extensions_seen = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [no_files_exist][crate::model::FileClusterSummary::no_files_exist].
    pub fn set_no_files_exist<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.no_files_exist = v.into();
        self
    }
}

impl wkt::message::Message for FileClusterSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileClusterSummary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileClusterSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_cluster_type,
            __file_store_info_type_summaries,
            __sensitivity_score,
            __data_risk_level,
            __errors,
            __file_extensions_scanned,
            __file_extensions_seen,
            __no_files_exist,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileClusterSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileClusterType" => Ok(__FieldTag::__file_cluster_type),
                            "file_cluster_type" => Ok(__FieldTag::__file_cluster_type),
                            "fileStoreInfoTypeSummaries" => {
                                Ok(__FieldTag::__file_store_info_type_summaries)
                            }
                            "file_store_info_type_summaries" => {
                                Ok(__FieldTag::__file_store_info_type_summaries)
                            }
                            "sensitivityScore" => Ok(__FieldTag::__sensitivity_score),
                            "sensitivity_score" => Ok(__FieldTag::__sensitivity_score),
                            "dataRiskLevel" => Ok(__FieldTag::__data_risk_level),
                            "data_risk_level" => Ok(__FieldTag::__data_risk_level),
                            "errors" => Ok(__FieldTag::__errors),
                            "fileExtensionsScanned" => Ok(__FieldTag::__file_extensions_scanned),
                            "file_extensions_scanned" => Ok(__FieldTag::__file_extensions_scanned),
                            "fileExtensionsSeen" => Ok(__FieldTag::__file_extensions_seen),
                            "file_extensions_seen" => Ok(__FieldTag::__file_extensions_seen),
                            "noFilesExist" => Ok(__FieldTag::__no_files_exist),
                            "no_files_exist" => Ok(__FieldTag::__no_files_exist),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileClusterSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileClusterSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_cluster_type => {
                            if !fields.insert(__FieldTag::__file_cluster_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_cluster_type",
                                ));
                            }
                            result.file_cluster_type = map
                                .next_value::<std::option::Option<crate::model::FileClusterType>>(
                                )?;
                        }
                        __FieldTag::__file_store_info_type_summaries => {
                            if !fields.insert(__FieldTag::__file_store_info_type_summaries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_store_info_type_summaries",
                                ));
                            }
                            result.file_store_info_type_summaries = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FileStoreInfoTypeSummary>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sensitivity_score => {
                            if !fields.insert(__FieldTag::__sensitivity_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sensitivity_score",
                                ));
                            }
                            result.sensitivity_score = map
                                .next_value::<std::option::Option<crate::model::SensitivityScore>>(
                                )?;
                        }
                        __FieldTag::__data_risk_level => {
                            if !fields.insert(__FieldTag::__data_risk_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_risk_level",
                                ));
                            }
                            result.data_risk_level = map
                                .next_value::<std::option::Option<crate::model::DataRiskLevel>>()?;
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Error>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_extensions_scanned => {
                            if !fields.insert(__FieldTag::__file_extensions_scanned) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_extensions_scanned",
                                ));
                            }
                            result.file_extensions_scanned =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FileExtensionInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_extensions_seen => {
                            if !fields.insert(__FieldTag::__file_extensions_seen) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_extensions_seen",
                                ));
                            }
                            result.file_extensions_seen =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FileExtensionInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__no_files_exist => {
                            if !fields.insert(__FieldTag::__no_files_exist) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for no_files_exist",
                                ));
                            }
                            result.no_files_exist = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileClusterSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.file_cluster_type.is_some() {
            state.serialize_entry("fileClusterType", &self.file_cluster_type)?;
        }
        if !self.file_store_info_type_summaries.is_empty() {
            state.serialize_entry(
                "fileStoreInfoTypeSummaries",
                &self.file_store_info_type_summaries,
            )?;
        }
        if self.sensitivity_score.is_some() {
            state.serialize_entry("sensitivityScore", &self.sensitivity_score)?;
        }
        if self.data_risk_level.is_some() {
            state.serialize_entry("dataRiskLevel", &self.data_risk_level)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self.file_extensions_scanned.is_empty() {
            state.serialize_entry("fileExtensionsScanned", &self.file_extensions_scanned)?;
        }
        if !self.file_extensions_seen.is_empty() {
            state.serialize_entry("fileExtensionsSeen", &self.file_extensions_seen)?;
        }
        if !wkt::internal::is_default(&self.no_files_exist) {
            state.serialize_entry("noFilesExist", &self.no_files_exist)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get a project data profile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProjectDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/projectDataProfiles/53234423`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProjectDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProjectDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProjectDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetProjectDataProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetProjectDataProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetProjectDataProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetProjectDataProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetProjectDataProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetProjectDataProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get a file store data profile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFileStoreDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/fileStoreDataProfiles/53234423`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFileStoreDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFileStoreDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFileStoreDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetFileStoreDataProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFileStoreDataProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFileStoreDataProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFileStoreDataProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFileStoreDataProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetFileStoreDataProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to list the file store profiles generated for a given organization or
/// project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFileStoreDataProfilesRequest {
    /// Required. Resource name of the organization or project, for
    /// example `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    pub parent: std::string::String,

    /// Optional. Page token to continue retrieval.
    pub page_token: std::string::String,

    /// Optional. Size of the page. This value can be limited by the server. If
    /// zero, server returns a page of max size 100.
    pub page_size: i32,

    /// Optional. Comma-separated list of fields to order by, followed by `asc` or
    /// `desc` postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id asc`
    /// * `name`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: The Google Cloud project ID.
    /// - `sensitivity_level`: How sensitive the data in a table is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    /// - `last_modified`: The last time the resource was modified.
    /// - `resource_visibility`: Visibility restriction for this resource.
    /// - `name`: The name of the profile.
    /// - `create_time`: The time the file store was first created.
    pub order_by: std::string::String,

    /// Optional. Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `project_id` - The Google Cloud project ID.
    ///   - `account_id` - The AWS account ID.
    ///   - `file_store_path` - The path like "gs://bucket".
    ///   - `data_source_type` - The profile's data source type, like
    ///     "google/storage/bucket".
    ///   - `data_storage_location` - The location where the file store's data is
    ///     stored, like "us-central1".
    ///   - `sensitivity_level` - HIGH|MODERATE|LOW
    ///   - `data_risk_level` - HIGH|MODERATE|LOW
    ///   - `resource_visibility`: PUBLIC|RESTRICTED
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * `project_id = 12345 AND status_code = 1`
    /// * `project_id = 12345 AND sensitivity_level = HIGH`
    /// * `project_id = 12345 AND resource_visibility = PUBLIC`
    /// * `file_store_path = "gs://mybucket"`
    ///
    /// The length of this field should be no more than 500 characters.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFileStoreDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFileStoreDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFileStoreDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFileStoreDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFileStoreDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFileStoreDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListFileStoreDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListFileStoreDataProfilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFileStoreDataProfilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFileStoreDataProfilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFileStoreDataProfilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFileStoreDataProfilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFileStoreDataProfilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List of file store data profiles generated for a given organization or
/// project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFileStoreDataProfilesResponse {
    /// List of data profiles.
    pub file_store_data_profiles: std::vec::Vec<crate::model::FileStoreDataProfile>,

    /// The next page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFileStoreDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_store_data_profiles][crate::model::ListFileStoreDataProfilesResponse::file_store_data_profiles].
    pub fn set_file_store_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreDataProfile>,
    {
        use std::iter::Iterator;
        self.file_store_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFileStoreDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFileStoreDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListFileStoreDataProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFileStoreDataProfilesResponse {
    type PageItem = crate::model::FileStoreDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.file_store_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFileStoreDataProfilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_store_data_profiles,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFileStoreDataProfilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileStoreDataProfiles" => Ok(__FieldTag::__file_store_data_profiles),
                            "file_store_data_profiles" => {
                                Ok(__FieldTag::__file_store_data_profiles)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFileStoreDataProfilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFileStoreDataProfilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_store_data_profiles => {
                            if !fields.insert(__FieldTag::__file_store_data_profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_store_data_profiles",
                                ));
                            }
                            result.file_store_data_profiles = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FileStoreDataProfile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFileStoreDataProfilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_store_data_profiles.is_empty() {
            state.serialize_entry("fileStoreDataProfiles", &self.file_store_data_profiles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteFileStoreProfile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteFileStoreDataProfileRequest {
    /// Required. Resource name of the file store data profile.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFileStoreDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFileStoreDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFileStoreDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteFileStoreDataProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteFileStoreDataProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteFileStoreDataProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteFileStoreDataProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteFileStoreDataProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteFileStoreDataProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get a table data profile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTableDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/tableDataProfiles/53234423`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTableDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTableDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTableDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetTableDataProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTableDataProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTableDataProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTableDataProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTableDataProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTableDataProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get a column data profile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetColumnDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/columnDataProfiles/53234423`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetColumnDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetColumnDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetColumnDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetColumnDataProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetColumnDataProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetColumnDataProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetColumnDataProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetColumnDataProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetColumnDataProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A condition for determining whether a Pub/Sub should be triggered.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfilePubSubCondition {
    /// An expression.
    pub expressions:
        std::option::Option<crate::model::data_profile_pub_sub_condition::PubSubExpressions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfilePubSubCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expressions][crate::model::DataProfilePubSubCondition::expressions].
    pub fn set_expressions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_pub_sub_condition::PubSubExpressions>,
    {
        self.expressions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expressions][crate::model::DataProfilePubSubCondition::expressions].
    pub fn set_or_clear_expressions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_profile_pub_sub_condition::PubSubExpressions>,
    {
        self.expressions = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataProfilePubSubCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubCondition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfilePubSubCondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __expressions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfilePubSubCondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "expressions" => Ok(__FieldTag::__expressions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfilePubSubCondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfilePubSubCondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__expressions => {
                            if !fields.insert(__FieldTag::__expressions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expressions",
                                ));
                            }
                            result.expressions = map.next_value::<std::option::Option<
                                crate::model::data_profile_pub_sub_condition::PubSubExpressions,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfilePubSubCondition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.expressions.is_some() {
            state.serialize_entry("expressions", &self.expressions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataProfilePubSubCondition].
pub mod data_profile_pub_sub_condition {
    #[allow(unused_imports)]
    use super::*;

    /// A condition consisting of a value.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PubSubCondition {
        /// The value for the condition to trigger.
        pub value: std::option::Option<
            crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PubSubCondition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// if it holds a `MinimumRiskScore`, `None` if the field is not set or
        /// holds a different branch.
        pub fn minimum_risk_score(
            &self,
        ) -> std::option::Option<&crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>
        {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumRiskScore(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// to hold a `MinimumRiskScore`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_minimum_risk_score<
            T: std::convert::Into<crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumRiskScore(
                    v.into()
                )
            );
            self
        }

        /// The value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// if it holds a `MinimumSensitivityScore`, `None` if the field is not set or
        /// holds a different branch.
        pub fn minimum_sensitivity_score(
            &self,
        ) -> std::option::Option<&crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>
        {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumSensitivityScore(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// to hold a `MinimumSensitivityScore`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_minimum_sensitivity_score<
            T: std::convert::Into<crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumSensitivityScore(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for PubSubCondition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubCondition.PubSubCondition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PubSubCondition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __minimum_risk_score,
                __minimum_sensitivity_score,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PubSubCondition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "minimumRiskScore" => Ok(__FieldTag::__minimum_risk_score),
                                "minimum_risk_score" => Ok(__FieldTag::__minimum_risk_score),
                                "minimumSensitivityScore" => {
                                    Ok(__FieldTag::__minimum_sensitivity_score)
                                }
                                "minimum_sensitivity_score" => {
                                    Ok(__FieldTag::__minimum_sensitivity_score)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PubSubCondition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PubSubCondition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__minimum_risk_score => {
                                if !fields.insert(__FieldTag::__minimum_risk_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for minimum_risk_score",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.privacy.dlp.v2.DataProfilePubSubCondition.PubSubCondition.minimum_risk_score, latest field was minimumRiskScore",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumRiskScore(
                                        map.next_value::<std::option::Option<crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__minimum_sensitivity_score => {
                                if !fields.insert(__FieldTag::__minimum_sensitivity_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for minimum_sensitivity_score",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.privacy.dlp.v2.DataProfilePubSubCondition.PubSubCondition.minimum_sensitivity_score, latest field was minimumSensitivityScore",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumSensitivityScore(
                                        map.next_value::<std::option::Option<crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PubSubCondition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.minimum_risk_score() {
                state.serialize_entry("minimumRiskScore", value)?;
            }
            if let Some(value) = self.minimum_sensitivity_score() {
                state.serialize_entry("minimumSensitivityScore", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PubSubCondition].
    pub mod pub_sub_condition {
        #[allow(unused_imports)]
        use super::*;

        /// The value for the condition to trigger.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Value {
            /// The minimum data risk score that triggers the condition.
            MinimumRiskScore(crate::model::data_profile_pub_sub_condition::ProfileScoreBucket),
            /// The minimum sensitivity level that triggers the condition.
            MinimumSensitivityScore(
                crate::model::data_profile_pub_sub_condition::ProfileScoreBucket,
            ),
        }
    }

    /// An expression, consisting of an operator and conditions.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PubSubExpressions {

        /// The operator to apply to the collection of conditions.
        pub logical_operator: crate::model::data_profile_pub_sub_condition::pub_sub_expressions::PubSubLogicalOperator,

        /// Conditions to apply to the expression.
        pub conditions: std::vec::Vec<crate::model::data_profile_pub_sub_condition::PubSubCondition>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PubSubExpressions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [logical_operator][crate::model::data_profile_pub_sub_condition::PubSubExpressions::logical_operator].
        pub fn set_logical_operator<T: std::convert::Into<crate::model::data_profile_pub_sub_condition::pub_sub_expressions::PubSubLogicalOperator>>(mut self, v: T) -> Self{
            self.logical_operator = v.into();
            self
        }

        /// Sets the value of [conditions][crate::model::data_profile_pub_sub_condition::PubSubExpressions::conditions].
        pub fn set_conditions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::data_profile_pub_sub_condition::PubSubCondition>,
        {
            use std::iter::Iterator;
            self.conditions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PubSubExpressions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubCondition.PubSubExpressions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PubSubExpressions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __logical_operator,
                __conditions,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PubSubExpressions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "logicalOperator" => Ok(__FieldTag::__logical_operator),
                                "logical_operator" => Ok(__FieldTag::__logical_operator),
                                "conditions" => Ok(__FieldTag::__conditions),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PubSubExpressions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PubSubExpressions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__logical_operator => {
                                if !fields.insert(__FieldTag::__logical_operator) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for logical_operator",
                                    ));
                                }
                                result.logical_operator = map.next_value::<std::option::Option<crate::model::data_profile_pub_sub_condition::pub_sub_expressions::PubSubLogicalOperator>>()?.unwrap_or_default();
                            }
                            __FieldTag::__conditions => {
                                if !fields.insert(__FieldTag::__conditions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for conditions",
                                    ));
                                }
                                result.conditions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::data_profile_pub_sub_condition::PubSubCondition>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PubSubExpressions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.logical_operator) {
                state.serialize_entry("logicalOperator", &self.logical_operator)?;
            }
            if !self.conditions.is_empty() {
                state.serialize_entry("conditions", &self.conditions)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PubSubExpressions].
    pub mod pub_sub_expressions {
        #[allow(unused_imports)]
        use super::*;

        /// Logical operators for conditional checks.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PubSubLogicalOperator {
            /// Unused.
            LogicalOperatorUnspecified,
            /// Conditional OR.
            Or,
            /// Conditional AND.
            And,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PubSubLogicalOperator::value] or
            /// [PubSubLogicalOperator::name].
            UnknownValue(pub_sub_logical_operator::UnknownValue),
        }

        #[doc(hidden)]
        pub mod pub_sub_logical_operator {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PubSubLogicalOperator {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::LogicalOperatorUnspecified => std::option::Option::Some(0),
                    Self::Or => std::option::Option::Some(1),
                    Self::And => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::LogicalOperatorUnspecified => {
                        std::option::Option::Some("LOGICAL_OPERATOR_UNSPECIFIED")
                    }
                    Self::Or => std::option::Option::Some("OR"),
                    Self::And => std::option::Option::Some("AND"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PubSubLogicalOperator {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PubSubLogicalOperator {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PubSubLogicalOperator {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::LogicalOperatorUnspecified,
                    1 => Self::Or,
                    2 => Self::And,
                    _ => Self::UnknownValue(pub_sub_logical_operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PubSubLogicalOperator {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LOGICAL_OPERATOR_UNSPECIFIED" => Self::LogicalOperatorUnspecified,
                    "OR" => Self::Or,
                    "AND" => Self::And,
                    _ => Self::UnknownValue(pub_sub_logical_operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PubSubLogicalOperator {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::LogicalOperatorUnspecified => serializer.serialize_i32(0),
                    Self::Or => serializer.serialize_i32(1),
                    Self::And => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PubSubLogicalOperator {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PubSubLogicalOperator>::new(
                    ".google.privacy.dlp.v2.DataProfilePubSubCondition.PubSubExpressions.PubSubLogicalOperator"))
            }
        }
    }

    /// Various score levels for resources.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProfileScoreBucket {
        /// Unused.
        Unspecified,
        /// High risk/sensitivity detected.
        High,
        /// Medium or high risk/sensitivity detected.
        MediumOrHigh,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ProfileScoreBucket::value] or
        /// [ProfileScoreBucket::name].
        UnknownValue(profile_score_bucket::UnknownValue),
    }

    #[doc(hidden)]
    pub mod profile_score_bucket {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ProfileScoreBucket {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::MediumOrHigh => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROFILE_SCORE_BUCKET_UNSPECIFIED"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::MediumOrHigh => std::option::Option::Some("MEDIUM_OR_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ProfileScoreBucket {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ProfileScoreBucket {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ProfileScoreBucket {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::MediumOrHigh,
                _ => Self::UnknownValue(profile_score_bucket::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ProfileScoreBucket {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROFILE_SCORE_BUCKET_UNSPECIFIED" => Self::Unspecified,
                "HIGH" => Self::High,
                "MEDIUM_OR_HIGH" => Self::MediumOrHigh,
                _ => Self::UnknownValue(profile_score_bucket::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ProfileScoreBucket {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::MediumOrHigh => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ProfileScoreBucket {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProfileScoreBucket>::new(
                ".google.privacy.dlp.v2.DataProfilePubSubCondition.ProfileScoreBucket",
            ))
        }
    }
}

/// Pub/Sub topic message for a DataProfileAction.PubSubNotification event.
/// To receive a message of protocol buffer schema type, convert the message data
/// to an object of this proto class.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataProfilePubSubMessage {
    /// If `DetailLevel` is `TABLE_PROFILE` this will be fully populated.
    /// Otherwise, if `DetailLevel` is `RESOURCE_NAME`, then only `name` and
    /// `full_resource` will be populated.
    pub profile: std::option::Option<crate::model::TableDataProfile>,

    /// If `DetailLevel` is `FILE_STORE_PROFILE` this will be fully populated.
    /// Otherwise, if `DetailLevel` is `RESOURCE_NAME`, then only `name` and
    /// `file_store_path` will be populated.
    pub file_store_profile: std::option::Option<crate::model::FileStoreDataProfile>,

    /// The event that caused the Pub/Sub message to be sent.
    pub event: crate::model::data_profile_action::EventType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfilePubSubMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [profile][crate::model::DataProfilePubSubMessage::profile].
    pub fn set_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableDataProfile>,
    {
        self.profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [profile][crate::model::DataProfilePubSubMessage::profile].
    pub fn set_or_clear_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableDataProfile>,
    {
        self.profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_store_profile][crate::model::DataProfilePubSubMessage::file_store_profile].
    pub fn set_file_store_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileStoreDataProfile>,
    {
        self.file_store_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_store_profile][crate::model::DataProfilePubSubMessage::file_store_profile].
    pub fn set_or_clear_file_store_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileStoreDataProfile>,
    {
        self.file_store_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event][crate::model::DataProfilePubSubMessage::event].
    pub fn set_event<T: std::convert::Into<crate::model::data_profile_action::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.event = v.into();
        self
    }
}

impl wkt::message::Message for DataProfilePubSubMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataProfilePubSubMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __profile,
            __file_store_profile,
            __event,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataProfilePubSubMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "profile" => Ok(__FieldTag::__profile),
                            "fileStoreProfile" => Ok(__FieldTag::__file_store_profile),
                            "file_store_profile" => Ok(__FieldTag::__file_store_profile),
                            "event" => Ok(__FieldTag::__event),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataProfilePubSubMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataProfilePubSubMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__profile => {
                            if !fields.insert(__FieldTag::__profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile",
                                ));
                            }
                            result.profile = map
                                .next_value::<std::option::Option<crate::model::TableDataProfile>>(
                                )?;
                        }
                        __FieldTag::__file_store_profile => {
                            if !fields.insert(__FieldTag::__file_store_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_store_profile",
                                ));
                            }
                            result.file_store_profile = map.next_value::<std::option::Option<crate::model::FileStoreDataProfile>>()?
                                ;
                        }
                        __FieldTag::__event => {
                            if !fields.insert(__FieldTag::__event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event",
                                ));
                            }
                            result.event =
                                map.next_value::<std::option::Option<
                                    crate::model::data_profile_action::EventType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataProfilePubSubMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.profile.is_some() {
            state.serialize_entry("profile", &self.profile)?;
        }
        if self.file_store_profile.is_some() {
            state.serialize_entry("fileStoreProfile", &self.file_store_profile)?;
        }
        if !wkt::internal::is_default(&self.event) {
            state.serialize_entry("event", &self.event)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateConnection.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConnectionRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization):
    ///
    /// + Projects scope:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Organizations scope:
    ///   `organizations/{org_id}/locations/{location_id}`
    pub parent: std::string::String,

    /// Required. The connection resource.
    pub connection: std::option::Option<crate::model::Connection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __connection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "connection" => Ok(__FieldTag::__connection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection =
                                map.next_value::<std::option::Option<crate::model::Connection>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.connection.is_some() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetConnection.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectionRequest {
    /// Required. Resource name in the format:
    /// `projects/{project}/locations/{location}/connections/{connection}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListConnections.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Resource name of the organization or project, for
    /// example, `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    pub parent: std::string::String,

    /// Optional. Number of results per page, max 1000.
    pub page_size: i32,

    /// Optional. Page token from a previous page to return the next set of
    /// results. If set, all other request fields must match the original request.
    pub page_token: std::string::String,

    /// Optional. Supported field/value: `state` - MISSING|AVAILABLE|ERROR
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for SearchConnections.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchConnectionsRequest {
    /// Required. Resource name of the organization or project with a wildcard
    /// location, for example, `organizations/433245324/locations/-` or
    /// `projects/project-id/locations/-`.
    pub parent: std::string::String,

    /// Optional. Number of results per page, max 1000.
    pub page_size: i32,

    /// Optional. Page token from a previous page to return the next set of
    /// results. If set, all other request fields must match the original request.
    pub page_token: std::string::String,

    /// Optional. Supported field/value: - `state` - MISSING|AVAILABLE|ERROR
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for SearchConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SearchConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListConnections.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// List of connections.
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// Token to retrieve the next page of results. An empty value means there are
    /// no more results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connections,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connections" => Ok(__FieldTag::__connections),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connections => {
                            if !fields.insert(__FieldTag::__connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connections",
                                ));
                            }
                            result.connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Connection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connections.is_empty() {
            state.serialize_entry("connections", &self.connections)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for SearchConnections.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchConnectionsResponse {
    /// List of connections that match the search query. Note that only a subset
    /// of the fields will be populated, and only "name" is guaranteed to be set.
    /// For full details of a Connection, call GetConnection with the name.
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// Token to retrieve the next page of results. An empty value means there are
    /// no more results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::SearchConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SearchConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchConnectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connections,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchConnectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connections" => Ok(__FieldTag::__connections),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchConnectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchConnectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connections => {
                            if !fields.insert(__FieldTag::__connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connections",
                                ));
                            }
                            result.connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Connection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchConnectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connections.is_empty() {
            state.serialize_entry("connections", &self.connections)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateConnection.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConnectionRequest {
    /// Required. Resource name in the format:
    /// `projects/{project}/locations/{location}/connections/{connection}`.
    pub name: std::string::String,

    /// Required. The connection with new values for the relevant fields.
    pub connection: std::option::Option<crate::model::Connection>,

    /// Optional. Mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __connection,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "connection" => Ok(__FieldTag::__connection),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection =
                                map.next_value::<std::option::Option<crate::model::Connection>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.connection.is_some() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteConnection.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConnectionRequest {
    /// Required. Resource name of the Connection to be deleted, in the format:
    /// `projects/{project}/locations/{location}/connections/{connection}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A data connection to allow the DLP API to profile data in locations that
/// require additional configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Connection {
    /// Output only. Name of the connection:
    /// `projects/{project}/locations/{location}/connections/{name}`.
    pub name: std::string::String,

    /// Required. The connection's state in its lifecycle.
    pub state: crate::model::ConnectionState,

    /// Output only. Set if status == ERROR, to provide additional details. Will
    /// store the last 10 errors sorted with the most recent first.
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Type of connection.
    pub properties: std::option::Option<crate::model::connection::Properties>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Connection::state].
    pub fn set_state<T: std::convert::Into<crate::model::ConnectionState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::Connection::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::Connection::properties].
    ///
    /// Note that all the setters affecting `properties` are mutually
    /// exclusive.
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::connection::Properties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `CloudSql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::CloudSql(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `CloudSql`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_cloud_sql<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::CloudSql(v.into()));
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Connection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Connection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __errors,
            __cloud_sql,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Connection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "errors" => Ok(__FieldTag::__errors),
                            "cloudSql" => Ok(__FieldTag::__cloud_sql),
                            "cloud_sql" => Ok(__FieldTag::__cloud_sql),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Connection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Connection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::ConnectionState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Error>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cloud_sql => {
                            if !fields.insert(__FieldTag::__cloud_sql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql",
                                ));
                            }
                            if result.properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `properties`, a oneof with full ID .google.privacy.dlp.v2.Connection.cloud_sql, latest field was cloudSql",
                                ));
                            }
                            result.properties = std::option::Option::Some(
                                crate::model::connection::Properties::CloudSql(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudSqlProperties>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Connection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if let Some(value) = self.cloud_sql() {
            state.serialize_entry("cloudSql", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Connection].
pub mod connection {
    #[allow(unused_imports)]
    use super::*;

    /// Type of connection.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Properties {
        /// Connect to a Cloud SQL instance.
        CloudSql(std::boxed::Box<crate::model::CloudSqlProperties>),
    }
}

/// A credential consisting of a username and password, where the password is
/// stored in a Secret Manager resource.
/// Note: Secret Manager [charges
/// apply](https://cloud.google.com/secret-manager/pricing).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretManagerCredential {
    /// Required. The username.
    pub username: std::string::String,

    /// Required. The name of the Secret Manager resource that stores the password,
    /// in the form `projects/project-id/secrets/secret-name/versions/version`.
    pub password_secret_version_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretManagerCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::SecretManagerCredential::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password_secret_version_name][crate::model::SecretManagerCredential::password_secret_version_name].
    pub fn set_password_secret_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.password_secret_version_name = v.into();
        self
    }
}

impl wkt::message::Message for SecretManagerCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SecretManagerCredential"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretManagerCredential {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __username,
            __password_secret_version_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretManagerCredential")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "username" => Ok(__FieldTag::__username),
                            "passwordSecretVersionName" => {
                                Ok(__FieldTag::__password_secret_version_name)
                            }
                            "password_secret_version_name" => {
                                Ok(__FieldTag::__password_secret_version_name)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretManagerCredential;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretManagerCredential")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password_secret_version_name => {
                            if !fields.insert(__FieldTag::__password_secret_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password_secret_version_name",
                                ));
                            }
                            result.password_secret_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretManagerCredential {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password_secret_version_name.is_empty() {
            state.serialize_entry(
                "passwordSecretVersionName",
                &self.password_secret_version_name,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Use IAM authentication to connect. This requires the Cloud SQL IAM feature
/// to be enabled on the instance, which is not the default for Cloud SQL.
/// See <https://cloud.google.com/sql/docs/postgres/authentication> and
/// <https://cloud.google.com/sql/docs/mysql/authentication>.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSqlIamCredential {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlIamCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CloudSqlIamCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudSqlIamCredential"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSqlIamCredential {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSqlIamCredential")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSqlIamCredential;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSqlIamCredential")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSqlIamCredential {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Cloud SQL connection properties.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSqlProperties {
    /// Optional. Immutable. The Cloud SQL instance for which the connection is
    /// defined. Only one connection per instance is allowed. This can only be set
    /// at creation time, and cannot be updated.
    ///
    /// It is an error to use a connection_name from different project or region
    /// than the one that holds the connection.
    /// For example, a Connection resource for Cloud SQL connection_name
    /// `project-id:us-central1:sql-instance`
    /// must be created under the parent
    /// `projects/project-id/locations/us-central1`
    pub connection_name: std::string::String,

    /// Required. The DLP API will limit its connections to max_connections.
    /// Must be 2 or greater.
    pub max_connections: i32,

    /// Required. The database engine used by the Cloud SQL instance that this
    /// connection configures.
    pub database_engine: crate::model::cloud_sql_properties::DatabaseEngine,

    /// How to authenticate to the instance.
    pub credential: std::option::Option<crate::model::cloud_sql_properties::Credential>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_name][crate::model::CloudSqlProperties::connection_name].
    pub fn set_connection_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_name = v.into();
        self
    }

    /// Sets the value of [max_connections][crate::model::CloudSqlProperties::max_connections].
    pub fn set_max_connections<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_connections = v.into();
        self
    }

    /// Sets the value of [database_engine][crate::model::CloudSqlProperties::database_engine].
    pub fn set_database_engine<
        T: std::convert::Into<crate::model::cloud_sql_properties::DatabaseEngine>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_engine = v.into();
        self
    }

    /// Sets the value of [credential][crate::model::CloudSqlProperties::credential].
    ///
    /// Note that all the setters affecting `credential` are mutually
    /// exclusive.
    pub fn set_credential<
        T: std::convert::Into<std::option::Option<crate::model::cloud_sql_properties::Credential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credential = v.into();
        self
    }

    /// The value of [credential][crate::model::CloudSqlProperties::credential]
    /// if it holds a `UsernamePassword`, `None` if the field is not set or
    /// holds a different branch.
    pub fn username_password(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SecretManagerCredential>> {
        #[allow(unreachable_patterns)]
        self.credential.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_properties::Credential::UsernamePassword(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credential][crate::model::CloudSqlProperties::credential]
    /// to hold a `UsernamePassword`.
    ///
    /// Note that all the setters affecting `credential` are
    /// mutually exclusive.
    pub fn set_username_password<
        T: std::convert::Into<std::boxed::Box<crate::model::SecretManagerCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credential = std::option::Option::Some(
            crate::model::cloud_sql_properties::Credential::UsernamePassword(v.into()),
        );
        self
    }

    /// The value of [credential][crate::model::CloudSqlProperties::credential]
    /// if it holds a `CloudSqlIam`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql_iam(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlIamCredential>> {
        #[allow(unreachable_patterns)]
        self.credential.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_properties::Credential::CloudSqlIam(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credential][crate::model::CloudSqlProperties::credential]
    /// to hold a `CloudSqlIam`.
    ///
    /// Note that all the setters affecting `credential` are
    /// mutually exclusive.
    pub fn set_cloud_sql_iam<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlIamCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credential = std::option::Option::Some(
            crate::model::cloud_sql_properties::Credential::CloudSqlIam(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudSqlProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudSqlProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSqlProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection_name,
            __username_password,
            __cloud_sql_iam,
            __max_connections,
            __database_engine,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSqlProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectionName" => Ok(__FieldTag::__connection_name),
                            "connection_name" => Ok(__FieldTag::__connection_name),
                            "usernamePassword" => Ok(__FieldTag::__username_password),
                            "username_password" => Ok(__FieldTag::__username_password),
                            "cloudSqlIam" => Ok(__FieldTag::__cloud_sql_iam),
                            "cloud_sql_iam" => Ok(__FieldTag::__cloud_sql_iam),
                            "maxConnections" => Ok(__FieldTag::__max_connections),
                            "max_connections" => Ok(__FieldTag::__max_connections),
                            "databaseEngine" => Ok(__FieldTag::__database_engine),
                            "database_engine" => Ok(__FieldTag::__database_engine),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSqlProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSqlProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection_name => {
                            if !fields.insert(__FieldTag::__connection_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_name",
                                ));
                            }
                            result.connection_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__username_password => {
                            if !fields.insert(__FieldTag::__username_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username_password",
                                ));
                            }
                            if result.credential.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `credential`, a oneof with full ID .google.privacy.dlp.v2.CloudSqlProperties.username_password, latest field was usernamePassword",
                                ));
                            }
                            result.credential = std::option::Option::Some(
                                crate::model::cloud_sql_properties::Credential::UsernamePassword(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SecretManagerCredential>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_sql_iam => {
                            if !fields.insert(__FieldTag::__cloud_sql_iam) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql_iam",
                                ));
                            }
                            if result.credential.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `credential`, a oneof with full ID .google.privacy.dlp.v2.CloudSqlProperties.cloud_sql_iam, latest field was cloudSqlIam",
                                ));
                            }
                            result.credential = std::option::Option::Some(
                                crate::model::cloud_sql_properties::Credential::CloudSqlIam(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudSqlIamCredential>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__max_connections => {
                            if !fields.insert(__FieldTag::__max_connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_connections",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_connections =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__database_engine => {
                            if !fields.insert(__FieldTag::__database_engine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_engine",
                                ));
                            }
                            result.database_engine = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_sql_properties::DatabaseEngine,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSqlProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connection_name.is_empty() {
            state.serialize_entry("connectionName", &self.connection_name)?;
        }
        if let Some(value) = self.username_password() {
            state.serialize_entry("usernamePassword", value)?;
        }
        if let Some(value) = self.cloud_sql_iam() {
            state.serialize_entry("cloudSqlIam", value)?;
        }
        if !wkt::internal::is_default(&self.max_connections) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxConnections", &__With(&self.max_connections))?;
        }
        if !wkt::internal::is_default(&self.database_engine) {
            state.serialize_entry("databaseEngine", &self.database_engine)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CloudSqlProperties].
pub mod cloud_sql_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Database engine of a Cloud SQL instance.
    /// New values may be added over time.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseEngine {
        /// An engine that is not currently supported by Sensitive Data Protection.
        Unknown,
        /// Cloud SQL for MySQL instance.
        Mysql,
        /// Cloud SQL for PostgreSQL instance.
        Postgres,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseEngine::value] or
        /// [DatabaseEngine::name].
        UnknownValue(database_engine::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_engine {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseEngine {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Mysql => std::option::Option::Some(1),
                Self::Postgres => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("DATABASE_ENGINE_UNKNOWN"),
                Self::Mysql => std::option::Option::Some("DATABASE_ENGINE_MYSQL"),
                Self::Postgres => std::option::Option::Some("DATABASE_ENGINE_POSTGRES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseEngine {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseEngine {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseEngine {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Mysql,
                2 => Self::Postgres,
                _ => Self::UnknownValue(database_engine::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseEngine {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_ENGINE_UNKNOWN" => Self::Unknown,
                "DATABASE_ENGINE_MYSQL" => Self::Mysql,
                "DATABASE_ENGINE_POSTGRES" => Self::Postgres,
                _ => Self::UnknownValue(database_engine::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseEngine {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Mysql => serializer.serialize_i32(1),
                Self::Postgres => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseEngine {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEngine>::new(
                ".google.privacy.dlp.v2.CloudSqlProperties.DatabaseEngine",
            ))
        }
    }

    /// How to authenticate to the instance.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Credential {
        /// A username and password stored in Secret Manager.
        UsernamePassword(std::boxed::Box<crate::model::SecretManagerCredential>),
        /// Built-in IAM authentication (must be configured in Cloud SQL).
        CloudSqlIam(std::boxed::Box<crate::model::CloudSqlIamCredential>),
    }
}

/// Request message for DeleteTableProfile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTableDataProfileRequest {
    /// Required. Resource name of the table data profile.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTableDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTableDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTableDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteTableDataProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTableDataProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTableDataProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTableDataProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTableDataProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTableDataProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message used to identify the type of resource being profiled.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSourceType {
    /// Output only. An identifying string to the type of resource being profiled.
    /// Current values:
    ///
    /// * google/bigquery/table
    /// * google/project
    /// * google/sql/table
    /// * google/gcs/bucket
    pub data_source: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSourceType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_source][crate::model::DataSourceType::data_source].
    pub fn set_data_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source = v.into();
        self
    }
}

impl wkt::message::Message for DataSourceType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataSourceType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataSourceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSourceType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataSource" => Ok(__FieldTag::__data_source),
                            "data_source" => Ok(__FieldTag::__data_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataSourceType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSourceType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_source => {
                            if !fields.insert(__FieldTag::__data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source",
                                ));
                            }
                            result.data_source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataSourceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_source.is_empty() {
            state.serialize_entry("dataSource", &self.data_source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message used to identify file cluster type being profiled.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileClusterType {
    /// File cluster type.
    pub file_cluster_type: std::option::Option<crate::model::file_cluster_type::FileClusterType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileClusterType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_cluster_type][crate::model::FileClusterType::file_cluster_type].
    ///
    /// Note that all the setters affecting `file_cluster_type` are mutually
    /// exclusive.
    pub fn set_file_cluster_type<
        T: std::convert::Into<std::option::Option<crate::model::file_cluster_type::FileClusterType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_cluster_type = v.into();
        self
    }

    /// The value of [file_cluster_type][crate::model::FileClusterType::file_cluster_type]
    /// if it holds a `Cluster`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cluster(&self) -> std::option::Option<&crate::model::file_cluster_type::Cluster> {
        #[allow(unreachable_patterns)]
        self.file_cluster_type.as_ref().and_then(|v| match v {
            crate::model::file_cluster_type::FileClusterType::Cluster(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [file_cluster_type][crate::model::FileClusterType::file_cluster_type]
    /// to hold a `Cluster`.
    ///
    /// Note that all the setters affecting `file_cluster_type` are
    /// mutually exclusive.
    pub fn set_cluster<T: std::convert::Into<crate::model::file_cluster_type::Cluster>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_cluster_type = std::option::Option::Some(
            crate::model::file_cluster_type::FileClusterType::Cluster(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileClusterType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileClusterType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileClusterType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileClusterType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cluster" => Ok(__FieldTag::__cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileClusterType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileClusterType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            if result.file_cluster_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `file_cluster_type`, a oneof with full ID .google.privacy.dlp.v2.FileClusterType.cluster, latest field was cluster",
                                ));
                            }
                            result.file_cluster_type = std::option::Option::Some(
                                crate::model::file_cluster_type::FileClusterType::Cluster(
                                    map.next_value::<std::option::Option<
                                        crate::model::file_cluster_type::Cluster,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileClusterType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cluster() {
            state.serialize_entry("cluster", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FileClusterType].
pub mod file_cluster_type {
    #[allow(unused_imports)]
    use super::*;

    /// Cluster type. Each cluster corresponds to a set of file types.
    /// Over time, new types may be added and files may move between clusters.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Cluster {
        /// Unused.
        Unspecified,
        /// Unsupported files.
        Unknown,
        /// Plain text.
        Text,
        /// Structured data like CSV, TSV etc.
        StructuredData,
        /// Source code.
        SourceCode,
        /// Rich document like docx, xlsx etc.
        RichDocument,
        /// Images like jpeg, bmp.
        Image,
        /// Archives and containers like .zip, .tar etc.
        Archive,
        /// Multimedia like .mp4, .avi etc.
        Multimedia,
        /// Executable files like .exe, .class, .apk etc.
        Executable,
        /// AI models like .tflite etc.
        AiModel,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Cluster::value] or
        /// [Cluster::name].
        UnknownValue(cluster::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cluster {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Cluster {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::Text => std::option::Option::Some(2),
                Self::StructuredData => std::option::Option::Some(3),
                Self::SourceCode => std::option::Option::Some(4),
                Self::RichDocument => std::option::Option::Some(5),
                Self::Image => std::option::Option::Some(6),
                Self::Archive => std::option::Option::Some(7),
                Self::Multimedia => std::option::Option::Some(8),
                Self::Executable => std::option::Option::Some(9),
                Self::AiModel => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLUSTER_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("CLUSTER_UNKNOWN"),
                Self::Text => std::option::Option::Some("CLUSTER_TEXT"),
                Self::StructuredData => std::option::Option::Some("CLUSTER_STRUCTURED_DATA"),
                Self::SourceCode => std::option::Option::Some("CLUSTER_SOURCE_CODE"),
                Self::RichDocument => std::option::Option::Some("CLUSTER_RICH_DOCUMENT"),
                Self::Image => std::option::Option::Some("CLUSTER_IMAGE"),
                Self::Archive => std::option::Option::Some("CLUSTER_ARCHIVE"),
                Self::Multimedia => std::option::Option::Some("CLUSTER_MULTIMEDIA"),
                Self::Executable => std::option::Option::Some("CLUSTER_EXECUTABLE"),
                Self::AiModel => std::option::Option::Some("CLUSTER_AI_MODEL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Cluster {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Cluster {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Cluster {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unknown,
                2 => Self::Text,
                3 => Self::StructuredData,
                4 => Self::SourceCode,
                5 => Self::RichDocument,
                6 => Self::Image,
                7 => Self::Archive,
                8 => Self::Multimedia,
                9 => Self::Executable,
                10 => Self::AiModel,
                _ => Self::UnknownValue(cluster::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Cluster {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLUSTER_UNSPECIFIED" => Self::Unspecified,
                "CLUSTER_UNKNOWN" => Self::Unknown,
                "CLUSTER_TEXT" => Self::Text,
                "CLUSTER_STRUCTURED_DATA" => Self::StructuredData,
                "CLUSTER_SOURCE_CODE" => Self::SourceCode,
                "CLUSTER_RICH_DOCUMENT" => Self::RichDocument,
                "CLUSTER_IMAGE" => Self::Image,
                "CLUSTER_ARCHIVE" => Self::Archive,
                "CLUSTER_MULTIMEDIA" => Self::Multimedia,
                "CLUSTER_EXECUTABLE" => Self::Executable,
                "CLUSTER_AI_MODEL" => Self::AiModel,
                _ => Self::UnknownValue(cluster::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Cluster {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::Text => serializer.serialize_i32(2),
                Self::StructuredData => serializer.serialize_i32(3),
                Self::SourceCode => serializer.serialize_i32(4),
                Self::RichDocument => serializer.serialize_i32(5),
                Self::Image => serializer.serialize_i32(6),
                Self::Archive => serializer.serialize_i32(7),
                Self::Multimedia => serializer.serialize_i32(8),
                Self::Executable => serializer.serialize_i32(9),
                Self::AiModel => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Cluster {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Cluster>::new(
                ".google.privacy.dlp.v2.FileClusterType.Cluster",
            ))
        }
    }

    /// File cluster type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FileClusterType {
        /// Cluster type.
        Cluster(crate::model::file_cluster_type::Cluster),
    }
}

/// Configure processing location for discovery and inspection. For example,
/// image OCR is only provided in limited regions but configuring
/// ProcessingLocation will redirect OCR to a location where OCR is provided.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ProcessingLocation {
    /// Image processing will fall back using this configuration.
    pub image_fallback_location:
        std::option::Option<crate::model::processing_location::ImageFallbackLocation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessingLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_fallback_location][crate::model::ProcessingLocation::image_fallback_location].
    pub fn set_image_fallback_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::processing_location::ImageFallbackLocation>,
    {
        self.image_fallback_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image_fallback_location][crate::model::ProcessingLocation::image_fallback_location].
    pub fn set_or_clear_image_fallback_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::processing_location::ImageFallbackLocation>,
    {
        self.image_fallback_location = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ProcessingLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProcessingLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image_fallback_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProcessingLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "imageFallbackLocation" => Ok(__FieldTag::__image_fallback_location),
                            "image_fallback_location" => Ok(__FieldTag::__image_fallback_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProcessingLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProcessingLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image_fallback_location => {
                            if !fields.insert(__FieldTag::__image_fallback_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_fallback_location",
                                ));
                            }
                            result.image_fallback_location = map.next_value::<std::option::Option<
                                crate::model::processing_location::ImageFallbackLocation,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProcessingLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.image_fallback_location.is_some() {
            state.serialize_entry("imageFallbackLocation", &self.image_fallback_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ProcessingLocation].
pub mod processing_location {
    #[allow(unused_imports)]
    use super::*;

    /// Processing will happen in a multi-region that contains the current region
    /// if available.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MultiRegionProcessing {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MultiRegionProcessing {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for MultiRegionProcessing {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation.MultiRegionProcessing"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MultiRegionProcessing {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MultiRegionProcessing")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MultiRegionProcessing;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MultiRegionProcessing")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MultiRegionProcessing {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Processing will happen in the global region.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GlobalProcessing {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GlobalProcessing {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for GlobalProcessing {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation.GlobalProcessing"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GlobalProcessing {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GlobalProcessing")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GlobalProcessing;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GlobalProcessing")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GlobalProcessing {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configure image processing to fall back to the configured processing option
    /// below if unavailable in the request location.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ImageFallbackLocation {
        /// Processing will happen in a multi-region that contains the current region
        /// if available.
        pub multi_region_processing:
            std::option::Option<crate::model::processing_location::MultiRegionProcessing>,

        /// Processing will happen in the global region.
        pub global_processing:
            std::option::Option<crate::model::processing_location::GlobalProcessing>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImageFallbackLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [multi_region_processing][crate::model::processing_location::ImageFallbackLocation::multi_region_processing].
        pub fn set_multi_region_processing<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::processing_location::MultiRegionProcessing>,
        {
            self.multi_region_processing = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [multi_region_processing][crate::model::processing_location::ImageFallbackLocation::multi_region_processing].
        pub fn set_or_clear_multi_region_processing<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::processing_location::MultiRegionProcessing>,
        {
            self.multi_region_processing = v.map(|x| x.into());
            self
        }

        /// Sets the value of [global_processing][crate::model::processing_location::ImageFallbackLocation::global_processing].
        pub fn set_global_processing<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::processing_location::GlobalProcessing>,
        {
            self.global_processing = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [global_processing][crate::model::processing_location::ImageFallbackLocation::global_processing].
        pub fn set_or_clear_global_processing<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::processing_location::GlobalProcessing>,
        {
            self.global_processing = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ImageFallbackLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation.ImageFallbackLocation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ImageFallbackLocation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __multi_region_processing,
                __global_processing,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ImageFallbackLocation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "multiRegionProcessing" => {
                                    Ok(__FieldTag::__multi_region_processing)
                                }
                                "multi_region_processing" => {
                                    Ok(__FieldTag::__multi_region_processing)
                                }
                                "globalProcessing" => Ok(__FieldTag::__global_processing),
                                "global_processing" => Ok(__FieldTag::__global_processing),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ImageFallbackLocation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ImageFallbackLocation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__multi_region_processing => {
                                if !fields.insert(__FieldTag::__multi_region_processing) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for multi_region_processing",
                                    ));
                                }
                                result.multi_region_processing = map
                                    .next_value::<std::option::Option<
                                        crate::model::processing_location::MultiRegionProcessing,
                                    >>()?;
                            }
                            __FieldTag::__global_processing => {
                                if !fields.insert(__FieldTag::__global_processing) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for global_processing",
                                    ));
                                }
                                result.global_processing = map
                                    .next_value::<std::option::Option<
                                        crate::model::processing_location::GlobalProcessing,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ImageFallbackLocation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.multi_region_processing.is_some() {
                state.serialize_entry("multiRegionProcessing", &self.multi_region_processing)?;
            }
            if self.global_processing.is_some() {
                state.serialize_entry("globalProcessing", &self.global_processing)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Collection of findings saved to a Cloud Storage bucket. This is used as the
/// proto schema for textproto files created when specifying a cloud storage
/// path to save inspection findings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SaveToGcsFindingsOutput {
    /// List of findings.
    pub findings: std::vec::Vec<crate::model::Finding>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SaveToGcsFindingsOutput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [findings][crate::model::SaveToGcsFindingsOutput::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Finding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SaveToGcsFindingsOutput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SaveToGcsFindingsOutput"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SaveToGcsFindingsOutput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __findings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SaveToGcsFindingsOutput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "findings" => Ok(__FieldTag::__findings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SaveToGcsFindingsOutput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SaveToGcsFindingsOutput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__findings => {
                            if !fields.insert(__FieldTag::__findings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for findings",
                                ));
                            }
                            result.findings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Finding>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SaveToGcsFindingsOutput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.findings.is_empty() {
            state.serialize_entry("findings", &self.findings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Type of information detected by the API.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InfoType {
    /// Name of the information type. Either a name of your choosing when
    /// creating a CustomInfoType, or one of the names listed
    /// at
    /// <https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference>
    /// when specifying a built-in type.  When sending Cloud DLP results to Data
    /// Catalog, infoType names should conform to the pattern
    /// `[A-Za-z0-9$_-]{1,64}`.
    pub name: std::string::String,

    /// Optional version name for this InfoType.
    pub version: std::string::String,

    /// Optional custom sensitivity for this InfoType.
    /// This only applies to data profiling.
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InfoType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::InfoType::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::InfoType::sensitivity_score].
    pub fn set_sensitivity_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sensitivity_score][crate::model::InfoType::sensitivity_score].
    pub fn set_or_clear_sensitivity_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InfoType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InfoType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            __sensitivity_score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InfoType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            "sensitivityScore" => Ok(__FieldTag::__sensitivity_score),
                            "sensitivity_score" => Ok(__FieldTag::__sensitivity_score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InfoType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InfoType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sensitivity_score => {
                            if !fields.insert(__FieldTag::__sensitivity_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sensitivity_score",
                                ));
                            }
                            result.sensitivity_score = map
                                .next_value::<std::option::Option<crate::model::SensitivityScore>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InfoType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.sensitivity_score.is_some() {
            state.serialize_entry("sensitivityScore", &self.sensitivity_score)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Score is calculated from of all elements in the data profile.
/// A higher level means the data is more sensitive.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SensitivityScore {
    /// The sensitivity score applied to the resource.
    pub score: crate::model::sensitivity_score::SensitivityScoreLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SensitivityScore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SensitivityScore::score].
    pub fn set_score<
        T: std::convert::Into<crate::model::sensitivity_score::SensitivityScoreLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for SensitivityScore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SensitivityScore"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SensitivityScore {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SensitivityScore")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "score" => Ok(__FieldTag::__score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SensitivityScore;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SensitivityScore")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            result.score = map
                                .next_value::<std::option::Option<
                                    crate::model::sensitivity_score::SensitivityScoreLevel,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SensitivityScore {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.score) {
            state.serialize_entry("score", &self.score)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SensitivityScore].
pub mod sensitivity_score {
    #[allow(unused_imports)]
    use super::*;

    /// Various sensitivity score levels for resources.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SensitivityScoreLevel {
        /// Unused.
        SensitivityScoreUnspecified,
        /// No sensitive information detected. The resource isn't publicly
        /// accessible.
        SensitivityLow,
        /// Unable to determine sensitivity.
        SensitivityUnknown,
        /// Medium risk. Contains personally identifiable information (PII),
        /// potentially sensitive data, or fields with free-text data that are at a
        /// higher risk of having intermittent sensitive data. Consider limiting
        /// access.
        SensitivityModerate,
        /// High risk. Sensitive personally identifiable information (SPII) can be
        /// present. Exfiltration of data can lead to user data loss.
        /// Re-identification of users might be possible. Consider limiting usage and
        /// or removing SPII.
        SensitivityHigh,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SensitivityScoreLevel::value] or
        /// [SensitivityScoreLevel::name].
        UnknownValue(sensitivity_score_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sensitivity_score_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SensitivityScoreLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::SensitivityScoreUnspecified => std::option::Option::Some(0),
                Self::SensitivityLow => std::option::Option::Some(10),
                Self::SensitivityUnknown => std::option::Option::Some(12),
                Self::SensitivityModerate => std::option::Option::Some(20),
                Self::SensitivityHigh => std::option::Option::Some(30),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::SensitivityScoreUnspecified => {
                    std::option::Option::Some("SENSITIVITY_SCORE_UNSPECIFIED")
                }
                Self::SensitivityLow => std::option::Option::Some("SENSITIVITY_LOW"),
                Self::SensitivityUnknown => std::option::Option::Some("SENSITIVITY_UNKNOWN"),
                Self::SensitivityModerate => std::option::Option::Some("SENSITIVITY_MODERATE"),
                Self::SensitivityHigh => std::option::Option::Some("SENSITIVITY_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SensitivityScoreLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SensitivityScoreLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SensitivityScoreLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::SensitivityScoreUnspecified,
                10 => Self::SensitivityLow,
                12 => Self::SensitivityUnknown,
                20 => Self::SensitivityModerate,
                30 => Self::SensitivityHigh,
                _ => Self::UnknownValue(sensitivity_score_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SensitivityScoreLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SENSITIVITY_SCORE_UNSPECIFIED" => Self::SensitivityScoreUnspecified,
                "SENSITIVITY_LOW" => Self::SensitivityLow,
                "SENSITIVITY_UNKNOWN" => Self::SensitivityUnknown,
                "SENSITIVITY_MODERATE" => Self::SensitivityModerate,
                "SENSITIVITY_HIGH" => Self::SensitivityHigh,
                _ => Self::UnknownValue(sensitivity_score_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SensitivityScoreLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::SensitivityScoreUnspecified => serializer.serialize_i32(0),
                Self::SensitivityLow => serializer.serialize_i32(10),
                Self::SensitivityUnknown => serializer.serialize_i32(12),
                Self::SensitivityModerate => serializer.serialize_i32(20),
                Self::SensitivityHigh => serializer.serialize_i32(30),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SensitivityScoreLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SensitivityScoreLevel>::new(
                ".google.privacy.dlp.v2.SensitivityScore.SensitivityScoreLevel",
            ))
        }
    }
}

/// A reference to a StoredInfoType to use with scanning.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StoredType {
    /// Resource name of the requested `StoredInfoType`, for example
    /// `organizations/433245324/storedInfoTypes/432452342` or
    /// `projects/project-id/storedInfoTypes/432452342`.
    pub name: std::string::String,

    /// Timestamp indicating when the version of the `StoredInfoType` used for
    /// inspection was created. Output-only field, populated by the system.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StoredType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::StoredType::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::StoredType::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StoredType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StoredType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StoredType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StoredType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StoredType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StoredType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Custom information type provided by the user. Used to find domain-specific
/// sensitive information configurable to the data in question.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomInfoType {
    /// CustomInfoType can either be a new infoType, or an extension of built-in
    /// infoType, when the name matches one of existing infoTypes and that infoType
    /// is specified in `InspectContent.info_types` field. Specifying the latter
    /// adds findings to the one detected by the system. If built-in info type is
    /// not specified in `InspectContent.info_types` list then the name is treated
    /// as a custom info type.
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Likelihood to return for this CustomInfoType. This base value can be
    /// altered by a detection rule if the finding meets the criteria specified by
    /// the rule. Defaults to `VERY_LIKELY` if not specified.
    pub likelihood: crate::model::Likelihood,

    /// Set of detection rules to apply to all findings of this CustomInfoType.
    /// Rules are applied in order that they are specified. Not supported for the
    /// `surrogate_type` CustomInfoType.
    pub detection_rules: std::vec::Vec<crate::model::custom_info_type::DetectionRule>,

    /// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding
    /// to be returned. It still can be used for rules matching.
    pub exclusion_type: crate::model::custom_info_type::ExclusionType,

    /// Sensitivity for this CustomInfoType. If this CustomInfoType extends an
    /// existing InfoType, the sensitivity here will take precedence over that of
    /// the original InfoType. If unset for a CustomInfoType, it will default to
    /// HIGH.
    /// This only applies to data profiling.
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// Type of custom detector.
    pub r#type: std::option::Option<crate::model::custom_info_type::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomInfoType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::CustomInfoType::info_type].
    pub fn set_info_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [info_type][crate::model::CustomInfoType::info_type].
    pub fn set_or_clear_info_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InfoType>,
    {
        self.info_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [likelihood][crate::model::CustomInfoType::likelihood].
    pub fn set_likelihood<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.likelihood = v.into();
        self
    }

    /// Sets the value of [detection_rules][crate::model::CustomInfoType::detection_rules].
    pub fn set_detection_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::custom_info_type::DetectionRule>,
    {
        use std::iter::Iterator;
        self.detection_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclusion_type][crate::model::CustomInfoType::exclusion_type].
    pub fn set_exclusion_type<
        T: std::convert::Into<crate::model::custom_info_type::ExclusionType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.exclusion_type = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::CustomInfoType::sensitivity_score].
    pub fn set_sensitivity_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sensitivity_score][crate::model::CustomInfoType::sensitivity_score].
    pub fn set_or_clear_sensitivity_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SensitivityScore>,
    {
        self.sensitivity_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::custom_info_type::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `Dictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Dictionary>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::Dictionary(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `Dictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Dictionary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::custom_info_type::Type::Dictionary(v.into()));
        self
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `Regex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Regex>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::Regex(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `Regex`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Regex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::custom_info_type::Type::Regex(v.into()));
        self
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `SurrogateType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn surrogate_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::SurrogateType>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::SurrogateType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `SurrogateType`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_surrogate_type<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::SurrogateType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::custom_info_type::Type::SurrogateType(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `StoredType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stored_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::StoredType>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::StoredType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `StoredType`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_stored_type<T: std::convert::Into<std::boxed::Box<crate::model::StoredType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::custom_info_type::Type::StoredType(v.into()));
        self
    }
}

impl wkt::message::Message for CustomInfoType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomInfoType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info_type,
            __likelihood,
            __dictionary,
            __regex,
            __surrogate_type,
            __stored_type,
            __detection_rules,
            __exclusion_type,
            __sensitivity_score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomInfoType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            "likelihood" => Ok(__FieldTag::__likelihood),
                            "dictionary" => Ok(__FieldTag::__dictionary),
                            "regex" => Ok(__FieldTag::__regex),
                            "surrogateType" => Ok(__FieldTag::__surrogate_type),
                            "surrogate_type" => Ok(__FieldTag::__surrogate_type),
                            "storedType" => Ok(__FieldTag::__stored_type),
                            "stored_type" => Ok(__FieldTag::__stored_type),
                            "detectionRules" => Ok(__FieldTag::__detection_rules),
                            "detection_rules" => Ok(__FieldTag::__detection_rules),
                            "exclusionType" => Ok(__FieldTag::__exclusion_type),
                            "exclusion_type" => Ok(__FieldTag::__exclusion_type),
                            "sensitivityScore" => Ok(__FieldTag::__sensitivity_score),
                            "sensitivity_score" => Ok(__FieldTag::__sensitivity_score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomInfoType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomInfoType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type",
                                ));
                            }
                            result.info_type =
                                map.next_value::<std::option::Option<crate::model::InfoType>>()?;
                        }
                        __FieldTag::__likelihood => {
                            if !fields.insert(__FieldTag::__likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for likelihood",
                                ));
                            }
                            result.likelihood = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dictionary => {
                            if !fields.insert(__FieldTag::__dictionary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dictionary",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.CustomInfoType.dictionary, latest field was dictionary",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::custom_info_type::Type::Dictionary(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::custom_info_type::Dictionary>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__regex => {
                            if !fields.insert(__FieldTag::__regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for regex",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.CustomInfoType.regex, latest field was regex",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::custom_info_type::Type::Regex(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::custom_info_type::Regex>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__surrogate_type => {
                            if !fields.insert(__FieldTag::__surrogate_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for surrogate_type",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.CustomInfoType.surrogate_type, latest field was surrogateType",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::custom_info_type::Type::SurrogateType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::custom_info_type::SurrogateType,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__stored_type => {
                            if !fields.insert(__FieldTag::__stored_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stored_type",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.CustomInfoType.stored_type, latest field was storedType",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::custom_info_type::Type::StoredType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StoredType>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__detection_rules => {
                            if !fields.insert(__FieldTag::__detection_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detection_rules",
                                ));
                            }
                            result.detection_rules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::custom_info_type::DetectionRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exclusion_type => {
                            if !fields.insert(__FieldTag::__exclusion_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusion_type",
                                ));
                            }
                            result.exclusion_type =
                                map.next_value::<std::option::Option<
                                    crate::model::custom_info_type::ExclusionType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sensitivity_score => {
                            if !fields.insert(__FieldTag::__sensitivity_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sensitivity_score",
                                ));
                            }
                            result.sensitivity_score = map
                                .next_value::<std::option::Option<crate::model::SensitivityScore>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomInfoType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.info_type.is_some() {
            state.serialize_entry("infoType", &self.info_type)?;
        }
        if !wkt::internal::is_default(&self.likelihood) {
            state.serialize_entry("likelihood", &self.likelihood)?;
        }
        if let Some(value) = self.dictionary() {
            state.serialize_entry("dictionary", value)?;
        }
        if let Some(value) = self.regex() {
            state.serialize_entry("regex", value)?;
        }
        if let Some(value) = self.surrogate_type() {
            state.serialize_entry("surrogateType", value)?;
        }
        if let Some(value) = self.stored_type() {
            state.serialize_entry("storedType", value)?;
        }
        if !self.detection_rules.is_empty() {
            state.serialize_entry("detectionRules", &self.detection_rules)?;
        }
        if !wkt::internal::is_default(&self.exclusion_type) {
            state.serialize_entry("exclusionType", &self.exclusion_type)?;
        }
        if self.sensitivity_score.is_some() {
            state.serialize_entry("sensitivityScore", &self.sensitivity_score)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CustomInfoType].
pub mod custom_info_type {
    #[allow(unused_imports)]
    use super::*;

    /// Custom information type based on a dictionary of words or phrases. This can
    /// be used to match sensitive information specific to the data, such as a list
    /// of employee IDs or job titles.
    ///
    /// Dictionary words are case-insensitive and all characters other than letters
    /// and digits in the unicode [Basic Multilingual
    /// Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane)
    /// will be replaced with whitespace when scanning for matches, so the
    /// dictionary phrase "Sam Johnson" will match all three phrases "sam johnson",
    /// "Sam, Johnson", and "Sam (Johnson)". Additionally, the characters
    /// surrounding any match must be of a different type than the adjacent
    /// characters within the word, so letters must be next to non-letters and
    /// digits next to non-digits. For example, the dictionary word "jen" will
    /// match the first three letters of the text "jen123" but will return no
    /// matches for "jennifer".
    ///
    /// Dictionary words containing a large number of characters that are not
    /// letters or digits may result in unexpected findings because such characters
    /// are treated as whitespace. The
    /// [limits](https://cloud.google.com/sensitive-data-protection/limits) page
    /// contains details about the size limits of dictionaries. For dictionaries
    /// that do not fit within these constraints, consider using
    /// `LargeCustomDictionaryConfig` in the `StoredInfoType` API.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Dictionary {
        /// The potential places the data can be read from.
        pub source: std::option::Option<crate::model::custom_info_type::dictionary::Source>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Dictionary {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source][crate::model::custom_info_type::Dictionary::source].
        ///
        /// Note that all the setters affecting `source` are mutually
        /// exclusive.
        pub fn set_source<
            T: std::convert::Into<
                    std::option::Option<crate::model::custom_info_type::dictionary::Source>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::custom_info_type::Dictionary::source]
        /// if it holds a `WordList`, `None` if the field is not set or
        /// holds a different branch.
        pub fn word_list(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>,
        > {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::custom_info_type::dictionary::Source::WordList(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::custom_info_type::Dictionary::source]
        /// to hold a `WordList`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_word_list<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::custom_info_type::dictionary::Source::WordList(v.into()),
            );
            self
        }

        /// The value of [source][crate::model::custom_info_type::Dictionary::source]
        /// if it holds a `CloudStoragePath`, `None` if the field is not set or
        /// holds a different branch.
        pub fn cloud_storage_path(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStoragePath>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::custom_info_type::dictionary::Source::CloudStoragePath(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::custom_info_type::Dictionary::source]
        /// to hold a `CloudStoragePath`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_cloud_storage_path<
            T: std::convert::Into<std::boxed::Box<crate::model::CloudStoragePath>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::custom_info_type::dictionary::Source::CloudStoragePath(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Dictionary {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.Dictionary"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Dictionary {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __word_list,
                __cloud_storage_path,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Dictionary")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "wordList" => Ok(__FieldTag::__word_list),
                                "word_list" => Ok(__FieldTag::__word_list),
                                "cloudStoragePath" => Ok(__FieldTag::__cloud_storage_path),
                                "cloud_storage_path" => Ok(__FieldTag::__cloud_storage_path),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Dictionary;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Dictionary")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__word_list => {
                                if !fields.insert(__FieldTag::__word_list) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for word_list",
                                    ));
                                }
                                if result.source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source`, a oneof with full ID .google.privacy.dlp.v2.CustomInfoType.Dictionary.word_list, latest field was wordList",
                                    ));
                                }
                                result.source = std::option::Option::Some(
                                    crate::model::custom_info_type::dictionary::Source::WordList(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__cloud_storage_path => {
                                if !fields.insert(__FieldTag::__cloud_storage_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cloud_storage_path",
                                    ));
                                }
                                if result.source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source`, a oneof with full ID .google.privacy.dlp.v2.CustomInfoType.Dictionary.cloud_storage_path, latest field was cloudStoragePath",
                                    ));
                                }
                                result.source = std::option::Option::Some(
                                    crate::model::custom_info_type::dictionary::Source::CloudStoragePath(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::CloudStoragePath>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Dictionary {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.word_list() {
                state.serialize_entry("wordList", value)?;
            }
            if let Some(value) = self.cloud_storage_path() {
                state.serialize_entry("cloudStoragePath", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Dictionary].
    pub mod dictionary {
        #[allow(unused_imports)]
        use super::*;

        /// Message defining a list of words or phrases to search for in the data.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct WordList {
            /// Words or phrases defining the dictionary. The dictionary must contain
            /// at least one phrase and every phrase must contain at least 2 characters
            /// that are letters or digits. [required]
            pub words: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl WordList {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [words][crate::model::custom_info_type::dictionary::WordList::words].
            pub fn set_words<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.words = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for WordList {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for WordList {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __words,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for WordList")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "words" => Ok(__FieldTag::__words),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = WordList;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct WordList")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__words => {
                                    if !fields.insert(__FieldTag::__words) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for words"),
                                        );
                                    }
                                    result.words = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for WordList {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.words.is_empty() {
                    state.serialize_entry("words", &self.words)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The potential places the data can be read from.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Source {
            /// List of words or phrases to search for.
            WordList(std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>),
            /// Newline-delimited file of words in Cloud Storage. Only a single file
            /// is accepted.
            CloudStoragePath(std::boxed::Box<crate::model::CloudStoragePath>),
        }
    }

    /// Message defining a custom regular expression.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Regex {
        /// Pattern defining the regular expression. Its syntax
        /// (<https://github.com/google/re2/wiki/Syntax>) can be found under the
        /// google/re2 repository on GitHub.
        pub pattern: std::string::String,

        /// The index of the submatch to extract as findings. When not
        /// specified, the entire match is returned. No more than 3 may be included.
        pub group_indexes: std::vec::Vec<i32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Regex {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pattern][crate::model::custom_info_type::Regex::pattern].
        pub fn set_pattern<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.pattern = v.into();
            self
        }

        /// Sets the value of [group_indexes][crate::model::custom_info_type::Regex::group_indexes].
        pub fn set_group_indexes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i32>,
        {
            use std::iter::Iterator;
            self.group_indexes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Regex {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.Regex"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Regex {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __pattern,
                __group_indexes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Regex")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pattern" => Ok(__FieldTag::__pattern),
                                "groupIndexes" => Ok(__FieldTag::__group_indexes),
                                "group_indexes" => Ok(__FieldTag::__group_indexes),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Regex;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Regex")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__pattern => {
                                if !fields.insert(__FieldTag::__pattern) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pattern",
                                    ));
                                }
                                result.pattern = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__group_indexes => {
                                if !fields.insert(__FieldTag::__group_indexes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for group_indexes",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<i32>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.group_indexes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Regex {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.pattern.is_empty() {
                state.serialize_entry("pattern", &self.pattern)?;
            }
            if !self.group_indexes.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("groupIndexes", &__With(&self.group_indexes))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Message for detecting output from deidentification transformations
    /// such as
    /// [`CryptoReplaceFfxFpeConfig`](https://cloud.google.com/sensitive-data-protection/docs/reference/rest/v2/organizations.deidentifyTemplates#cryptoreplaceffxfpeconfig).
    /// These types of transformations are
    /// those that perform pseudonymization, thereby producing a "surrogate" as
    /// output. This should be used in conjunction with a field on the
    /// transformation such as `surrogate_info_type`. This CustomInfoType does
    /// not support the use of `detection_rules`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SurrogateType {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SurrogateType {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for SurrogateType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.SurrogateType"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SurrogateType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SurrogateType")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SurrogateType;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SurrogateType")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SurrogateType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Deprecated; use `InspectionRuleSet` instead. Rule for modifying a
    /// `CustomInfoType` to alter behavior under certain circumstances, depending
    /// on the specific details of the rule. Not supported for the `surrogate_type`
    /// custom infoType.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DetectionRule {
        /// Type of hotword rule.
        pub r#type: std::option::Option<crate::model::custom_info_type::detection_rule::Type>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DetectionRule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::custom_info_type::DetectionRule::type].
        ///
        /// Note that all the setters affecting `r#type` are mutually
        /// exclusive.
        pub fn set_type<
            T: std::convert::Into<
                    std::option::Option<crate::model::custom_info_type::detection_rule::Type>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// The value of [r#type][crate::model::custom_info_type::DetectionRule::r#type]
        /// if it holds a `HotwordRule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn hotword_rule(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
        > {
            #[allow(unreachable_patterns)]
            self.r#type.as_ref().and_then(|v| match v {
                crate::model::custom_info_type::detection_rule::Type::HotwordRule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#type][crate::model::custom_info_type::DetectionRule::r#type]
        /// to hold a `HotwordRule`.
        ///
        /// Note that all the setters affecting `r#type` are
        /// mutually exclusive.
        pub fn set_hotword_rule<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = std::option::Option::Some(
                crate::model::custom_info_type::detection_rule::Type::HotwordRule(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for DetectionRule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DetectionRule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __hotword_rule,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DetectionRule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "hotwordRule" => Ok(__FieldTag::__hotword_rule),
                                "hotword_rule" => Ok(__FieldTag::__hotword_rule),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DetectionRule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DetectionRule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__hotword_rule => {
                                if !fields.insert(__FieldTag::__hotword_rule) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hotword_rule",
                                    ));
                                }
                                if result.r#type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.CustomInfoType.DetectionRule.hotword_rule, latest field was hotwordRule",
                                    ));
                                }
                                result.r#type = std::option::Option::Some(
                                    crate::model::custom_info_type::detection_rule::Type::HotwordRule(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DetectionRule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.hotword_rule() {
                state.serialize_entry("hotwordRule", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [DetectionRule].
    pub mod detection_rule {
        #[allow(unused_imports)]
        use super::*;

        /// Message for specifying a window around a finding to apply a detection
        /// rule.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Proximity {
            /// Number of characters before the finding to consider. For tabular data,
            /// if you want to modify the likelihood of an entire column of findngs,
            /// set this to 1. For more information, see
            /// [Hotword example: Set the match likelihood of a table column]
            /// (<https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes-likelihood#match-column-values>).
            pub window_before: i32,

            /// Number of characters after the finding to consider.
            pub window_after: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Proximity {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [window_before][crate::model::custom_info_type::detection_rule::Proximity::window_before].
            pub fn set_window_before<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.window_before = v.into();
                self
            }

            /// Sets the value of [window_after][crate::model::custom_info_type::detection_rule::Proximity::window_after].
            pub fn set_window_after<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.window_after = v.into();
                self
            }
        }

        impl wkt::message::Message for Proximity {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Proximity {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __window_before,
                    __window_after,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Proximity")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "windowBefore" => Ok(__FieldTag::__window_before),
                                    "window_before" => Ok(__FieldTag::__window_before),
                                    "windowAfter" => Ok(__FieldTag::__window_after),
                                    "window_after" => Ok(__FieldTag::__window_after),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Proximity;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Proximity")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__window_before => {
                                    if !fields.insert(__FieldTag::__window_before) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for window_before",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.window_before =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__window_after => {
                                    if !fields.insert(__FieldTag::__window_after) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for window_after",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.window_after =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Proximity {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.window_before) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("windowBefore", &__With(&self.window_before))?;
                }
                if !wkt::internal::is_default(&self.window_after) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("windowAfter", &__With(&self.window_after))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Message for specifying an adjustment to the likelihood of a finding as
        /// part of a detection rule.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct LikelihoodAdjustment {
            /// How the likelihood will be modified.
            pub adjustment: std::option::Option<
                crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl LikelihoodAdjustment {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment].
            ///
            /// Note that all the setters affecting `adjustment` are mutually
            /// exclusive.
            pub fn set_adjustment<T: std::convert::Into<std::option::Option<crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment>>>(mut self, v: T) -> Self
            {
                self.adjustment = v.into();
                self
            }

            /// The value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// if it holds a `FixedLikelihood`, `None` if the field is not set or
            /// holds a different branch.
            pub fn fixed_likelihood(&self) -> std::option::Option<&crate::model::Likelihood> {
                #[allow(unreachable_patterns)]
                self.adjustment.as_ref().and_then(|v| match v {
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::FixedLikelihood(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// to hold a `FixedLikelihood`.
            ///
            /// Note that all the setters affecting `adjustment` are
            /// mutually exclusive.
            pub fn set_fixed_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
                mut self,
                v: T,
            ) -> Self {
                self.adjustment = std::option::Option::Some(
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::FixedLikelihood(
                        v.into()
                    )
                );
                self
            }

            /// The value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// if it holds a `RelativeLikelihood`, `None` if the field is not set or
            /// holds a different branch.
            pub fn relative_likelihood(&self) -> std::option::Option<&i32> {
                #[allow(unreachable_patterns)]
                self.adjustment.as_ref().and_then(|v| match v {
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::RelativeLikelihood(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// to hold a `RelativeLikelihood`.
            ///
            /// Note that all the setters affecting `adjustment` are
            /// mutually exclusive.
            pub fn set_relative_likelihood<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.adjustment = std::option::Option::Some(
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::RelativeLikelihood(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for LikelihoodAdjustment {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for LikelihoodAdjustment {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __fixed_likelihood,
                    __relative_likelihood,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for LikelihoodAdjustment")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "fixedLikelihood" => Ok(__FieldTag::__fixed_likelihood),
                                    "fixed_likelihood" => Ok(__FieldTag::__fixed_likelihood),
                                    "relativeLikelihood" => Ok(__FieldTag::__relative_likelihood),
                                    "relative_likelihood" => Ok(__FieldTag::__relative_likelihood),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = LikelihoodAdjustment;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct LikelihoodAdjustment")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__fixed_likelihood => {
                                    if !fields.insert(__FieldTag::__fixed_likelihood) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for fixed_likelihood",
                                            ),
                                        );
                                    }
                                    if result.adjustment.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `adjustment`, a oneof with full ID .google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment.fixed_likelihood, latest field was fixedLikelihood",
                                            ),
                                        );
                                    }
                                    result.adjustment = std::option::Option::Some(
                                        crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::FixedLikelihood(
                                            map.next_value::<std::option::Option<crate::model::Likelihood>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__relative_likelihood => {
                                    if !fields.insert(__FieldTag::__relative_likelihood) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for relative_likelihood",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    if result.adjustment.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `adjustment`, a oneof with full ID .google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment.relative_likelihood, latest field was relativeLikelihood",
                                            ),
                                        );
                                    }
                                    result.adjustment = std::option::Option::Some(
                                        crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::RelativeLikelihood(
                                            map.next_value::<__With>()?.0.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for LikelihoodAdjustment {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.fixed_likelihood() {
                    state.serialize_entry("fixedLikelihood", value)?;
                }
                if let Some(value) = self.relative_likelihood() {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("relativeLikelihood", &__With(value))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [LikelihoodAdjustment].
        pub mod likelihood_adjustment {
            #[allow(unused_imports)]
            use super::*;

            /// How the likelihood will be modified.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Adjustment {
                /// Set the likelihood of a finding to a fixed value.
                FixedLikelihood(crate::model::Likelihood),
                /// Increase or decrease the likelihood by the specified number of
                /// levels. For example, if a finding would be `POSSIBLE` without the
                /// detection rule and `relative_likelihood` is 1, then it is upgraded to
                /// `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`.
                /// Likelihood may never drop below `VERY_UNLIKELY` or exceed
                /// `VERY_LIKELY`, so applying an adjustment of 1 followed by an
                /// adjustment of -1 when base likelihood is `VERY_LIKELY` will result in
                /// a final likelihood of `LIKELY`.
                RelativeLikelihood(i32),
            }
        }

        /// The rule that adjusts the likelihood of findings within a certain
        /// proximity of hotwords.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct HotwordRule {
            /// Regular expression pattern defining what qualifies as a hotword.
            pub hotword_regex: std::option::Option<crate::model::custom_info_type::Regex>,

            /// Range of characters within which the entire hotword must reside.
            /// The total length of the window cannot exceed 1000 characters.
            /// The finding itself will be included in the window, so that hotwords can
            /// be used to match substrings of the finding itself. Suppose you
            /// want Cloud DLP to promote the likelihood of the phone number
            /// regex "\(\d{3}\) \d{3}-\d{4}" if the area code is known to be the
            /// area code of a company's office. In this case, use the hotword regex
            /// "\(xxx\)", where "xxx" is the area code in question.
            ///
            /// For tabular data, if you want to modify the likelihood of an entire
            /// column of findngs, see
            /// [Hotword example: Set the match likelihood of a table column]
            /// (<https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes-likelihood#match-column-values>).
            pub proximity:
                std::option::Option<crate::model::custom_info_type::detection_rule::Proximity>,

            /// Likelihood adjustment to apply to all matching findings.
            pub likelihood_adjustment: std::option::Option<
                crate::model::custom_info_type::detection_rule::LikelihoodAdjustment,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl HotwordRule {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [hotword_regex][crate::model::custom_info_type::detection_rule::HotwordRule::hotword_regex].
            pub fn set_hotword_regex<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::custom_info_type::Regex>,
            {
                self.hotword_regex = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [hotword_regex][crate::model::custom_info_type::detection_rule::HotwordRule::hotword_regex].
            pub fn set_or_clear_hotword_regex<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::custom_info_type::Regex>,
            {
                self.hotword_regex = v.map(|x| x.into());
                self
            }

            /// Sets the value of [proximity][crate::model::custom_info_type::detection_rule::HotwordRule::proximity].
            pub fn set_proximity<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::custom_info_type::detection_rule::Proximity>,
            {
                self.proximity = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [proximity][crate::model::custom_info_type::detection_rule::HotwordRule::proximity].
            pub fn set_or_clear_proximity<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::custom_info_type::detection_rule::Proximity>,
            {
                self.proximity = v.map(|x| x.into());
                self
            }

            /// Sets the value of [likelihood_adjustment][crate::model::custom_info_type::detection_rule::HotwordRule::likelihood_adjustment].
            pub fn set_likelihood_adjustment<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::custom_info_type::detection_rule::LikelihoodAdjustment,
                    >,
            {
                self.likelihood_adjustment = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [likelihood_adjustment][crate::model::custom_info_type::detection_rule::HotwordRule::likelihood_adjustment].
            pub fn set_or_clear_likelihood_adjustment<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<
                        crate::model::custom_info_type::detection_rule::LikelihoodAdjustment,
                    >,
            {
                self.likelihood_adjustment = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for HotwordRule {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for HotwordRule {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __hotword_regex,
                    __proximity,
                    __likelihood_adjustment,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for HotwordRule")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "hotwordRegex" => Ok(__FieldTag::__hotword_regex),
                                    "hotword_regex" => Ok(__FieldTag::__hotword_regex),
                                    "proximity" => Ok(__FieldTag::__proximity),
                                    "likelihoodAdjustment" => {
                                        Ok(__FieldTag::__likelihood_adjustment)
                                    }
                                    "likelihood_adjustment" => {
                                        Ok(__FieldTag::__likelihood_adjustment)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = HotwordRule;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct HotwordRule")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__hotword_regex => {
                                    if !fields.insert(__FieldTag::__hotword_regex) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for hotword_regex",
                                            ),
                                        );
                                    }
                                    result.hotword_regex = map
                                        .next_value::<std::option::Option<
                                            crate::model::custom_info_type::Regex,
                                        >>()?;
                                }
                                __FieldTag::__proximity => {
                                    if !fields.insert(__FieldTag::__proximity) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for proximity",
                                            ),
                                        );
                                    }
                                    result.proximity = map.next_value::<std::option::Option<
                                        crate::model::custom_info_type::detection_rule::Proximity,
                                    >>(
                                    )?;
                                }
                                __FieldTag::__likelihood_adjustment => {
                                    if !fields.insert(__FieldTag::__likelihood_adjustment) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for likelihood_adjustment",
                                            ),
                                        );
                                    }
                                    result.likelihood_adjustment = map.next_value::<std::option::Option<crate::model::custom_info_type::detection_rule::LikelihoodAdjustment>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for HotwordRule {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.hotword_regex.is_some() {
                    state.serialize_entry("hotwordRegex", &self.hotword_regex)?;
                }
                if self.proximity.is_some() {
                    state.serialize_entry("proximity", &self.proximity)?;
                }
                if self.likelihood_adjustment.is_some() {
                    state.serialize_entry("likelihoodAdjustment", &self.likelihood_adjustment)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Type of hotword rule.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Hotword-based detection rule.
            HotwordRule(
                std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
            ),
        }
    }

    /// Type of exclusion rule.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExclusionType {
        /// A finding of this custom info type will not be excluded from results.
        Unspecified,
        /// A finding of this custom info type will be excluded from final results,
        /// but can still affect rule execution.
        Exclude,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExclusionType::value] or
        /// [ExclusionType::name].
        UnknownValue(exclusion_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod exclusion_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExclusionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Exclude => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXCLUSION_TYPE_UNSPECIFIED"),
                Self::Exclude => std::option::Option::Some("EXCLUSION_TYPE_EXCLUDE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExclusionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExclusionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExclusionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Exclude,
                _ => Self::UnknownValue(exclusion_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExclusionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXCLUSION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "EXCLUSION_TYPE_EXCLUDE" => Self::Exclude,
                _ => Self::UnknownValue(exclusion_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExclusionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Exclude => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExclusionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExclusionType>::new(
                ".google.privacy.dlp.v2.CustomInfoType.ExclusionType",
            ))
        }
    }

    /// Type of custom detector.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// A list of phrases to detect as a CustomInfoType.
        Dictionary(std::boxed::Box<crate::model::custom_info_type::Dictionary>),
        /// Regular expression based CustomInfoType.
        Regex(std::boxed::Box<crate::model::custom_info_type::Regex>),
        /// Message for detecting output from deidentification transformations that
        /// support reversing.
        SurrogateType(std::boxed::Box<crate::model::custom_info_type::SurrogateType>),
        /// Load an existing `StoredInfoType` resource for use in
        /// `InspectDataSource`. Not currently supported in `InspectContent`.
        StoredType(std::boxed::Box<crate::model::StoredType>),
    }
}

/// General identifier of a data field in a storage service.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FieldId {
    /// Name describing the field.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FieldId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FieldId::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for FieldId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FieldId"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FieldId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FieldId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FieldId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FieldId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FieldId {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Datastore partition ID.
/// A partition ID identifies a grouping of entities. The grouping is always
/// by project and namespace, however the namespace ID may be empty.
///
/// A partition ID contains several dimensions:
/// project ID and namespace ID.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PartitionId {
    /// The ID of the project to which the entities belong.
    pub project_id: std::string::String,

    /// If not empty, the ID of the namespace to which the entities belong.
    pub namespace_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PartitionId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PartitionId::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [namespace_id][crate::model::PartitionId::namespace_id].
    pub fn set_namespace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace_id = v.into();
        self
    }
}

impl wkt::message::Message for PartitionId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.PartitionId"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PartitionId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __namespace_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartitionId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "namespaceId" => Ok(__FieldTag::__namespace_id),
                            "namespace_id" => Ok(__FieldTag::__namespace_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PartitionId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartitionId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__namespace_id => {
                            if !fields.insert(__FieldTag::__namespace_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace_id",
                                ));
                            }
                            result.namespace_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PartitionId {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.namespace_id.is_empty() {
            state.serialize_entry("namespaceId", &self.namespace_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A representation of a Datastore kind.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KindExpression {
    /// The name of the kind.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KindExpression {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KindExpression::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for KindExpression {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.KindExpression"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KindExpression {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KindExpression")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KindExpression;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KindExpression")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KindExpression {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options defining a data set within Google Cloud Datastore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatastoreOptions {
    /// A partition ID identifies a grouping of entities. The grouping is always
    /// by project and namespace, however the namespace ID may be empty.
    pub partition_id: std::option::Option<crate::model::PartitionId>,

    /// The kind to process.
    pub kind: std::option::Option<crate::model::KindExpression>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatastoreOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partition_id][crate::model::DatastoreOptions::partition_id].
    pub fn set_partition_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PartitionId>,
    {
        self.partition_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [partition_id][crate::model::DatastoreOptions::partition_id].
    pub fn set_or_clear_partition_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PartitionId>,
    {
        self.partition_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::DatastoreOptions::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KindExpression>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::DatastoreOptions::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KindExpression>,
    {
        self.kind = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DatastoreOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatastoreOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatastoreOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __partition_id,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatastoreOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "partitionId" => Ok(__FieldTag::__partition_id),
                            "partition_id" => Ok(__FieldTag::__partition_id),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatastoreOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatastoreOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__partition_id => {
                            if !fields.insert(__FieldTag::__partition_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition_id",
                                ));
                            }
                            result.partition_id =
                                map.next_value::<std::option::Option<crate::model::PartitionId>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<crate::model::KindExpression>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatastoreOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.partition_id.is_some() {
            state.serialize_entry("partitionId", &self.partition_id)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message representing a set of files in a Cloud Storage bucket. Regular
/// expressions are used to allow fine-grained control over which files in the
/// bucket to include.
///
/// Included files are those that match at least one item in `include_regex` and
/// do not match any items in `exclude_regex`. Note that a file that matches
/// items from both lists will _not_ be included. For a match to occur, the
/// entire file path (i.e., everything in the url after the bucket name) must
/// match the regular expression.
///
/// For example, given the input `{bucket_name: "mybucket", include_regex:
/// ["directory1/.*"], exclude_regex:
/// ["directory1/excluded.*"]}`:
///
/// * `gs://mybucket/directory1/myfile` will be included
/// * `gs://mybucket/directory1/directory2/myfile` will be included (`.*` matches
///   across `/`)
/// * `gs://mybucket/directory0/directory1/myfile` will _not_ be included (the
///   full path doesn't match any items in `include_regex`)
/// * `gs://mybucket/directory1/excludedfile` will _not_ be included (the path
///   matches an item in `exclude_regex`)
///
/// If `include_regex` is left empty, it will match all files by default
/// (this is equivalent to setting `include_regex: [".*"]`).
///
/// Some other common use cases:
///
/// * `{bucket_name: "mybucket", exclude_regex: [".*\.pdf"]}` will include all
///   files in `mybucket` except for .pdf files
/// * `{bucket_name: "mybucket", include_regex: ["directory/[^/]+"]}` will
///   include all files directly under `gs://mybucket/directory/`, without matching
///   across `/`
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStorageRegexFileSet {
    /// The name of a Cloud Storage bucket. Required.
    pub bucket_name: std::string::String,

    /// A list of regular expressions matching file paths to include. All files in
    /// the bucket that match at least one of these regular expressions will be
    /// included in the set of files, except for those that also match an item in
    /// `exclude_regex`. Leaving this field empty will match all files by default
    /// (this is equivalent to including `.*` in the list).
    ///
    /// Regular expressions use RE2
    /// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
    /// under the google/re2 repository on GitHub.
    pub include_regex: std::vec::Vec<std::string::String>,

    /// A list of regular expressions matching file paths to exclude. All files in
    /// the bucket that match at least one of these regular expressions will be
    /// excluded from the scan.
    ///
    /// Regular expressions use RE2
    /// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
    /// under the google/re2 repository on GitHub.
    pub exclude_regex: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageRegexFileSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::CloudStorageRegexFileSet::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [include_regex][crate::model::CloudStorageRegexFileSet::include_regex].
    pub fn set_include_regex<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.include_regex = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclude_regex][crate::model::CloudStorageRegexFileSet::exclude_regex].
    pub fn set_exclude_regex<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclude_regex = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudStorageRegexFileSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageRegexFileSet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudStorageRegexFileSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket_name,
            __include_regex,
            __exclude_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudStorageRegexFileSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucketName" => Ok(__FieldTag::__bucket_name),
                            "bucket_name" => Ok(__FieldTag::__bucket_name),
                            "includeRegex" => Ok(__FieldTag::__include_regex),
                            "include_regex" => Ok(__FieldTag::__include_regex),
                            "excludeRegex" => Ok(__FieldTag::__exclude_regex),
                            "exclude_regex" => Ok(__FieldTag::__exclude_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudStorageRegexFileSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudStorageRegexFileSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket_name => {
                            if !fields.insert(__FieldTag::__bucket_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name",
                                ));
                            }
                            result.bucket_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__include_regex => {
                            if !fields.insert(__FieldTag::__include_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_regex",
                                ));
                            }
                            result.include_regex = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclude_regex => {
                            if !fields.insert(__FieldTag::__exclude_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_regex",
                                ));
                            }
                            result.exclude_regex = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudStorageRegexFileSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket_name.is_empty() {
            state.serialize_entry("bucketName", &self.bucket_name)?;
        }
        if !self.include_regex.is_empty() {
            state.serialize_entry("includeRegex", &self.include_regex)?;
        }
        if !self.exclude_regex.is_empty() {
            state.serialize_entry("excludeRegex", &self.exclude_regex)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options defining a file or a set of files within a Cloud Storage
/// bucket.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStorageOptions {
    /// The set of one or more files to scan.
    pub file_set: std::option::Option<crate::model::cloud_storage_options::FileSet>,

    /// Max number of bytes to scan from a file. If a scanned file's size is bigger
    /// than this value then the rest of the bytes are omitted. Only one of
    /// `bytes_limit_per_file` and `bytes_limit_per_file_percent` can be specified.
    /// This field can't be set if de-identification is requested. For certain file
    /// types, setting this field has no effect. For more information, see [Limits
    /// on bytes scanned per
    /// file](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types#max-byte-size-per-file).
    pub bytes_limit_per_file: i64,

    /// Max percentage of bytes to scan from a file. The rest are omitted. The
    /// number of bytes scanned is rounded down. Must be between 0 and 100,
    /// inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
    /// bytes_limit_per_file and bytes_limit_per_file_percent can be specified.
    /// This field can't be set if de-identification is requested. For certain file
    /// types, setting this field has no effect. For more information, see [Limits
    /// on bytes scanned per
    /// file](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types#max-byte-size-per-file).
    pub bytes_limit_per_file_percent: i32,

    /// List of file type groups to include in the scan.
    /// If empty, all files are scanned and available data format processors
    /// are applied. In addition, the binary content of the selected files
    /// is always scanned as well.
    /// Images are scanned only as binary if the specified region
    /// does not support image inspection and no file_types were specified.
    /// Image inspection is restricted to 'global', 'us', 'asia', and 'europe'.
    pub file_types: std::vec::Vec<crate::model::FileType>,

    /// How to sample the data.
    pub sample_method: crate::model::cloud_storage_options::SampleMethod,

    /// Limits the number of files to scan to this percentage of the input FileSet.
    /// Number of files scanned is rounded down. Must be between 0 and 100,
    /// inclusively. Both 0 and 100 means no limit. Defaults to 0.
    pub files_limit_percent: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_set][crate::model::CloudStorageOptions::file_set].
    pub fn set_file_set<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cloud_storage_options::FileSet>,
    {
        self.file_set = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_set][crate::model::CloudStorageOptions::file_set].
    pub fn set_or_clear_file_set<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cloud_storage_options::FileSet>,
    {
        self.file_set = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bytes_limit_per_file][crate::model::CloudStorageOptions::bytes_limit_per_file].
    pub fn set_bytes_limit_per_file<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_limit_per_file = v.into();
        self
    }

    /// Sets the value of [bytes_limit_per_file_percent][crate::model::CloudStorageOptions::bytes_limit_per_file_percent].
    pub fn set_bytes_limit_per_file_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.bytes_limit_per_file_percent = v.into();
        self
    }

    /// Sets the value of [file_types][crate::model::CloudStorageOptions::file_types].
    pub fn set_file_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileType>,
    {
        use std::iter::Iterator;
        self.file_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sample_method][crate::model::CloudStorageOptions::sample_method].
    pub fn set_sample_method<
        T: std::convert::Into<crate::model::cloud_storage_options::SampleMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_method = v.into();
        self
    }

    /// Sets the value of [files_limit_percent][crate::model::CloudStorageOptions::files_limit_percent].
    pub fn set_files_limit_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.files_limit_percent = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudStorageOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_set,
            __bytes_limit_per_file,
            __bytes_limit_per_file_percent,
            __file_types,
            __sample_method,
            __files_limit_percent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudStorageOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileSet" => Ok(__FieldTag::__file_set),
                            "file_set" => Ok(__FieldTag::__file_set),
                            "bytesLimitPerFile" => Ok(__FieldTag::__bytes_limit_per_file),
                            "bytes_limit_per_file" => Ok(__FieldTag::__bytes_limit_per_file),
                            "bytesLimitPerFilePercent" => {
                                Ok(__FieldTag::__bytes_limit_per_file_percent)
                            }
                            "bytes_limit_per_file_percent" => {
                                Ok(__FieldTag::__bytes_limit_per_file_percent)
                            }
                            "fileTypes" => Ok(__FieldTag::__file_types),
                            "file_types" => Ok(__FieldTag::__file_types),
                            "sampleMethod" => Ok(__FieldTag::__sample_method),
                            "sample_method" => Ok(__FieldTag::__sample_method),
                            "filesLimitPercent" => Ok(__FieldTag::__files_limit_percent),
                            "files_limit_percent" => Ok(__FieldTag::__files_limit_percent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudStorageOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudStorageOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_set => {
                            if !fields.insert(__FieldTag::__file_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_set",
                                ));
                            }
                            result.file_set =
                                map.next_value::<std::option::Option<
                                    crate::model::cloud_storage_options::FileSet,
                                >>()?;
                        }
                        __FieldTag::__bytes_limit_per_file => {
                            if !fields.insert(__FieldTag::__bytes_limit_per_file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_limit_per_file",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_limit_per_file =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_limit_per_file_percent => {
                            if !fields.insert(__FieldTag::__bytes_limit_per_file_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_limit_per_file_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_limit_per_file_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__file_types => {
                            if !fields.insert(__FieldTag::__file_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_types",
                                ));
                            }
                            result.file_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FileType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sample_method => {
                            if !fields.insert(__FieldTag::__sample_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_method",
                                ));
                            }
                            result.sample_method = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_storage_options::SampleMethod,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__files_limit_percent => {
                            if !fields.insert(__FieldTag::__files_limit_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for files_limit_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.files_limit_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudStorageOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.file_set.is_some() {
            state.serialize_entry("fileSet", &self.file_set)?;
        }
        if !wkt::internal::is_default(&self.bytes_limit_per_file) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("bytesLimitPerFile", &__With(&self.bytes_limit_per_file))?;
        }
        if !wkt::internal::is_default(&self.bytes_limit_per_file_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "bytesLimitPerFilePercent",
                &__With(&self.bytes_limit_per_file_percent),
            )?;
        }
        if !self.file_types.is_empty() {
            state.serialize_entry("fileTypes", &self.file_types)?;
        }
        if !wkt::internal::is_default(&self.sample_method) {
            state.serialize_entry("sampleMethod", &self.sample_method)?;
        }
        if !wkt::internal::is_default(&self.files_limit_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("filesLimitPercent", &__With(&self.files_limit_percent))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CloudStorageOptions].
pub mod cloud_storage_options {
    #[allow(unused_imports)]
    use super::*;

    /// Set of files to scan.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FileSet {
        /// The Cloud Storage url of the file(s) to scan, in the format
        /// `gs://<bucket>/<path>`. Trailing wildcard in the path is allowed.
        ///
        /// If the url ends in a trailing slash, the bucket or directory represented
        /// by the url will be scanned non-recursively (content in sub-directories
        /// will not be scanned). This means that `gs://mybucket/` is equivalent to
        /// `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to
        /// `gs://mybucket/directory/*`.
        ///
        /// Exactly one of `url` or `regex_file_set` must be set.
        pub url: std::string::String,

        /// The regex-filtered set of files to scan. Exactly one of `url` or
        /// `regex_file_set` must be set.
        pub regex_file_set: std::option::Option<crate::model::CloudStorageRegexFileSet>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FileSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [url][crate::model::cloud_storage_options::FileSet::url].
        pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.url = v.into();
            self
        }

        /// Sets the value of [regex_file_set][crate::model::cloud_storage_options::FileSet::regex_file_set].
        pub fn set_regex_file_set<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::CloudStorageRegexFileSet>,
        {
            self.regex_file_set = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [regex_file_set][crate::model::cloud_storage_options::FileSet::regex_file_set].
        pub fn set_or_clear_regex_file_set<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::CloudStorageRegexFileSet>,
        {
            self.regex_file_set = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for FileSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CloudStorageOptions.FileSet"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FileSet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __url,
                __regex_file_set,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FileSet")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "url" => Ok(__FieldTag::__url),
                                "regexFileSet" => Ok(__FieldTag::__regex_file_set),
                                "regex_file_set" => Ok(__FieldTag::__regex_file_set),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FileSet;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FileSet")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__url => {
                                if !fields.insert(__FieldTag::__url) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for url",
                                    ));
                                }
                                result.url = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__regex_file_set => {
                                if !fields.insert(__FieldTag::__regex_file_set) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for regex_file_set",
                                    ));
                                }
                                result.regex_file_set = map.next_value::<std::option::Option<crate::model::CloudStorageRegexFileSet>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FileSet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.url.is_empty() {
                state.serialize_entry("url", &self.url)?;
            }
            if self.regex_file_set.is_some() {
                state.serialize_entry("regexFileSet", &self.regex_file_set)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// How to sample bytes if not all bytes are scanned. Meaningful only when used
    /// in conjunction with bytes_limit_per_file. If not specified, scanning would
    /// start from the top.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SampleMethod {
        /// No sampling.
        Unspecified,
        /// Scan from the top (default).
        Top,
        /// For each file larger than bytes_limit_per_file, randomly pick the offset
        /// to start scanning. The scanned bytes are contiguous.
        RandomStart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SampleMethod::value] or
        /// [SampleMethod::name].
        UnknownValue(sample_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sample_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SampleMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Top => std::option::Option::Some(1),
                Self::RandomStart => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SAMPLE_METHOD_UNSPECIFIED"),
                Self::Top => std::option::Option::Some("TOP"),
                Self::RandomStart => std::option::Option::Some("RANDOM_START"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SampleMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SampleMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SampleMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Top,
                2 => Self::RandomStart,
                _ => Self::UnknownValue(sample_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SampleMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SAMPLE_METHOD_UNSPECIFIED" => Self::Unspecified,
                "TOP" => Self::Top,
                "RANDOM_START" => Self::RandomStart,
                _ => Self::UnknownValue(sample_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SampleMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Top => serializer.serialize_i32(1),
                Self::RandomStart => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SampleMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SampleMethod>::new(
                ".google.privacy.dlp.v2.CloudStorageOptions.SampleMethod",
            ))
        }
    }
}

/// Message representing a set of files in Cloud Storage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStorageFileSet {
    /// The url, in the format `gs://<bucket>/<path>`. Trailing wildcard in the
    /// path is allowed.
    pub url: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageFileSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::CloudStorageFileSet::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageFileSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageFileSet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudStorageFileSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudStorageFileSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudStorageFileSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudStorageFileSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudStorageFileSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message representing a single file or path in Cloud Storage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStoragePath {
    /// A URL representing a file or path (no wildcards) in Cloud Storage.
    /// Example: `gs://[BUCKET_NAME]/dictionary.txt`
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStoragePath {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::CloudStoragePath::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for CloudStoragePath {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStoragePath"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudStoragePath {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudStoragePath")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudStoragePath;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudStoragePath")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudStoragePath {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options defining BigQuery table and row identifiers.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryOptions {
    /// Complete BigQuery table reference.
    pub table_reference: std::option::Option<crate::model::BigQueryTable>,

    /// Table fields that may uniquely identify a row within the table. When
    /// `actions.saveFindings.outputConfig.table` is specified, the values of
    /// columns specified here are available in the output table under
    /// `location.content_locations.record_location.record_key.id_values`. Nested
    /// fields such as `person.birthdate.year` are allowed.
    pub identifying_fields: std::vec::Vec<crate::model::FieldId>,

    /// Max number of rows to scan. If the table has more rows than this value, the
    /// rest of the rows are omitted. If not set, or if set to 0, all rows will be
    /// scanned. Only one of rows_limit and rows_limit_percent can be specified.
    /// Cannot be used in conjunction with TimespanConfig.
    pub rows_limit: i64,

    /// Max percentage of rows to scan. The rest are omitted. The number of rows
    /// scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and
    /// 100 means no limit. Defaults to 0. Only one of rows_limit and
    /// rows_limit_percent can be specified. Cannot be used in conjunction with
    /// TimespanConfig.
    ///
    /// Caution: A [known
    /// issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#bq-sampling)
    /// is causing the `rowsLimitPercent` field to behave unexpectedly. We
    /// recommend using `rowsLimit` instead.
    pub rows_limit_percent: i32,

    /// How to sample the data.
    pub sample_method: crate::model::big_query_options::SampleMethod,

    /// References to fields excluded from scanning. This allows you to skip
    /// inspection of entire columns which you know have no findings.
    /// When inspecting a table, we recommend that you inspect all columns.
    /// Otherwise, findings might be affected because hints from excluded columns
    /// will not be used.
    pub excluded_fields: std::vec::Vec<crate::model::FieldId>,

    /// Limit scanning only to these fields.
    /// When inspecting a table, we recommend that you inspect all columns.
    /// Otherwise, findings might be affected because hints from excluded columns
    /// will not be used.
    pub included_fields: std::vec::Vec<crate::model::FieldId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_reference][crate::model::BigQueryOptions::table_reference].
    pub fn set_table_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.table_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table_reference][crate::model::BigQueryOptions::table_reference].
    pub fn set_or_clear_table_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.table_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [identifying_fields][crate::model::BigQueryOptions::identifying_fields].
    pub fn set_identifying_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.identifying_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rows_limit][crate::model::BigQueryOptions::rows_limit].
    pub fn set_rows_limit<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.rows_limit = v.into();
        self
    }

    /// Sets the value of [rows_limit_percent][crate::model::BigQueryOptions::rows_limit_percent].
    pub fn set_rows_limit_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rows_limit_percent = v.into();
        self
    }

    /// Sets the value of [sample_method][crate::model::BigQueryOptions::sample_method].
    pub fn set_sample_method<
        T: std::convert::Into<crate::model::big_query_options::SampleMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_method = v.into();
        self
    }

    /// Sets the value of [excluded_fields][crate::model::BigQueryOptions::excluded_fields].
    pub fn set_excluded_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.excluded_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [included_fields][crate::model::BigQueryOptions::included_fields].
    pub fn set_included_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.included_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table_reference,
            __identifying_fields,
            __rows_limit,
            __rows_limit_percent,
            __sample_method,
            __excluded_fields,
            __included_fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tableReference" => Ok(__FieldTag::__table_reference),
                            "table_reference" => Ok(__FieldTag::__table_reference),
                            "identifyingFields" => Ok(__FieldTag::__identifying_fields),
                            "identifying_fields" => Ok(__FieldTag::__identifying_fields),
                            "rowsLimit" => Ok(__FieldTag::__rows_limit),
                            "rows_limit" => Ok(__FieldTag::__rows_limit),
                            "rowsLimitPercent" => Ok(__FieldTag::__rows_limit_percent),
                            "rows_limit_percent" => Ok(__FieldTag::__rows_limit_percent),
                            "sampleMethod" => Ok(__FieldTag::__sample_method),
                            "sample_method" => Ok(__FieldTag::__sample_method),
                            "excludedFields" => Ok(__FieldTag::__excluded_fields),
                            "excluded_fields" => Ok(__FieldTag::__excluded_fields),
                            "includedFields" => Ok(__FieldTag::__included_fields),
                            "included_fields" => Ok(__FieldTag::__included_fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table_reference => {
                            if !fields.insert(__FieldTag::__table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_reference",
                                ));
                            }
                            result.table_reference = map
                                .next_value::<std::option::Option<crate::model::BigQueryTable>>()?;
                        }
                        __FieldTag::__identifying_fields => {
                            if !fields.insert(__FieldTag::__identifying_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identifying_fields",
                                ));
                            }
                            result.identifying_fields = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FieldId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rows_limit => {
                            if !fields.insert(__FieldTag::__rows_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rows_limit",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.rows_limit = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__rows_limit_percent => {
                            if !fields.insert(__FieldTag::__rows_limit_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rows_limit_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.rows_limit_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__sample_method => {
                            if !fields.insert(__FieldTag::__sample_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_method",
                                ));
                            }
                            result.sample_method =
                                map.next_value::<std::option::Option<
                                    crate::model::big_query_options::SampleMethod,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__excluded_fields => {
                            if !fields.insert(__FieldTag::__excluded_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excluded_fields",
                                ));
                            }
                            result.excluded_fields = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FieldId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__included_fields => {
                            if !fields.insert(__FieldTag::__included_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for included_fields",
                                ));
                            }
                            result.included_fields = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FieldId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.table_reference.is_some() {
            state.serialize_entry("tableReference", &self.table_reference)?;
        }
        if !self.identifying_fields.is_empty() {
            state.serialize_entry("identifyingFields", &self.identifying_fields)?;
        }
        if !wkt::internal::is_default(&self.rows_limit) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rowsLimit", &__With(&self.rows_limit))?;
        }
        if !wkt::internal::is_default(&self.rows_limit_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rowsLimitPercent", &__With(&self.rows_limit_percent))?;
        }
        if !wkt::internal::is_default(&self.sample_method) {
            state.serialize_entry("sampleMethod", &self.sample_method)?;
        }
        if !self.excluded_fields.is_empty() {
            state.serialize_entry("excludedFields", &self.excluded_fields)?;
        }
        if !self.included_fields.is_empty() {
            state.serialize_entry("includedFields", &self.included_fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BigQueryOptions].
pub mod big_query_options {
    #[allow(unused_imports)]
    use super::*;

    /// How to sample rows if not all rows are scanned. Meaningful only when used
    /// in conjunction with either rows_limit or rows_limit_percent. If not
    /// specified, rows are scanned in the order BigQuery reads them.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SampleMethod {
        /// No sampling.
        Unspecified,
        /// Scan groups of rows in the order BigQuery provides (default). Multiple
        /// groups of rows may be scanned in parallel, so results may not appear in
        /// the same order the rows are read.
        Top,
        /// Randomly pick groups of rows to scan.
        RandomStart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SampleMethod::value] or
        /// [SampleMethod::name].
        UnknownValue(sample_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sample_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SampleMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Top => std::option::Option::Some(1),
                Self::RandomStart => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SAMPLE_METHOD_UNSPECIFIED"),
                Self::Top => std::option::Option::Some("TOP"),
                Self::RandomStart => std::option::Option::Some("RANDOM_START"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SampleMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SampleMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SampleMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Top,
                2 => Self::RandomStart,
                _ => Self::UnknownValue(sample_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SampleMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SAMPLE_METHOD_UNSPECIFIED" => Self::Unspecified,
                "TOP" => Self::Top,
                "RANDOM_START" => Self::RandomStart,
                _ => Self::UnknownValue(sample_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SampleMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Top => serializer.serialize_i32(1),
                Self::RandomStart => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SampleMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SampleMethod>::new(
                ".google.privacy.dlp.v2.BigQueryOptions.SampleMethod",
            ))
        }
    }
}

/// Shared message indicating Cloud storage type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageConfig {
    /// Configuration of the timespan of the items to include in scanning.
    pub timespan_config: std::option::Option<crate::model::storage_config::TimespanConfig>,

    /// Type of storage system to inspect.
    pub r#type: std::option::Option<crate::model::storage_config::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timespan_config][crate::model::StorageConfig::timespan_config].
    pub fn set_timespan_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::storage_config::TimespanConfig>,
    {
        self.timespan_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timespan_config][crate::model::StorageConfig::timespan_config].
    pub fn set_or_clear_timespan_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::storage_config::TimespanConfig>,
    {
        self.timespan_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::storage_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `DatastoreOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn datastore_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatastoreOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::DatastoreOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `DatastoreOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_datastore_options<
        T: std::convert::Into<std::boxed::Box<crate::model::DatastoreOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::storage_config::Type::DatastoreOptions(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `CloudStorageOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::CloudStorageOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `CloudStorageOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_cloud_storage_options<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::storage_config::Type::CloudStorageOptions(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `BigQueryOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::BigQueryOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `BigQueryOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_big_query_options<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::storage_config::Type::BigQueryOptions(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `HybridOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hybrid_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HybridOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::HybridOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `HybridOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_hybrid_options<
        T: std::convert::Into<std::boxed::Box<crate::model::HybridOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::storage_config::Type::HybridOptions(v.into()));
        self
    }
}

impl wkt::message::Message for StorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StorageConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __datastore_options,
            __cloud_storage_options,
            __big_query_options,
            __hybrid_options,
            __timespan_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datastoreOptions" => Ok(__FieldTag::__datastore_options),
                            "datastore_options" => Ok(__FieldTag::__datastore_options),
                            "cloudStorageOptions" => Ok(__FieldTag::__cloud_storage_options),
                            "cloud_storage_options" => Ok(__FieldTag::__cloud_storage_options),
                            "bigQueryOptions" => Ok(__FieldTag::__big_query_options),
                            "big_query_options" => Ok(__FieldTag::__big_query_options),
                            "hybridOptions" => Ok(__FieldTag::__hybrid_options),
                            "hybrid_options" => Ok(__FieldTag::__hybrid_options),
                            "timespanConfig" => Ok(__FieldTag::__timespan_config),
                            "timespan_config" => Ok(__FieldTag::__timespan_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__datastore_options => {
                            if !fields.insert(__FieldTag::__datastore_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datastore_options",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.StorageConfig.datastore_options, latest field was datastoreOptions",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::storage_config::Type::DatastoreOptions(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DatastoreOptions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_storage_options => {
                            if !fields.insert(__FieldTag::__cloud_storage_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_options",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.StorageConfig.cloud_storage_options, latest field was cloudStorageOptions",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::storage_config::Type::CloudStorageOptions(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudStorageOptions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__big_query_options => {
                            if !fields.insert(__FieldTag::__big_query_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_options",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.StorageConfig.big_query_options, latest field was bigQueryOptions",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::storage_config::Type::BigQueryOptions(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryOptions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__hybrid_options => {
                            if !fields.insert(__FieldTag::__hybrid_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hybrid_options",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.StorageConfig.hybrid_options, latest field was hybridOptions",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::storage_config::Type::HybridOptions(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HybridOptions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__timespan_config => {
                            if !fields.insert(__FieldTag::__timespan_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timespan_config",
                                ));
                            }
                            result.timespan_config =
                                map.next_value::<std::option::Option<
                                    crate::model::storage_config::TimespanConfig,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.datastore_options() {
            state.serialize_entry("datastoreOptions", value)?;
        }
        if let Some(value) = self.cloud_storage_options() {
            state.serialize_entry("cloudStorageOptions", value)?;
        }
        if let Some(value) = self.big_query_options() {
            state.serialize_entry("bigQueryOptions", value)?;
        }
        if let Some(value) = self.hybrid_options() {
            state.serialize_entry("hybridOptions", value)?;
        }
        if self.timespan_config.is_some() {
            state.serialize_entry("timespanConfig", &self.timespan_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StorageConfig].
pub mod storage_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of the timespan of the items to include in scanning.
    /// Currently only supported when inspecting Cloud Storage and BigQuery.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TimespanConfig {
        /// Exclude files, tables, or rows older than this value.
        /// If not set, no lower time limit is applied.
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Exclude files, tables, or rows newer than this value.
        /// If not set, no upper time limit is applied.
        pub end_time: std::option::Option<wkt::Timestamp>,

        /// Specification of the field containing the timestamp of scanned items.
        /// Used for data sources like Datastore and BigQuery.
        ///
        /// **For BigQuery**
        ///
        /// If this value is not specified and the table was modified between the
        /// given start and end times, the entire table will be scanned. If this
        /// value is specified, then rows are filtered based on the given start and
        /// end times. Rows with a `NULL` value in the provided BigQuery column are
        /// skipped.
        /// Valid data types of the provided BigQuery column are: `INTEGER`, `DATE`,
        /// `TIMESTAMP`, and `DATETIME`.
        ///
        /// If your BigQuery table is [partitioned at ingestion
        /// time](https://cloud.google.com/bigquery/docs/partitioned-tables#ingestion_time),
        /// you can use any of the following pseudo-columns as your timestamp field.
        /// When used with Cloud DLP, these pseudo-column names are case sensitive.
        ///
        /// - `_PARTITIONTIME`
        /// - `_PARTITIONDATE`
        /// - `_PARTITION_LOAD_TIME`
        ///
        /// **For Datastore**
        ///
        /// If this value is specified, then entities are filtered based on the given
        /// start and end times. If an entity does not contain the provided timestamp
        /// property or contains empty or invalid values, then it is included.
        /// Valid data types of the provided timestamp property are: `TIMESTAMP`.
        ///
        /// See the
        /// [known
        /// issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#bq-timespan)
        /// related to this operation.
        pub timestamp_field: std::option::Option<crate::model::FieldId>,

        /// When the job is started by a JobTrigger we will automatically figure out
        /// a valid start_time to avoid scanning files that have not been modified
        /// since the last time the JobTrigger executed. This will be based on the
        /// time of the execution of the last run of the JobTrigger or the timespan
        /// end_time used in the last run of the JobTrigger.
        ///
        /// **For BigQuery**
        ///
        /// Inspect jobs triggered by automatic population will scan data that is at
        /// least three hours old when the job starts. This is because streaming
        /// buffer rows are not read during inspection and reading up to the current
        /// timestamp will result in skipped rows.
        ///
        /// See the [known
        /// issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#recently-streamed-data)
        /// related to this operation.
        pub enable_auto_population_of_timespan_config: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimespanConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::storage_config::TimespanConfig::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::storage_config::TimespanConfig::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_time][crate::model::storage_config::TimespanConfig::end_time].
        pub fn set_end_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_time][crate::model::storage_config::TimespanConfig::end_time].
        pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [timestamp_field][crate::model::storage_config::TimespanConfig::timestamp_field].
        pub fn set_timestamp_field<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.timestamp_field = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [timestamp_field][crate::model::storage_config::TimespanConfig::timestamp_field].
        pub fn set_or_clear_timestamp_field<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::FieldId>,
        {
            self.timestamp_field = v.map(|x| x.into());
            self
        }

        /// Sets the value of [enable_auto_population_of_timespan_config][crate::model::storage_config::TimespanConfig::enable_auto_population_of_timespan_config].
        pub fn set_enable_auto_population_of_timespan_config<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.enable_auto_population_of_timespan_config = v.into();
            self
        }
    }

    impl wkt::message::Message for TimespanConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.StorageConfig.TimespanConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TimespanConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __start_time,
                __end_time,
                __timestamp_field,
                __enable_auto_population_of_timespan_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TimespanConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                "endTime" => Ok(__FieldTag::__end_time),
                                "end_time" => Ok(__FieldTag::__end_time),
                                "timestampField" => Ok(__FieldTag::__timestamp_field),
                                "timestamp_field" => Ok(__FieldTag::__timestamp_field),
                                "enableAutoPopulationOfTimespanConfig" => {
                                    Ok(__FieldTag::__enable_auto_population_of_timespan_config)
                                }
                                "enable_auto_population_of_timespan_config" => {
                                    Ok(__FieldTag::__enable_auto_population_of_timespan_config)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TimespanConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TimespanConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__end_time => {
                                if !fields.insert(__FieldTag::__end_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for end_time",
                                    ));
                                }
                                result.end_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__timestamp_field => {
                                if !fields.insert(__FieldTag::__timestamp_field) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for timestamp_field",
                                    ));
                                }
                                result.timestamp_field =
                                    map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                            }
                            __FieldTag::__enable_auto_population_of_timespan_config => {
                                if !fields
                                    .insert(__FieldTag::__enable_auto_population_of_timespan_config)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_auto_population_of_timespan_config",
                                    ));
                                }
                                result.enable_auto_population_of_timespan_config = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TimespanConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if self.end_time.is_some() {
                state.serialize_entry("endTime", &self.end_time)?;
            }
            if self.timestamp_field.is_some() {
                state.serialize_entry("timestampField", &self.timestamp_field)?;
            }
            if !wkt::internal::is_default(&self.enable_auto_population_of_timespan_config) {
                state.serialize_entry(
                    "enableAutoPopulationOfTimespanConfig",
                    &self.enable_auto_population_of_timespan_config,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Type of storage system to inspect.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Google Cloud Datastore options.
        DatastoreOptions(std::boxed::Box<crate::model::DatastoreOptions>),
        /// Cloud Storage options.
        CloudStorageOptions(std::boxed::Box<crate::model::CloudStorageOptions>),
        /// BigQuery options.
        BigQueryOptions(std::boxed::Box<crate::model::BigQueryOptions>),
        /// Hybrid inspection options.
        HybridOptions(std::boxed::Box<crate::model::HybridOptions>),
    }
}

/// Configuration to control jobs where the content being inspected is outside
/// of Google Cloud Platform.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HybridOptions {
    /// A short description of where the data is coming from. Will be stored once
    /// in the job. 256 max length.
    pub description: std::string::String,

    /// These are labels that each inspection request must include within their
    /// 'finding_labels' map. Request may contain others, but any missing one of
    /// these will be rejected.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// No more than 10 keys can be required.
    pub required_finding_label_keys: std::vec::Vec<std::string::String>,

    /// To organize findings, these labels will be added to each finding.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// Label values must be between 0 and 63 characters long and must conform
    /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
    ///
    /// No more than 10 labels can be associated with a given finding.
    ///
    /// Examples:
    ///
    /// * `"environment" : "production"`
    /// * `"pipeline" : "etl"`
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// If the container is a table, additional information to make findings
    /// meaningful such as the columns that are primary keys.
    pub table_options: std::option::Option<crate::model::TableOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::HybridOptions::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [required_finding_label_keys][crate::model::HybridOptions::required_finding_label_keys].
    pub fn set_required_finding_label_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.required_finding_label_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::HybridOptions::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [table_options][crate::model::HybridOptions::table_options].
    pub fn set_table_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableOptions>,
    {
        self.table_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table_options][crate::model::HybridOptions::table_options].
    pub fn set_or_clear_table_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableOptions>,
    {
        self.table_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for HybridOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HybridOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __description,
            __required_finding_label_keys,
            __labels,
            __table_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HybridOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "description" => Ok(__FieldTag::__description),
                            "requiredFindingLabelKeys" => {
                                Ok(__FieldTag::__required_finding_label_keys)
                            }
                            "required_finding_label_keys" => {
                                Ok(__FieldTag::__required_finding_label_keys)
                            }
                            "labels" => Ok(__FieldTag::__labels),
                            "tableOptions" => Ok(__FieldTag::__table_options),
                            "table_options" => Ok(__FieldTag::__table_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HybridOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HybridOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__required_finding_label_keys => {
                            if !fields.insert(__FieldTag::__required_finding_label_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for required_finding_label_keys",
                                ));
                            }
                            result.required_finding_label_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_options => {
                            if !fields.insert(__FieldTag::__table_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_options",
                                ));
                            }
                            result.table_options = map
                                .next_value::<std::option::Option<crate::model::TableOptions>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HybridOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.required_finding_label_keys.is_empty() {
            state.serialize_entry(
                "requiredFindingLabelKeys",
                &self.required_finding_label_keys,
            )?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.table_options.is_some() {
            state.serialize_entry("tableOptions", &self.table_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Row key for identifying a record in BigQuery table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryKey {
    /// Complete BigQuery table reference.
    pub table_reference: std::option::Option<crate::model::BigQueryTable>,

    /// Row number inferred at the time the table was scanned. This value is
    /// nondeterministic, cannot be queried, and may be null for inspection
    /// jobs. To locate findings within a table, specify
    /// `inspect_job.storage_config.big_query_options.identifying_fields` in
    /// `CreateDlpJobRequest`.
    pub row_number: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_reference][crate::model::BigQueryKey::table_reference].
    pub fn set_table_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.table_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table_reference][crate::model::BigQueryKey::table_reference].
    pub fn set_or_clear_table_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.table_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [row_number][crate::model::BigQueryKey::row_number].
    pub fn set_row_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_number = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table_reference,
            __row_number,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tableReference" => Ok(__FieldTag::__table_reference),
                            "table_reference" => Ok(__FieldTag::__table_reference),
                            "rowNumber" => Ok(__FieldTag::__row_number),
                            "row_number" => Ok(__FieldTag::__row_number),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table_reference => {
                            if !fields.insert(__FieldTag::__table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_reference",
                                ));
                            }
                            result.table_reference = map
                                .next_value::<std::option::Option<crate::model::BigQueryTable>>()?;
                        }
                        __FieldTag::__row_number => {
                            if !fields.insert(__FieldTag::__row_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_number",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.row_number = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.table_reference.is_some() {
            state.serialize_entry("tableReference", &self.table_reference)?;
        }
        if !wkt::internal::is_default(&self.row_number) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rowNumber", &__With(&self.row_number))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Record key for a finding in Cloud Datastore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatastoreKey {
    /// Datastore entity key.
    pub entity_key: std::option::Option<crate::model::Key>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatastoreKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_key][crate::model::DatastoreKey::entity_key].
    pub fn set_entity_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Key>,
    {
        self.entity_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity_key][crate::model::DatastoreKey::entity_key].
    pub fn set_or_clear_entity_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Key>,
    {
        self.entity_key = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DatastoreKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatastoreKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatastoreKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatastoreKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityKey" => Ok(__FieldTag::__entity_key),
                            "entity_key" => Ok(__FieldTag::__entity_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatastoreKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatastoreKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_key => {
                            if !fields.insert(__FieldTag::__entity_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_key",
                                ));
                            }
                            result.entity_key =
                                map.next_value::<std::option::Option<crate::model::Key>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatastoreKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entity_key.is_some() {
            state.serialize_entry("entityKey", &self.entity_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A unique identifier for a Datastore entity.
/// If a key's partition ID or any of its path kinds or names are
/// reserved/read-only, the key is reserved/read-only.
/// A reserved/read-only key is forbidden in certain documented contexts.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Key {
    /// Entities are partitioned into subsets, currently identified by a project
    /// ID and namespace ID.
    /// Queries are scoped to a single partition.
    pub partition_id: std::option::Option<crate::model::PartitionId>,

    /// The entity path.
    /// An entity path consists of one or more elements composed of a kind and a
    /// string or numerical identifier, which identify entities. The first
    /// element identifies a _root entity_, the second element identifies
    /// a _child_ of the root entity, the third element identifies a child of the
    /// second entity, and so forth. The entities identified by all prefixes of
    /// the path are called the element's _ancestors_.
    ///
    /// A path can never be empty, and a path can have at most 100 elements.
    pub path: std::vec::Vec<crate::model::key::PathElement>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Key {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partition_id][crate::model::Key::partition_id].
    pub fn set_partition_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PartitionId>,
    {
        self.partition_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [partition_id][crate::model::Key::partition_id].
    pub fn set_or_clear_partition_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PartitionId>,
    {
        self.partition_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [path][crate::model::Key::path].
    pub fn set_path<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::key::PathElement>,
    {
        use std::iter::Iterator;
        self.path = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Key {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Key"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Key {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __partition_id,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Key")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "partitionId" => Ok(__FieldTag::__partition_id),
                            "partition_id" => Ok(__FieldTag::__partition_id),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Key;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Key")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__partition_id => {
                            if !fields.insert(__FieldTag::__partition_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition_id",
                                ));
                            }
                            result.partition_id =
                                map.next_value::<std::option::Option<crate::model::PartitionId>>()?;
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::key::PathElement>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Key {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.partition_id.is_some() {
            state.serialize_entry("partitionId", &self.partition_id)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Key].
pub mod key {
    #[allow(unused_imports)]
    use super::*;

    /// A (kind, ID/name) pair used to construct a key path.
    ///
    /// If either name or ID is set, the element is complete.
    /// If neither is set, the element is incomplete.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PathElement {
        /// The kind of the entity.
        /// A kind matching regex `__.*__` is reserved/read-only.
        /// A kind must not contain more than 1500 bytes when UTF-8 encoded.
        /// Cannot be `""`.
        pub kind: std::string::String,

        /// The type of ID.
        pub id_type: std::option::Option<crate::model::key::path_element::IdType>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PathElement {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::key::PathElement::kind].
        pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kind = v.into();
            self
        }

        /// Sets the value of [id_type][crate::model::key::PathElement::id_type].
        ///
        /// Note that all the setters affecting `id_type` are mutually
        /// exclusive.
        pub fn set_id_type<
            T: std::convert::Into<std::option::Option<crate::model::key::path_element::IdType>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.id_type = v.into();
            self
        }

        /// The value of [id_type][crate::model::key::PathElement::id_type]
        /// if it holds a `Id`, `None` if the field is not set or
        /// holds a different branch.
        pub fn id(&self) -> std::option::Option<&i64> {
            #[allow(unreachable_patterns)]
            self.id_type.as_ref().and_then(|v| match v {
                crate::model::key::path_element::IdType::Id(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [id_type][crate::model::key::PathElement::id_type]
        /// to hold a `Id`.
        ///
        /// Note that all the setters affecting `id_type` are
        /// mutually exclusive.
        pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.id_type =
                std::option::Option::Some(crate::model::key::path_element::IdType::Id(v.into()));
            self
        }

        /// The value of [id_type][crate::model::key::PathElement::id_type]
        /// if it holds a `Name`, `None` if the field is not set or
        /// holds a different branch.
        pub fn name(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.id_type.as_ref().and_then(|v| match v {
                crate::model::key::path_element::IdType::Name(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [id_type][crate::model::key::PathElement::id_type]
        /// to hold a `Name`.
        ///
        /// Note that all the setters affecting `id_type` are
        /// mutually exclusive.
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id_type =
                std::option::Option::Some(crate::model::key::path_element::IdType::Name(v.into()));
            self
        }
    }

    impl wkt::message::Message for PathElement {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Key.PathElement"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PathElement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __kind,
                __id,
                __name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PathElement")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kind" => Ok(__FieldTag::__kind),
                                "id" => Ok(__FieldTag::__id),
                                "name" => Ok(__FieldTag::__name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PathElement;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PathElement")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__kind => {
                                if !fields.insert(__FieldTag::__kind) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kind",
                                    ));
                                }
                                result.kind = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.id_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `id_type`, a oneof with full ID .google.privacy.dlp.v2.Key.PathElement.id, latest field was id",
                                    ));
                                }
                                result.id_type = std::option::Option::Some(
                                    crate::model::key::path_element::IdType::Id(
                                        map.next_value::<__With>()?.0.unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                if result.id_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `id_type`, a oneof with full ID .google.privacy.dlp.v2.Key.PathElement.name, latest field was name",
                                    ));
                                }
                                result.id_type = std::option::Option::Some(
                                    crate::model::key::path_element::IdType::Name(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PathElement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.kind.is_empty() {
                state.serialize_entry("kind", &self.kind)?;
            }
            if let Some(value) = self.id() {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("id", &__With(value))?;
            }
            if let Some(value) = self.name() {
                state.serialize_entry("name", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PathElement].
    pub mod path_element {
        #[allow(unused_imports)]
        use super::*;

        /// The type of ID.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum IdType {
            /// The auto-allocated ID of the entity.
            /// Never equal to zero. Values less than zero are discouraged and may not
            /// be supported in the future.
            Id(i64),
            /// The name of the entity.
            /// A name matching regex `__.*__` is reserved/read-only.
            /// A name must not be more than 1500 bytes when UTF-8 encoded.
            /// Cannot be `""`.
            Name(std::string::String),
        }
    }
}

/// Message for a unique key indicating a record that contains a finding.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecordKey {
    /// Values of identifying columns in the given row. Order of values matches
    /// the order of `identifying_fields` specified in the scanning request.
    pub id_values: std::vec::Vec<std::string::String>,

    /// Type of key
    pub r#type: std::option::Option<crate::model::record_key::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id_values][crate::model::RecordKey::id_values].
    pub fn set_id_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.id_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [r#type][crate::model::RecordKey::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::record_key::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::RecordKey::r#type]
    /// if it holds a `DatastoreKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn datastore_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatastoreKey>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::record_key::Type::DatastoreKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::RecordKey::r#type]
    /// to hold a `DatastoreKey`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_datastore_key<T: std::convert::Into<std::boxed::Box<crate::model::DatastoreKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::record_key::Type::DatastoreKey(v.into()));
        self
    }

    /// The value of [r#type][crate::model::RecordKey::r#type]
    /// if it holds a `BigQueryKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryKey>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::record_key::Type::BigQueryKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::RecordKey::r#type]
    /// to hold a `BigQueryKey`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_big_query_key<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::record_key::Type::BigQueryKey(v.into()));
        self
    }
}

impl wkt::message::Message for RecordKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecordKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __datastore_key,
            __big_query_key,
            __id_values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecordKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datastoreKey" => Ok(__FieldTag::__datastore_key),
                            "datastore_key" => Ok(__FieldTag::__datastore_key),
                            "bigQueryKey" => Ok(__FieldTag::__big_query_key),
                            "big_query_key" => Ok(__FieldTag::__big_query_key),
                            "idValues" => Ok(__FieldTag::__id_values),
                            "id_values" => Ok(__FieldTag::__id_values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecordKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecordKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__datastore_key => {
                            if !fields.insert(__FieldTag::__datastore_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datastore_key",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.RecordKey.datastore_key, latest field was datastoreKey",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::record_key::Type::DatastoreKey(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DatastoreKey>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__big_query_key => {
                            if !fields.insert(__FieldTag::__big_query_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_key",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.privacy.dlp.v2.RecordKey.big_query_key, latest field was bigQueryKey",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::record_key::Type::BigQueryKey(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryKey>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__id_values => {
                            if !fields.insert(__FieldTag::__id_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id_values",
                                ));
                            }
                            result.id_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecordKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.datastore_key() {
            state.serialize_entry("datastoreKey", value)?;
        }
        if let Some(value) = self.big_query_key() {
            state.serialize_entry("bigQueryKey", value)?;
        }
        if !self.id_values.is_empty() {
            state.serialize_entry("idValues", &self.id_values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RecordKey].
pub mod record_key {
    #[allow(unused_imports)]
    use super::*;

    /// Type of key
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// BigQuery key
        DatastoreKey(std::boxed::Box<crate::model::DatastoreKey>),
        /// Datastore key
        BigQueryKey(std::boxed::Box<crate::model::BigQueryKey>),
    }
}

/// Message defining the location of a BigQuery table. A table is uniquely
/// identified  by its project_id, dataset_id, and table_name. Within a query
/// a table is often referenced with a string in the format of:
/// `<project_id>:<dataset_id>.<table_id>` or
/// `<project_id>.<dataset_id>.<table_id>`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryTable {
    /// The Google Cloud project ID of the project containing the table.
    /// If omitted, project ID is inferred from the API call.
    pub project_id: std::string::String,

    /// Dataset ID of the table.
    pub dataset_id: std::string::String,

    /// Name of the table.
    pub table_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::BigQueryTable::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::BigQueryTable::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::BigQueryTable::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryTable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryTable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryTable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryTable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryTable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryTable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message defining the location of a BigQuery table with the projectId inferred
/// from the parent project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TableReference {
    /// Dataset ID of the table.
    pub dataset_id: std::string::String,

    /// Name of the table.
    pub table_id: std::string::String,

    /// The Google Cloud project ID of the project containing the table.
    /// If omitted, the project ID is inferred from the parent project. This field
    /// is required if the parent resource is an organization.
    pub project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_id][crate::model::TableReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::TableReference::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::TableReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for TableReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset_id,
            __table_id,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message defining a field of a BigQuery table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryField {
    /// Source table of the field.
    pub table: std::option::Option<crate::model::BigQueryTable>,

    /// Designated field in the BigQuery table.
    pub field: std::option::Option<crate::model::FieldId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::BigQueryField::table].
    pub fn set_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table][crate::model::BigQueryField::table].
    pub fn set_or_clear_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryTable>,
    {
        self.table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field][crate::model::BigQueryField::field].
    pub fn set_field<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field][crate::model::BigQueryField::field].
    pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BigQueryField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryField"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryField {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table,
            __field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryField")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "table" => Ok(__FieldTag::__table),
                            "field" => Ok(__FieldTag::__field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryField;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryField")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table = map
                                .next_value::<std::option::Option<crate::model::BigQueryTable>>()?;
                        }
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field =
                                map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryField {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.table.is_some() {
            state.serialize_entry("table", &self.table)?;
        }
        if self.field.is_some() {
            state.serialize_entry("field", &self.field)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An entity in a dataset is a field or set of fields that correspond to a
/// single person. For example, in medical records the `EntityId` might be a
/// patient identifier, or for financial records it might be an account
/// identifier. This message is used when generalizations or analysis must take
/// into account that multiple rows correspond to the same entity.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityId {
    /// Composite key indicating which field contains the entity identifier.
    pub field: std::option::Option<crate::model::FieldId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::EntityId::field].
    pub fn set_field<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field][crate::model::EntityId::field].
    pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FieldId>,
    {
        self.field = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EntityId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.EntityId"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field =
                                map.next_value::<std::option::Option<crate::model::FieldId>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntityId {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.field.is_some() {
            state.serialize_entry("field", &self.field)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instructions regarding the table content being inspected.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TableOptions {
    /// The columns that are the primary keys for table objects included in
    /// ContentItem. A copy of this cell's value will stored alongside alongside
    /// each finding so that the finding can be traced to the specific row it came
    /// from. No more than 3 may be provided.
    pub identifying_fields: std::vec::Vec<crate::model::FieldId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [identifying_fields][crate::model::TableOptions::identifying_fields].
    pub fn set_identifying_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.identifying_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __identifying_fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "identifyingFields" => Ok(__FieldTag::__identifying_fields),
                            "identifying_fields" => Ok(__FieldTag::__identifying_fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__identifying_fields => {
                            if !fields.insert(__FieldTag::__identifying_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identifying_fields",
                                ));
                            }
                            result.identifying_fields = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FieldId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.identifying_fields.is_empty() {
            state.serialize_entry("identifyingFields", &self.identifying_fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Enum of possible outcomes of transformations. SUCCESS if transformation and
/// storing of transformation was successful, otherwise, reason for not
/// transforming.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TransformationResultStatusType {
    /// Unused.
    StateTypeUnspecified,
    /// This will be set when a finding could not be transformed (i.e. outside user
    /// set bucket range).
    InvalidTransform,
    /// This will be set when a BigQuery transformation was successful but could
    /// not be stored back in BigQuery because the transformed row exceeds
    /// BigQuery's max row size.
    BigqueryMaxRowSizeExceeded,
    /// This will be set when there is a finding in the custom metadata of a file,
    /// but at the write time of the transformed file, this key / value pair is
    /// unretrievable.
    MetadataUnretrievable,
    /// This will be set when the transformation and storing of it is successful.
    Success,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TransformationResultStatusType::value] or
    /// [TransformationResultStatusType::name].
    UnknownValue(transformation_result_status_type::UnknownValue),
}

#[doc(hidden)]
pub mod transformation_result_status_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TransformationResultStatusType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::StateTypeUnspecified => std::option::Option::Some(0),
            Self::InvalidTransform => std::option::Option::Some(1),
            Self::BigqueryMaxRowSizeExceeded => std::option::Option::Some(2),
            Self::MetadataUnretrievable => std::option::Option::Some(3),
            Self::Success => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::StateTypeUnspecified => std::option::Option::Some("STATE_TYPE_UNSPECIFIED"),
            Self::InvalidTransform => std::option::Option::Some("INVALID_TRANSFORM"),
            Self::BigqueryMaxRowSizeExceeded => {
                std::option::Option::Some("BIGQUERY_MAX_ROW_SIZE_EXCEEDED")
            }
            Self::MetadataUnretrievable => std::option::Option::Some("METADATA_UNRETRIEVABLE"),
            Self::Success => std::option::Option::Some("SUCCESS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TransformationResultStatusType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TransformationResultStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TransformationResultStatusType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::StateTypeUnspecified,
            1 => Self::InvalidTransform,
            2 => Self::BigqueryMaxRowSizeExceeded,
            3 => Self::MetadataUnretrievable,
            4 => Self::Success,
            _ => Self::UnknownValue(transformation_result_status_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TransformationResultStatusType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STATE_TYPE_UNSPECIFIED" => Self::StateTypeUnspecified,
            "INVALID_TRANSFORM" => Self::InvalidTransform,
            "BIGQUERY_MAX_ROW_SIZE_EXCEEDED" => Self::BigqueryMaxRowSizeExceeded,
            "METADATA_UNRETRIEVABLE" => Self::MetadataUnretrievable,
            "SUCCESS" => Self::Success,
            _ => Self::UnknownValue(transformation_result_status_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TransformationResultStatusType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::StateTypeUnspecified => serializer.serialize_i32(0),
            Self::InvalidTransform => serializer.serialize_i32(1),
            Self::BigqueryMaxRowSizeExceeded => serializer.serialize_i32(2),
            Self::MetadataUnretrievable => serializer.serialize_i32(3),
            Self::Success => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TransformationResultStatusType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<TransformationResultStatusType>::new(
                ".google.privacy.dlp.v2.TransformationResultStatusType",
            ),
        )
    }
}

/// Describes functionality of a given container in its original format.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TransformationContainerType {
    /// Unused.
    TransformUnknownContainer,
    /// Body of a file.
    TransformBody,
    /// Metadata for a file.
    TransformMetadata,
    /// A table.
    TransformTable,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TransformationContainerType::value] or
    /// [TransformationContainerType::name].
    UnknownValue(transformation_container_type::UnknownValue),
}

#[doc(hidden)]
pub mod transformation_container_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TransformationContainerType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::TransformUnknownContainer => std::option::Option::Some(0),
            Self::TransformBody => std::option::Option::Some(1),
            Self::TransformMetadata => std::option::Option::Some(2),
            Self::TransformTable => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::TransformUnknownContainer => {
                std::option::Option::Some("TRANSFORM_UNKNOWN_CONTAINER")
            }
            Self::TransformBody => std::option::Option::Some("TRANSFORM_BODY"),
            Self::TransformMetadata => std::option::Option::Some("TRANSFORM_METADATA"),
            Self::TransformTable => std::option::Option::Some("TRANSFORM_TABLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TransformationContainerType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TransformationContainerType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TransformationContainerType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::TransformUnknownContainer,
            1 => Self::TransformBody,
            2 => Self::TransformMetadata,
            3 => Self::TransformTable,
            _ => Self::UnknownValue(transformation_container_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TransformationContainerType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRANSFORM_UNKNOWN_CONTAINER" => Self::TransformUnknownContainer,
            "TRANSFORM_BODY" => Self::TransformBody,
            "TRANSFORM_METADATA" => Self::TransformMetadata,
            "TRANSFORM_TABLE" => Self::TransformTable,
            _ => Self::UnknownValue(transformation_container_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TransformationContainerType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::TransformUnknownContainer => serializer.serialize_i32(0),
            Self::TransformBody => serializer.serialize_i32(1),
            Self::TransformMetadata => serializer.serialize_i32(2),
            Self::TransformTable => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TransformationContainerType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<TransformationContainerType>::new(
                ".google.privacy.dlp.v2.TransformationContainerType",
            ),
        )
    }
}

/// An enum of rules that can be used to transform a value. Can be a
/// record suppression, or one of the transformation rules specified under
/// `PrimitiveTransformation`.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TransformationType {
    /// Unused
    Unspecified,
    /// Record suppression
    RecordSuppression,
    /// Replace value
    ReplaceValue,
    /// Replace value using a dictionary.
    ReplaceDictionary,
    /// Redact
    Redact,
    /// Character mask
    CharacterMask,
    /// FFX-FPE
    CryptoReplaceFfxFpe,
    /// Fixed size bucketing
    FixedSizeBucketing,
    /// Bucketing
    Bucketing,
    /// Replace with info type
    ReplaceWithInfoType,
    /// Time part
    TimePart,
    /// Crypto hash
    CryptoHash,
    /// Date shift
    DateShift,
    /// Deterministic crypto
    CryptoDeterministicConfig,
    /// Redact image
    RedactImage,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TransformationType::value] or
    /// [TransformationType::name].
    UnknownValue(transformation_type::UnknownValue),
}

#[doc(hidden)]
pub mod transformation_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TransformationType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::RecordSuppression => std::option::Option::Some(1),
            Self::ReplaceValue => std::option::Option::Some(2),
            Self::ReplaceDictionary => std::option::Option::Some(15),
            Self::Redact => std::option::Option::Some(3),
            Self::CharacterMask => std::option::Option::Some(4),
            Self::CryptoReplaceFfxFpe => std::option::Option::Some(5),
            Self::FixedSizeBucketing => std::option::Option::Some(6),
            Self::Bucketing => std::option::Option::Some(7),
            Self::ReplaceWithInfoType => std::option::Option::Some(8),
            Self::TimePart => std::option::Option::Some(9),
            Self::CryptoHash => std::option::Option::Some(10),
            Self::DateShift => std::option::Option::Some(12),
            Self::CryptoDeterministicConfig => std::option::Option::Some(13),
            Self::RedactImage => std::option::Option::Some(14),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TRANSFORMATION_TYPE_UNSPECIFIED"),
            Self::RecordSuppression => std::option::Option::Some("RECORD_SUPPRESSION"),
            Self::ReplaceValue => std::option::Option::Some("REPLACE_VALUE"),
            Self::ReplaceDictionary => std::option::Option::Some("REPLACE_DICTIONARY"),
            Self::Redact => std::option::Option::Some("REDACT"),
            Self::CharacterMask => std::option::Option::Some("CHARACTER_MASK"),
            Self::CryptoReplaceFfxFpe => std::option::Option::Some("CRYPTO_REPLACE_FFX_FPE"),
            Self::FixedSizeBucketing => std::option::Option::Some("FIXED_SIZE_BUCKETING"),
            Self::Bucketing => std::option::Option::Some("BUCKETING"),
            Self::ReplaceWithInfoType => std::option::Option::Some("REPLACE_WITH_INFO_TYPE"),
            Self::TimePart => std::option::Option::Some("TIME_PART"),
            Self::CryptoHash => std::option::Option::Some("CRYPTO_HASH"),
            Self::DateShift => std::option::Option::Some("DATE_SHIFT"),
            Self::CryptoDeterministicConfig => {
                std::option::Option::Some("CRYPTO_DETERMINISTIC_CONFIG")
            }
            Self::RedactImage => std::option::Option::Some("REDACT_IMAGE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TransformationType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TransformationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TransformationType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::RecordSuppression,
            2 => Self::ReplaceValue,
            3 => Self::Redact,
            4 => Self::CharacterMask,
            5 => Self::CryptoReplaceFfxFpe,
            6 => Self::FixedSizeBucketing,
            7 => Self::Bucketing,
            8 => Self::ReplaceWithInfoType,
            9 => Self::TimePart,
            10 => Self::CryptoHash,
            12 => Self::DateShift,
            13 => Self::CryptoDeterministicConfig,
            14 => Self::RedactImage,
            15 => Self::ReplaceDictionary,
            _ => Self::UnknownValue(transformation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TransformationType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRANSFORMATION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "RECORD_SUPPRESSION" => Self::RecordSuppression,
            "REPLACE_VALUE" => Self::ReplaceValue,
            "REPLACE_DICTIONARY" => Self::ReplaceDictionary,
            "REDACT" => Self::Redact,
            "CHARACTER_MASK" => Self::CharacterMask,
            "CRYPTO_REPLACE_FFX_FPE" => Self::CryptoReplaceFfxFpe,
            "FIXED_SIZE_BUCKETING" => Self::FixedSizeBucketing,
            "BUCKETING" => Self::Bucketing,
            "REPLACE_WITH_INFO_TYPE" => Self::ReplaceWithInfoType,
            "TIME_PART" => Self::TimePart,
            "CRYPTO_HASH" => Self::CryptoHash,
            "DATE_SHIFT" => Self::DateShift,
            "CRYPTO_DETERMINISTIC_CONFIG" => Self::CryptoDeterministicConfig,
            "REDACT_IMAGE" => Self::RedactImage,
            _ => Self::UnknownValue(transformation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TransformationType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::RecordSuppression => serializer.serialize_i32(1),
            Self::ReplaceValue => serializer.serialize_i32(2),
            Self::ReplaceDictionary => serializer.serialize_i32(15),
            Self::Redact => serializer.serialize_i32(3),
            Self::CharacterMask => serializer.serialize_i32(4),
            Self::CryptoReplaceFfxFpe => serializer.serialize_i32(5),
            Self::FixedSizeBucketing => serializer.serialize_i32(6),
            Self::Bucketing => serializer.serialize_i32(7),
            Self::ReplaceWithInfoType => serializer.serialize_i32(8),
            Self::TimePart => serializer.serialize_i32(9),
            Self::CryptoHash => serializer.serialize_i32(10),
            Self::DateShift => serializer.serialize_i32(12),
            Self::CryptoDeterministicConfig => serializer.serialize_i32(13),
            Self::RedactImage => serializer.serialize_i32(14),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TransformationType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransformationType>::new(
            ".google.privacy.dlp.v2.TransformationType",
        ))
    }
}

/// Whether a profile being created is the first generation or an update.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ProfileGeneration {
    /// Unused.
    Unspecified,
    /// The profile is the first profile for the resource.
    New,
    /// The profile is an update to a previous profile.
    Update,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ProfileGeneration::value] or
    /// [ProfileGeneration::name].
    UnknownValue(profile_generation::UnknownValue),
}

#[doc(hidden)]
pub mod profile_generation {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ProfileGeneration {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::New => std::option::Option::Some(1),
            Self::Update => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PROFILE_GENERATION_UNSPECIFIED"),
            Self::New => std::option::Option::Some("PROFILE_GENERATION_NEW"),
            Self::Update => std::option::Option::Some("PROFILE_GENERATION_UPDATE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ProfileGeneration {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ProfileGeneration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ProfileGeneration {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::New,
            2 => Self::Update,
            _ => Self::UnknownValue(profile_generation::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ProfileGeneration {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PROFILE_GENERATION_UNSPECIFIED" => Self::Unspecified,
            "PROFILE_GENERATION_NEW" => Self::New,
            "PROFILE_GENERATION_UPDATE" => Self::Update,
            _ => Self::UnknownValue(profile_generation::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ProfileGeneration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::New => serializer.serialize_i32(1),
            Self::Update => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ProfileGeneration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProfileGeneration>::new(
            ".google.privacy.dlp.v2.ProfileGeneration",
        ))
    }
}

/// Over time new types may be added. Currently VIEW, MATERIALIZED_VIEW, and
/// non-BigLake external tables are not supported.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BigQueryTableTypeCollection {
    /// Unused.
    BigQueryCollectionUnspecified,
    /// Automatically generate profiles for all tables, even if the table type is
    /// not yet fully supported for analysis. Profiles for unsupported tables will
    /// be generated with errors to indicate their partial support. When full
    /// support is added, the tables will automatically be profiled during the next
    /// scheduled run.
    BigQueryCollectionAllTypes,
    /// Only those types fully supported will be profiled. Will expand
    /// automatically as Cloud DLP adds support for new table types. Unsupported
    /// table types will not have partial profiles generated.
    BigQueryCollectionOnlySupportedTypes,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BigQueryTableTypeCollection::value] or
    /// [BigQueryTableTypeCollection::name].
    UnknownValue(big_query_table_type_collection::UnknownValue),
}

#[doc(hidden)]
pub mod big_query_table_type_collection {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BigQueryTableTypeCollection {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::BigQueryCollectionUnspecified => std::option::Option::Some(0),
            Self::BigQueryCollectionAllTypes => std::option::Option::Some(1),
            Self::BigQueryCollectionOnlySupportedTypes => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::BigQueryCollectionUnspecified => {
                std::option::Option::Some("BIG_QUERY_COLLECTION_UNSPECIFIED")
            }
            Self::BigQueryCollectionAllTypes => {
                std::option::Option::Some("BIG_QUERY_COLLECTION_ALL_TYPES")
            }
            Self::BigQueryCollectionOnlySupportedTypes => {
                std::option::Option::Some("BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BigQueryTableTypeCollection {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BigQueryTableTypeCollection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BigQueryTableTypeCollection {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::BigQueryCollectionUnspecified,
            1 => Self::BigQueryCollectionAllTypes,
            2 => Self::BigQueryCollectionOnlySupportedTypes,
            _ => Self::UnknownValue(big_query_table_type_collection::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BigQueryTableTypeCollection {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BIG_QUERY_COLLECTION_UNSPECIFIED" => Self::BigQueryCollectionUnspecified,
            "BIG_QUERY_COLLECTION_ALL_TYPES" => Self::BigQueryCollectionAllTypes,
            "BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES" => {
                Self::BigQueryCollectionOnlySupportedTypes
            }
            _ => Self::UnknownValue(big_query_table_type_collection::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BigQueryTableTypeCollection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::BigQueryCollectionUnspecified => serializer.serialize_i32(0),
            Self::BigQueryCollectionAllTypes => serializer.serialize_i32(1),
            Self::BigQueryCollectionOnlySupportedTypes => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BigQueryTableTypeCollection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<BigQueryTableTypeCollection>::new(
                ".google.privacy.dlp.v2.BigQueryTableTypeCollection",
            ),
        )
    }
}

/// Over time new types may be added. Currently VIEW, MATERIALIZED_VIEW, and
/// non-BigLake external tables are not supported.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BigQueryTableType {
    /// Unused.
    Unspecified,
    /// A normal BigQuery table.
    Table,
    /// A table that references data stored in Cloud Storage.
    ExternalBigLake,
    /// A snapshot of a BigQuery table.
    Snapshot,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BigQueryTableType::value] or
    /// [BigQueryTableType::name].
    UnknownValue(big_query_table_type::UnknownValue),
}

#[doc(hidden)]
pub mod big_query_table_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BigQueryTableType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Table => std::option::Option::Some(1),
            Self::ExternalBigLake => std::option::Option::Some(2),
            Self::Snapshot => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BIG_QUERY_TABLE_TYPE_UNSPECIFIED"),
            Self::Table => std::option::Option::Some("BIG_QUERY_TABLE_TYPE_TABLE"),
            Self::ExternalBigLake => {
                std::option::Option::Some("BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE")
            }
            Self::Snapshot => std::option::Option::Some("BIG_QUERY_TABLE_TYPE_SNAPSHOT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BigQueryTableType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BigQueryTableType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BigQueryTableType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Table,
            2 => Self::ExternalBigLake,
            3 => Self::Snapshot,
            _ => Self::UnknownValue(big_query_table_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BigQueryTableType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BIG_QUERY_TABLE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BIG_QUERY_TABLE_TYPE_TABLE" => Self::Table,
            "BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE" => Self::ExternalBigLake,
            "BIG_QUERY_TABLE_TYPE_SNAPSHOT" => Self::Snapshot,
            _ => Self::UnknownValue(big_query_table_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BigQueryTableType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Table => serializer.serialize_i32(1),
            Self::ExternalBigLake => serializer.serialize_i32(2),
            Self::Snapshot => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BigQueryTableType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BigQueryTableType>::new(
            ".google.privacy.dlp.v2.BigQueryTableType",
        ))
    }
}

/// How frequently data profiles can be updated. New options can be added at a
/// later time.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DataProfileUpdateFrequency {
    /// Unspecified.
    UpdateFrequencyUnspecified,
    /// After the data profile is created, it will never be updated.
    UpdateFrequencyNever,
    /// The data profile can be updated up to once every 24 hours.
    UpdateFrequencyDaily,
    /// The data profile can be updated up to once every 30 days. Default.
    UpdateFrequencyMonthly,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DataProfileUpdateFrequency::value] or
    /// [DataProfileUpdateFrequency::name].
    UnknownValue(data_profile_update_frequency::UnknownValue),
}

#[doc(hidden)]
pub mod data_profile_update_frequency {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DataProfileUpdateFrequency {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::UpdateFrequencyUnspecified => std::option::Option::Some(0),
            Self::UpdateFrequencyNever => std::option::Option::Some(1),
            Self::UpdateFrequencyDaily => std::option::Option::Some(2),
            Self::UpdateFrequencyMonthly => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::UpdateFrequencyUnspecified => {
                std::option::Option::Some("UPDATE_FREQUENCY_UNSPECIFIED")
            }
            Self::UpdateFrequencyNever => std::option::Option::Some("UPDATE_FREQUENCY_NEVER"),
            Self::UpdateFrequencyDaily => std::option::Option::Some("UPDATE_FREQUENCY_DAILY"),
            Self::UpdateFrequencyMonthly => std::option::Option::Some("UPDATE_FREQUENCY_MONTHLY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DataProfileUpdateFrequency {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DataProfileUpdateFrequency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DataProfileUpdateFrequency {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::UpdateFrequencyUnspecified,
            1 => Self::UpdateFrequencyNever,
            2 => Self::UpdateFrequencyDaily,
            4 => Self::UpdateFrequencyMonthly,
            _ => Self::UnknownValue(data_profile_update_frequency::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DataProfileUpdateFrequency {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UPDATE_FREQUENCY_UNSPECIFIED" => Self::UpdateFrequencyUnspecified,
            "UPDATE_FREQUENCY_NEVER" => Self::UpdateFrequencyNever,
            "UPDATE_FREQUENCY_DAILY" => Self::UpdateFrequencyDaily,
            "UPDATE_FREQUENCY_MONTHLY" => Self::UpdateFrequencyMonthly,
            _ => Self::UnknownValue(data_profile_update_frequency::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DataProfileUpdateFrequency {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::UpdateFrequencyUnspecified => serializer.serialize_i32(0),
            Self::UpdateFrequencyNever => serializer.serialize_i32(1),
            Self::UpdateFrequencyDaily => serializer.serialize_i32(2),
            Self::UpdateFrequencyMonthly => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DataProfileUpdateFrequency {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<DataProfileUpdateFrequency>::new(
                ".google.privacy.dlp.v2.DataProfileUpdateFrequency",
            ),
        )
    }
}

/// Attributes evaluated to determine if a table has been modified. New values
/// may be added at a later time.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BigQueryTableModification {
    /// Unused.
    TableModificationUnspecified,
    /// A table will be considered modified when the last_modified_time from
    /// BigQuery has been updated.
    TableModifiedTimestamp,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BigQueryTableModification::value] or
    /// [BigQueryTableModification::name].
    UnknownValue(big_query_table_modification::UnknownValue),
}

#[doc(hidden)]
pub mod big_query_table_modification {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BigQueryTableModification {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::TableModificationUnspecified => std::option::Option::Some(0),
            Self::TableModifiedTimestamp => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::TableModificationUnspecified => {
                std::option::Option::Some("TABLE_MODIFICATION_UNSPECIFIED")
            }
            Self::TableModifiedTimestamp => std::option::Option::Some("TABLE_MODIFIED_TIMESTAMP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BigQueryTableModification {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BigQueryTableModification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BigQueryTableModification {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::TableModificationUnspecified,
            1 => Self::TableModifiedTimestamp,
            _ => Self::UnknownValue(big_query_table_modification::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BigQueryTableModification {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TABLE_MODIFICATION_UNSPECIFIED" => Self::TableModificationUnspecified,
            "TABLE_MODIFIED_TIMESTAMP" => Self::TableModifiedTimestamp,
            _ => Self::UnknownValue(big_query_table_modification::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BigQueryTableModification {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::TableModificationUnspecified => serializer.serialize_i32(0),
            Self::TableModifiedTimestamp => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BigQueryTableModification {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<BigQueryTableModification>::new(
                ".google.privacy.dlp.v2.BigQueryTableModification",
            ),
        )
    }
}

/// Attributes evaluated to determine if a schema has been modified. New values
/// may be added at a later time.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BigQuerySchemaModification {
    /// Unused
    SchemaModificationUnspecified,
    /// Profiles should be regenerated when new columns are added to the table.
    /// Default.
    SchemaNewColumns,
    /// Profiles should be regenerated when columns are removed from the table.
    SchemaRemovedColumns,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BigQuerySchemaModification::value] or
    /// [BigQuerySchemaModification::name].
    UnknownValue(big_query_schema_modification::UnknownValue),
}

#[doc(hidden)]
pub mod big_query_schema_modification {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BigQuerySchemaModification {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::SchemaModificationUnspecified => std::option::Option::Some(0),
            Self::SchemaNewColumns => std::option::Option::Some(1),
            Self::SchemaRemovedColumns => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::SchemaModificationUnspecified => {
                std::option::Option::Some("SCHEMA_MODIFICATION_UNSPECIFIED")
            }
            Self::SchemaNewColumns => std::option::Option::Some("SCHEMA_NEW_COLUMNS"),
            Self::SchemaRemovedColumns => std::option::Option::Some("SCHEMA_REMOVED_COLUMNS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BigQuerySchemaModification {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BigQuerySchemaModification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BigQuerySchemaModification {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::SchemaModificationUnspecified,
            1 => Self::SchemaNewColumns,
            2 => Self::SchemaRemovedColumns,
            _ => Self::UnknownValue(big_query_schema_modification::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BigQuerySchemaModification {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SCHEMA_MODIFICATION_UNSPECIFIED" => Self::SchemaModificationUnspecified,
            "SCHEMA_NEW_COLUMNS" => Self::SchemaNewColumns,
            "SCHEMA_REMOVED_COLUMNS" => Self::SchemaRemovedColumns,
            _ => Self::UnknownValue(big_query_schema_modification::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BigQuerySchemaModification {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::SchemaModificationUnspecified => serializer.serialize_i32(0),
            Self::SchemaNewColumns => serializer.serialize_i32(1),
            Self::SchemaRemovedColumns => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BigQuerySchemaModification {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<BigQuerySchemaModification>::new(
                ".google.privacy.dlp.v2.BigQuerySchemaModification",
            ),
        )
    }
}

/// Operators available for comparing the value of fields.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RelationalOperator {
    /// Unused
    Unspecified,
    /// Equal. Attempts to match even with incompatible types.
    EqualTo,
    /// Not equal to. Attempts to match even with incompatible types.
    NotEqualTo,
    /// Greater than.
    GreaterThan,
    /// Less than.
    LessThan,
    /// Greater than or equals.
    GreaterThanOrEquals,
    /// Less than or equals.
    LessThanOrEquals,
    /// Exists
    Exists,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RelationalOperator::value] or
    /// [RelationalOperator::name].
    UnknownValue(relational_operator::UnknownValue),
}

#[doc(hidden)]
pub mod relational_operator {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RelationalOperator {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::EqualTo => std::option::Option::Some(1),
            Self::NotEqualTo => std::option::Option::Some(2),
            Self::GreaterThan => std::option::Option::Some(3),
            Self::LessThan => std::option::Option::Some(4),
            Self::GreaterThanOrEquals => std::option::Option::Some(5),
            Self::LessThanOrEquals => std::option::Option::Some(6),
            Self::Exists => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RELATIONAL_OPERATOR_UNSPECIFIED"),
            Self::EqualTo => std::option::Option::Some("EQUAL_TO"),
            Self::NotEqualTo => std::option::Option::Some("NOT_EQUAL_TO"),
            Self::GreaterThan => std::option::Option::Some("GREATER_THAN"),
            Self::LessThan => std::option::Option::Some("LESS_THAN"),
            Self::GreaterThanOrEquals => std::option::Option::Some("GREATER_THAN_OR_EQUALS"),
            Self::LessThanOrEquals => std::option::Option::Some("LESS_THAN_OR_EQUALS"),
            Self::Exists => std::option::Option::Some("EXISTS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RelationalOperator {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RelationalOperator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RelationalOperator {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::EqualTo,
            2 => Self::NotEqualTo,
            3 => Self::GreaterThan,
            4 => Self::LessThan,
            5 => Self::GreaterThanOrEquals,
            6 => Self::LessThanOrEquals,
            7 => Self::Exists,
            _ => Self::UnknownValue(relational_operator::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RelationalOperator {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RELATIONAL_OPERATOR_UNSPECIFIED" => Self::Unspecified,
            "EQUAL_TO" => Self::EqualTo,
            "NOT_EQUAL_TO" => Self::NotEqualTo,
            "GREATER_THAN" => Self::GreaterThan,
            "LESS_THAN" => Self::LessThan,
            "GREATER_THAN_OR_EQUALS" => Self::GreaterThanOrEquals,
            "LESS_THAN_OR_EQUALS" => Self::LessThanOrEquals,
            "EXISTS" => Self::Exists,
            _ => Self::UnknownValue(relational_operator::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RelationalOperator {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::EqualTo => serializer.serialize_i32(1),
            Self::NotEqualTo => serializer.serialize_i32(2),
            Self::GreaterThan => serializer.serialize_i32(3),
            Self::LessThan => serializer.serialize_i32(4),
            Self::GreaterThanOrEquals => serializer.serialize_i32(5),
            Self::LessThanOrEquals => serializer.serialize_i32(6),
            Self::Exists => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RelationalOperator {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<RelationalOperator>::new(
            ".google.privacy.dlp.v2.RelationalOperator",
        ))
    }
}

/// Type of the match which can be applied to different ways of matching, like
/// Dictionary, regular expression and intersecting with findings of another
/// info type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MatchingType {
    /// Invalid.
    Unspecified,
    /// Full match.
    ///
    /// - Dictionary: join of Dictionary results matched complete finding quote
    /// - Regex: all regex matches fill a finding quote start to end
    /// - Exclude info type: completely inside affecting info types findings
    FullMatch,
    /// Partial match.
    ///
    /// - Dictionary: at least one of the tokens in the finding matches
    /// - Regex: substring of the finding matches
    /// - Exclude info type: intersects with affecting info types findings
    PartialMatch,
    /// Inverse match.
    ///
    /// - Dictionary: no tokens in the finding match the dictionary
    /// - Regex: finding doesn't match the regex
    /// - Exclude info type: no intersection with affecting info types findings
    InverseMatch,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MatchingType::value] or
    /// [MatchingType::name].
    UnknownValue(matching_type::UnknownValue),
}

#[doc(hidden)]
pub mod matching_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MatchingType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::FullMatch => std::option::Option::Some(1),
            Self::PartialMatch => std::option::Option::Some(2),
            Self::InverseMatch => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MATCHING_TYPE_UNSPECIFIED"),
            Self::FullMatch => std::option::Option::Some("MATCHING_TYPE_FULL_MATCH"),
            Self::PartialMatch => std::option::Option::Some("MATCHING_TYPE_PARTIAL_MATCH"),
            Self::InverseMatch => std::option::Option::Some("MATCHING_TYPE_INVERSE_MATCH"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MatchingType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MatchingType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MatchingType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::FullMatch,
            2 => Self::PartialMatch,
            3 => Self::InverseMatch,
            _ => Self::UnknownValue(matching_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MatchingType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MATCHING_TYPE_UNSPECIFIED" => Self::Unspecified,
            "MATCHING_TYPE_FULL_MATCH" => Self::FullMatch,
            "MATCHING_TYPE_PARTIAL_MATCH" => Self::PartialMatch,
            "MATCHING_TYPE_INVERSE_MATCH" => Self::InverseMatch,
            _ => Self::UnknownValue(matching_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MatchingType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::FullMatch => serializer.serialize_i32(1),
            Self::PartialMatch => serializer.serialize_i32(2),
            Self::InverseMatch => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MatchingType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MatchingType>::new(
            ".google.privacy.dlp.v2.MatchingType",
        ))
    }
}

/// Deprecated and unused.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ContentOption {
    /// Includes entire content of a file or a data stream.
    ContentUnspecified,
    /// Text content within the data, excluding any metadata.
    ContentText,
    /// Images found in the data.
    ContentImage,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ContentOption::value] or
    /// [ContentOption::name].
    UnknownValue(content_option::UnknownValue),
}

#[doc(hidden)]
pub mod content_option {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ContentOption {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::ContentUnspecified => std::option::Option::Some(0),
            Self::ContentText => std::option::Option::Some(1),
            Self::ContentImage => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::ContentUnspecified => std::option::Option::Some("CONTENT_UNSPECIFIED"),
            Self::ContentText => std::option::Option::Some("CONTENT_TEXT"),
            Self::ContentImage => std::option::Option::Some("CONTENT_IMAGE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ContentOption {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ContentOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ContentOption {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::ContentUnspecified,
            1 => Self::ContentText,
            2 => Self::ContentImage,
            _ => Self::UnknownValue(content_option::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ContentOption {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONTENT_UNSPECIFIED" => Self::ContentUnspecified,
            "CONTENT_TEXT" => Self::ContentText,
            "CONTENT_IMAGE" => Self::ContentImage,
            _ => Self::UnknownValue(content_option::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ContentOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::ContentUnspecified => serializer.serialize_i32(0),
            Self::ContentText => serializer.serialize_i32(1),
            Self::ContentImage => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ContentOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContentOption>::new(
            ".google.privacy.dlp.v2.ContentOption",
        ))
    }
}

/// Type of metadata containing the finding.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MetadataType {
    /// Unused
    MetadatatypeUnspecified,
    /// General file metadata provided by Cloud Storage.
    StorageMetadata,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MetadataType::value] or
    /// [MetadataType::name].
    UnknownValue(metadata_type::UnknownValue),
}

#[doc(hidden)]
pub mod metadata_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MetadataType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::MetadatatypeUnspecified => std::option::Option::Some(0),
            Self::StorageMetadata => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::MetadatatypeUnspecified => std::option::Option::Some("METADATATYPE_UNSPECIFIED"),
            Self::StorageMetadata => std::option::Option::Some("STORAGE_METADATA"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MetadataType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MetadataType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MetadataType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::MetadatatypeUnspecified,
            2 => Self::StorageMetadata,
            _ => Self::UnknownValue(metadata_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MetadataType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "METADATATYPE_UNSPECIFIED" => Self::MetadatatypeUnspecified,
            "STORAGE_METADATA" => Self::StorageMetadata,
            _ => Self::UnknownValue(metadata_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MetadataType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::MetadatatypeUnspecified => serializer.serialize_i32(0),
            Self::StorageMetadata => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MetadataType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MetadataType>::new(
            ".google.privacy.dlp.v2.MetadataType",
        ))
    }
}

/// Parts of the APIs which use certain infoTypes.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InfoTypeSupportedBy {
    /// Unused.
    EnumTypeUnspecified,
    /// Supported by the inspect operations.
    Inspect,
    /// Supported by the risk analysis operations.
    RiskAnalysis,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InfoTypeSupportedBy::value] or
    /// [InfoTypeSupportedBy::name].
    UnknownValue(info_type_supported_by::UnknownValue),
}

#[doc(hidden)]
pub mod info_type_supported_by {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InfoTypeSupportedBy {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::EnumTypeUnspecified => std::option::Option::Some(0),
            Self::Inspect => std::option::Option::Some(1),
            Self::RiskAnalysis => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::EnumTypeUnspecified => std::option::Option::Some("ENUM_TYPE_UNSPECIFIED"),
            Self::Inspect => std::option::Option::Some("INSPECT"),
            Self::RiskAnalysis => std::option::Option::Some("RISK_ANALYSIS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InfoTypeSupportedBy {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InfoTypeSupportedBy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InfoTypeSupportedBy {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::EnumTypeUnspecified,
            1 => Self::Inspect,
            2 => Self::RiskAnalysis,
            _ => Self::UnknownValue(info_type_supported_by::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InfoTypeSupportedBy {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENUM_TYPE_UNSPECIFIED" => Self::EnumTypeUnspecified,
            "INSPECT" => Self::Inspect,
            "RISK_ANALYSIS" => Self::RiskAnalysis,
            _ => Self::UnknownValue(info_type_supported_by::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InfoTypeSupportedBy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::EnumTypeUnspecified => serializer.serialize_i32(0),
            Self::Inspect => serializer.serialize_i32(1),
            Self::RiskAnalysis => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InfoTypeSupportedBy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<InfoTypeSupportedBy>::new(
            ".google.privacy.dlp.v2.InfoTypeSupportedBy",
        ))
    }
}

/// An enum to represent the various types of DLP jobs.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DlpJobType {
    /// Defaults to INSPECT_JOB.
    Unspecified,
    /// The job inspected Google Cloud for sensitive data.
    InspectJob,
    /// The job executed a Risk Analysis computation.
    RiskAnalysisJob,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DlpJobType::value] or
    /// [DlpJobType::name].
    UnknownValue(dlp_job_type::UnknownValue),
}

#[doc(hidden)]
pub mod dlp_job_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DlpJobType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::InspectJob => std::option::Option::Some(1),
            Self::RiskAnalysisJob => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DLP_JOB_TYPE_UNSPECIFIED"),
            Self::InspectJob => std::option::Option::Some("INSPECT_JOB"),
            Self::RiskAnalysisJob => std::option::Option::Some("RISK_ANALYSIS_JOB"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DlpJobType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DlpJobType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DlpJobType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::InspectJob,
            2 => Self::RiskAnalysisJob,
            _ => Self::UnknownValue(dlp_job_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DlpJobType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DLP_JOB_TYPE_UNSPECIFIED" => Self::Unspecified,
            "INSPECT_JOB" => Self::InspectJob,
            "RISK_ANALYSIS_JOB" => Self::RiskAnalysisJob,
            _ => Self::UnknownValue(dlp_job_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DlpJobType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::InspectJob => serializer.serialize_i32(1),
            Self::RiskAnalysisJob => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DlpJobType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DlpJobType>::new(
            ".google.privacy.dlp.v2.DlpJobType",
        ))
    }
}

/// State of a StoredInfoType version.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum StoredInfoTypeState {
    /// Unused
    Unspecified,
    /// StoredInfoType version is being created.
    Pending,
    /// StoredInfoType version is ready for use.
    Ready,
    /// StoredInfoType creation failed. All relevant error messages are returned in
    /// the `StoredInfoTypeVersion` message.
    Failed,
    /// StoredInfoType is no longer valid because artifacts stored in
    /// user-controlled storage were modified. To fix an invalid StoredInfoType,
    /// use the `UpdateStoredInfoType` method to create a new version.
    Invalid,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [StoredInfoTypeState::value] or
    /// [StoredInfoTypeState::name].
    UnknownValue(stored_info_type_state::UnknownValue),
}

#[doc(hidden)]
pub mod stored_info_type_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl StoredInfoTypeState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Pending => std::option::Option::Some(1),
            Self::Ready => std::option::Option::Some(2),
            Self::Failed => std::option::Option::Some(3),
            Self::Invalid => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STORED_INFO_TYPE_STATE_UNSPECIFIED"),
            Self::Pending => std::option::Option::Some("PENDING"),
            Self::Ready => std::option::Option::Some("READY"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::Invalid => std::option::Option::Some("INVALID"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for StoredInfoTypeState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for StoredInfoTypeState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for StoredInfoTypeState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Pending,
            2 => Self::Ready,
            3 => Self::Failed,
            4 => Self::Invalid,
            _ => Self::UnknownValue(stored_info_type_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for StoredInfoTypeState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STORED_INFO_TYPE_STATE_UNSPECIFIED" => Self::Unspecified,
            "PENDING" => Self::Pending,
            "READY" => Self::Ready,
            "FAILED" => Self::Failed,
            "INVALID" => Self::Invalid,
            _ => Self::UnknownValue(stored_info_type_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for StoredInfoTypeState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Pending => serializer.serialize_i32(1),
            Self::Ready => serializer.serialize_i32(2),
            Self::Failed => serializer.serialize_i32(3),
            Self::Invalid => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for StoredInfoTypeState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<StoredInfoTypeState>::new(
            ".google.privacy.dlp.v2.StoredInfoTypeState",
        ))
    }
}

/// How broadly the data in the resource has been shared. New items may be added
/// over time. A higher number means more restricted.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ResourceVisibility {
    /// Unused.
    Unspecified,
    /// Visible to any user.
    Public,
    /// May contain public items.
    /// For example, if a Cloud Storage bucket has uniform bucket level access
    /// disabled, some objects inside it may be public, but none are known yet.
    Inconclusive,
    /// Visible only to specific users.
    Restricted,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ResourceVisibility::value] or
    /// [ResourceVisibility::name].
    UnknownValue(resource_visibility::UnknownValue),
}

#[doc(hidden)]
pub mod resource_visibility {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ResourceVisibility {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Public => std::option::Option::Some(10),
            Self::Inconclusive => std::option::Option::Some(15),
            Self::Restricted => std::option::Option::Some(20),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RESOURCE_VISIBILITY_UNSPECIFIED"),
            Self::Public => std::option::Option::Some("RESOURCE_VISIBILITY_PUBLIC"),
            Self::Inconclusive => std::option::Option::Some("RESOURCE_VISIBILITY_INCONCLUSIVE"),
            Self::Restricted => std::option::Option::Some("RESOURCE_VISIBILITY_RESTRICTED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ResourceVisibility {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ResourceVisibility {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ResourceVisibility {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            10 => Self::Public,
            15 => Self::Inconclusive,
            20 => Self::Restricted,
            _ => Self::UnknownValue(resource_visibility::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ResourceVisibility {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RESOURCE_VISIBILITY_UNSPECIFIED" => Self::Unspecified,
            "RESOURCE_VISIBILITY_PUBLIC" => Self::Public,
            "RESOURCE_VISIBILITY_INCONCLUSIVE" => Self::Inconclusive,
            "RESOURCE_VISIBILITY_RESTRICTED" => Self::Restricted,
            _ => Self::UnknownValue(resource_visibility::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ResourceVisibility {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Public => serializer.serialize_i32(10),
            Self::Inconclusive => serializer.serialize_i32(15),
            Self::Restricted => serializer.serialize_i32(20),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ResourceVisibility {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResourceVisibility>::new(
            ".google.privacy.dlp.v2.ResourceVisibility",
        ))
    }
}

/// How a resource is encrypted.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EncryptionStatus {
    /// Unused.
    Unspecified,
    /// Google manages server-side encryption keys on your behalf.
    EncryptionGoogleManaged,
    /// Customer provides the key.
    EncryptionCustomerManaged,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EncryptionStatus::value] or
    /// [EncryptionStatus::name].
    UnknownValue(encryption_status::UnknownValue),
}

#[doc(hidden)]
pub mod encryption_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EncryptionStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::EncryptionGoogleManaged => std::option::Option::Some(1),
            Self::EncryptionCustomerManaged => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENCRYPTION_STATUS_UNSPECIFIED"),
            Self::EncryptionGoogleManaged => std::option::Option::Some("ENCRYPTION_GOOGLE_MANAGED"),
            Self::EncryptionCustomerManaged => {
                std::option::Option::Some("ENCRYPTION_CUSTOMER_MANAGED")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EncryptionStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EncryptionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EncryptionStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::EncryptionGoogleManaged,
            2 => Self::EncryptionCustomerManaged,
            _ => Self::UnknownValue(encryption_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EncryptionStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENCRYPTION_STATUS_UNSPECIFIED" => Self::Unspecified,
            "ENCRYPTION_GOOGLE_MANAGED" => Self::EncryptionGoogleManaged,
            "ENCRYPTION_CUSTOMER_MANAGED" => Self::EncryptionCustomerManaged,
            _ => Self::UnknownValue(encryption_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EncryptionStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::EncryptionGoogleManaged => serializer.serialize_i32(1),
            Self::EncryptionCustomerManaged => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EncryptionStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncryptionStatus>::new(
            ".google.privacy.dlp.v2.EncryptionStatus",
        ))
    }
}

/// Bucketized nullness percentage levels. A higher level means a higher
/// percentage of the column is null.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NullPercentageLevel {
    /// Unused.
    Unspecified,
    /// Very few null entries.
    NullPercentageVeryLow,
    /// Some null entries.
    NullPercentageLow,
    /// A few null entries.
    NullPercentageMedium,
    /// A lot of null entries.
    NullPercentageHigh,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NullPercentageLevel::value] or
    /// [NullPercentageLevel::name].
    UnknownValue(null_percentage_level::UnknownValue),
}

#[doc(hidden)]
pub mod null_percentage_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NullPercentageLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NullPercentageVeryLow => std::option::Option::Some(1),
            Self::NullPercentageLow => std::option::Option::Some(2),
            Self::NullPercentageMedium => std::option::Option::Some(3),
            Self::NullPercentageHigh => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NULL_PERCENTAGE_LEVEL_UNSPECIFIED"),
            Self::NullPercentageVeryLow => std::option::Option::Some("NULL_PERCENTAGE_VERY_LOW"),
            Self::NullPercentageLow => std::option::Option::Some("NULL_PERCENTAGE_LOW"),
            Self::NullPercentageMedium => std::option::Option::Some("NULL_PERCENTAGE_MEDIUM"),
            Self::NullPercentageHigh => std::option::Option::Some("NULL_PERCENTAGE_HIGH"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NullPercentageLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NullPercentageLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NullPercentageLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NullPercentageVeryLow,
            2 => Self::NullPercentageLow,
            3 => Self::NullPercentageMedium,
            4 => Self::NullPercentageHigh,
            _ => Self::UnknownValue(null_percentage_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for NullPercentageLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NULL_PERCENTAGE_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "NULL_PERCENTAGE_VERY_LOW" => Self::NullPercentageVeryLow,
            "NULL_PERCENTAGE_LOW" => Self::NullPercentageLow,
            "NULL_PERCENTAGE_MEDIUM" => Self::NullPercentageMedium,
            "NULL_PERCENTAGE_HIGH" => Self::NullPercentageHigh,
            _ => Self::UnknownValue(null_percentage_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for NullPercentageLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NullPercentageVeryLow => serializer.serialize_i32(1),
            Self::NullPercentageLow => serializer.serialize_i32(2),
            Self::NullPercentageMedium => serializer.serialize_i32(3),
            Self::NullPercentageHigh => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NullPercentageLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NullPercentageLevel>::new(
            ".google.privacy.dlp.v2.NullPercentageLevel",
        ))
    }
}

/// Bucketized uniqueness score levels. A higher uniqueness score is a strong
/// signal that the column may contain a unique identifier like user id. A low
/// value indicates that the column contains few unique values like booleans or
/// other classifiers.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum UniquenessScoreLevel {
    /// Some columns do not have estimated uniqueness. Possible reasons include
    /// having too few values.
    Unspecified,
    /// Low uniqueness, possibly a boolean, enum or similiarly typed column.
    UniquenessScoreLow,
    /// Medium uniqueness.
    UniquenessScoreMedium,
    /// High uniqueness, possibly a column of free text or unique identifiers.
    UniquenessScoreHigh,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [UniquenessScoreLevel::value] or
    /// [UniquenessScoreLevel::name].
    UnknownValue(uniqueness_score_level::UnknownValue),
}

#[doc(hidden)]
pub mod uniqueness_score_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl UniquenessScoreLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::UniquenessScoreLow => std::option::Option::Some(1),
            Self::UniquenessScoreMedium => std::option::Option::Some(2),
            Self::UniquenessScoreHigh => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("UNIQUENESS_SCORE_LEVEL_UNSPECIFIED"),
            Self::UniquenessScoreLow => std::option::Option::Some("UNIQUENESS_SCORE_LOW"),
            Self::UniquenessScoreMedium => std::option::Option::Some("UNIQUENESS_SCORE_MEDIUM"),
            Self::UniquenessScoreHigh => std::option::Option::Some("UNIQUENESS_SCORE_HIGH"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for UniquenessScoreLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for UniquenessScoreLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for UniquenessScoreLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::UniquenessScoreLow,
            2 => Self::UniquenessScoreMedium,
            3 => Self::UniquenessScoreHigh,
            _ => Self::UnknownValue(uniqueness_score_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for UniquenessScoreLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UNIQUENESS_SCORE_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "UNIQUENESS_SCORE_LOW" => Self::UniquenessScoreLow,
            "UNIQUENESS_SCORE_MEDIUM" => Self::UniquenessScoreMedium,
            "UNIQUENESS_SCORE_HIGH" => Self::UniquenessScoreHigh,
            _ => Self::UnknownValue(uniqueness_score_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for UniquenessScoreLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::UniquenessScoreLow => serializer.serialize_i32(1),
            Self::UniquenessScoreMedium => serializer.serialize_i32(2),
            Self::UniquenessScoreHigh => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for UniquenessScoreLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<UniquenessScoreLevel>::new(
            ".google.privacy.dlp.v2.UniquenessScoreLevel",
        ))
    }
}

/// State of the connection.
/// New values may be added over time.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ConnectionState {
    /// Unused
    Unspecified,
    /// The DLP API automatically created this connection during an initial scan,
    /// and it is awaiting full configuration by a user.
    MissingCredentials,
    /// A configured connection that has not encountered any errors.
    Available,
    /// A configured connection that encountered errors during its last use. It
    /// will not be used again until it is set to AVAILABLE.
    ///
    /// If the resolution requires external action, then the client must send a
    /// request to set the status to AVAILABLE when the connection is ready for
    /// use. If the resolution doesn't require external action, then any changes to
    /// the connection properties will automatically mark it as AVAILABLE.
    Error,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ConnectionState::value] or
    /// [ConnectionState::name].
    UnknownValue(connection_state::UnknownValue),
}

#[doc(hidden)]
pub mod connection_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ConnectionState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::MissingCredentials => std::option::Option::Some(1),
            Self::Available => std::option::Option::Some(2),
            Self::Error => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONNECTION_STATE_UNSPECIFIED"),
            Self::MissingCredentials => std::option::Option::Some("MISSING_CREDENTIALS"),
            Self::Available => std::option::Option::Some("AVAILABLE"),
            Self::Error => std::option::Option::Some("ERROR"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ConnectionState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ConnectionState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ConnectionState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::MissingCredentials,
            2 => Self::Available,
            3 => Self::Error,
            _ => Self::UnknownValue(connection_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ConnectionState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONNECTION_STATE_UNSPECIFIED" => Self::Unspecified,
            "MISSING_CREDENTIALS" => Self::MissingCredentials,
            "AVAILABLE" => Self::Available,
            "ERROR" => Self::Error,
            _ => Self::UnknownValue(connection_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ConnectionState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::MissingCredentials => serializer.serialize_i32(1),
            Self::Available => serializer.serialize_i32(2),
            Self::Error => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ConnectionState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionState>::new(
            ".google.privacy.dlp.v2.ConnectionState",
        ))
    }
}

/// Coarse-grained confidence level of how well a particular finding
/// satisfies the criteria to match a particular infoType.
///
/// Likelihood is calculated based on the number of signals a
/// finding has that implies that the finding matches the infoType. For
/// example, a string that has an '@' and a '.com' is more likely to be a
/// match for an email address than a string that only has an '@'.
///
/// In general, the highest likelihood level has the strongest signals that
/// indicate a match. That is, a finding with a high likelihood has a low chance
/// of being a false positive.
///
/// For more information about each likelihood level
/// and how likelihood works, see [Match
/// likelihood](https://cloud.google.com/sensitive-data-protection/docs/likelihood).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Likelihood {
    /// Default value; same as POSSIBLE.
    Unspecified,
    /// Highest chance of a false positive.
    VeryUnlikely,
    /// High chance of a false positive.
    Unlikely,
    /// Some matching signals. The default value.
    Possible,
    /// Low chance of a false positive.
    Likely,
    /// Confidence level is high. Lowest chance of a false positive.
    VeryLikely,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Likelihood::value] or
    /// [Likelihood::name].
    UnknownValue(likelihood::UnknownValue),
}

#[doc(hidden)]
pub mod likelihood {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Likelihood {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::VeryUnlikely => std::option::Option::Some(1),
            Self::Unlikely => std::option::Option::Some(2),
            Self::Possible => std::option::Option::Some(3),
            Self::Likely => std::option::Option::Some(4),
            Self::VeryLikely => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LIKELIHOOD_UNSPECIFIED"),
            Self::VeryUnlikely => std::option::Option::Some("VERY_UNLIKELY"),
            Self::Unlikely => std::option::Option::Some("UNLIKELY"),
            Self::Possible => std::option::Option::Some("POSSIBLE"),
            Self::Likely => std::option::Option::Some("LIKELY"),
            Self::VeryLikely => std::option::Option::Some("VERY_LIKELY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Likelihood {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Likelihood {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Likelihood {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::VeryUnlikely,
            2 => Self::Unlikely,
            3 => Self::Possible,
            4 => Self::Likely,
            5 => Self::VeryLikely,
            _ => Self::UnknownValue(likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Likelihood {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LIKELIHOOD_UNSPECIFIED" => Self::Unspecified,
            "VERY_UNLIKELY" => Self::VeryUnlikely,
            "UNLIKELY" => Self::Unlikely,
            "POSSIBLE" => Self::Possible,
            "LIKELY" => Self::Likely,
            "VERY_LIKELY" => Self::VeryLikely,
            _ => Self::UnknownValue(likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Likelihood {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::VeryUnlikely => serializer.serialize_i32(1),
            Self::Unlikely => serializer.serialize_i32(2),
            Self::Possible => serializer.serialize_i32(3),
            Self::Likely => serializer.serialize_i32(4),
            Self::VeryLikely => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Likelihood {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Likelihood>::new(
            ".google.privacy.dlp.v2.Likelihood",
        ))
    }
}

/// Definitions of file type groups to scan. New types will be added to this
/// list.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FileType {
    /// Includes all files.
    Unspecified,
    /// Includes all file extensions not covered by another entry. Binary
    /// scanning attempts to convert the content of the file to utf_8 to scan
    /// the file.
    /// If you wish to avoid this fall back, specify one or more of the other
    /// file types in your storage scan.
    BinaryFile,
    /// Included file extensions:
    /// asc,asp, aspx, brf, c, cc,cfm, cgi, cpp, csv, cxx, c++, cs, css, dart,
    /// dat, dot, eml,, epbub, ged, go, h, hh, hpp, hxx, h++, hs, html, htm,
    /// mkd, markdown, m, ml, mli, perl, pl, plist, pm, php, phtml, pht,
    /// properties, py, pyw, rb, rbw, rs, rss,  rc, scala, sh, sql, swift, tex,
    /// shtml, shtm, xhtml, lhs, ics, ini, java, js, json, jsonl, kix, kml,
    /// ocaml, md, txt, text, tsv, vb, vcard, vcs, wml, xcodeproj, xml, xsl, xsd,
    /// yml, yaml.
    TextFile,
    /// Included file extensions:
    /// bmp, gif, jpg, jpeg, jpe, png. Setting
    /// [bytes_limit_per_file][google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file]
    /// or
    /// [bytes_limit_per_file_percent][google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file]
    /// has no effect on image files. Image inspection is restricted to the
    /// `global`, `us`, `asia`, and `europe` regions.
    ///
    /// [google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file]: crate::model::CloudStorageOptions::bytes_limit_per_file
    Image,
    /// Microsoft Word files larger than 30 MB will be scanned as binary files.
    /// Included file extensions:
    /// docx, dotx, docm, dotm. Setting `bytes_limit_per_file` or
    /// `bytes_limit_per_file_percent` has no effect on Word files.
    Word,
    /// PDF files larger than 30 MB will be scanned as binary files.
    /// Included file extensions:
    /// pdf. Setting `bytes_limit_per_file` or `bytes_limit_per_file_percent`
    /// has no effect on PDF files.
    Pdf,
    /// Included file extensions:
    /// avro
    Avro,
    /// Included file extensions:
    /// csv
    Csv,
    /// Included file extensions:
    /// tsv
    Tsv,
    /// Microsoft PowerPoint files larger than 30 MB will be scanned as binary
    /// files. Included file extensions:
    /// pptx, pptm, potx, potm, pot. Setting `bytes_limit_per_file` or
    /// `bytes_limit_per_file_percent` has no effect on PowerPoint files.
    Powerpoint,
    /// Microsoft Excel files larger than 30 MB will be scanned as binary files.
    /// Included file extensions:
    /// xlsx, xlsm, xltx, xltm. Setting `bytes_limit_per_file` or
    /// `bytes_limit_per_file_percent` has no effect on Excel files.
    Excel,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FileType::value] or
    /// [FileType::name].
    UnknownValue(file_type::UnknownValue),
}

#[doc(hidden)]
pub mod file_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FileType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::BinaryFile => std::option::Option::Some(1),
            Self::TextFile => std::option::Option::Some(2),
            Self::Image => std::option::Option::Some(3),
            Self::Word => std::option::Option::Some(5),
            Self::Pdf => std::option::Option::Some(6),
            Self::Avro => std::option::Option::Some(7),
            Self::Csv => std::option::Option::Some(8),
            Self::Tsv => std::option::Option::Some(9),
            Self::Powerpoint => std::option::Option::Some(11),
            Self::Excel => std::option::Option::Some(12),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FILE_TYPE_UNSPECIFIED"),
            Self::BinaryFile => std::option::Option::Some("BINARY_FILE"),
            Self::TextFile => std::option::Option::Some("TEXT_FILE"),
            Self::Image => std::option::Option::Some("IMAGE"),
            Self::Word => std::option::Option::Some("WORD"),
            Self::Pdf => std::option::Option::Some("PDF"),
            Self::Avro => std::option::Option::Some("AVRO"),
            Self::Csv => std::option::Option::Some("CSV"),
            Self::Tsv => std::option::Option::Some("TSV"),
            Self::Powerpoint => std::option::Option::Some("POWERPOINT"),
            Self::Excel => std::option::Option::Some("EXCEL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FileType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FileType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FileType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::BinaryFile,
            2 => Self::TextFile,
            3 => Self::Image,
            5 => Self::Word,
            6 => Self::Pdf,
            7 => Self::Avro,
            8 => Self::Csv,
            9 => Self::Tsv,
            11 => Self::Powerpoint,
            12 => Self::Excel,
            _ => Self::UnknownValue(file_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FileType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FILE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BINARY_FILE" => Self::BinaryFile,
            "TEXT_FILE" => Self::TextFile,
            "IMAGE" => Self::Image,
            "WORD" => Self::Word,
            "PDF" => Self::Pdf,
            "AVRO" => Self::Avro,
            "CSV" => Self::Csv,
            "TSV" => Self::Tsv,
            "POWERPOINT" => Self::Powerpoint,
            "EXCEL" => Self::Excel,
            _ => Self::UnknownValue(file_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FileType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::BinaryFile => serializer.serialize_i32(1),
            Self::TextFile => serializer.serialize_i32(2),
            Self::Image => serializer.serialize_i32(3),
            Self::Word => serializer.serialize_i32(5),
            Self::Pdf => serializer.serialize_i32(6),
            Self::Avro => serializer.serialize_i32(7),
            Self::Csv => serializer.serialize_i32(8),
            Self::Tsv => serializer.serialize_i32(9),
            Self::Powerpoint => serializer.serialize_i32(11),
            Self::Excel => serializer.serialize_i32(12),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FileType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FileType>::new(
            ".google.privacy.dlp.v2.FileType",
        ))
    }
}
