// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// List of excluded infoTypes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExcludeInfoTypes {
    /// InfoType list in ExclusionRule rule drops a finding when it overlaps or
    /// contained within with a finding of an infoType from this list. For
    /// example, for `InspectionRuleSet.info_types` containing "PHONE_NUMBER"` and
    /// `exclusion_rule` containing `exclude_info_types.info_types` with
    /// "EMAIL_ADDRESS" the phone number findings are dropped if they overlap
    /// with EMAIL_ADDRESS finding.
    /// That leads to "555-222-2222@example.org" to generate only a single
    /// finding, namely email address.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub info_types: std::vec::Vec<crate::model::InfoType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExcludeInfoTypes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_types][crate::model::ExcludeInfoTypes::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoType>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExcludeInfoTypes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ExcludeInfoTypes"
    }
}

/// The rule to exclude findings based on a hotword. For record inspection of
/// tables, column names are considered hotwords. An example of this is to
/// exclude a finding if it belongs to a BigQuery column that matches a specific
/// pattern.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExcludeByHotword {
    /// Regular expression pattern defining what qualifies as a hotword.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hotword_regex: std::option::Option<crate::model::custom_info_type::Regex>,

    /// Range of characters within which the entire hotword must reside.
    /// The total length of the window cannot exceed 1000 characters.
    /// The windowBefore property in proximity should be set to 1 if the hotword
    /// needs to be included in a column header.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub proximity: std::option::Option<crate::model::custom_info_type::detection_rule::Proximity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExcludeByHotword {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hotword_regex][crate::model::ExcludeByHotword::hotword_regex].
    pub fn set_hotword_regex<
        T: std::convert::Into<std::option::Option<crate::model::custom_info_type::Regex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hotword_regex = v.into();
        self
    }

    /// Sets the value of [proximity][crate::model::ExcludeByHotword::proximity].
    pub fn set_proximity<
        T: std::convert::Into<
                std::option::Option<crate::model::custom_info_type::detection_rule::Proximity>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.proximity = v.into();
        self
    }
}

impl wkt::message::Message for ExcludeByHotword {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ExcludeByHotword"
    }
}

/// The rule that specifies conditions when findings of infoTypes specified in
/// `InspectionRuleSet` are removed from results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExclusionRule {
    /// How the rule is applied, see MatchingType documentation for details.
    pub matching_type: crate::model::MatchingType,

    /// Exclusion rule types.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::exclusion_rule::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExclusionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [matching_type][crate::model::ExclusionRule::matching_type].
    pub fn set_matching_type<T: std::convert::Into<crate::model::MatchingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.matching_type = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::exclusion_rule::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `Dictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Dictionary>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::Dictionary(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `Dictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Dictionary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::exclusion_rule::Type::Dictionary(v.into()));
        self
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `Regex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Regex>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::Regex(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `Regex`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Regex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::exclusion_rule::Type::Regex(v.into()));
        self
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `ExcludeInfoTypes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclude_info_types(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExcludeInfoTypes>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::ExcludeInfoTypes(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `ExcludeInfoTypes`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_exclude_info_types<
        T: std::convert::Into<std::boxed::Box<crate::model::ExcludeInfoTypes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::exclusion_rule::Type::ExcludeInfoTypes(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `ExcludeByHotword`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclude_by_hotword(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExcludeByHotword>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::ExcludeByHotword(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `ExcludeByHotword`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_exclude_by_hotword<
        T: std::convert::Into<std::boxed::Box<crate::model::ExcludeByHotword>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::exclusion_rule::Type::ExcludeByHotword(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExclusionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ExclusionRule"
    }
}

/// Defines additional types related to [ExclusionRule].
pub mod exclusion_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Exclusion rule types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// Dictionary which defines the rule.
        Dictionary(std::boxed::Box<crate::model::custom_info_type::Dictionary>),
        /// Regular expression which defines the rule.
        Regex(std::boxed::Box<crate::model::custom_info_type::Regex>),
        /// Set of infoTypes for which findings would affect this rule.
        ExcludeInfoTypes(std::boxed::Box<crate::model::ExcludeInfoTypes>),
        /// Drop if the hotword rule is contained in the proximate context. For
        /// tabular data, the context includes the column name.
        ExcludeByHotword(std::boxed::Box<crate::model::ExcludeByHotword>),
    }
}

/// A single inspection rule to be applied to infoTypes, specified in
/// `InspectionRuleSet`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectionRule {
    /// Inspection rule types.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::inspection_rule::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::InspectionRule::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::inspection_rule::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::InspectionRule::r#type]
    /// if it holds a `HotwordRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hotword_rule(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
    > {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::inspection_rule::Type::HotwordRule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::InspectionRule::r#type]
    /// to hold a `HotwordRule`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_hotword_rule<
        T: std::convert::Into<
                std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::inspection_rule::Type::HotwordRule(v.into()));
        self
    }

    /// The value of [r#type][crate::model::InspectionRule::r#type]
    /// if it holds a `ExclusionRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclusion_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExclusionRule>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::inspection_rule::Type::ExclusionRule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::InspectionRule::r#type]
    /// to hold a `ExclusionRule`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_exclusion_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::ExclusionRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::inspection_rule::Type::ExclusionRule(v.into()));
        self
    }
}

impl wkt::message::Message for InspectionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectionRule"
    }
}

/// Defines additional types related to [InspectionRule].
pub mod inspection_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Inspection rule types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// Hotword-based detection rule.
        HotwordRule(std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>),
        /// Exclusion rule.
        ExclusionRule(std::boxed::Box<crate::model::ExclusionRule>),
    }
}

/// Rule set for modifying a set of infoTypes to alter behavior under certain
/// circumstances, depending on the specific details of the rules within the set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectionRuleSet {
    /// List of infoTypes this rule set is applied to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub info_types: std::vec::Vec<crate::model::InfoType>,

    /// Set of rules to be applied to infoTypes. The rules are applied in order.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rules: std::vec::Vec<crate::model::InspectionRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectionRuleSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_types][crate::model::InspectionRuleSet::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoType>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rules][crate::model::InspectionRuleSet::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InspectionRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InspectionRuleSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectionRuleSet"
    }
}

/// Configuration description of the scanning process.
/// When used with redactContent only info_types and min_likelihood are currently
/// used.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectConfig {
    /// Restricts what info_types to look for. The values must correspond to
    /// InfoType values returned by ListInfoTypes or listed at
    /// <https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference>.
    ///
    /// When no InfoTypes or CustomInfoTypes are specified in a request, the
    /// system may automatically choose a default list of detectors to run, which
    /// may change over time.
    ///
    /// If you need precise control and predictability as to what detectors are
    /// run you should specify specific InfoTypes listed in the reference,
    /// otherwise a default list will be used, which may change over time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub info_types: std::vec::Vec<crate::model::InfoType>,

    /// Only returns findings equal to or above this threshold. The default is
    /// POSSIBLE.
    ///
    /// In general, the highest likelihood setting yields the fewest findings in
    /// results and the lowest chance of a false positive. For more information,
    /// see [Match
    /// likelihood](https://cloud.google.com/sensitive-data-protection/docs/likelihood).
    pub min_likelihood: crate::model::Likelihood,

    /// Minimum likelihood per infotype. For each infotype, a user can specify a
    /// minimum likelihood. The system only returns a finding if its likelihood is
    /// above this threshold. If this field is not set, the system uses the
    /// InspectConfig min_likelihood.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub min_likelihood_per_info_type:
        std::vec::Vec<crate::model::inspect_config::InfoTypeLikelihood>,

    /// Configuration to control the number of findings returned.
    /// This is not used for data profiling.
    ///
    /// When redacting sensitive data from images, finding limits don't apply. They
    /// can cause unexpected or inconsistent results, where only some data is
    /// redacted. Don't include finding limits in
    /// [RedactImage][google.privacy.dlp.v2.DlpService.RedactImage]
    /// requests. Otherwise, Cloud DLP returns an error.
    ///
    /// When set within an
    /// [InspectJobConfig][google.privacy.dlp.v2.InspectJobConfig], the specified
    /// maximum values aren't hard limits. If an inspection job reaches these
    /// limits, the job ends gradually, not abruptly. Therefore, the actual number
    /// of findings that Cloud DLP returns can be multiple times higher than these
    /// maximum values.
    ///
    /// [google.privacy.dlp.v2.DlpService.RedactImage]: crate::client::DlpService::redact_image
    /// [google.privacy.dlp.v2.InspectJobConfig]: crate::model::InspectJobConfig
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub limits: std::option::Option<crate::model::inspect_config::FindingLimits>,

    /// When true, a contextual quote from the data that triggered a finding is
    /// included in the response; see
    /// [Finding.quote][google.privacy.dlp.v2.Finding.quote]. This is not used for
    /// data profiling.
    ///
    /// [google.privacy.dlp.v2.Finding.quote]: crate::model::Finding::quote
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub include_quote: bool,

    /// When true, excludes type information of the findings.
    /// This is not used for data profiling.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub exclude_info_types: bool,

    /// CustomInfoTypes provided by the user. See
    /// <https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes>
    /// to learn more.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub custom_info_types: std::vec::Vec<crate::model::CustomInfoType>,

    /// Deprecated and unused.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub content_options: std::vec::Vec<crate::model::ContentOption>,

    /// Set of rules to apply to the findings for this InspectConfig.
    /// Exclusion rules, contained in the set are executed in the end, other
    /// rules are executed in the order they are specified for each info type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rule_set: std::vec::Vec<crate::model::InspectionRuleSet>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_types][crate::model::InspectConfig::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoType>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_likelihood][crate::model::InspectConfig::min_likelihood].
    pub fn set_min_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_likelihood = v.into();
        self
    }

    /// Sets the value of [min_likelihood_per_info_type][crate::model::InspectConfig::min_likelihood_per_info_type].
    pub fn set_min_likelihood_per_info_type<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::inspect_config::InfoTypeLikelihood>,
    {
        use std::iter::Iterator;
        self.min_likelihood_per_info_type = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [limits][crate::model::InspectConfig::limits].
    pub fn set_limits<
        T: std::convert::Into<std::option::Option<crate::model::inspect_config::FindingLimits>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.limits = v.into();
        self
    }

    /// Sets the value of [include_quote][crate::model::InspectConfig::include_quote].
    pub fn set_include_quote<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_quote = v.into();
        self
    }

    /// Sets the value of [exclude_info_types][crate::model::InspectConfig::exclude_info_types].
    pub fn set_exclude_info_types<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.exclude_info_types = v.into();
        self
    }

    /// Sets the value of [custom_info_types][crate::model::InspectConfig::custom_info_types].
    pub fn set_custom_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomInfoType>,
    {
        use std::iter::Iterator;
        self.custom_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [content_options][crate::model::InspectConfig::content_options].
    pub fn set_content_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ContentOption>,
    {
        use std::iter::Iterator;
        self.content_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rule_set][crate::model::InspectConfig::rule_set].
    pub fn set_rule_set<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InspectionRuleSet>,
    {
        use std::iter::Iterator;
        self.rule_set = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InspectConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectConfig"
    }
}

/// Defines additional types related to [InspectConfig].
pub mod inspect_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for setting a minimum likelihood per infotype. Used to
    /// customize the minimum likelihood level for specific infotypes in the
    /// request. For example, use this if you want to lower the precision for
    /// PERSON_NAME without lowering the precision for the other infotypes in the
    /// request.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InfoTypeLikelihood {
        /// Type of information the likelihood threshold applies to. Only one
        /// likelihood per info_type should be provided. If InfoTypeLikelihood does
        /// not have an info_type, the configuration fails.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub info_type: std::option::Option<crate::model::InfoType>,

        /// Only returns findings equal to or above this threshold. This field is
        /// required or else the configuration fails.
        pub min_likelihood: crate::model::Likelihood,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InfoTypeLikelihood {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [info_type][crate::model::inspect_config::InfoTypeLikelihood::info_type].
        pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
            mut self,
            v: T,
        ) -> Self {
            self.info_type = v.into();
            self
        }

        /// Sets the value of [min_likelihood][crate::model::inspect_config::InfoTypeLikelihood::min_likelihood].
        pub fn set_min_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_likelihood = v.into();
            self
        }
    }

    impl wkt::message::Message for InfoTypeLikelihood {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectConfig.InfoTypeLikelihood"
        }
    }

    /// Configuration to control the number of findings returned for inspection.
    /// This is not used for de-identification or data profiling.
    ///
    /// When redacting sensitive data from images, finding limits don't apply. They
    /// can cause unexpected or inconsistent results, where only some data is
    /// redacted. Don't include finding limits in
    /// [RedactImage][google.privacy.dlp.v2.DlpService.RedactImage]
    /// requests. Otherwise, Cloud DLP returns an error.
    ///
    /// [google.privacy.dlp.v2.DlpService.RedactImage]: crate::client::DlpService::redact_image
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FindingLimits {
        /// Max number of findings that are returned for each item scanned.
        ///
        /// When set within an
        /// [InspectContentRequest][google.privacy.dlp.v2.InspectContentRequest],
        /// this field is ignored.
        ///
        /// This value isn't a hard limit. If the number of findings for an item
        /// reaches this limit, the inspection of that item ends gradually, not
        /// abruptly. Therefore, the actual number of findings that Cloud DLP returns
        /// for the item can be multiple times higher than this value.
        ///
        /// [google.privacy.dlp.v2.InspectContentRequest]: crate::model::InspectContentRequest
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub max_findings_per_item: i32,

        /// Max number of findings that are returned per request or job.
        ///
        /// If you set this field in an
        /// [InspectContentRequest][google.privacy.dlp.v2.InspectContentRequest], the
        /// resulting maximum value is the value that you set or 3,000, whichever is
        /// lower.
        ///
        /// This value isn't a hard limit. If an inspection reaches this limit, the
        /// inspection ends gradually, not abruptly. Therefore, the actual number of
        /// findings that Cloud DLP returns can be multiple times higher than this
        /// value.
        ///
        /// [google.privacy.dlp.v2.InspectContentRequest]: crate::model::InspectContentRequest
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub max_findings_per_request: i32,

        /// Configuration of findings limit given for specified infoTypes.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub max_findings_per_info_type:
            std::vec::Vec<crate::model::inspect_config::finding_limits::InfoTypeLimit>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FindingLimits {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_findings_per_item][crate::model::inspect_config::FindingLimits::max_findings_per_item].
        pub fn set_max_findings_per_item<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_findings_per_item = v.into();
            self
        }

        /// Sets the value of [max_findings_per_request][crate::model::inspect_config::FindingLimits::max_findings_per_request].
        pub fn set_max_findings_per_request<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_findings_per_request = v.into();
            self
        }

        /// Sets the value of [max_findings_per_info_type][crate::model::inspect_config::FindingLimits::max_findings_per_info_type].
        pub fn set_max_findings_per_info_type<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::inspect_config::finding_limits::InfoTypeLimit>,
        {
            use std::iter::Iterator;
            self.max_findings_per_info_type = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for FindingLimits {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectConfig.FindingLimits"
        }
    }

    /// Defines additional types related to [FindingLimits].
    pub mod finding_limits {
        #[allow(unused_imports)]
        use super::*;

        /// Max findings configuration per infoType, per content item or long
        /// running DlpJob.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct InfoTypeLimit {
            /// Type of information the findings limit applies to. Only one limit per
            /// info_type should be provided. If InfoTypeLimit does not have an
            /// info_type, the DLP API applies the limit against all info_types that
            /// are found but not specified in another InfoTypeLimit.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub info_type: std::option::Option<crate::model::InfoType>,

            /// Max findings limit for the given infoType.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub max_findings: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl InfoTypeLimit {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [info_type][crate::model::inspect_config::finding_limits::InfoTypeLimit::info_type].
            pub fn set_info_type<
                T: std::convert::Into<std::option::Option<crate::model::InfoType>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.info_type = v.into();
                self
            }

            /// Sets the value of [max_findings][crate::model::inspect_config::finding_limits::InfoTypeLimit::max_findings].
            pub fn set_max_findings<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_findings = v.into();
                self
            }
        }

        impl wkt::message::Message for InfoTypeLimit {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.InspectConfig.FindingLimits.InfoTypeLimit"
            }
        }
    }
}

/// Container for bytes to inspect or redact.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ByteContentItem {
    /// The type of data stored in the bytes string. Default will be TEXT_UTF8.
    #[serde(rename = "type")]
    pub r#type: crate::model::byte_content_item::BytesType,

    /// Content data to inspect or redact.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub data: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ByteContentItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::ByteContentItem::type].
    pub fn set_type<T: std::convert::Into<crate::model::byte_content_item::BytesType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [data][crate::model::ByteContentItem::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }
}

impl wkt::message::Message for ByteContentItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ByteContentItem"
    }
}

/// Defines additional types related to [ByteContentItem].
pub mod byte_content_item {
    #[allow(unused_imports)]
    use super::*;

    /// The type of data being sent for inspection. To learn more, see
    /// [Supported file
    /// types](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types).
    ///
    /// Only the first frame of each multiframe image is inspected. Metadata and
    /// other frames aren't inspected.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BytesType {
        /// Unused
        Unspecified,
        /// Any image type.
        Image,
        /// jpeg
        ImageJpeg,
        /// bmp
        ImageBmp,
        /// png
        ImagePng,
        /// svg
        ImageSvg,
        /// plain text
        TextUtf8,
        /// docx, docm, dotx, dotm
        WordDocument,
        /// pdf
        Pdf,
        /// pptx, pptm, potx, potm, pot
        PowerpointDocument,
        /// xlsx, xlsm, xltx, xltm
        ExcelDocument,
        /// avro
        Avro,
        /// csv
        Csv,
        /// tsv
        Tsv,
        /// Audio file types. Only used for profiling.
        Audio,
        /// Video file types. Only used for profiling.
        Video,
        /// Executable file types. Only used for profiling.
        Executable,
        /// AI model file types. Only used for profiling.
        AiModel,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BytesType::value] or
        /// [BytesType::name].
        UnknownValue(bytes_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod bytes_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BytesType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Image => std::option::Option::Some(6),
                Self::ImageJpeg => std::option::Option::Some(1),
                Self::ImageBmp => std::option::Option::Some(2),
                Self::ImagePng => std::option::Option::Some(3),
                Self::ImageSvg => std::option::Option::Some(4),
                Self::TextUtf8 => std::option::Option::Some(5),
                Self::WordDocument => std::option::Option::Some(7),
                Self::Pdf => std::option::Option::Some(8),
                Self::PowerpointDocument => std::option::Option::Some(9),
                Self::ExcelDocument => std::option::Option::Some(10),
                Self::Avro => std::option::Option::Some(11),
                Self::Csv => std::option::Option::Some(12),
                Self::Tsv => std::option::Option::Some(13),
                Self::Audio => std::option::Option::Some(15),
                Self::Video => std::option::Option::Some(16),
                Self::Executable => std::option::Option::Some(17),
                Self::AiModel => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BYTES_TYPE_UNSPECIFIED"),
                Self::Image => std::option::Option::Some("IMAGE"),
                Self::ImageJpeg => std::option::Option::Some("IMAGE_JPEG"),
                Self::ImageBmp => std::option::Option::Some("IMAGE_BMP"),
                Self::ImagePng => std::option::Option::Some("IMAGE_PNG"),
                Self::ImageSvg => std::option::Option::Some("IMAGE_SVG"),
                Self::TextUtf8 => std::option::Option::Some("TEXT_UTF8"),
                Self::WordDocument => std::option::Option::Some("WORD_DOCUMENT"),
                Self::Pdf => std::option::Option::Some("PDF"),
                Self::PowerpointDocument => std::option::Option::Some("POWERPOINT_DOCUMENT"),
                Self::ExcelDocument => std::option::Option::Some("EXCEL_DOCUMENT"),
                Self::Avro => std::option::Option::Some("AVRO"),
                Self::Csv => std::option::Option::Some("CSV"),
                Self::Tsv => std::option::Option::Some("TSV"),
                Self::Audio => std::option::Option::Some("AUDIO"),
                Self::Video => std::option::Option::Some("VIDEO"),
                Self::Executable => std::option::Option::Some("EXECUTABLE"),
                Self::AiModel => std::option::Option::Some("AI_MODEL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BytesType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BytesType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BytesType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ImageJpeg,
                2 => Self::ImageBmp,
                3 => Self::ImagePng,
                4 => Self::ImageSvg,
                5 => Self::TextUtf8,
                6 => Self::Image,
                7 => Self::WordDocument,
                8 => Self::Pdf,
                9 => Self::PowerpointDocument,
                10 => Self::ExcelDocument,
                11 => Self::Avro,
                12 => Self::Csv,
                13 => Self::Tsv,
                15 => Self::Audio,
                16 => Self::Video,
                17 => Self::Executable,
                18 => Self::AiModel,
                _ => Self::UnknownValue(bytes_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BytesType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BYTES_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMAGE" => Self::Image,
                "IMAGE_JPEG" => Self::ImageJpeg,
                "IMAGE_BMP" => Self::ImageBmp,
                "IMAGE_PNG" => Self::ImagePng,
                "IMAGE_SVG" => Self::ImageSvg,
                "TEXT_UTF8" => Self::TextUtf8,
                "WORD_DOCUMENT" => Self::WordDocument,
                "PDF" => Self::Pdf,
                "POWERPOINT_DOCUMENT" => Self::PowerpointDocument,
                "EXCEL_DOCUMENT" => Self::ExcelDocument,
                "AVRO" => Self::Avro,
                "CSV" => Self::Csv,
                "TSV" => Self::Tsv,
                "AUDIO" => Self::Audio,
                "VIDEO" => Self::Video,
                "EXECUTABLE" => Self::Executable,
                "AI_MODEL" => Self::AiModel,
                _ => Self::UnknownValue(bytes_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BytesType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Image => serializer.serialize_i32(6),
                Self::ImageJpeg => serializer.serialize_i32(1),
                Self::ImageBmp => serializer.serialize_i32(2),
                Self::ImagePng => serializer.serialize_i32(3),
                Self::ImageSvg => serializer.serialize_i32(4),
                Self::TextUtf8 => serializer.serialize_i32(5),
                Self::WordDocument => serializer.serialize_i32(7),
                Self::Pdf => serializer.serialize_i32(8),
                Self::PowerpointDocument => serializer.serialize_i32(9),
                Self::ExcelDocument => serializer.serialize_i32(10),
                Self::Avro => serializer.serialize_i32(11),
                Self::Csv => serializer.serialize_i32(12),
                Self::Tsv => serializer.serialize_i32(13),
                Self::Audio => serializer.serialize_i32(15),
                Self::Video => serializer.serialize_i32(16),
                Self::Executable => serializer.serialize_i32(17),
                Self::AiModel => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BytesType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BytesType>::new(
                ".google.privacy.dlp.v2.ByteContentItem.BytesType",
            ))
        }
    }
}

/// Type of content to inspect.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContentItem {
    /// Data of the item either in the byte array or UTF-8 string form, or table.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_item: std::option::Option<crate::model::content_item::DataItem>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContentItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_item][crate::model::ContentItem::data_item].
    ///
    /// Note that all the setters affecting `data_item` are mutually
    /// exclusive.
    pub fn set_data_item<
        T: std::convert::Into<std::option::Option<crate::model::content_item::DataItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_item = v.into();
        self
    }

    /// The value of [data_item][crate::model::ContentItem::data_item]
    /// if it holds a `Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::content_item::DataItem::Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::ContentItem::data_item]
    /// to hold a `Value`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::content_item::DataItem::Value(v.into()));
        self
    }

    /// The value of [data_item][crate::model::ContentItem::data_item]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table(&self) -> std::option::Option<&std::boxed::Box<crate::model::Table>> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::content_item::DataItem::Table(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::ContentItem::data_item]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::Table>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::content_item::DataItem::Table(v.into()));
        self
    }

    /// The value of [data_item][crate::model::ContentItem::data_item]
    /// if it holds a `ByteItem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn byte_item(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ByteContentItem>> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::content_item::DataItem::ByteItem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::ContentItem::data_item]
    /// to hold a `ByteItem`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_byte_item<T: std::convert::Into<std::boxed::Box<crate::model::ByteContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::content_item::DataItem::ByteItem(v.into()));
        self
    }
}

impl wkt::message::Message for ContentItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ContentItem"
    }
}

/// Defines additional types related to [ContentItem].
pub mod content_item {
    #[allow(unused_imports)]
    use super::*;

    /// Data of the item either in the byte array or UTF-8 string form, or table.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataItem {
        /// String data to inspect or redact.
        Value(std::string::String),
        /// Structured content for inspection. See
        /// <https://cloud.google.com/sensitive-data-protection/docs/inspecting-text#inspecting_a_table>
        /// to learn more.
        Table(std::boxed::Box<crate::model::Table>),
        /// Content data to inspect or redact. Replaces `type` and `data`.
        ByteItem(std::boxed::Box<crate::model::ByteContentItem>),
    }
}

/// Structured content to inspect. Up to 50,000 `Value`s per request allowed. See
/// <https://cloud.google.com/sensitive-data-protection/docs/inspecting-structured-text#inspecting_a_table>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Table {
    /// Headers of the table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub headers: std::vec::Vec<crate::model::FieldId>,

    /// Rows of the table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rows: std::vec::Vec<crate::model::table::Row>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Table {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [headers][crate::model::Table::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rows][crate::model::Table::rows].
    pub fn set_rows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::table::Row>,
    {
        use std::iter::Iterator;
        self.rows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Table {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Table"
    }
}

/// Defines additional types related to [Table].
pub mod table {
    #[allow(unused_imports)]
    use super::*;

    /// Values of the row.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Row {
        /// Individual cells.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub values: std::vec::Vec<crate::model::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Row {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::table::Row::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Value>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Row {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Table.Row"
        }
    }
}

/// All the findings for a single scanned item.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectResult {
    /// List of findings for an item.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub findings: std::vec::Vec<crate::model::Finding>,

    /// If true, then this item might have more findings than were returned,
    /// and the findings returned are an arbitrary subset of all findings.
    /// The findings list might be truncated because the input items were too
    /// large, or because the server reached the maximum amount of resources
    /// allowed for a single API call. For best results, divide the input into
    /// smaller batches.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub findings_truncated: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [findings][crate::model::InspectResult::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Finding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [findings_truncated][crate::model::InspectResult::findings_truncated].
    pub fn set_findings_truncated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.findings_truncated = v.into();
        self
    }
}

impl wkt::message::Message for InspectResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectResult"
    }
}

/// Represents a piece of potentially sensitive content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Finding {
    /// Resource name in format
    /// projects/{project}/locations/{location}/findings/{finding} Populated only
    /// when viewing persisted findings.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The content that was found. Even if the content is not textual, it
    /// may be converted to a textual representation here.
    /// Provided if `include_quote` is true and the finding is
    /// less than or equal to 4096 bytes long. If the finding exceeds 4096 bytes
    /// in length, the quote may be omitted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub quote: std::string::String,

    /// The type of content that might have been found.
    /// Provided if `excluded_types` is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Confidence of how likely it is that the `info_type` is correct.
    pub likelihood: crate::model::Likelihood,

    /// Where the content was found.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::Location>,

    /// Timestamp when finding was detected.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Contains data parsed from quotes. Only populated if include_quote was set
    /// to true and a supported infoType was requested. Currently supported
    /// infoTypes: DATE, DATE_OF_BIRTH and TIME.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quote_info: std::option::Option<crate::model::QuoteInfo>,

    /// The job that stored the finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_name: std::string::String,

    /// Job trigger name, if applicable, for this finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_name: std::string::String,

    /// The labels associated with this `Finding`.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// Label values must be between 0 and 63 characters long and must conform
    /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
    ///
    /// No more than 10 labels can be associated with a given finding.
    ///
    /// Examples:
    ///
    /// * `"environment" : "production"`
    /// * `"pipeline" : "etl"`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Time the job started that produced this finding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_create_time: std::option::Option<wkt::Timestamp>,

    /// The job that stored the finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_name: std::string::String,

    /// The unique finding id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub finding_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Finding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Finding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [quote][crate::model::Finding::quote].
    pub fn set_quote<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.quote = v.into();
        self
    }

    /// Sets the value of [info_type][crate::model::Finding::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [likelihood][crate::model::Finding::likelihood].
    pub fn set_likelihood<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.likelihood = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Finding::location].
    pub fn set_location<T: std::convert::Into<std::option::Option<crate::model::Location>>>(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Finding::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [quote_info][crate::model::Finding::quote_info].
    pub fn set_quote_info<T: std::convert::Into<std::option::Option<crate::model::QuoteInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.quote_info = v.into();
        self
    }

    /// Sets the value of [resource_name][crate::model::Finding::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [trigger_name][crate::model::Finding::trigger_name].
    pub fn set_trigger_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Finding::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [job_create_time][crate::model::Finding::job_create_time].
    pub fn set_job_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_create_time = v.into();
        self
    }

    /// Sets the value of [job_name][crate::model::Finding::job_name].
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_name = v.into();
        self
    }

    /// Sets the value of [finding_id][crate::model::Finding::finding_id].
    pub fn set_finding_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_id = v.into();
        self
    }
}

impl wkt::message::Message for Finding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Finding"
    }
}

/// Specifies the location of the finding.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Location {
    /// Zero-based byte offsets delimiting the finding.
    /// These are relative to the finding's containing element.
    /// Note that when the content is not textual, this references
    /// the UTF-8 encoded textual representation of the content.
    /// Omitted if content is an image.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub byte_range: std::option::Option<crate::model::Range>,

    /// Unicode character offsets delimiting the finding.
    /// These are relative to the finding's containing element.
    /// Provided when the content is text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub codepoint_range: std::option::Option<crate::model::Range>,

    /// List of nested objects pointing to the precise location of the finding
    /// within the file or record.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub content_locations: std::vec::Vec<crate::model::ContentLocation>,

    /// Information about the container where this finding occurred, if available.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container: std::option::Option<crate::model::Container>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Location {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [byte_range][crate::model::Location::byte_range].
    pub fn set_byte_range<T: std::convert::Into<std::option::Option<crate::model::Range>>>(
        mut self,
        v: T,
    ) -> Self {
        self.byte_range = v.into();
        self
    }

    /// Sets the value of [codepoint_range][crate::model::Location::codepoint_range].
    pub fn set_codepoint_range<T: std::convert::Into<std::option::Option<crate::model::Range>>>(
        mut self,
        v: T,
    ) -> Self {
        self.codepoint_range = v.into();
        self
    }

    /// Sets the value of [content_locations][crate::model::Location::content_locations].
    pub fn set_content_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ContentLocation>,
    {
        use std::iter::Iterator;
        self.content_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [container][crate::model::Location::container].
    pub fn set_container<T: std::convert::Into<std::option::Option<crate::model::Container>>>(
        mut self,
        v: T,
    ) -> Self {
        self.container = v.into();
        self
    }
}

impl wkt::message::Message for Location {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Location"
    }
}

/// Precise location of the finding within a document, record, image, or metadata
/// container.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContentLocation {
    /// Name of the container where the finding is located.
    /// The top level name is the source file name or table name. Names of some
    /// common storage containers are formatted as follows:
    ///
    /// * BigQuery tables:  `{project_id}:{dataset_id}.{table_id}`
    /// * Cloud Storage files: `gs://{bucket}/{path}`
    /// * Datastore namespace: {namespace}
    ///
    /// Nested names could be absent if the embedded object has no string
    /// identifier (for example, an image contained within a document).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_name: std::string::String,

    /// Finding container modification timestamp, if applicable. For Cloud Storage,
    /// this field contains the last file modification timestamp. For a BigQuery
    /// table, this field contains the last_modified_time property. For Datastore,
    /// this field isn't populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container_timestamp: std::option::Option<wkt::Timestamp>,

    /// Finding container version, if available
    /// ("generation" for Cloud Storage).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_version: std::string::String,

    /// Type of the container within the file with location of the finding.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::content_location::Location>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContentLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_name][crate::model::ContentLocation::container_name].
    pub fn set_container_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_name = v.into();
        self
    }

    /// Sets the value of [container_timestamp][crate::model::ContentLocation::container_timestamp].
    pub fn set_container_timestamp<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_timestamp = v.into();
        self
    }

    /// Sets the value of [container_version][crate::model::ContentLocation::container_version].
    pub fn set_container_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_version = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ContentLocation::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::content_location::Location>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `RecordLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn record_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecordLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::RecordLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `RecordLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_record_location<
        T: std::convert::Into<std::boxed::Box<crate::model::RecordLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::RecordLocation(v.into()),
        );
        self
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `ImageLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImageLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::ImageLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `ImageLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_image_location<
        T: std::convert::Into<std::boxed::Box<crate::model::ImageLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::ImageLocation(v.into()),
        );
        self
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `DocumentLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn document_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DocumentLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::DocumentLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `DocumentLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_document_location<
        T: std::convert::Into<std::boxed::Box<crate::model::DocumentLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::DocumentLocation(v.into()),
        );
        self
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `MetadataLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn metadata_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MetadataLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::MetadataLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `MetadataLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_metadata_location<
        T: std::convert::Into<std::boxed::Box<crate::model::MetadataLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::MetadataLocation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ContentLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ContentLocation"
    }
}

/// Defines additional types related to [ContentLocation].
pub mod content_location {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the container within the file with location of the finding.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Location {
        /// Location within a row or record of a database table.
        RecordLocation(std::boxed::Box<crate::model::RecordLocation>),
        /// Location within an image's pixels.
        ImageLocation(std::boxed::Box<crate::model::ImageLocation>),
        /// Location data for document files.
        DocumentLocation(std::boxed::Box<crate::model::DocumentLocation>),
        /// Location within the metadata for inspected content.
        MetadataLocation(std::boxed::Box<crate::model::MetadataLocation>),
    }
}

/// Metadata Location
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetadataLocation {
    /// Type of metadata containing the finding.
    #[serde(rename = "type")]
    pub r#type: crate::model::MetadataType,

    /// Label of the piece of metadata containing the finding, for example -
    /// latitude, author, caption.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub label: std::option::Option<crate::model::metadata_location::Label>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetadataLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::MetadataLocation::type].
    pub fn set_type<T: std::convert::Into<crate::model::MetadataType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [label][crate::model::MetadataLocation::label].
    ///
    /// Note that all the setters affecting `label` are mutually
    /// exclusive.
    pub fn set_label<
        T: std::convert::Into<std::option::Option<crate::model::metadata_location::Label>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.label = v.into();
        self
    }

    /// The value of [label][crate::model::MetadataLocation::label]
    /// if it holds a `StorageLabel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_label(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageMetadataLabel>> {
        #[allow(unreachable_patterns)]
        self.label.as_ref().and_then(|v| match v {
            crate::model::metadata_location::Label::StorageLabel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [label][crate::model::MetadataLocation::label]
    /// to hold a `StorageLabel`.
    ///
    /// Note that all the setters affecting `label` are
    /// mutually exclusive.
    pub fn set_storage_label<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageMetadataLabel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.label = std::option::Option::Some(
            crate::model::metadata_location::Label::StorageLabel(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MetadataLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.MetadataLocation"
    }
}

/// Defines additional types related to [MetadataLocation].
pub mod metadata_location {
    #[allow(unused_imports)]
    use super::*;

    /// Label of the piece of metadata containing the finding, for example -
    /// latitude, author, caption.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Label {
        /// Storage metadata.
        StorageLabel(std::boxed::Box<crate::model::StorageMetadataLabel>),
    }
}

/// Storage metadata label to indicate which metadata entry contains findings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageMetadataLabel {
    /// Label name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageMetadataLabel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::StorageMetadataLabel::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for StorageMetadataLabel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StorageMetadataLabel"
    }
}

/// Location of a finding within a document.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DocumentLocation {
    /// Offset of the line, from the beginning of the file, where the finding
    /// is located.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub file_offset: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DocumentLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_offset][crate::model::DocumentLocation::file_offset].
    pub fn set_file_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.file_offset = v.into();
        self
    }
}

impl wkt::message::Message for DocumentLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DocumentLocation"
    }
}

/// Location of a finding within a row or record.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordLocation {
    /// Key of the finding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub record_key: std::option::Option<crate::model::RecordKey>,

    /// Field id of the field containing the finding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field_id: std::option::Option<crate::model::FieldId>,

    /// Location within a `ContentItem.Table`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_location: std::option::Option<crate::model::TableLocation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [record_key][crate::model::RecordLocation::record_key].
    pub fn set_record_key<T: std::convert::Into<std::option::Option<crate::model::RecordKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.record_key = v.into();
        self
    }

    /// Sets the value of [field_id][crate::model::RecordLocation::field_id].
    pub fn set_field_id<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field_id = v.into();
        self
    }

    /// Sets the value of [table_location][crate::model::RecordLocation::table_location].
    pub fn set_table_location<
        T: std::convert::Into<std::option::Option<crate::model::TableLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_location = v.into();
        self
    }
}

impl wkt::message::Message for RecordLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordLocation"
    }
}

/// Location of a finding within a table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableLocation {
    /// The zero-based index of the row where the finding is located. Only
    /// populated for resources that have a natural ordering, not BigQuery. In
    /// BigQuery, to identify the row a finding came from, populate
    /// BigQueryOptions.identifying_fields with your primary key column names and
    /// when you store the findings the value of those columns will be stored
    /// inside of Finding.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub row_index: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [row_index][crate::model::TableLocation::row_index].
    pub fn set_row_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_index = v.into();
        self
    }
}

impl wkt::message::Message for TableLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableLocation"
    }
}

/// Represents a container that may contain DLP findings.
/// Examples of a container include a file, table, or database record.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Container {
    /// Container type, for example BigQuery or Cloud Storage.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Project where the finding was found.
    /// Can be different from the project that owns the finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// A string representation of the full container name.
    /// Examples:
    ///
    /// - BigQuery: 'Project:DataSetId.TableId'
    /// - Cloud Storage: 'gs://Bucket/folders/filename.txt'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_path: std::string::String,

    /// The root of the container.
    /// Examples:
    ///
    /// - For BigQuery table `project_id:dataset_id.table_id`, the root is
    ///   `dataset_id`
    /// - For Cloud Storage file `gs://bucket/folder/filename.txt`, the root
    ///   is `gs://bucket`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub root_path: std::string::String,

    /// The rest of the path after the root.
    /// Examples:
    ///
    /// - For BigQuery table `project_id:dataset_id.table_id`, the relative path is
    ///   `table_id`
    /// - For Cloud Storage file `gs://bucket/folder/filename.txt`, the relative
    ///   path is `folder/filename.txt`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub relative_path: std::string::String,

    /// Findings container modification timestamp, if applicable. For Cloud
    /// Storage, this field contains the last file modification timestamp. For a
    /// BigQuery table, this field contains the last_modified_time property. For
    /// Datastore, this field isn't populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Findings container version, if available
    /// ("generation" for Cloud Storage).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Container {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Container::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::Container::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [full_path][crate::model::Container::full_path].
    pub fn set_full_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_path = v.into();
        self
    }

    /// Sets the value of [root_path][crate::model::Container::root_path].
    pub fn set_root_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_path = v.into();
        self
    }

    /// Sets the value of [relative_path][crate::model::Container::relative_path].
    pub fn set_relative_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_path = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Container::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Container::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for Container {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Container"
    }
}

/// Generic half-open interval [start, end)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Range {
    /// Index of the first character of the range (inclusive).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub start: i64,

    /// Index of the last character of the range (exclusive).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub end: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Range {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start][crate::model::Range::start].
    pub fn set_start<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.start = v.into();
        self
    }

    /// Sets the value of [end][crate::model::Range::end].
    pub fn set_end<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.end = v.into();
        self
    }
}

impl wkt::message::Message for Range {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Range"
    }
}

/// Location of the finding within an image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImageLocation {
    /// Bounding boxes locating the pixels within the image containing the finding.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bounding_boxes: std::vec::Vec<crate::model::BoundingBox>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bounding_boxes][crate::model::ImageLocation::bounding_boxes].
    pub fn set_bounding_boxes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BoundingBox>,
    {
        use std::iter::Iterator;
        self.bounding_boxes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImageLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ImageLocation"
    }
}

/// Bounding box encompassing detected text within an image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BoundingBox {
    /// Top coordinate of the bounding box. (0,0) is upper left.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub top: i32,

    /// Left coordinate of the bounding box. (0,0) is upper left.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub left: i32,

    /// Width of the bounding box in pixels.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub width: i32,

    /// Height of the bounding box in pixels.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub height: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BoundingBox {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [top][crate::model::BoundingBox::top].
    pub fn set_top<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.top = v.into();
        self
    }

    /// Sets the value of [left][crate::model::BoundingBox::left].
    pub fn set_left<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.left = v.into();
        self
    }

    /// Sets the value of [width][crate::model::BoundingBox::width].
    pub fn set_width<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.width = v.into();
        self
    }

    /// Sets the value of [height][crate::model::BoundingBox::height].
    pub fn set_height<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.height = v.into();
        self
    }
}

impl wkt::message::Message for BoundingBox {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BoundingBox"
    }
}

/// Request to search for potentially sensitive info in an image and redact it
/// by covering it with a colored rectangle.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RedactImageRequest {
    /// Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    /// Configuration for the inspector.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The configuration for specifying what content to redact from images.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub image_redaction_configs:
        std::vec::Vec<crate::model::redact_image_request::ImageRedactionConfig>,

    /// Whether the response should include findings along with the redacted
    /// image.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub include_findings: bool,

    /// The content must be PNG, JPEG, SVG or BMP.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub byte_item: std::option::Option<crate::model::ByteContentItem>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedactImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RedactImageRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::RedactImageRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::RedactImageRequest::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [image_redaction_configs][crate::model::RedactImageRequest::image_redaction_configs].
    pub fn set_image_redaction_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::redact_image_request::ImageRedactionConfig>,
    {
        use std::iter::Iterator;
        self.image_redaction_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [include_findings][crate::model::RedactImageRequest::include_findings].
    pub fn set_include_findings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_findings = v.into();
        self
    }

    /// Sets the value of [byte_item][crate::model::RedactImageRequest::byte_item].
    pub fn set_byte_item<
        T: std::convert::Into<std::option::Option<crate::model::ByteContentItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.byte_item = v.into();
        self
    }
}

impl wkt::message::Message for RedactImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RedactImageRequest"
    }
}

/// Defines additional types related to [RedactImageRequest].
pub mod redact_image_request {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for determining how redaction of images should occur.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImageRedactionConfig {
        /// The color to use when redacting content from an image. If not specified,
        /// the default is black.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub redaction_color: std::option::Option<crate::model::Color>,

        /// Type of information to redact from images.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub target:
            std::option::Option<crate::model::redact_image_request::image_redaction_config::Target>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImageRedactionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [redaction_color][crate::model::redact_image_request::ImageRedactionConfig::redaction_color].
        pub fn set_redaction_color<
            T: std::convert::Into<std::option::Option<crate::model::Color>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.redaction_color = v.into();
            self
        }

        /// Sets the value of [target][crate::model::redact_image_request::ImageRedactionConfig::target].
        ///
        /// Note that all the setters affecting `target` are mutually
        /// exclusive.
        pub fn set_target<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::redact_image_request::image_redaction_config::Target,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = v.into();
            self
        }

        /// The value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// if it holds a `InfoType`, `None` if the field is not set or
        /// holds a different branch.
        pub fn info_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::InfoType>> {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::redact_image_request::image_redaction_config::Target::InfoType(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// to hold a `InfoType`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_info_type<T: std::convert::Into<std::boxed::Box<crate::model::InfoType>>>(
            mut self,
            v: T,
        ) -> Self {
            self.target = std::option::Option::Some(
                crate::model::redact_image_request::image_redaction_config::Target::InfoType(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// if it holds a `RedactAllText`, `None` if the field is not set or
        /// holds a different branch.
        pub fn redact_all_text(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::redact_image_request::image_redaction_config::Target::RedactAllText(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// to hold a `RedactAllText`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_redact_all_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.target = std::option::Option::Some(
                crate::model::redact_image_request::image_redaction_config::Target::RedactAllText(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for ImageRedactionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RedactImageRequest.ImageRedactionConfig"
        }
    }

    /// Defines additional types related to [ImageRedactionConfig].
    pub mod image_redaction_config {
        #[allow(unused_imports)]
        use super::*;

        /// Type of information to redact from images.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Target {
            /// Only one per info_type should be provided per request. If not
            /// specified, and redact_all_text is false, the DLP API will redact all
            /// text that it matches against all info_types that are found, but not
            /// specified in another ImageRedactionConfig.
            InfoType(std::boxed::Box<crate::model::InfoType>),
            /// If true, all text found in the image, regardless whether it matches an
            /// info_type, is redacted. Only one should be provided.
            RedactAllText(bool),
        }
    }
}

/// Represents a color in the RGB color space.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Color {
    /// The amount of red in the color as a value in the interval [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub red: f32,

    /// The amount of green in the color as a value in the interval [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub green: f32,

    /// The amount of blue in the color as a value in the interval [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub blue: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Color {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [red][crate::model::Color::red].
    pub fn set_red<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.red = v.into();
        self
    }

    /// Sets the value of [green][crate::model::Color::green].
    pub fn set_green<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.green = v.into();
        self
    }

    /// Sets the value of [blue][crate::model::Color::blue].
    pub fn set_blue<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.blue = v.into();
        self
    }
}

impl wkt::message::Message for Color {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Color"
    }
}

/// Results of redacting an image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RedactImageResponse {
    /// The redacted image. The type will be the same as the original image.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub redacted_image: ::bytes::Bytes,

    /// If an image was being inspected and the InspectConfig's include_quote was
    /// set to true, then this field will include all text, if any, that was found
    /// in the image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub extracted_text: std::string::String,

    /// The findings. Populated when include_findings in the request is true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_result: std::option::Option<crate::model::InspectResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedactImageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [redacted_image][crate::model::RedactImageResponse::redacted_image].
    pub fn set_redacted_image<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.redacted_image = v.into();
        self
    }

    /// Sets the value of [extracted_text][crate::model::RedactImageResponse::extracted_text].
    pub fn set_extracted_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.extracted_text = v.into();
        self
    }

    /// Sets the value of [inspect_result][crate::model::RedactImageResponse::inspect_result].
    pub fn set_inspect_result<
        T: std::convert::Into<std::option::Option<crate::model::InspectResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_result = v.into();
        self
    }
}

impl wkt::message::Message for RedactImageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RedactImageResponse"
    }
}

/// Request to de-identify a ContentItem.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyContentRequest {
    /// Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Configuration for the de-identification of the content item.
    /// Items specified here will override the template referenced by the
    /// deidentify_template_name argument.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deidentify_config: std::option::Option<crate::model::DeidentifyConfig>,

    /// Configuration for the inspector.
    /// Items specified here will override the template referenced by the
    /// inspect_template_name argument.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The item to de-identify. Will be treated as text.
    ///
    /// This value must be of type
    /// [Table][google.privacy.dlp.v2.Table] if your
    /// [deidentify_config][google.privacy.dlp.v2.DeidentifyContentRequest.deidentify_config]
    /// is a
    /// [RecordTransformations][google.privacy.dlp.v2.RecordTransformations]
    /// object.
    ///
    /// [google.privacy.dlp.v2.DeidentifyContentRequest.deidentify_config]: crate::model::DeidentifyContentRequest::deidentify_config
    /// [google.privacy.dlp.v2.RecordTransformations]: crate::model::RecordTransformations
    /// [google.privacy.dlp.v2.Table]: crate::model::Table
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Template to use. Any configuration directly specified in
    /// inspect_config will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template_name: std::string::String,

    /// Template to use. Any configuration directly specified in
    /// deidentify_config will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deidentify_template_name: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::DeidentifyContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deidentify_config][crate::model::DeidentifyContentRequest::deidentify_config].
    pub fn set_deidentify_config<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_config = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::DeidentifyContentRequest::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [item][crate::model::DeidentifyContentRequest::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::DeidentifyContentRequest::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [deidentify_template_name][crate::model::DeidentifyContentRequest::deidentify_template_name].
    pub fn set_deidentify_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template_name = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::DeidentifyContentRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyContentRequest"
    }
}

/// Results of de-identifying a ContentItem.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyContentResponse {
    /// The de-identified item.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// An overview of the changes that were made on the `item`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub overview: std::option::Option<crate::model::TransformationOverview>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [item][crate::model::DeidentifyContentResponse::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [overview][crate::model::DeidentifyContentResponse::overview].
    pub fn set_overview<
        T: std::convert::Into<std::option::Option<crate::model::TransformationOverview>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.overview = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyContentResponse"
    }
}

/// Request to re-identify an item.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReidentifyContentRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Configuration for the re-identification of the content item.
    /// This field shares the same proto message type that is used for
    /// de-identification, however its usage here is for the reversal of the
    /// previous de-identification. Re-identification is performed by examining
    /// the transformations used to de-identify the items and executing the
    /// reverse. This requires that only reversible transformations
    /// be provided here. The reversible transformations are:
    ///
    /// - `CryptoDeterministicConfig`
    /// - `CryptoReplaceFfxFpeConfig`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reidentify_config: std::option::Option<crate::model::DeidentifyConfig>,

    /// Configuration for the inspector.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The item to re-identify. Will be treated as text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Template to use. Any configuration directly specified in
    /// `inspect_config` will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template_name: std::string::String,

    /// Template to use. References an instance of `DeidentifyTemplate`.
    /// Any configuration directly specified in `reidentify_config` or
    /// `inspect_config` will override those set in the template. The
    /// `DeidentifyTemplate` used must include only reversible transformations.
    /// Singular fields that are set in this request will replace their
    /// corresponding fields in the template. Repeated fields are appended.
    /// Singular sub-messages and groups are recursively merged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reidentify_template_name: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReidentifyContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ReidentifyContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [reidentify_config][crate::model::ReidentifyContentRequest::reidentify_config].
    pub fn set_reidentify_config<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reidentify_config = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::ReidentifyContentRequest::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [item][crate::model::ReidentifyContentRequest::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::ReidentifyContentRequest::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [reidentify_template_name][crate::model::ReidentifyContentRequest::reidentify_template_name].
    pub fn set_reidentify_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reidentify_template_name = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ReidentifyContentRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ReidentifyContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReidentifyContentRequest"
    }
}

/// Results of re-identifying an item.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReidentifyContentResponse {
    /// The re-identified item.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// An overview of the changes that were made to the `item`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub overview: std::option::Option<crate::model::TransformationOverview>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReidentifyContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [item][crate::model::ReidentifyContentResponse::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [overview][crate::model::ReidentifyContentResponse::overview].
    pub fn set_overview<
        T: std::convert::Into<std::option::Option<crate::model::TransformationOverview>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.overview = v.into();
        self
    }
}

impl wkt::message::Message for ReidentifyContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReidentifyContentResponse"
    }
}

/// Request to search for potentially sensitive info in a ContentItem.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectContentRequest {
    /// Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Configuration for the inspector. What specified here will override
    /// the template referenced by the inspect_template_name argument.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The item to inspect.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Template to use. Any configuration directly specified in
    /// inspect_config will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template_name: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::InspectContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::InspectContentRequest::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [item][crate::model::InspectContentRequest::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::InspectContentRequest::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::InspectContentRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for InspectContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectContentRequest"
    }
}

/// Results of inspecting an item.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectContentResponse {
    /// The findings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::InspectResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::InspectContentResponse::result].
    pub fn set_result<T: std::convert::Into<std::option::Option<crate::model::InspectResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }
}

impl wkt::message::Message for InspectContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectContentResponse"
    }
}

/// Cloud repository for storing output.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OutputStorageConfig {
    /// Schema used for writing the findings for Inspect jobs. This field is only
    /// used for Inspect and must be unspecified for Risk jobs. Columns are derived
    /// from the `Finding` object. If appending to an existing table, any columns
    /// from the predefined schema that are missing will be added. No columns in
    /// the existing table will be deleted.
    ///
    /// If unspecified, then all available columns will be used for a new table or
    /// an (existing) table with no schema, and no changes will be made to an
    /// existing table that has a schema.
    /// Only for use with external storage.
    pub output_schema: crate::model::output_storage_config::OutputSchema,

    /// Output storage types.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::output_storage_config::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutputStorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_schema][crate::model::OutputStorageConfig::output_schema].
    pub fn set_output_schema<
        T: std::convert::Into<crate::model::output_storage_config::OutputSchema>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_schema = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::OutputStorageConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::output_storage_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::OutputStorageConfig::r#type]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table(&self) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTable>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::output_storage_config::Type::Table(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::OutputStorageConfig::r#type]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTable>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::output_storage_config::Type::Table(v.into()));
        self
    }
}

impl wkt::message::Message for OutputStorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OutputStorageConfig"
    }
}

/// Defines additional types related to [OutputStorageConfig].
pub mod output_storage_config {
    #[allow(unused_imports)]
    use super::*;

    /// Predefined schemas for storing findings.
    /// Only for use with external storage.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OutputSchema {
        /// Unused.
        Unspecified,
        /// Basic schema including only `info_type`, `quote`, `certainty`, and
        /// `timestamp`.
        BasicColumns,
        /// Schema tailored to findings from scanning Cloud Storage.
        GcsColumns,
        /// Schema tailored to findings from scanning Google Datastore.
        DatastoreColumns,
        /// Schema tailored to findings from scanning Google BigQuery.
        BigQueryColumns,
        /// Schema containing all columns.
        AllColumns,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OutputSchema::value] or
        /// [OutputSchema::name].
        UnknownValue(output_schema::UnknownValue),
    }

    #[doc(hidden)]
    pub mod output_schema {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OutputSchema {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BasicColumns => std::option::Option::Some(1),
                Self::GcsColumns => std::option::Option::Some(2),
                Self::DatastoreColumns => std::option::Option::Some(3),
                Self::BigQueryColumns => std::option::Option::Some(4),
                Self::AllColumns => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OUTPUT_SCHEMA_UNSPECIFIED"),
                Self::BasicColumns => std::option::Option::Some("BASIC_COLUMNS"),
                Self::GcsColumns => std::option::Option::Some("GCS_COLUMNS"),
                Self::DatastoreColumns => std::option::Option::Some("DATASTORE_COLUMNS"),
                Self::BigQueryColumns => std::option::Option::Some("BIG_QUERY_COLUMNS"),
                Self::AllColumns => std::option::Option::Some("ALL_COLUMNS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OutputSchema {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OutputSchema {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OutputSchema {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BasicColumns,
                2 => Self::GcsColumns,
                3 => Self::DatastoreColumns,
                4 => Self::BigQueryColumns,
                5 => Self::AllColumns,
                _ => Self::UnknownValue(output_schema::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OutputSchema {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OUTPUT_SCHEMA_UNSPECIFIED" => Self::Unspecified,
                "BASIC_COLUMNS" => Self::BasicColumns,
                "GCS_COLUMNS" => Self::GcsColumns,
                "DATASTORE_COLUMNS" => Self::DatastoreColumns,
                "BIG_QUERY_COLUMNS" => Self::BigQueryColumns,
                "ALL_COLUMNS" => Self::AllColumns,
                _ => Self::UnknownValue(output_schema::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OutputSchema {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BasicColumns => serializer.serialize_i32(1),
                Self::GcsColumns => serializer.serialize_i32(2),
                Self::DatastoreColumns => serializer.serialize_i32(3),
                Self::BigQueryColumns => serializer.serialize_i32(4),
                Self::AllColumns => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OutputSchema {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OutputSchema>::new(
                ".google.privacy.dlp.v2.OutputStorageConfig.OutputSchema",
            ))
        }
    }

    /// Output storage types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// Store findings in an existing table or a new table in an existing
        /// dataset. If table_id is not set a new one will be generated
        /// for you with the following format:
        /// dlp_googleapis_yyyy_mm_dd_[dlp_job_id]. Pacific time zone will be used
        /// for generating the date details.
        ///
        /// For Inspect, each column in an existing output table must have the same
        /// name, type, and mode of a field in the `Finding` object.
        ///
        /// For Risk, an existing output table should be the output of a previous
        /// Risk analysis job run on the same source table, with the same privacy
        /// metric and quasi-identifiers. Risk jobs that analyze the same table but
        /// compute a different privacy metric, or use different sets of
        /// quasi-identifiers, cannot store their results in the same table.
        Table(std::boxed::Box<crate::model::BigQueryTable>),
    }
}

/// Statistics regarding a specific InfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoTypeStats {
    /// The type of finding this stat is for.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Number of findings for this infoType.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoTypeStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::InfoTypeStats::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [count][crate::model::InfoTypeStats::count].
    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.count = v.into();
        self
    }
}

impl wkt::message::Message for InfoTypeStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeStats"
    }
}

/// The results of an inspect DataSource job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectDataSourceDetails {
    /// The configuration used for this job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_options:
        std::option::Option<crate::model::inspect_data_source_details::RequestedOptions>,

    /// A summary of the outcome of this inspection job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::inspect_data_source_details::Result>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectDataSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_options][crate::model::InspectDataSourceDetails::requested_options].
    pub fn set_requested_options<
        T: std::convert::Into<
                std::option::Option<crate::model::inspect_data_source_details::RequestedOptions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_options = v.into();
        self
    }

    /// Sets the value of [result][crate::model::InspectDataSourceDetails::result].
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::inspect_data_source_details::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }
}

impl wkt::message::Message for InspectDataSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectDataSourceDetails"
    }
}

/// Defines additional types related to [InspectDataSourceDetails].
pub mod inspect_data_source_details {
    #[allow(unused_imports)]
    use super::*;

    /// Snapshot of the inspection configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RequestedOptions {
        /// If run with an InspectTemplate, a snapshot of its state at the time of
        /// this run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub snapshot_inspect_template: std::option::Option<crate::model::InspectTemplate>,

        /// Inspect config.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub job_config: std::option::Option<crate::model::InspectJobConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RequestedOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [snapshot_inspect_template][crate::model::inspect_data_source_details::RequestedOptions::snapshot_inspect_template].
        pub fn set_snapshot_inspect_template<
            T: std::convert::Into<std::option::Option<crate::model::InspectTemplate>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.snapshot_inspect_template = v.into();
            self
        }

        /// Sets the value of [job_config][crate::model::inspect_data_source_details::RequestedOptions::job_config].
        pub fn set_job_config<
            T: std::convert::Into<std::option::Option<crate::model::InspectJobConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.job_config = v.into();
            self
        }
    }

    impl wkt::message::Message for RequestedOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectDataSourceDetails.RequestedOptions"
        }
    }

    /// All result fields mentioned below are updated while the job is processing.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Result {
        /// Total size in bytes that were processed.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub processed_bytes: i64,

        /// Estimate of the number of bytes to process.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub total_estimated_bytes: i64,

        /// Statistics of how many instances of each info type were found during
        /// inspect job.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub info_type_stats: std::vec::Vec<crate::model::InfoTypeStats>,

        /// Number of rows scanned after sampling and time filtering (applicable for
        /// row based stores such as BigQuery).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub num_rows_processed: i64,

        /// Statistics related to the processing of hybrid inspect.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub hybrid_stats: std::option::Option<crate::model::HybridInspectStatistics>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Result {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [processed_bytes][crate::model::inspect_data_source_details::Result::processed_bytes].
        pub fn set_processed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.processed_bytes = v.into();
            self
        }

        /// Sets the value of [total_estimated_bytes][crate::model::inspect_data_source_details::Result::total_estimated_bytes].
        pub fn set_total_estimated_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_estimated_bytes = v.into();
            self
        }

        /// Sets the value of [info_type_stats][crate::model::inspect_data_source_details::Result::info_type_stats].
        pub fn set_info_type_stats<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::InfoTypeStats>,
        {
            use std::iter::Iterator;
            self.info_type_stats = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [num_rows_processed][crate::model::inspect_data_source_details::Result::num_rows_processed].
        pub fn set_num_rows_processed<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.num_rows_processed = v.into();
            self
        }

        /// Sets the value of [hybrid_stats][crate::model::inspect_data_source_details::Result::hybrid_stats].
        pub fn set_hybrid_stats<
            T: std::convert::Into<std::option::Option<crate::model::HybridInspectStatistics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.hybrid_stats = v.into();
            self
        }
    }

    impl wkt::message::Message for Result {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectDataSourceDetails.Result"
        }
    }
}

/// The schema of data to be saved to the BigQuery table when the
/// `DataProfileAction` is enabled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileBigQueryRowSchema {
    /// Data profile type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_profile:
        std::option::Option<crate::model::data_profile_big_query_row_schema::DataProfile>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileBigQueryRowSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile].
    ///
    /// Note that all the setters affecting `data_profile` are mutually
    /// exclusive.
    pub fn set_data_profile<
        T: std::convert::Into<
                std::option::Option<crate::model::data_profile_big_query_row_schema::DataProfile>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = v.into();
        self
    }

    /// The value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// if it holds a `TableProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TableDataProfile>> {
        #[allow(unreachable_patterns)]
        self.data_profile.as_ref().and_then(|v| match v {
            crate::model::data_profile_big_query_row_schema::DataProfile::TableProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// to hold a `TableProfile`.
    ///
    /// Note that all the setters affecting `data_profile` are
    /// mutually exclusive.
    pub fn set_table_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::TableDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = std::option::Option::Some(
            crate::model::data_profile_big_query_row_schema::DataProfile::TableProfile(v.into()),
        );
        self
    }

    /// The value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// if it holds a `ColumnProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn column_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ColumnDataProfile>> {
        #[allow(unreachable_patterns)]
        self.data_profile.as_ref().and_then(|v| match v {
            crate::model::data_profile_big_query_row_schema::DataProfile::ColumnProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// to hold a `ColumnProfile`.
    ///
    /// Note that all the setters affecting `data_profile` are
    /// mutually exclusive.
    pub fn set_column_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::ColumnDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = std::option::Option::Some(
            crate::model::data_profile_big_query_row_schema::DataProfile::ColumnProfile(v.into()),
        );
        self
    }

    /// The value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// if it holds a `FileStoreProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn file_store_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileStoreDataProfile>> {
        #[allow(unreachable_patterns)]
        self.data_profile.as_ref().and_then(|v| match v {
            crate::model::data_profile_big_query_row_schema::DataProfile::FileStoreProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// to hold a `FileStoreProfile`.
    ///
    /// Note that all the setters affecting `data_profile` are
    /// mutually exclusive.
    pub fn set_file_store_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::FileStoreDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = std::option::Option::Some(
            crate::model::data_profile_big_query_row_schema::DataProfile::FileStoreProfile(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DataProfileBigQueryRowSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileBigQueryRowSchema"
    }
}

/// Defines additional types related to [DataProfileBigQueryRowSchema].
pub mod data_profile_big_query_row_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Data profile type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataProfile {
        /// Table data profile column
        TableProfile(std::boxed::Box<crate::model::TableDataProfile>),
        /// Column data profile column
        ColumnProfile(std::boxed::Box<crate::model::ColumnDataProfile>),
        /// File store data profile column.
        FileStoreProfile(std::boxed::Box<crate::model::FileStoreDataProfile>),
    }
}

/// Statistics related to processing hybrid inspect requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridInspectStatistics {
    /// The number of hybrid inspection requests processed within this job.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub processed_count: i64,

    /// The number of hybrid inspection requests aborted because the job ran
    /// out of quota or was ended before they could be processed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub aborted_count: i64,

    /// The number of hybrid requests currently being processed. Only populated
    /// when called via method `getDlpJob`.
    /// A burst of traffic may cause hybrid inspect requests to be enqueued.
    /// Processing will take place as quickly as possible, but resource limitations
    /// may impact how long a request is enqueued for.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub pending_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridInspectStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [processed_count][crate::model::HybridInspectStatistics::processed_count].
    pub fn set_processed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.processed_count = v.into();
        self
    }

    /// Sets the value of [aborted_count][crate::model::HybridInspectStatistics::aborted_count].
    pub fn set_aborted_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.aborted_count = v.into();
        self
    }

    /// Sets the value of [pending_count][crate::model::HybridInspectStatistics::pending_count].
    pub fn set_pending_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pending_count = v.into();
        self
    }
}

impl wkt::message::Message for HybridInspectStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectStatistics"
    }
}

/// The results of an [Action][google.privacy.dlp.v2.Action].
///
/// [google.privacy.dlp.v2.Action]: crate::model::Action
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ActionDetails {
    /// Summary of what occurred in the actions.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::action_details::Details>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ActionDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::ActionDetails::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::action_details::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::ActionDetails::details]
    /// if it holds a `DeidentifyDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deidentify_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeidentifyDataSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action_details::Details::DeidentifyDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::ActionDetails::details]
    /// to hold a `DeidentifyDetails`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_deidentify_details<
        T: std::convert::Into<std::boxed::Box<crate::model::DeidentifyDataSourceDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action_details::Details::DeidentifyDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ActionDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ActionDetails"
    }
}

/// Defines additional types related to [ActionDetails].
pub mod action_details {
    #[allow(unused_imports)]
    use super::*;

    /// Summary of what occurred in the actions.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Outcome of a de-identification action.
        DeidentifyDetails(std::boxed::Box<crate::model::DeidentifyDataSourceDetails>),
    }
}

/// Summary of what was modified during a transformation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyDataSourceStats {
    /// Total size in bytes that were transformed in some way.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformed_bytes: i64,

    /// Number of successfully applied transformations.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformation_count: i64,

    /// Number of errors encountered while trying to apply transformations.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformation_error_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyDataSourceStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformed_bytes][crate::model::DeidentifyDataSourceStats::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [transformation_count][crate::model::DeidentifyDataSourceStats::transformation_count].
    pub fn set_transformation_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformation_count = v.into();
        self
    }

    /// Sets the value of [transformation_error_count][crate::model::DeidentifyDataSourceStats::transformation_error_count].
    pub fn set_transformation_error_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformation_error_count = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyDataSourceStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyDataSourceStats"
    }
}

/// The results of a [Deidentify][google.privacy.dlp.v2.Action.Deidentify] action
/// from an inspect job.
///
/// [google.privacy.dlp.v2.Action.Deidentify]: crate::model::action::Deidentify
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyDataSourceDetails {
    /// De-identification config used for the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_options: std::option::Option<
        crate::model::deidentify_data_source_details::RequestedDeidentifyOptions,
    >,

    /// Stats about the de-identification operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deidentify_stats: std::option::Option<crate::model::DeidentifyDataSourceStats>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyDataSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_options][crate::model::DeidentifyDataSourceDetails::requested_options].
    pub fn set_requested_options<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::deidentify_data_source_details::RequestedDeidentifyOptions,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_options = v.into();
        self
    }

    /// Sets the value of [deidentify_stats][crate::model::DeidentifyDataSourceDetails::deidentify_stats].
    pub fn set_deidentify_stats<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyDataSourceStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_stats = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyDataSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyDataSourceDetails"
    }
}

/// Defines additional types related to [DeidentifyDataSourceDetails].
pub mod deidentify_data_source_details {
    #[allow(unused_imports)]
    use super::*;

    /// De-identification options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RequestedDeidentifyOptions {
        /// Snapshot of the state of the `DeidentifyTemplate` from the
        /// [Deidentify][google.privacy.dlp.v2.Action.Deidentify] action at the time
        /// this job was run.
        ///
        /// [google.privacy.dlp.v2.Action.Deidentify]: crate::model::action::Deidentify
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub snapshot_deidentify_template: std::option::Option<crate::model::DeidentifyTemplate>,

        /// Snapshot of the state of the structured `DeidentifyTemplate` from the
        /// `Deidentify` action at the time this job was run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub snapshot_structured_deidentify_template:
            std::option::Option<crate::model::DeidentifyTemplate>,

        /// Snapshot of the state of the image transformation `DeidentifyTemplate`
        /// from the `Deidentify` action at the time this job was run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub snapshot_image_redact_template: std::option::Option<crate::model::DeidentifyTemplate>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RequestedDeidentifyOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [snapshot_deidentify_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_deidentify_template].
        pub fn set_snapshot_deidentify_template<
            T: std::convert::Into<std::option::Option<crate::model::DeidentifyTemplate>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.snapshot_deidentify_template = v.into();
            self
        }

        /// Sets the value of [snapshot_structured_deidentify_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_structured_deidentify_template].
        pub fn set_snapshot_structured_deidentify_template<
            T: std::convert::Into<std::option::Option<crate::model::DeidentifyTemplate>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.snapshot_structured_deidentify_template = v.into();
            self
        }

        /// Sets the value of [snapshot_image_redact_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_image_redact_template].
        pub fn set_snapshot_image_redact_template<
            T: std::convert::Into<std::option::Option<crate::model::DeidentifyTemplate>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.snapshot_image_redact_template = v.into();
            self
        }
    }

    impl wkt::message::Message for RequestedDeidentifyOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DeidentifyDataSourceDetails.RequestedDeidentifyOptions"
        }
    }
}

/// InfoType description.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoTypeDescription {
    /// Internal name of the infoType.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Human readable form of the infoType name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Which parts of the API supports this InfoType.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_by: std::vec::Vec<crate::model::InfoTypeSupportedBy>,

    /// Description of the infotype. Translated when language is provided in the
    /// request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// A sample that is a true positive for this infoType.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub example: std::string::String,

    /// A list of available versions for the infotype.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub versions: std::vec::Vec<crate::model::VersionDescription>,

    /// The category of the infoType.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub categories: std::vec::Vec<crate::model::InfoTypeCategory>,

    /// The default sensitivity of the infoType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// If this field is set, this infoType is a general infoType and these
    /// specific infoTypes are contained within it.
    /// General infoTypes are infoTypes that encompass multiple specific infoTypes.
    /// For example, the "GEOGRAPHIC_DATA" general infoType would have set for this
    /// field "LOCATION", "LOCATION_COORDINATES", and "STREET_ADDRESS".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub specific_info_types: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoTypeDescription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InfoTypeDescription::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InfoTypeDescription::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [supported_by][crate::model::InfoTypeDescription::supported_by].
    pub fn set_supported_by<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeSupportedBy>,
    {
        use std::iter::Iterator;
        self.supported_by = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [description][crate::model::InfoTypeDescription::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [example][crate::model::InfoTypeDescription::example].
    pub fn set_example<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.example = v.into();
        self
    }

    /// Sets the value of [versions][crate::model::InfoTypeDescription::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VersionDescription>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [categories][crate::model::InfoTypeDescription::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::InfoTypeDescription::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [specific_info_types][crate::model::InfoTypeDescription::specific_info_types].
    pub fn set_specific_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.specific_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InfoTypeDescription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeDescription"
    }
}

/// Classification of infoTypes to organize them according to geographic
/// location, industry, and data type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoTypeCategory {
    /// Categories of infotypes.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub category: std::option::Option<crate::model::info_type_category::Category>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoTypeCategory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [category][crate::model::InfoTypeCategory::category].
    ///
    /// Note that all the setters affecting `category` are mutually
    /// exclusive.
    pub fn set_category<
        T: std::convert::Into<std::option::Option<crate::model::info_type_category::Category>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = v.into();
        self
    }

    /// The value of [category][crate::model::InfoTypeCategory::category]
    /// if it holds a `LocationCategory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn location_category(
        &self,
    ) -> std::option::Option<&crate::model::info_type_category::LocationCategory> {
        #[allow(unreachable_patterns)]
        self.category.as_ref().and_then(|v| match v {
            crate::model::info_type_category::Category::LocationCategory(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [category][crate::model::InfoTypeCategory::category]
    /// to hold a `LocationCategory`.
    ///
    /// Note that all the setters affecting `category` are
    /// mutually exclusive.
    pub fn set_location_category<
        T: std::convert::Into<crate::model::info_type_category::LocationCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = std::option::Option::Some(
            crate::model::info_type_category::Category::LocationCategory(v.into()),
        );
        self
    }

    /// The value of [category][crate::model::InfoTypeCategory::category]
    /// if it holds a `IndustryCategory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn industry_category(
        &self,
    ) -> std::option::Option<&crate::model::info_type_category::IndustryCategory> {
        #[allow(unreachable_patterns)]
        self.category.as_ref().and_then(|v| match v {
            crate::model::info_type_category::Category::IndustryCategory(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [category][crate::model::InfoTypeCategory::category]
    /// to hold a `IndustryCategory`.
    ///
    /// Note that all the setters affecting `category` are
    /// mutually exclusive.
    pub fn set_industry_category<
        T: std::convert::Into<crate::model::info_type_category::IndustryCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = std::option::Option::Some(
            crate::model::info_type_category::Category::IndustryCategory(v.into()),
        );
        self
    }

    /// The value of [category][crate::model::InfoTypeCategory::category]
    /// if it holds a `TypeCategory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn type_category(
        &self,
    ) -> std::option::Option<&crate::model::info_type_category::TypeCategory> {
        #[allow(unreachable_patterns)]
        self.category.as_ref().and_then(|v| match v {
            crate::model::info_type_category::Category::TypeCategory(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [category][crate::model::InfoTypeCategory::category]
    /// to hold a `TypeCategory`.
    ///
    /// Note that all the setters affecting `category` are
    /// mutually exclusive.
    pub fn set_type_category<
        T: std::convert::Into<crate::model::info_type_category::TypeCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = std::option::Option::Some(
            crate::model::info_type_category::Category::TypeCategory(v.into()),
        );
        self
    }
}

impl wkt::message::Message for InfoTypeCategory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeCategory"
    }
}

/// Defines additional types related to [InfoTypeCategory].
pub mod info_type_category {
    #[allow(unused_imports)]
    use super::*;

    /// Enum of the current locations.
    /// We might add more locations in the future.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocationCategory {
        /// Unused location
        LocationUnspecified,
        /// The infoType is not issued by or tied to a specific region, but is used
        /// almost everywhere.
        Global,
        /// The infoType is typically used in Argentina.
        Argentina,
        /// The infoType is typically used in Armenia.
        Armenia,
        /// The infoType is typically used in Australia.
        Australia,
        /// The infoType is typically used in Azerbaijan.
        Azerbaijan,
        /// The infoType is typically used in Belarus.
        Belarus,
        /// The infoType is typically used in Belgium.
        Belgium,
        /// The infoType is typically used in Brazil.
        Brazil,
        /// The infoType is typically used in Canada.
        Canada,
        /// The infoType is typically used in Chile.
        Chile,
        /// The infoType is typically used in China.
        China,
        /// The infoType is typically used in Colombia.
        Colombia,
        /// The infoType is typically used in Croatia.
        Croatia,
        /// The infoType is typically used in Czechia.
        Czechia,
        /// The infoType is typically used in Denmark.
        Denmark,
        /// The infoType is typically used in France.
        France,
        /// The infoType is typically used in Finland.
        Finland,
        /// The infoType is typically used in Germany.
        Germany,
        /// The infoType is typically used in Hong Kong.
        HongKong,
        /// The infoType is typically used in India.
        India,
        /// The infoType is typically used in Indonesia.
        Indonesia,
        /// The infoType is typically used in Ireland.
        Ireland,
        /// The infoType is typically used in Israel.
        Israel,
        /// The infoType is typically used in Italy.
        Italy,
        /// The infoType is typically used in Japan.
        Japan,
        /// The infoType is typically used in Kazakhstan.
        Kazakhstan,
        /// The infoType is typically used in Korea.
        Korea,
        /// The infoType is typically used in Mexico.
        Mexico,
        /// The infoType is typically used in the Netherlands.
        TheNetherlands,
        /// The infoType is typically used in New Zealand.
        NewZealand,
        /// The infoType is typically used in Norway.
        Norway,
        /// The infoType is typically used in Paraguay.
        Paraguay,
        /// The infoType is typically used in Peru.
        Peru,
        /// The infoType is typically used in Poland.
        Poland,
        /// The infoType is typically used in Portugal.
        Portugal,
        /// The infoType is typically used in Russia.
        Russia,
        /// The infoType is typically used in Singapore.
        Singapore,
        /// The infoType is typically used in South Africa.
        SouthAfrica,
        /// The infoType is typically used in Spain.
        Spain,
        /// The infoType is typically used in Sweden.
        Sweden,
        /// The infoType is typically used in Switzerland.
        Switzerland,
        /// The infoType is typically used in Taiwan.
        Taiwan,
        /// The infoType is typically used in Thailand.
        Thailand,
        /// The infoType is typically used in Turkey.
        Turkey,
        /// The infoType is typically used in Ukraine.
        Ukraine,
        /// The infoType is typically used in the United Kingdom.
        UnitedKingdom,
        /// The infoType is typically used in the United States.
        UnitedStates,
        /// The infoType is typically used in Uruguay.
        Uruguay,
        /// The infoType is typically used in Uzbekistan.
        Uzbekistan,
        /// The infoType is typically used in Venezuela.
        Venezuela,
        /// The infoType is typically used in Google internally.
        Internal,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LocationCategory::value] or
        /// [LocationCategory::name].
        UnknownValue(location_category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod location_category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LocationCategory {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::LocationUnspecified => std::option::Option::Some(0),
                Self::Global => std::option::Option::Some(1),
                Self::Argentina => std::option::Option::Some(2),
                Self::Armenia => std::option::Option::Some(51),
                Self::Australia => std::option::Option::Some(3),
                Self::Azerbaijan => std::option::Option::Some(48),
                Self::Belarus => std::option::Option::Some(50),
                Self::Belgium => std::option::Option::Some(4),
                Self::Brazil => std::option::Option::Some(5),
                Self::Canada => std::option::Option::Some(6),
                Self::Chile => std::option::Option::Some(7),
                Self::China => std::option::Option::Some(8),
                Self::Colombia => std::option::Option::Some(9),
                Self::Croatia => std::option::Option::Some(42),
                Self::Czechia => std::option::Option::Some(52),
                Self::Denmark => std::option::Option::Some(10),
                Self::France => std::option::Option::Some(11),
                Self::Finland => std::option::Option::Some(12),
                Self::Germany => std::option::Option::Some(13),
                Self::HongKong => std::option::Option::Some(14),
                Self::India => std::option::Option::Some(15),
                Self::Indonesia => std::option::Option::Some(16),
                Self::Ireland => std::option::Option::Some(17),
                Self::Israel => std::option::Option::Some(18),
                Self::Italy => std::option::Option::Some(19),
                Self::Japan => std::option::Option::Some(20),
                Self::Kazakhstan => std::option::Option::Some(47),
                Self::Korea => std::option::Option::Some(21),
                Self::Mexico => std::option::Option::Some(22),
                Self::TheNetherlands => std::option::Option::Some(23),
                Self::NewZealand => std::option::Option::Some(41),
                Self::Norway => std::option::Option::Some(24),
                Self::Paraguay => std::option::Option::Some(25),
                Self::Peru => std::option::Option::Some(26),
                Self::Poland => std::option::Option::Some(27),
                Self::Portugal => std::option::Option::Some(28),
                Self::Russia => std::option::Option::Some(44),
                Self::Singapore => std::option::Option::Some(29),
                Self::SouthAfrica => std::option::Option::Some(30),
                Self::Spain => std::option::Option::Some(31),
                Self::Sweden => std::option::Option::Some(32),
                Self::Switzerland => std::option::Option::Some(43),
                Self::Taiwan => std::option::Option::Some(33),
                Self::Thailand => std::option::Option::Some(34),
                Self::Turkey => std::option::Option::Some(35),
                Self::Ukraine => std::option::Option::Some(45),
                Self::UnitedKingdom => std::option::Option::Some(36),
                Self::UnitedStates => std::option::Option::Some(37),
                Self::Uruguay => std::option::Option::Some(38),
                Self::Uzbekistan => std::option::Option::Some(46),
                Self::Venezuela => std::option::Option::Some(39),
                Self::Internal => std::option::Option::Some(40),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::LocationUnspecified => std::option::Option::Some("LOCATION_UNSPECIFIED"),
                Self::Global => std::option::Option::Some("GLOBAL"),
                Self::Argentina => std::option::Option::Some("ARGENTINA"),
                Self::Armenia => std::option::Option::Some("ARMENIA"),
                Self::Australia => std::option::Option::Some("AUSTRALIA"),
                Self::Azerbaijan => std::option::Option::Some("AZERBAIJAN"),
                Self::Belarus => std::option::Option::Some("BELARUS"),
                Self::Belgium => std::option::Option::Some("BELGIUM"),
                Self::Brazil => std::option::Option::Some("BRAZIL"),
                Self::Canada => std::option::Option::Some("CANADA"),
                Self::Chile => std::option::Option::Some("CHILE"),
                Self::China => std::option::Option::Some("CHINA"),
                Self::Colombia => std::option::Option::Some("COLOMBIA"),
                Self::Croatia => std::option::Option::Some("CROATIA"),
                Self::Czechia => std::option::Option::Some("CZECHIA"),
                Self::Denmark => std::option::Option::Some("DENMARK"),
                Self::France => std::option::Option::Some("FRANCE"),
                Self::Finland => std::option::Option::Some("FINLAND"),
                Self::Germany => std::option::Option::Some("GERMANY"),
                Self::HongKong => std::option::Option::Some("HONG_KONG"),
                Self::India => std::option::Option::Some("INDIA"),
                Self::Indonesia => std::option::Option::Some("INDONESIA"),
                Self::Ireland => std::option::Option::Some("IRELAND"),
                Self::Israel => std::option::Option::Some("ISRAEL"),
                Self::Italy => std::option::Option::Some("ITALY"),
                Self::Japan => std::option::Option::Some("JAPAN"),
                Self::Kazakhstan => std::option::Option::Some("KAZAKHSTAN"),
                Self::Korea => std::option::Option::Some("KOREA"),
                Self::Mexico => std::option::Option::Some("MEXICO"),
                Self::TheNetherlands => std::option::Option::Some("THE_NETHERLANDS"),
                Self::NewZealand => std::option::Option::Some("NEW_ZEALAND"),
                Self::Norway => std::option::Option::Some("NORWAY"),
                Self::Paraguay => std::option::Option::Some("PARAGUAY"),
                Self::Peru => std::option::Option::Some("PERU"),
                Self::Poland => std::option::Option::Some("POLAND"),
                Self::Portugal => std::option::Option::Some("PORTUGAL"),
                Self::Russia => std::option::Option::Some("RUSSIA"),
                Self::Singapore => std::option::Option::Some("SINGAPORE"),
                Self::SouthAfrica => std::option::Option::Some("SOUTH_AFRICA"),
                Self::Spain => std::option::Option::Some("SPAIN"),
                Self::Sweden => std::option::Option::Some("SWEDEN"),
                Self::Switzerland => std::option::Option::Some("SWITZERLAND"),
                Self::Taiwan => std::option::Option::Some("TAIWAN"),
                Self::Thailand => std::option::Option::Some("THAILAND"),
                Self::Turkey => std::option::Option::Some("TURKEY"),
                Self::Ukraine => std::option::Option::Some("UKRAINE"),
                Self::UnitedKingdom => std::option::Option::Some("UNITED_KINGDOM"),
                Self::UnitedStates => std::option::Option::Some("UNITED_STATES"),
                Self::Uruguay => std::option::Option::Some("URUGUAY"),
                Self::Uzbekistan => std::option::Option::Some("UZBEKISTAN"),
                Self::Venezuela => std::option::Option::Some("VENEZUELA"),
                Self::Internal => std::option::Option::Some("INTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LocationCategory {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LocationCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LocationCategory {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::LocationUnspecified,
                1 => Self::Global,
                2 => Self::Argentina,
                3 => Self::Australia,
                4 => Self::Belgium,
                5 => Self::Brazil,
                6 => Self::Canada,
                7 => Self::Chile,
                8 => Self::China,
                9 => Self::Colombia,
                10 => Self::Denmark,
                11 => Self::France,
                12 => Self::Finland,
                13 => Self::Germany,
                14 => Self::HongKong,
                15 => Self::India,
                16 => Self::Indonesia,
                17 => Self::Ireland,
                18 => Self::Israel,
                19 => Self::Italy,
                20 => Self::Japan,
                21 => Self::Korea,
                22 => Self::Mexico,
                23 => Self::TheNetherlands,
                24 => Self::Norway,
                25 => Self::Paraguay,
                26 => Self::Peru,
                27 => Self::Poland,
                28 => Self::Portugal,
                29 => Self::Singapore,
                30 => Self::SouthAfrica,
                31 => Self::Spain,
                32 => Self::Sweden,
                33 => Self::Taiwan,
                34 => Self::Thailand,
                35 => Self::Turkey,
                36 => Self::UnitedKingdom,
                37 => Self::UnitedStates,
                38 => Self::Uruguay,
                39 => Self::Venezuela,
                40 => Self::Internal,
                41 => Self::NewZealand,
                42 => Self::Croatia,
                43 => Self::Switzerland,
                44 => Self::Russia,
                45 => Self::Ukraine,
                46 => Self::Uzbekistan,
                47 => Self::Kazakhstan,
                48 => Self::Azerbaijan,
                50 => Self::Belarus,
                51 => Self::Armenia,
                52 => Self::Czechia,
                _ => Self::UnknownValue(location_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LocationCategory {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCATION_UNSPECIFIED" => Self::LocationUnspecified,
                "GLOBAL" => Self::Global,
                "ARGENTINA" => Self::Argentina,
                "ARMENIA" => Self::Armenia,
                "AUSTRALIA" => Self::Australia,
                "AZERBAIJAN" => Self::Azerbaijan,
                "BELARUS" => Self::Belarus,
                "BELGIUM" => Self::Belgium,
                "BRAZIL" => Self::Brazil,
                "CANADA" => Self::Canada,
                "CHILE" => Self::Chile,
                "CHINA" => Self::China,
                "COLOMBIA" => Self::Colombia,
                "CROATIA" => Self::Croatia,
                "CZECHIA" => Self::Czechia,
                "DENMARK" => Self::Denmark,
                "FRANCE" => Self::France,
                "FINLAND" => Self::Finland,
                "GERMANY" => Self::Germany,
                "HONG_KONG" => Self::HongKong,
                "INDIA" => Self::India,
                "INDONESIA" => Self::Indonesia,
                "IRELAND" => Self::Ireland,
                "ISRAEL" => Self::Israel,
                "ITALY" => Self::Italy,
                "JAPAN" => Self::Japan,
                "KAZAKHSTAN" => Self::Kazakhstan,
                "KOREA" => Self::Korea,
                "MEXICO" => Self::Mexico,
                "THE_NETHERLANDS" => Self::TheNetherlands,
                "NEW_ZEALAND" => Self::NewZealand,
                "NORWAY" => Self::Norway,
                "PARAGUAY" => Self::Paraguay,
                "PERU" => Self::Peru,
                "POLAND" => Self::Poland,
                "PORTUGAL" => Self::Portugal,
                "RUSSIA" => Self::Russia,
                "SINGAPORE" => Self::Singapore,
                "SOUTH_AFRICA" => Self::SouthAfrica,
                "SPAIN" => Self::Spain,
                "SWEDEN" => Self::Sweden,
                "SWITZERLAND" => Self::Switzerland,
                "TAIWAN" => Self::Taiwan,
                "THAILAND" => Self::Thailand,
                "TURKEY" => Self::Turkey,
                "UKRAINE" => Self::Ukraine,
                "UNITED_KINGDOM" => Self::UnitedKingdom,
                "UNITED_STATES" => Self::UnitedStates,
                "URUGUAY" => Self::Uruguay,
                "UZBEKISTAN" => Self::Uzbekistan,
                "VENEZUELA" => Self::Venezuela,
                "INTERNAL" => Self::Internal,
                _ => Self::UnknownValue(location_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LocationCategory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::LocationUnspecified => serializer.serialize_i32(0),
                Self::Global => serializer.serialize_i32(1),
                Self::Argentina => serializer.serialize_i32(2),
                Self::Armenia => serializer.serialize_i32(51),
                Self::Australia => serializer.serialize_i32(3),
                Self::Azerbaijan => serializer.serialize_i32(48),
                Self::Belarus => serializer.serialize_i32(50),
                Self::Belgium => serializer.serialize_i32(4),
                Self::Brazil => serializer.serialize_i32(5),
                Self::Canada => serializer.serialize_i32(6),
                Self::Chile => serializer.serialize_i32(7),
                Self::China => serializer.serialize_i32(8),
                Self::Colombia => serializer.serialize_i32(9),
                Self::Croatia => serializer.serialize_i32(42),
                Self::Czechia => serializer.serialize_i32(52),
                Self::Denmark => serializer.serialize_i32(10),
                Self::France => serializer.serialize_i32(11),
                Self::Finland => serializer.serialize_i32(12),
                Self::Germany => serializer.serialize_i32(13),
                Self::HongKong => serializer.serialize_i32(14),
                Self::India => serializer.serialize_i32(15),
                Self::Indonesia => serializer.serialize_i32(16),
                Self::Ireland => serializer.serialize_i32(17),
                Self::Israel => serializer.serialize_i32(18),
                Self::Italy => serializer.serialize_i32(19),
                Self::Japan => serializer.serialize_i32(20),
                Self::Kazakhstan => serializer.serialize_i32(47),
                Self::Korea => serializer.serialize_i32(21),
                Self::Mexico => serializer.serialize_i32(22),
                Self::TheNetherlands => serializer.serialize_i32(23),
                Self::NewZealand => serializer.serialize_i32(41),
                Self::Norway => serializer.serialize_i32(24),
                Self::Paraguay => serializer.serialize_i32(25),
                Self::Peru => serializer.serialize_i32(26),
                Self::Poland => serializer.serialize_i32(27),
                Self::Portugal => serializer.serialize_i32(28),
                Self::Russia => serializer.serialize_i32(44),
                Self::Singapore => serializer.serialize_i32(29),
                Self::SouthAfrica => serializer.serialize_i32(30),
                Self::Spain => serializer.serialize_i32(31),
                Self::Sweden => serializer.serialize_i32(32),
                Self::Switzerland => serializer.serialize_i32(43),
                Self::Taiwan => serializer.serialize_i32(33),
                Self::Thailand => serializer.serialize_i32(34),
                Self::Turkey => serializer.serialize_i32(35),
                Self::Ukraine => serializer.serialize_i32(45),
                Self::UnitedKingdom => serializer.serialize_i32(36),
                Self::UnitedStates => serializer.serialize_i32(37),
                Self::Uruguay => serializer.serialize_i32(38),
                Self::Uzbekistan => serializer.serialize_i32(46),
                Self::Venezuela => serializer.serialize_i32(39),
                Self::Internal => serializer.serialize_i32(40),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LocationCategory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocationCategory>::new(
                ".google.privacy.dlp.v2.InfoTypeCategory.LocationCategory",
            ))
        }
    }

    /// Enum of the current industries in the category.
    /// We might add more industries in the future.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IndustryCategory {
        /// Unused industry
        IndustryUnspecified,
        /// The infoType is typically used in the finance industry.
        Finance,
        /// The infoType is typically used in the health industry.
        Health,
        /// The infoType is typically used in the telecommunications industry.
        Telecommunications,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IndustryCategory::value] or
        /// [IndustryCategory::name].
        UnknownValue(industry_category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod industry_category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IndustryCategory {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::IndustryUnspecified => std::option::Option::Some(0),
                Self::Finance => std::option::Option::Some(1),
                Self::Health => std::option::Option::Some(2),
                Self::Telecommunications => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::IndustryUnspecified => std::option::Option::Some("INDUSTRY_UNSPECIFIED"),
                Self::Finance => std::option::Option::Some("FINANCE"),
                Self::Health => std::option::Option::Some("HEALTH"),
                Self::Telecommunications => std::option::Option::Some("TELECOMMUNICATIONS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IndustryCategory {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IndustryCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IndustryCategory {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::IndustryUnspecified,
                1 => Self::Finance,
                2 => Self::Health,
                3 => Self::Telecommunications,
                _ => Self::UnknownValue(industry_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IndustryCategory {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INDUSTRY_UNSPECIFIED" => Self::IndustryUnspecified,
                "FINANCE" => Self::Finance,
                "HEALTH" => Self::Health,
                "TELECOMMUNICATIONS" => Self::Telecommunications,
                _ => Self::UnknownValue(industry_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IndustryCategory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::IndustryUnspecified => serializer.serialize_i32(0),
                Self::Finance => serializer.serialize_i32(1),
                Self::Health => serializer.serialize_i32(2),
                Self::Telecommunications => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IndustryCategory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IndustryCategory>::new(
                ".google.privacy.dlp.v2.InfoTypeCategory.IndustryCategory",
            ))
        }
    }

    /// Enum of the current types in the category.
    /// We might add more types in the future.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TypeCategory {
        /// Unused type
        TypeUnspecified,
        /// Personally identifiable information, for example, a
        /// name or phone number
        Pii,
        /// Personally identifiable information that is especially sensitive, for
        /// example, a passport number.
        Spii,
        /// Attributes that can partially identify someone, especially in
        /// combination with other attributes, like age, height, and gender.
        Demographic,
        /// Confidential or secret information, for example, a password.
        Credential,
        /// An identification document issued by a government.
        GovernmentId,
        /// A document, for example, a resume or source code.
        Document,
        /// Information that is not sensitive on its own, but provides details about
        /// the circumstances surrounding an entity or an event.
        ContextualInformation,
        /// Category for `CustomInfoType` types.
        Custom,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TypeCategory::value] or
        /// [TypeCategory::name].
        UnknownValue(type_category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod type_category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TypeCategory {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some(0),
                Self::Pii => std::option::Option::Some(1),
                Self::Spii => std::option::Option::Some(2),
                Self::Demographic => std::option::Option::Some(3),
                Self::Credential => std::option::Option::Some(4),
                Self::GovernmentId => std::option::Option::Some(5),
                Self::Document => std::option::Option::Some(6),
                Self::ContextualInformation => std::option::Option::Some(7),
                Self::Custom => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Pii => std::option::Option::Some("PII"),
                Self::Spii => std::option::Option::Some("SPII"),
                Self::Demographic => std::option::Option::Some("DEMOGRAPHIC"),
                Self::Credential => std::option::Option::Some("CREDENTIAL"),
                Self::GovernmentId => std::option::Option::Some("GOVERNMENT_ID"),
                Self::Document => std::option::Option::Some("DOCUMENT"),
                Self::ContextualInformation => std::option::Option::Some("CONTEXTUAL_INFORMATION"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TypeCategory {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TypeCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TypeCategory {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::TypeUnspecified,
                1 => Self::Pii,
                2 => Self::Spii,
                3 => Self::Demographic,
                4 => Self::Credential,
                5 => Self::GovernmentId,
                6 => Self::Document,
                7 => Self::ContextualInformation,
                8 => Self::Custom,
                _ => Self::UnknownValue(type_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TypeCategory {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::TypeUnspecified,
                "PII" => Self::Pii,
                "SPII" => Self::Spii,
                "DEMOGRAPHIC" => Self::Demographic,
                "CREDENTIAL" => Self::Credential,
                "GOVERNMENT_ID" => Self::GovernmentId,
                "DOCUMENT" => Self::Document,
                "CONTEXTUAL_INFORMATION" => Self::ContextualInformation,
                "CUSTOM" => Self::Custom,
                _ => Self::UnknownValue(type_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TypeCategory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::TypeUnspecified => serializer.serialize_i32(0),
                Self::Pii => serializer.serialize_i32(1),
                Self::Spii => serializer.serialize_i32(2),
                Self::Demographic => serializer.serialize_i32(3),
                Self::Credential => serializer.serialize_i32(4),
                Self::GovernmentId => serializer.serialize_i32(5),
                Self::Document => serializer.serialize_i32(6),
                Self::ContextualInformation => serializer.serialize_i32(7),
                Self::Custom => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TypeCategory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TypeCategory>::new(
                ".google.privacy.dlp.v2.InfoTypeCategory.TypeCategory",
            ))
        }
    }

    /// Categories of infotypes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Category {
        /// The region or country that issued the ID or document represented by the
        /// infoType.
        LocationCategory(crate::model::info_type_category::LocationCategory),
        /// The group of relevant businesses where this infoType is commonly used
        IndustryCategory(crate::model::info_type_category::IndustryCategory),
        /// The class of identifiers where this infoType belongs
        TypeCategory(crate::model::info_type_category::TypeCategory),
    }
}

/// Details about each available version for an infotype.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VersionDescription {
    /// Name of the version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Description of the version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VersionDescription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::VersionDescription::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [description][crate::model::VersionDescription::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for VersionDescription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VersionDescription"
    }
}

/// Request for the list of infoTypes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInfoTypesRequest {
    /// The parent resource name.
    ///
    /// The format of this value is as follows:
    ///
    /// ```norust
    /// `locations/{location_id}`
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// BCP-47 language code for localized infoType friendly
    /// names. If omitted, or if localized strings are not available,
    /// en-US strings will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// filter to only return infoTypes supported by certain parts of the
    /// API. Defaults to supported_by=INSPECT.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInfoTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInfoTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ListInfoTypesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInfoTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListInfoTypesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListInfoTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInfoTypesRequest"
    }
}

/// Response to the ListInfoTypes request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInfoTypesResponse {
    /// Set of sensitive infoTypes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub info_types: std::vec::Vec<crate::model::InfoTypeDescription>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInfoTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_types][crate::model::ListInfoTypesResponse::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeDescription>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInfoTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInfoTypesResponse"
    }
}

/// Configuration for a risk analysis job. See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-risk-analysis>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RiskAnalysisJobConfig {
    /// Privacy metric to compute.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub privacy_metric: std::option::Option<crate::model::PrivacyMetric>,

    /// Input dataset to compute metrics over.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_table: std::option::Option<crate::model::BigQueryTable>,

    /// Actions to execute at the completion of the job. Are executed in the order
    /// provided.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub actions: std::vec::Vec<crate::model::Action>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RiskAnalysisJobConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [privacy_metric][crate::model::RiskAnalysisJobConfig::privacy_metric].
    pub fn set_privacy_metric<
        T: std::convert::Into<std::option::Option<crate::model::PrivacyMetric>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privacy_metric = v.into();
        self
    }

    /// Sets the value of [source_table][crate::model::RiskAnalysisJobConfig::source_table].
    pub fn set_source_table<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_table = v.into();
        self
    }

    /// Sets the value of [actions][crate::model::RiskAnalysisJobConfig::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Action>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RiskAnalysisJobConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RiskAnalysisJobConfig"
    }
}

/// A column with a semantic tag attached.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuasiId {
    /// Required. Identifies the column.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<crate::model::FieldId>,

    /// Semantic tag that identifies what a column contains, to determine which
    /// statistical model to use to estimate the reidentifiability of each
    /// value. [required]
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub tag: std::option::Option<crate::model::quasi_id::Tag>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuasiId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::QuasiId::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::QuasiId::tag].
    ///
    /// Note that all the setters affecting `tag` are mutually
    /// exclusive.
    pub fn set_tag<T: std::convert::Into<std::option::Option<crate::model::quasi_id::Tag>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = v.into();
        self
    }

    /// The value of [tag][crate::model::QuasiId::tag]
    /// if it holds a `InfoType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn info_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::InfoType>> {
        #[allow(unreachable_patterns)]
        self.tag.as_ref().and_then(|v| match v {
            crate::model::quasi_id::Tag::InfoType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tag][crate::model::QuasiId::tag]
    /// to hold a `InfoType`.
    ///
    /// Note that all the setters affecting `tag` are
    /// mutually exclusive.
    pub fn set_info_type<T: std::convert::Into<std::boxed::Box<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = std::option::Option::Some(crate::model::quasi_id::Tag::InfoType(v.into()));
        self
    }

    /// The value of [tag][crate::model::QuasiId::tag]
    /// if it holds a `CustomTag`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_tag(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.tag.as_ref().and_then(|v| match v {
            crate::model::quasi_id::Tag::CustomTag(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tag][crate::model::QuasiId::tag]
    /// to hold a `CustomTag`.
    ///
    /// Note that all the setters affecting `tag` are
    /// mutually exclusive.
    pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = std::option::Option::Some(crate::model::quasi_id::Tag::CustomTag(v.into()));
        self
    }

    /// The value of [tag][crate::model::QuasiId::tag]
    /// if it holds a `Inferred`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inferred(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.tag.as_ref().and_then(|v| match v {
            crate::model::quasi_id::Tag::Inferred(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tag][crate::model::QuasiId::tag]
    /// to hold a `Inferred`.
    ///
    /// Note that all the setters affecting `tag` are
    /// mutually exclusive.
    pub fn set_inferred<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = std::option::Option::Some(crate::model::quasi_id::Tag::Inferred(v.into()));
        self
    }
}

impl wkt::message::Message for QuasiId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.QuasiId"
    }
}

/// Defines additional types related to [QuasiId].
pub mod quasi_id {
    #[allow(unused_imports)]
    use super::*;

    /// Semantic tag that identifies what a column contains, to determine which
    /// statistical model to use to estimate the reidentifiability of each
    /// value. [required]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Tag {
        /// A column can be tagged with a InfoType to use the relevant public
        /// dataset as a statistical model of population, if available. We
        /// currently support US ZIP codes, region codes, ages and genders.
        /// To programmatically obtain the list of supported InfoTypes, use
        /// ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
        InfoType(std::boxed::Box<crate::model::InfoType>),
        /// A column can be tagged with a custom tag. In this case, the user must
        /// indicate an auxiliary table that contains statistical information on
        /// the possible values of this column (below).
        CustomTag(std::string::String),
        /// If no semantic tag is indicated, we infer the statistical model from
        /// the distribution of values in the input data
        Inferred(std::boxed::Box<wkt::Empty>),
    }
}

/// An auxiliary table containing statistical information on the relative
/// frequency of different quasi-identifiers values. It has one or several
/// quasi-identifiers columns, and one column that indicates the relative
/// frequency of each quasi-identifier tuple.
/// If a tuple is present in the data but not in the auxiliary table, the
/// corresponding relative frequency is assumed to be zero (and thus, the
/// tuple is highly reidentifiable).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StatisticalTable {
    /// Required. Auxiliary table location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table: std::option::Option<crate::model::BigQueryTable>,

    /// Required. Quasi-identifier columns.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub quasi_ids: std::vec::Vec<crate::model::statistical_table::QuasiIdentifierField>,

    /// Required. The relative frequency column must contain a floating-point
    /// number between 0 and 1 (inclusive). Null values are assumed to be zero.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub relative_frequency: std::option::Option<crate::model::FieldId>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StatisticalTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::StatisticalTable::table].
    pub fn set_table<T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>>(
        mut self,
        v: T,
    ) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [quasi_ids][crate::model::StatisticalTable::quasi_ids].
    pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::statistical_table::QuasiIdentifierField>,
    {
        use std::iter::Iterator;
        self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [relative_frequency][crate::model::StatisticalTable::relative_frequency].
    pub fn set_relative_frequency<
        T: std::convert::Into<std::option::Option<crate::model::FieldId>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.relative_frequency = v.into();
        self
    }
}

impl wkt::message::Message for StatisticalTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StatisticalTable"
    }
}

/// Defines additional types related to [StatisticalTable].
pub mod statistical_table {
    #[allow(unused_imports)]
    use super::*;

    /// A quasi-identifier column has a custom_tag, used to know which column
    /// in the data corresponds to which column in the statistical model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QuasiIdentifierField {
        /// Identifies the column.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub field: std::option::Option<crate::model::FieldId>,

        /// A column can be tagged with a custom tag. In this case, the user must
        /// indicate an auxiliary table that contains statistical information on
        /// the possible values of this column (below).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub custom_tag: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QuasiIdentifierField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::statistical_table::QuasiIdentifierField::field].
        pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
            mut self,
            v: T,
        ) -> Self {
            self.field = v.into();
            self
        }

        /// Sets the value of [custom_tag][crate::model::statistical_table::QuasiIdentifierField::custom_tag].
        pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.custom_tag = v.into();
            self
        }
    }

    impl wkt::message::Message for QuasiIdentifierField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.StatisticalTable.QuasiIdentifierField"
        }
    }
}

/// Privacy metric to compute for reidentification risk analysis.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivacyMetric {
    /// Types of analysis.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::privacy_metric::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivacyMetric {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::privacy_metric::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `NumericalStatsConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn numerical_stats_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::NumericalStatsConfig>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::NumericalStatsConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `NumericalStatsConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_numerical_stats_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::NumericalStatsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::NumericalStatsConfig(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `CategoricalStatsConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn categorical_stats_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::CategoricalStatsConfig>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::CategoricalStatsConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `CategoricalStatsConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_categorical_stats_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::CategoricalStatsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::CategoricalStatsConfig(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `KAnonymityConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn k_anonymity_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::KAnonymityConfig>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::KAnonymityConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `KAnonymityConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_k_anonymity_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::KAnonymityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::KAnonymityConfig(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `LDiversityConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn l_diversity_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::LDiversityConfig>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::LDiversityConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `LDiversityConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_l_diversity_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::LDiversityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::LDiversityConfig(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `KMapEstimationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn k_map_estimation_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::KMapEstimationConfig>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::KMapEstimationConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `KMapEstimationConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_k_map_estimation_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::KMapEstimationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::KMapEstimationConfig(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `DeltaPresenceEstimationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delta_presence_estimation_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::privacy_metric::DeltaPresenceEstimationConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::DeltaPresenceEstimationConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `DeltaPresenceEstimationConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_delta_presence_estimation_config<
        T: std::convert::Into<
                std::boxed::Box<crate::model::privacy_metric::DeltaPresenceEstimationConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::DeltaPresenceEstimationConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PrivacyMetric {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric"
    }
}

/// Defines additional types related to [PrivacyMetric].
pub mod privacy_metric {
    #[allow(unused_imports)]
    use super::*;

    /// Compute numerical stats over an individual column, including
    /// min, max, and quantiles.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NumericalStatsConfig {
        /// Field to compute numerical stats on. Supported types are
        /// integer, float, date, datetime, timestamp, time.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub field: std::option::Option<crate::model::FieldId>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NumericalStatsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::privacy_metric::NumericalStatsConfig::field].
        pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
            mut self,
            v: T,
        ) -> Self {
            self.field = v.into();
            self
        }
    }

    impl wkt::message::Message for NumericalStatsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.NumericalStatsConfig"
        }
    }

    /// Compute numerical stats over an individual column, including
    /// number of distinct values and value count distribution.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CategoricalStatsConfig {
        /// Field to compute categorical stats on. All column types are
        /// supported except for arrays and structs. However, it may be more
        /// informative to use NumericalStats when the field type is supported,
        /// depending on the data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub field: std::option::Option<crate::model::FieldId>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CategoricalStatsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::privacy_metric::CategoricalStatsConfig::field].
        pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
            mut self,
            v: T,
        ) -> Self {
            self.field = v.into();
            self
        }
    }

    impl wkt::message::Message for CategoricalStatsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.CategoricalStatsConfig"
        }
    }

    /// k-anonymity metric, used for analysis of reidentification risk.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct KAnonymityConfig {
        /// Set of fields to compute k-anonymity over. When multiple fields are
        /// specified, they are considered a single composite key. Structs and
        /// repeated data types are not supported; however, nested fields are
        /// supported so long as they are not structs themselves or nested within
        /// a repeated field.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub quasi_ids: std::vec::Vec<crate::model::FieldId>,

        /// Message indicating that multiple rows might be associated to a
        /// single individual. If the same entity_id is associated to multiple
        /// quasi-identifier tuples over distinct rows, we consider the entire
        /// collection of tuples as the composite quasi-identifier. This collection
        /// is a multiset: the order in which the different tuples appear in the
        /// dataset is ignored, but their frequency is taken into account.
        ///
        /// Important note: a maximum of 1000 rows can be associated to a single
        /// entity ID. If more rows are associated with the same entity ID, some
        /// might be ignored.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub entity_id: std::option::Option<crate::model::EntityId>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KAnonymityConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::KAnonymityConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FieldId>,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [entity_id][crate::model::privacy_metric::KAnonymityConfig::entity_id].
        pub fn set_entity_id<T: std::convert::Into<std::option::Option<crate::model::EntityId>>>(
            mut self,
            v: T,
        ) -> Self {
            self.entity_id = v.into();
            self
        }
    }

    impl wkt::message::Message for KAnonymityConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KAnonymityConfig"
        }
    }

    /// l-diversity metric, used for analysis of reidentification risk.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LDiversityConfig {
        /// Set of quasi-identifiers indicating how equivalence classes are
        /// defined for the l-diversity computation. When multiple fields are
        /// specified, they are considered a single composite key.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub quasi_ids: std::vec::Vec<crate::model::FieldId>,

        /// Sensitive field for computing the l-value.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub sensitive_attribute: std::option::Option<crate::model::FieldId>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LDiversityConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::LDiversityConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FieldId>,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [sensitive_attribute][crate::model::privacy_metric::LDiversityConfig::sensitive_attribute].
        pub fn set_sensitive_attribute<
            T: std::convert::Into<std::option::Option<crate::model::FieldId>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.sensitive_attribute = v.into();
            self
        }
    }

    impl wkt::message::Message for LDiversityConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.LDiversityConfig"
        }
    }

    /// Reidentifiability metric. This corresponds to a risk model similar to what
    /// is called "journalist risk" in the literature, except the attack dataset is
    /// statistically modeled instead of being perfectly known. This can be done
    /// using publicly available data (like the US Census), or using a custom
    /// statistical model (indicated as one or several BigQuery tables), or by
    /// extrapolating from the distribution of values in the input dataset.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct KMapEstimationConfig {
        /// Required. Fields considered to be quasi-identifiers. No two columns can
        /// have the same tag.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub quasi_ids:
            std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::TaggedField>,

        /// ISO 3166-1 alpha-2 region code to use in the statistical modeling.
        /// Set if no column is tagged with a region-specific InfoType (like
        /// US_ZIP_5) or a region code.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub region_code: std::string::String,

        /// Several auxiliary tables can be used in the analysis. Each custom_tag
        /// used to tag a quasi-identifiers column must appear in exactly one column
        /// of one auxiliary table.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub auxiliary_tables:
            std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KMapEstimationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::KMapEstimationConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::privacy_metric::k_map_estimation_config::TaggedField,
                >,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [region_code][crate::model::privacy_metric::KMapEstimationConfig::region_code].
        pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region_code = v.into();
            self
        }

        /// Sets the value of [auxiliary_tables][crate::model::privacy_metric::KMapEstimationConfig::auxiliary_tables].
        pub fn set_auxiliary_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable,
                >,
        {
            use std::iter::Iterator;
            self.auxiliary_tables = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for KMapEstimationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig"
        }
    }

    /// Defines additional types related to [KMapEstimationConfig].
    pub mod k_map_estimation_config {
        #[allow(unused_imports)]
        use super::*;

        /// A column with a semantic tag attached.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TaggedField {
            /// Required. Identifies the column.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub field: std::option::Option<crate::model::FieldId>,

            /// Semantic tag that identifies what a column contains, to determine which
            /// statistical model to use to estimate the reidentifiability of each
            /// value. [required]
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub tag: std::option::Option<
                crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TaggedField {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [field][crate::model::privacy_metric::k_map_estimation_config::TaggedField::field].
            pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
                mut self,
                v: T,
            ) -> Self {
                self.field = v.into();
                self
            }

            /// Sets the value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag].
            ///
            /// Note that all the setters affecting `tag` are mutually
            /// exclusive.
            pub fn set_tag<T: std::convert::Into<std::option::Option<crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag>>>(mut self, v: T) -> Self
            {
                self.tag = v.into();
                self
            }

            /// The value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// if it holds a `InfoType`, `None` if the field is not set or
            /// holds a different branch.
            pub fn info_type(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::InfoType>> {
                #[allow(unreachable_patterns)]
                self.tag.as_ref().and_then(|v| match v {
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::InfoType(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// to hold a `InfoType`.
            ///
            /// Note that all the setters affecting `tag` are
            /// mutually exclusive.
            pub fn set_info_type<T: std::convert::Into<std::boxed::Box<crate::model::InfoType>>>(
                mut self,
                v: T,
            ) -> Self {
                self.tag = std::option::Option::Some(
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::InfoType(
                        v.into()
                    )
                );
                self
            }

            /// The value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// if it holds a `CustomTag`, `None` if the field is not set or
            /// holds a different branch.
            pub fn custom_tag(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.tag.as_ref().and_then(|v| match v {
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::CustomTag(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// to hold a `CustomTag`.
            ///
            /// Note that all the setters affecting `tag` are
            /// mutually exclusive.
            pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.tag = std::option::Option::Some(
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::CustomTag(
                        v.into()
                    )
                );
                self
            }

            /// The value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// if it holds a `Inferred`, `None` if the field is not set or
            /// holds a different branch.
            pub fn inferred(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
                #[allow(unreachable_patterns)]
                self.tag.as_ref().and_then(|v| match v {
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::Inferred(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// to hold a `Inferred`.
            ///
            /// Note that all the setters affecting `tag` are
            /// mutually exclusive.
            pub fn set_inferred<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
                mut self,
                v: T,
            ) -> Self {
                self.tag = std::option::Option::Some(
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::Inferred(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for TaggedField {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.TaggedField"
            }
        }

        /// Defines additional types related to [TaggedField].
        pub mod tagged_field {
            #[allow(unused_imports)]
            use super::*;

            /// Semantic tag that identifies what a column contains, to determine which
            /// statistical model to use to estimate the reidentifiability of each
            /// value. [required]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Tag {
                /// A column can be tagged with a InfoType to use the relevant public
                /// dataset as a statistical model of population, if available. We
                /// currently support US ZIP codes, region codes, ages and genders.
                /// To programmatically obtain the list of supported InfoTypes, use
                /// ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
                InfoType(std::boxed::Box<crate::model::InfoType>),
                /// A column can be tagged with a custom tag. In this case, the user must
                /// indicate an auxiliary table that contains statistical information on
                /// the possible values of this column (below).
                CustomTag(std::string::String),
                /// If no semantic tag is indicated, we infer the statistical model from
                /// the distribution of values in the input data
                Inferred(std::boxed::Box<wkt::Empty>),
            }
        }

        /// An auxiliary table contains statistical information on the relative
        /// frequency of different quasi-identifiers values. It has one or several
        /// quasi-identifiers columns, and one column that indicates the relative
        /// frequency of each quasi-identifier tuple.
        /// If a tuple is present in the data but not in the auxiliary table, the
        /// corresponding relative frequency is assumed to be zero (and thus, the
        /// tuple is highly reidentifiable).
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AuxiliaryTable {

            /// Required. Auxiliary table location.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub table: std::option::Option<crate::model::BigQueryTable>,

            /// Required. Quasi-identifier columns.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub quasi_ids: std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField>,

            /// Required. The relative frequency column must contain a floating-point
            /// number between 0 and 1 (inclusive). Null values are assumed to be zero.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub relative_frequency: std::option::Option<crate::model::FieldId>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AuxiliaryTable {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [table][crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable::table].
            pub fn set_table<
                T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.table = v.into();
                self
            }

            /// Sets the value of [quasi_ids][crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable::quasi_ids].
            pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField>
            {
                use std::iter::Iterator;
                self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [relative_frequency][crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable::relative_frequency].
            pub fn set_relative_frequency<
                T: std::convert::Into<std::option::Option<crate::model::FieldId>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.relative_frequency = v.into();
                self
            }
        }

        impl wkt::message::Message for AuxiliaryTable {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.AuxiliaryTable"
            }
        }

        /// Defines additional types related to [AuxiliaryTable].
        pub mod auxiliary_table {
            #[allow(unused_imports)]
            use super::*;

            /// A quasi-identifier column has a custom_tag, used to know which column
            /// in the data corresponds to which column in the statistical model.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct QuasiIdField {
                /// Identifies the column.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub field: std::option::Option<crate::model::FieldId>,

                /// A auxiliary field.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub custom_tag: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl QuasiIdField {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [field][crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField::field].
                pub fn set_field<
                    T: std::convert::Into<std::option::Option<crate::model::FieldId>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.field = v.into();
                    self
                }

                /// Sets the value of [custom_tag][crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField::custom_tag].
                pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.custom_tag = v.into();
                    self
                }
            }

            impl wkt::message::Message for QuasiIdField {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.AuxiliaryTable.QuasiIdField"
                }
            }
        }
    }

    /// δ-presence metric, used to estimate how likely it is for an attacker to
    /// figure out that one given individual appears in a de-identified dataset.
    /// Similarly to the k-map metric, we cannot compute δ-presence exactly without
    /// knowing the attack dataset, so we use a statistical model instead.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DeltaPresenceEstimationConfig {
        /// Required. Fields considered to be quasi-identifiers. No two fields can
        /// have the same tag.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub quasi_ids: std::vec::Vec<crate::model::QuasiId>,

        /// ISO 3166-1 alpha-2 region code to use in the statistical modeling.
        /// Set if no column is tagged with a region-specific InfoType (like
        /// US_ZIP_5) or a region code.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub region_code: std::string::String,

        /// Several auxiliary tables can be used in the analysis. Each custom_tag
        /// used to tag a quasi-identifiers field must appear in exactly one
        /// field of one auxiliary table.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub auxiliary_tables: std::vec::Vec<crate::model::StatisticalTable>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DeltaPresenceEstimationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::DeltaPresenceEstimationConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::QuasiId>,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [region_code][crate::model::privacy_metric::DeltaPresenceEstimationConfig::region_code].
        pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region_code = v.into();
            self
        }

        /// Sets the value of [auxiliary_tables][crate::model::privacy_metric::DeltaPresenceEstimationConfig::auxiliary_tables].
        pub fn set_auxiliary_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::StatisticalTable>,
        {
            use std::iter::Iterator;
            self.auxiliary_tables = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DeltaPresenceEstimationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.DeltaPresenceEstimationConfig"
        }
    }

    /// Types of analysis.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// Numerical stats
        NumericalStatsConfig(std::boxed::Box<crate::model::privacy_metric::NumericalStatsConfig>),
        /// Categorical stats
        CategoricalStatsConfig(
            std::boxed::Box<crate::model::privacy_metric::CategoricalStatsConfig>,
        ),
        /// K-anonymity
        KAnonymityConfig(std::boxed::Box<crate::model::privacy_metric::KAnonymityConfig>),
        /// l-diversity
        LDiversityConfig(std::boxed::Box<crate::model::privacy_metric::LDiversityConfig>),
        /// k-map
        KMapEstimationConfig(std::boxed::Box<crate::model::privacy_metric::KMapEstimationConfig>),
        /// delta-presence
        DeltaPresenceEstimationConfig(
            std::boxed::Box<crate::model::privacy_metric::DeltaPresenceEstimationConfig>,
        ),
    }
}

/// Result of a risk analysis operation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeDataSourceRiskDetails {
    /// Privacy metric to compute.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_privacy_metric: std::option::Option<crate::model::PrivacyMetric>,

    /// Input dataset to compute metrics over.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_source_table: std::option::Option<crate::model::BigQueryTable>,

    /// The configuration used for this job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_options: std::option::Option<
        crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions,
    >,

    /// Values associated with this metric.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::analyze_data_source_risk_details::Result>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalyzeDataSourceRiskDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_privacy_metric][crate::model::AnalyzeDataSourceRiskDetails::requested_privacy_metric].
    pub fn set_requested_privacy_metric<
        T: std::convert::Into<std::option::Option<crate::model::PrivacyMetric>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_privacy_metric = v.into();
        self
    }

    /// Sets the value of [requested_source_table][crate::model::AnalyzeDataSourceRiskDetails::requested_source_table].
    pub fn set_requested_source_table<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_source_table = v.into();
        self
    }

    /// Sets the value of [requested_options][crate::model::AnalyzeDataSourceRiskDetails::requested_options].
    pub fn set_requested_options<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_options = v.into();
        self
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<
                std::option::Option<crate::model::analyze_data_source_risk_details::Result>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `NumericalStatsResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn numerical_stats_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::NumericalStatsResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::NumericalStatsResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `NumericalStatsResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_numerical_stats_result<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::analyze_data_source_risk_details::NumericalStatsResult,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::NumericalStatsResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `CategoricalStatsResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn categorical_stats_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::CategoricalStatsResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::CategoricalStatsResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `CategoricalStatsResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_categorical_stats_result<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::analyze_data_source_risk_details::CategoricalStatsResult,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::CategoricalStatsResult(
                v.into(),
            ),
        );
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `KAnonymityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn k_anonymity_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::KAnonymityResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::KAnonymityResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `KAnonymityResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_k_anonymity_result<
        T: std::convert::Into<
                std::boxed::Box<crate::model::analyze_data_source_risk_details::KAnonymityResult>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::KAnonymityResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `LDiversityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn l_diversity_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::LDiversityResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::LDiversityResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `LDiversityResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_l_diversity_result<
        T: std::convert::Into<
                std::boxed::Box<crate::model::analyze_data_source_risk_details::LDiversityResult>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::LDiversityResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `KMapEstimationResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn k_map_estimation_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::KMapEstimationResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::KMapEstimationResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `KMapEstimationResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_k_map_estimation_result<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::analyze_data_source_risk_details::KMapEstimationResult,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::KMapEstimationResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `DeltaPresenceEstimationResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delta_presence_estimation_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<
            crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult,
        >,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::DeltaPresenceEstimationResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `DeltaPresenceEstimationResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_delta_presence_estimation_result<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::DeltaPresenceEstimationResult(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for AnalyzeDataSourceRiskDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails"
    }
}

/// Defines additional types related to [AnalyzeDataSourceRiskDetails].
pub mod analyze_data_source_risk_details {
    #[allow(unused_imports)]
    use super::*;

    /// Result of the numerical stats computation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NumericalStatsResult {
        /// Minimum value appearing in the column.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_value: std::option::Option<crate::model::Value>,

        /// Maximum value appearing in the column.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_value: std::option::Option<crate::model::Value>,

        /// List of 99 values that partition the set of field values into 100 equal
        /// sized buckets.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub quantile_values: std::vec::Vec<crate::model::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NumericalStatsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_value][crate::model::analyze_data_source_risk_details::NumericalStatsResult::min_value].
        pub fn set_min_value<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_value = v.into();
            self
        }

        /// Sets the value of [max_value][crate::model::analyze_data_source_risk_details::NumericalStatsResult::max_value].
        pub fn set_max_value<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_value = v.into();
            self
        }

        /// Sets the value of [quantile_values][crate::model::analyze_data_source_risk_details::NumericalStatsResult::quantile_values].
        pub fn set_quantile_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Value>,
        {
            use std::iter::Iterator;
            self.quantile_values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NumericalStatsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.NumericalStatsResult"
        }
    }

    /// Result of the categorical stats computation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CategoricalStatsResult {

        /// Histogram of value frequencies in the column.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub value_frequency_histogram_buckets: std::vec::Vec<crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CategoricalStatsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value_frequency_histogram_buckets][crate::model::analyze_data_source_risk_details::CategoricalStatsResult::value_frequency_histogram_buckets].
        pub fn set_value_frequency_histogram_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket>
        {
            use std::iter::Iterator;
            self.value_frequency_histogram_buckets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CategoricalStatsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.CategoricalStatsResult"
        }
    }

    /// Defines additional types related to [CategoricalStatsResult].
    pub mod categorical_stats_result {
        #[allow(unused_imports)]
        use super::*;

        /// Histogram of value frequencies in the column.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CategoricalStatsHistogramBucket {
            /// Lower bound on the value frequency of the values in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub value_frequency_lower_bound: i64,

            /// Upper bound on the value frequency of the values in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub value_frequency_upper_bound: i64,

            /// Total number of values in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_size: i64,

            /// Sample of value frequencies in this bucket. The total number of
            /// values returned per bucket is capped at 20.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub bucket_values: std::vec::Vec<crate::model::ValueFrequency>,

            /// Total number of distinct values in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_value_count: i64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CategoricalStatsHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [value_frequency_lower_bound][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::value_frequency_lower_bound].
            pub fn set_value_frequency_lower_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.value_frequency_lower_bound = v.into();
                self
            }

            /// Sets the value of [value_frequency_upper_bound][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::value_frequency_upper_bound].
            pub fn set_value_frequency_upper_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.value_frequency_upper_bound = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::ValueFrequency>,
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }
        }

        impl wkt::message::Message for CategoricalStatsHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.CategoricalStatsResult.CategoricalStatsHistogramBucket"
            }
        }
    }

    /// Result of the k-anonymity computation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct KAnonymityResult {

        /// Histogram of k-anonymity equivalence classes.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub equivalence_class_histogram_buckets: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KAnonymityResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [equivalence_class_histogram_buckets][crate::model::analyze_data_source_risk_details::KAnonymityResult::equivalence_class_histogram_buckets].
        pub fn set_equivalence_class_histogram_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket>
        {
            use std::iter::Iterator;
            self.equivalence_class_histogram_buckets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for KAnonymityResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KAnonymityResult"
        }
    }

    /// Defines additional types related to [KAnonymityResult].
    pub mod k_anonymity_result {
        #[allow(unused_imports)]
        use super::*;

        /// The set of columns' values that share the same ldiversity value
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct KAnonymityEquivalenceClass {
            /// Set of values defining the equivalence class. One value per
            /// quasi-identifier column in the original KAnonymity metric message.
            /// The order is always the same as the original request.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// Size of the equivalence class, for example number of rows with the
            /// above set of values.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub equivalence_class_size: i64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl KAnonymityEquivalenceClass {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [equivalence_class_size][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass::equivalence_class_size].
            pub fn set_equivalence_class_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.equivalence_class_size = v.into();
                self
            }
        }

        impl wkt::message::Message for KAnonymityEquivalenceClass {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityEquivalenceClass"
            }
        }

        /// Histogram of k-anonymity equivalence classes.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct KAnonymityHistogramBucket {

            /// Lower bound on the size of the equivalence classes in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub equivalence_class_size_lower_bound: i64,

            /// Upper bound on the size of the equivalence classes in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub equivalence_class_size_upper_bound: i64,

            /// Total number of equivalence classes in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_size: i64,

            /// Sample of equivalence classes in this bucket. The total number of
            /// classes returned per bucket is capped at 20.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass>,

            /// Total number of distinct equivalence classes in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_value_count: i64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl KAnonymityHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [equivalence_class_size_lower_bound][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::equivalence_class_size_lower_bound].
            pub fn set_equivalence_class_size_lower_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.equivalence_class_size_lower_bound = v.into();
                self
            }

            /// Sets the value of [equivalence_class_size_upper_bound][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::equivalence_class_size_upper_bound].
            pub fn set_equivalence_class_size_upper_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.equivalence_class_size_upper_bound = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }
        }

        impl wkt::message::Message for KAnonymityHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityHistogramBucket"
            }
        }
    }

    /// Result of the l-diversity computation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LDiversityResult {

        /// Histogram of l-diversity equivalence class sensitive value frequencies.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub sensitive_value_frequency_histogram_buckets: std::vec::Vec<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LDiversityResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sensitive_value_frequency_histogram_buckets][crate::model::analyze_data_source_risk_details::LDiversityResult::sensitive_value_frequency_histogram_buckets].
        pub fn set_sensitive_value_frequency_histogram_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket>
        {
            use std::iter::Iterator;
            self.sensitive_value_frequency_histogram_buckets =
                v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for LDiversityResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.LDiversityResult"
        }
    }

    /// Defines additional types related to [LDiversityResult].
    pub mod l_diversity_result {
        #[allow(unused_imports)]
        use super::*;

        /// The set of columns' values that share the same ldiversity value.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct LDiversityEquivalenceClass {
            /// Quasi-identifier values defining the k-anonymity equivalence
            /// class. The order is always the same as the original request.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// Size of the k-anonymity equivalence class.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub equivalence_class_size: i64,

            /// Number of distinct sensitive values in this equivalence class.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub num_distinct_sensitive_values: i64,

            /// Estimated frequencies of top sensitive values.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub top_sensitive_values: std::vec::Vec<crate::model::ValueFrequency>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl LDiversityEquivalenceClass {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [equivalence_class_size][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::equivalence_class_size].
            pub fn set_equivalence_class_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.equivalence_class_size = v.into();
                self
            }

            /// Sets the value of [num_distinct_sensitive_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::num_distinct_sensitive_values].
            pub fn set_num_distinct_sensitive_values<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.num_distinct_sensitive_values = v.into();
                self
            }

            /// Sets the value of [top_sensitive_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::top_sensitive_values].
            pub fn set_top_sensitive_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::ValueFrequency>,
            {
                use std::iter::Iterator;
                self.top_sensitive_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for LDiversityEquivalenceClass {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityEquivalenceClass"
            }
        }

        /// Histogram of l-diversity equivalence class sensitive value frequencies.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct LDiversityHistogramBucket {

            /// Lower bound on the sensitive value frequencies of the equivalence
            /// classes in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub sensitive_value_frequency_lower_bound: i64,

            /// Upper bound on the sensitive value frequencies of the equivalence
            /// classes in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub sensitive_value_frequency_upper_bound: i64,

            /// Total number of equivalence classes in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_size: i64,

            /// Sample of equivalence classes in this bucket. The total number of
            /// classes returned per bucket is capped at 20.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass>,

            /// Total number of distinct equivalence classes in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_value_count: i64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl LDiversityHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [sensitive_value_frequency_lower_bound][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::sensitive_value_frequency_lower_bound].
            pub fn set_sensitive_value_frequency_lower_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.sensitive_value_frequency_lower_bound = v.into();
                self
            }

            /// Sets the value of [sensitive_value_frequency_upper_bound][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::sensitive_value_frequency_upper_bound].
            pub fn set_sensitive_value_frequency_upper_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.sensitive_value_frequency_upper_bound = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }
        }

        impl wkt::message::Message for LDiversityHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityHistogramBucket"
            }
        }
    }

    /// Result of the reidentifiability analysis. Note that these results are an
    /// estimation, not exact values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct KMapEstimationResult {

        /// The intervals [min_anonymity, max_anonymity] do not overlap. If a value
        /// doesn't correspond to any such interval, the associated frequency is
        /// zero. For example, the following records:
        /// {min_anonymity: 1, max_anonymity: 1, frequency: 17}
        /// {min_anonymity: 2, max_anonymity: 3, frequency: 42}
        /// {min_anonymity: 5, max_anonymity: 10, frequency: 99}
        /// mean that there are no record with an estimated anonymity of 4, 5, or
        /// larger than 10.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub k_map_estimation_histogram: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KMapEstimationResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [k_map_estimation_histogram][crate::model::analyze_data_source_risk_details::KMapEstimationResult::k_map_estimation_histogram].
        pub fn set_k_map_estimation_histogram<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket>
        {
            use std::iter::Iterator;
            self.k_map_estimation_histogram = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for KMapEstimationResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KMapEstimationResult"
        }
    }

    /// Defines additional types related to [KMapEstimationResult].
    pub mod k_map_estimation_result {
        #[allow(unused_imports)]
        use super::*;

        /// A tuple of values for the quasi-identifier columns.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct KMapEstimationQuasiIdValues {
            /// The quasi-identifier values.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// The estimated anonymity for these quasi-identifier values.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub estimated_anonymity: i64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl KMapEstimationQuasiIdValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [estimated_anonymity][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues::estimated_anonymity].
            pub fn set_estimated_anonymity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.estimated_anonymity = v.into();
                self
            }
        }

        impl wkt::message::Message for KMapEstimationQuasiIdValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationQuasiIdValues"
            }
        }

        /// A KMapEstimationHistogramBucket message with the following values:
        /// min_anonymity: 3
        /// max_anonymity: 5
        /// frequency: 42
        /// means that there are 42 records whose quasi-identifier values correspond
        /// to 3, 4 or 5 people in the overlying population. An important particular
        /// case is when min_anonymity = max_anonymity = 1: the frequency field then
        /// corresponds to the number of uniquely identifiable records.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct KMapEstimationHistogramBucket {

            /// Always positive.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub min_anonymity: i64,

            /// Always greater than or equal to min_anonymity.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub max_anonymity: i64,

            /// Number of records within these anonymity bounds.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_size: i64,

            /// Sample of quasi-identifier tuple values in this bucket. The total
            /// number of classes returned per bucket is capped at 20.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues>,

            /// Total number of distinct quasi-identifier tuple values in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_value_count: i64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl KMapEstimationHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_anonymity][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::min_anonymity].
            pub fn set_min_anonymity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.min_anonymity = v.into();
                self
            }

            /// Sets the value of [max_anonymity][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::max_anonymity].
            pub fn set_max_anonymity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_anonymity = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }
        }

        impl wkt::message::Message for KMapEstimationHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationHistogramBucket"
            }
        }
    }

    /// Result of the δ-presence computation. Note that these results are an
    /// estimation, not exact values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DeltaPresenceEstimationResult {

        /// The intervals [min_probability, max_probability) do not overlap. If a
        /// value doesn't correspond to any such interval, the associated frequency
        /// is zero. For example, the following records:
        /// {min_probability: 0, max_probability: 0.1, frequency: 17}
        /// {min_probability: 0.2, max_probability: 0.3, frequency: 42}
        /// {min_probability: 0.3, max_probability: 0.4, frequency: 99}
        /// mean that there are no record with an estimated probability in [0.1, 0.2)
        /// nor larger or equal to 0.4.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub delta_presence_estimation_histogram: std::vec::Vec<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DeltaPresenceEstimationResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [delta_presence_estimation_histogram][crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult::delta_presence_estimation_histogram].
        pub fn set_delta_presence_estimation_histogram<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket>
        {
            use std::iter::Iterator;
            self.delta_presence_estimation_histogram = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DeltaPresenceEstimationResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult"
        }
    }

    /// Defines additional types related to [DeltaPresenceEstimationResult].
    pub mod delta_presence_estimation_result {
        #[allow(unused_imports)]
        use super::*;

        /// A tuple of values for the quasi-identifier columns.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DeltaPresenceEstimationQuasiIdValues {
            /// The quasi-identifier values.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// The estimated probability that a given individual sharing these
            /// quasi-identifier values is in the dataset. This value, typically
            /// called δ, is the ratio between the number of records in the dataset
            /// with these quasi-identifier values, and the total number of individuals
            /// (inside *and* outside the dataset) with these quasi-identifier values.
            /// For example, if there are 15 individuals in the dataset who share the
            /// same quasi-identifier values, and an estimated 100 people in the entire
            /// population with these values, then δ is 0.15.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::F64")]
            pub estimated_probability: f64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DeltaPresenceEstimationQuasiIdValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [estimated_probability][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues::estimated_probability].
            pub fn set_estimated_probability<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.estimated_probability = v.into();
                self
            }
        }

        impl wkt::message::Message for DeltaPresenceEstimationQuasiIdValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationQuasiIdValues"
            }
        }

        /// A DeltaPresenceEstimationHistogramBucket message with the following
        /// values:
        /// min_probability: 0.1
        /// max_probability: 0.2
        /// frequency: 42
        /// means that there are 42 records for which δ is in [0.1, 0.2). An
        /// important particular case is when min_probability = max_probability = 1:
        /// then, every individual who shares this quasi-identifier combination is in
        /// the dataset.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DeltaPresenceEstimationHistogramBucket {

            /// Between 0 and 1.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::F64")]
            pub min_probability: f64,

            /// Always greater than or equal to min_probability.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::F64")]
            pub max_probability: f64,

            /// Number of records within these probability bounds.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_size: i64,

            /// Sample of quasi-identifier tuple values in this bucket. The total
            /// number of classes returned per bucket is capped at 20.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues>,

            /// Total number of distinct quasi-identifier tuple values in this bucket.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_value_count: i64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DeltaPresenceEstimationHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_probability][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::min_probability].
            pub fn set_min_probability<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.min_probability = v.into();
                self
            }

            /// Sets the value of [max_probability][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::max_probability].
            pub fn set_max_probability<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.max_probability = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }
        }

        impl wkt::message::Message for DeltaPresenceEstimationHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationHistogramBucket"
            }
        }
    }

    /// Risk analysis options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RequestedRiskAnalysisOptions {
        /// The job config for the risk job.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub job_config: std::option::Option<crate::model::RiskAnalysisJobConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RequestedRiskAnalysisOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [job_config][crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions::job_config].
        pub fn set_job_config<
            T: std::convert::Into<std::option::Option<crate::model::RiskAnalysisJobConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.job_config = v.into();
            self
        }
    }

    impl wkt::message::Message for RequestedRiskAnalysisOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.RequestedRiskAnalysisOptions"
        }
    }

    /// Values associated with this metric.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// Numerical stats result
        NumericalStatsResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::NumericalStatsResult>,
        ),
        /// Categorical stats result
        CategoricalStatsResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::CategoricalStatsResult>,
        ),
        /// K-anonymity result
        KAnonymityResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::KAnonymityResult>,
        ),
        /// L-divesity result
        LDiversityResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::LDiversityResult>,
        ),
        /// K-map result
        KMapEstimationResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::KMapEstimationResult>,
        ),
        /// Delta-presence result
        DeltaPresenceEstimationResult(
            std::boxed::Box<
                crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult,
            >,
        ),
    }
}

/// A value of a field, including its frequency.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValueFrequency {
    /// A value contained in the field in question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::Value>,

    /// How many times the value is contained in the field.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValueFrequency {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::ValueFrequency::value].
    pub fn set_value<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [count][crate::model::ValueFrequency::count].
    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.count = v.into();
        self
    }
}

impl wkt::message::Message for ValueFrequency {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ValueFrequency"
    }
}

/// Set of primitive values supported by the system.
/// Note that for the purposes of inspection or transformation, the number
/// of bytes considered to comprise a 'Value' is based on its representation
/// as a UTF-8 encoded string. For example, if 'integer_value' is set to
/// 123456789, the number of bytes would be counted as 9, even though an
/// int64 only holds up to 8 bytes of data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Value {
    /// Value types
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::value::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Value {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Value::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::value::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `IntegerValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn integer_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::IntegerValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `IntegerValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_integer_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::IntegerValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `FloatValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn float_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::FloatValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `FloatValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_float_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::FloatValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::StringValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `BooleanValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn boolean_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::BooleanValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `BooleanValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_boolean_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::BooleanValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `TimestampValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timestamp_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::TimestampValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `TimestampValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_timestamp_value<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::value::Type::TimestampValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `TimeValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_value(&self) -> std::option::Option<&std::boxed::Box<gtype::model::TimeOfDay>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::TimeValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `TimeValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_time_value<T: std::convert::Into<std::boxed::Box<gtype::model::TimeOfDay>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::TimeValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `DateValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn date_value(&self) -> std::option::Option<&std::boxed::Box<gtype::model::Date>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::DateValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `DateValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_date_value<T: std::convert::Into<std::boxed::Box<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::DateValue(v.into()));
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `DayOfWeekValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn day_of_week_value(&self) -> std::option::Option<&gtype::model::DayOfWeek> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::DayOfWeekValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `DayOfWeekValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_day_of_week_value<T: std::convert::Into<gtype::model::DayOfWeek>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::value::Type::DayOfWeekValue(v.into()));
        self
    }
}

impl wkt::message::Message for Value {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Value"
    }
}

/// Defines additional types related to [Value].
pub mod value {
    #[allow(unused_imports)]
    use super::*;

    /// Value types
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// integer
        IntegerValue(i64),
        /// float
        FloatValue(f64),
        /// string
        StringValue(std::string::String),
        /// boolean
        BooleanValue(bool),
        /// timestamp
        TimestampValue(std::boxed::Box<wkt::Timestamp>),
        /// time of day
        TimeValue(std::boxed::Box<gtype::model::TimeOfDay>),
        /// date
        DateValue(std::boxed::Box<gtype::model::Date>),
        /// day of week
        DayOfWeekValue(gtype::model::DayOfWeek),
    }
}

/// Message for infoType-dependent details parsed from quote.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuoteInfo {
    /// Object representation of the quote.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub parsed_quote: std::option::Option<crate::model::quote_info::ParsedQuote>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuoteInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parsed_quote][crate::model::QuoteInfo::parsed_quote].
    ///
    /// Note that all the setters affecting `parsed_quote` are mutually
    /// exclusive.
    pub fn set_parsed_quote<
        T: std::convert::Into<std::option::Option<crate::model::quote_info::ParsedQuote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parsed_quote = v.into();
        self
    }

    /// The value of [parsed_quote][crate::model::QuoteInfo::parsed_quote]
    /// if it holds a `DateTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn date_time(&self) -> std::option::Option<&std::boxed::Box<crate::model::DateTime>> {
        #[allow(unreachable_patterns)]
        self.parsed_quote.as_ref().and_then(|v| match v {
            crate::model::quote_info::ParsedQuote::DateTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [parsed_quote][crate::model::QuoteInfo::parsed_quote]
    /// to hold a `DateTime`.
    ///
    /// Note that all the setters affecting `parsed_quote` are
    /// mutually exclusive.
    pub fn set_date_time<T: std::convert::Into<std::boxed::Box<crate::model::DateTime>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parsed_quote =
            std::option::Option::Some(crate::model::quote_info::ParsedQuote::DateTime(v.into()));
        self
    }
}

impl wkt::message::Message for QuoteInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.QuoteInfo"
    }
}

/// Defines additional types related to [QuoteInfo].
pub mod quote_info {
    #[allow(unused_imports)]
    use super::*;

    /// Object representation of the quote.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ParsedQuote {
        /// The date time indicated by the quote.
        DateTime(std::boxed::Box<crate::model::DateTime>),
    }
}

/// Message for a date time object.
/// e.g. 2018-01-01, 5th August.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DateTime {
    /// One or more of the following must be set.
    /// Must be a valid date or time value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub date: std::option::Option<gtype::model::Date>,

    /// Day of week
    pub day_of_week: gtype::model::DayOfWeek,

    /// Time of day
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time: std::option::Option<gtype::model::TimeOfDay>,

    /// Time zone
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_zone: std::option::Option<crate::model::date_time::TimeZone>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DateTime {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [date][crate::model::DateTime::date].
    pub fn set_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.date = v.into();
        self
    }

    /// Sets the value of [day_of_week][crate::model::DateTime::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }

    /// Sets the value of [time][crate::model::DateTime::time].
    pub fn set_time<T: std::convert::Into<std::option::Option<gtype::model::TimeOfDay>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::DateTime::time_zone].
    pub fn set_time_zone<
        T: std::convert::Into<std::option::Option<crate::model::date_time::TimeZone>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_zone = v.into();
        self
    }
}

impl wkt::message::Message for DateTime {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DateTime"
    }
}

/// Defines additional types related to [DateTime].
pub mod date_time {
    #[allow(unused_imports)]
    use super::*;

    /// Time zone of the date time object.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TimeZone {
        /// Set only if the offset can be determined. Positive for time ahead of UTC.
        /// E.g. For "UTC-9", this value is -540.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub offset_minutes: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeZone {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [offset_minutes][crate::model::date_time::TimeZone::offset_minutes].
        pub fn set_offset_minutes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.offset_minutes = v.into();
            self
        }
    }

    impl wkt::message::Message for TimeZone {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DateTime.TimeZone"
        }
    }
}

/// The configuration that controls how the data will change.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyConfig {
    /// Mode for handling transformation errors. If left unspecified, the default
    /// mode is `TransformationErrorHandling.ThrowError`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transformation_error_handling:
        std::option::Option<crate::model::TransformationErrorHandling>,

    /// Type of transformation
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub transformation: std::option::Option<crate::model::deidentify_config::Transformation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformation_error_handling][crate::model::DeidentifyConfig::transformation_error_handling].
    pub fn set_transformation_error_handling<
        T: std::convert::Into<std::option::Option<crate::model::TransformationErrorHandling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation_error_handling = v.into();
        self
    }

    /// Sets the value of [transformation][crate::model::DeidentifyConfig::transformation].
    ///
    /// Note that all the setters affecting `transformation` are mutually
    /// exclusive.
    pub fn set_transformation<
        T: std::convert::Into<std::option::Option<crate::model::deidentify_config::Transformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = v.into();
        self
    }

    /// The value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// if it holds a `InfoTypeTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn info_type_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InfoTypeTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::deidentify_config::Transformation::InfoTypeTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// to hold a `InfoTypeTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_info_type_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::InfoTypeTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::deidentify_config::Transformation::InfoTypeTransformations(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// if it holds a `RecordTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn record_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecordTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::deidentify_config::Transformation::RecordTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// to hold a `RecordTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_record_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::RecordTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::deidentify_config::Transformation::RecordTransformations(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// if it holds a `ImageTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImageTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::deidentify_config::Transformation::ImageTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// to hold a `ImageTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_image_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::ImageTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::deidentify_config::Transformation::ImageTransformations(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DeidentifyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyConfig"
    }
}

/// Defines additional types related to [DeidentifyConfig].
pub mod deidentify_config {
    #[allow(unused_imports)]
    use super::*;

    /// Type of transformation
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Transformation {
        /// Treat the dataset as free-form text and apply the same free text
        /// transformation everywhere.
        InfoTypeTransformations(std::boxed::Box<crate::model::InfoTypeTransformations>),
        /// Treat the dataset as structured. Transformations can be applied to
        /// specific locations within structured datasets, such as transforming
        /// a column within a table.
        RecordTransformations(std::boxed::Box<crate::model::RecordTransformations>),
        /// Treat the dataset as an image and redact.
        ImageTransformations(std::boxed::Box<crate::model::ImageTransformations>),
    }
}

/// A type of transformation that is applied over images.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImageTransformations {
    /// List of transforms to make.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub transforms: std::vec::Vec<crate::model::image_transformations::ImageTransformation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageTransformations {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transforms][crate::model::ImageTransformations::transforms].
    pub fn set_transforms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::image_transformations::ImageTransformation>,
    {
        use std::iter::Iterator;
        self.transforms = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImageTransformations {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations"
    }
}

/// Defines additional types related to [ImageTransformations].
pub mod image_transformations {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for determining how redaction of images should occur.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImageTransformation {
        /// The color to use when redacting content from an image. If not
        /// specified, the default is black.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub redaction_color: std::option::Option<crate::model::Color>,

        /// Part of the image to transform.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub target:
            std::option::Option<crate::model::image_transformations::image_transformation::Target>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImageTransformation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [redaction_color][crate::model::image_transformations::ImageTransformation::redaction_color].
        pub fn set_redaction_color<
            T: std::convert::Into<std::option::Option<crate::model::Color>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.redaction_color = v.into();
            self
        }

        /// Sets the value of [target][crate::model::image_transformations::ImageTransformation::target].
        ///
        /// Note that all the setters affecting `target` are mutually
        /// exclusive.
        pub fn set_target<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::image_transformations::image_transformation::Target,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = v.into();
            self
        }

        /// The value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// if it holds a `SelectedInfoTypes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn selected_info_types(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::image_transformations::image_transformation::SelectedInfoTypes,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::image_transformations::image_transformation::Target::SelectedInfoTypes(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// to hold a `SelectedInfoTypes`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_selected_info_types<T: std::convert::Into<std::boxed::Box<crate::model::image_transformations::image_transformation::SelectedInfoTypes>>>(mut self, v: T) -> Self{
            self.target = std::option::Option::Some(
                crate::model::image_transformations::image_transformation::Target::SelectedInfoTypes(
                    v.into()
                )
            );
            self
        }

        /// The value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// if it holds a `AllInfoTypes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn all_info_types(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::image_transformations::image_transformation::AllInfoTypes,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::image_transformations::image_transformation::Target::AllInfoTypes(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// to hold a `AllInfoTypes`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_all_info_types<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::image_transformations::image_transformation::AllInfoTypes,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = std::option::Option::Some(
                crate::model::image_transformations::image_transformation::Target::AllInfoTypes(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// if it holds a `AllText`, `None` if the field is not set or
        /// holds a different branch.
        pub fn all_text(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::image_transformations::image_transformation::AllText>,
        > {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::image_transformations::image_transformation::Target::AllText(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// to hold a `AllText`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_all_text<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::image_transformations::image_transformation::AllText,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = std::option::Option::Some(
                crate::model::image_transformations::image_transformation::Target::AllText(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for ImageTransformation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation"
        }
    }

    /// Defines additional types related to [ImageTransformation].
    pub mod image_transformation {
        #[allow(unused_imports)]
        use super::*;

        /// Apply transformation to the selected info_types.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SelectedInfoTypes {
            /// Required. InfoTypes to apply the transformation to. Required. Provided
            /// InfoType must be unique within the ImageTransformations message.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub info_types: std::vec::Vec<crate::model::InfoType>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SelectedInfoTypes {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [info_types][crate::model::image_transformations::image_transformation::SelectedInfoTypes::info_types].
            pub fn set_info_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::InfoType>,
            {
                use std::iter::Iterator;
                self.info_types = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for SelectedInfoTypes {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation.SelectedInfoTypes"
            }
        }

        /// Apply transformation to all findings.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AllInfoTypes {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AllInfoTypes {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for AllInfoTypes {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation.AllInfoTypes"
            }
        }

        /// Apply to all text.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AllText {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AllText {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for AllText {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation.AllText"
            }
        }

        /// Part of the image to transform.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Target {
            /// Apply transformation to the selected info_types.
            SelectedInfoTypes(
                std::boxed::Box<
                    crate::model::image_transformations::image_transformation::SelectedInfoTypes,
                >,
            ),
            /// Apply transformation to all findings not specified in other
            /// ImageTransformation's selected_info_types. Only one instance is allowed
            /// within the ImageTransformations message.
            AllInfoTypes(
                std::boxed::Box<
                    crate::model::image_transformations::image_transformation::AllInfoTypes,
                >,
            ),
            /// Apply transformation to all text that doesn't match an infoType. Only
            /// one instance is allowed within the ImageTransformations message.
            AllText(
                std::boxed::Box<crate::model::image_transformations::image_transformation::AllText>,
            ),
        }
    }
}

/// How to handle transformation errors during de-identification. A
/// transformation error occurs when the requested transformation is incompatible
/// with the data. For example, trying to de-identify an IP address using a
/// `DateShift` transformation would result in a transformation error, since date
/// info cannot be extracted from an IP address.
/// Information about any incompatible transformations, and how they were
/// handled, is returned in the response as part of the
/// `TransformationOverviews`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationErrorHandling {
    /// How transformation errors should be handled.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub mode: std::option::Option<crate::model::transformation_error_handling::Mode>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationErrorHandling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::TransformationErrorHandling::mode].
    ///
    /// Note that all the setters affecting `mode` are mutually
    /// exclusive.
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::transformation_error_handling::Mode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::TransformationErrorHandling::mode]
    /// if it holds a `ThrowError`, `None` if the field is not set or
    /// holds a different branch.
    pub fn throw_error(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::transformation_error_handling::ThrowError>,
    > {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::transformation_error_handling::Mode::ThrowError(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::TransformationErrorHandling::mode]
    /// to hold a `ThrowError`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_throw_error<
        T: std::convert::Into<
                std::boxed::Box<crate::model::transformation_error_handling::ThrowError>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::transformation_error_handling::Mode::ThrowError(v.into()),
        );
        self
    }

    /// The value of [mode][crate::model::TransformationErrorHandling::mode]
    /// if it holds a `LeaveUntransformed`, `None` if the field is not set or
    /// holds a different branch.
    pub fn leave_untransformed(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::transformation_error_handling::LeaveUntransformed>,
    > {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::transformation_error_handling::Mode::LeaveUntransformed(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::TransformationErrorHandling::mode]
    /// to hold a `LeaveUntransformed`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_leave_untransformed<
        T: std::convert::Into<
                std::boxed::Box<crate::model::transformation_error_handling::LeaveUntransformed>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::transformation_error_handling::Mode::LeaveUntransformed(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TransformationErrorHandling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationErrorHandling"
    }
}

/// Defines additional types related to [TransformationErrorHandling].
pub mod transformation_error_handling {
    #[allow(unused_imports)]
    use super::*;

    /// Throw an error and fail the request when a transformation error occurs.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThrowError {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ThrowError {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for ThrowError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.TransformationErrorHandling.ThrowError"
        }
    }

    /// Skips the data without modifying it if the requested transformation would
    /// cause an error. For example, if a `DateShift` transformation were applied
    /// an an IP address, this mode would leave the IP address unchanged in the
    /// response.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LeaveUntransformed {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LeaveUntransformed {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for LeaveUntransformed {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.TransformationErrorHandling.LeaveUntransformed"
        }
    }

    /// How transformation errors should be handled.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Mode {
        /// Throw an error
        ThrowError(std::boxed::Box<crate::model::transformation_error_handling::ThrowError>),
        /// Ignore errors
        LeaveUntransformed(
            std::boxed::Box<crate::model::transformation_error_handling::LeaveUntransformed>,
        ),
    }
}

/// A rule for transforming a value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrimitiveTransformation {
    /// Type of transformation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub transformation: std::option::Option<crate::model::primitive_transformation::Transformation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrimitiveTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation].
    ///
    /// Note that all the setters affecting `transformation` are mutually
    /// exclusive.
    pub fn set_transformation<
        T: std::convert::Into<
                std::option::Option<crate::model::primitive_transformation::Transformation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = v.into();
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `ReplaceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn replace_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplaceValueConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::ReplaceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `ReplaceConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_replace_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplaceValueConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::ReplaceConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `RedactConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redact_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RedactConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::RedactConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `RedactConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_redact_config<T: std::convert::Into<std::boxed::Box<crate::model::RedactConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::RedactConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CharacterMaskConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn character_mask_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CharacterMaskConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CharacterMaskConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CharacterMaskConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_character_mask_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CharacterMaskConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CharacterMaskConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CryptoReplaceFfxFpeConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn crypto_replace_ffx_fpe_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CryptoReplaceFfxFpeConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CryptoReplaceFfxFpeConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CryptoReplaceFfxFpeConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_crypto_replace_ffx_fpe_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CryptoReplaceFfxFpeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CryptoReplaceFfxFpeConfig(
                v.into(),
            ),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `FixedSizeBucketingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fixed_size_bucketing_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FixedSizeBucketingConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::FixedSizeBucketingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `FixedSizeBucketingConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_fixed_size_bucketing_config<
        T: std::convert::Into<std::boxed::Box<crate::model::FixedSizeBucketingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::FixedSizeBucketingConfig(
                v.into(),
            ),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `BucketingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bucketing_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BucketingConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::BucketingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `BucketingConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_bucketing_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BucketingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::BucketingConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `ReplaceWithInfoTypeConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn replace_with_info_type_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplaceWithInfoTypeConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::ReplaceWithInfoTypeConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `ReplaceWithInfoTypeConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_replace_with_info_type_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplaceWithInfoTypeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::ReplaceWithInfoTypeConfig(
                v.into(),
            ),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `TimePartConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_part_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimePartConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::TimePartConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `TimePartConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_time_part_config<
        T: std::convert::Into<std::boxed::Box<crate::model::TimePartConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::TimePartConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CryptoHashConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn crypto_hash_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CryptoHashConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CryptoHashConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CryptoHashConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_crypto_hash_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CryptoHashConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CryptoHashConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `DateShiftConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn date_shift_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DateShiftConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::DateShiftConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `DateShiftConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_date_shift_config<
        T: std::convert::Into<std::boxed::Box<crate::model::DateShiftConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::DateShiftConfig(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CryptoDeterministicConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn crypto_deterministic_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CryptoDeterministicConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CryptoDeterministicConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CryptoDeterministicConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_crypto_deterministic_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CryptoDeterministicConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CryptoDeterministicConfig(
                v.into(),
            ),
        );
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `ReplaceDictionaryConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn replace_dictionary_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplaceDictionaryConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::ReplaceDictionaryConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `ReplaceDictionaryConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_replace_dictionary_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplaceDictionaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::ReplaceDictionaryConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for PrimitiveTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.PrimitiveTransformation"
    }
}

/// Defines additional types related to [PrimitiveTransformation].
pub mod primitive_transformation {
    #[allow(unused_imports)]
    use super::*;

    /// Type of transformation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Transformation {
        /// Replace with a specified value.
        ReplaceConfig(std::boxed::Box<crate::model::ReplaceValueConfig>),
        /// Redact
        RedactConfig(std::boxed::Box<crate::model::RedactConfig>),
        /// Mask
        CharacterMaskConfig(std::boxed::Box<crate::model::CharacterMaskConfig>),
        /// Ffx-Fpe. Strongly discouraged, consider using CryptoDeterministicConfig
        /// instead. Fpe is computationally expensive incurring latency costs.
        CryptoReplaceFfxFpeConfig(std::boxed::Box<crate::model::CryptoReplaceFfxFpeConfig>),
        /// Fixed size bucketing
        FixedSizeBucketingConfig(std::boxed::Box<crate::model::FixedSizeBucketingConfig>),
        /// Bucketing
        BucketingConfig(std::boxed::Box<crate::model::BucketingConfig>),
        /// Replace with infotype
        ReplaceWithInfoTypeConfig(std::boxed::Box<crate::model::ReplaceWithInfoTypeConfig>),
        /// Time extraction
        TimePartConfig(std::boxed::Box<crate::model::TimePartConfig>),
        /// Crypto
        CryptoHashConfig(std::boxed::Box<crate::model::CryptoHashConfig>),
        /// Date Shift
        DateShiftConfig(std::boxed::Box<crate::model::DateShiftConfig>),
        /// Deterministic Crypto
        CryptoDeterministicConfig(std::boxed::Box<crate::model::CryptoDeterministicConfig>),
        /// Replace with a value randomly drawn (with replacement) from a dictionary.
        ReplaceDictionaryConfig(std::boxed::Box<crate::model::ReplaceDictionaryConfig>),
    }
}

/// For use with `Date`, `Timestamp`, and `TimeOfDay`, extract or preserve a
/// portion of the value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimePartConfig {
    /// The part of the time to keep.
    pub part_to_extract: crate::model::time_part_config::TimePart,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimePartConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [part_to_extract][crate::model::TimePartConfig::part_to_extract].
    pub fn set_part_to_extract<T: std::convert::Into<crate::model::time_part_config::TimePart>>(
        mut self,
        v: T,
    ) -> Self {
        self.part_to_extract = v.into();
        self
    }
}

impl wkt::message::Message for TimePartConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TimePartConfig"
    }
}

/// Defines additional types related to [TimePartConfig].
pub mod time_part_config {
    #[allow(unused_imports)]
    use super::*;

    /// Components that make up time.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimePart {
        /// Unused
        Unspecified,
        /// [0-9999]
        Year,
        /// [1-12]
        Month,
        /// [1-31]
        DayOfMonth,
        /// [1-7]
        DayOfWeek,
        /// [1-53]
        WeekOfYear,
        /// [0-23]
        HourOfDay,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimePart::value] or
        /// [TimePart::name].
        UnknownValue(time_part::UnknownValue),
    }

    #[doc(hidden)]
    pub mod time_part {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimePart {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Year => std::option::Option::Some(1),
                Self::Month => std::option::Option::Some(2),
                Self::DayOfMonth => std::option::Option::Some(3),
                Self::DayOfWeek => std::option::Option::Some(4),
                Self::WeekOfYear => std::option::Option::Some(5),
                Self::HourOfDay => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIME_PART_UNSPECIFIED"),
                Self::Year => std::option::Option::Some("YEAR"),
                Self::Month => std::option::Option::Some("MONTH"),
                Self::DayOfMonth => std::option::Option::Some("DAY_OF_MONTH"),
                Self::DayOfWeek => std::option::Option::Some("DAY_OF_WEEK"),
                Self::WeekOfYear => std::option::Option::Some("WEEK_OF_YEAR"),
                Self::HourOfDay => std::option::Option::Some("HOUR_OF_DAY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimePart {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimePart {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimePart {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Year,
                2 => Self::Month,
                3 => Self::DayOfMonth,
                4 => Self::DayOfWeek,
                5 => Self::WeekOfYear,
                6 => Self::HourOfDay,
                _ => Self::UnknownValue(time_part::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimePart {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIME_PART_UNSPECIFIED" => Self::Unspecified,
                "YEAR" => Self::Year,
                "MONTH" => Self::Month,
                "DAY_OF_MONTH" => Self::DayOfMonth,
                "DAY_OF_WEEK" => Self::DayOfWeek,
                "WEEK_OF_YEAR" => Self::WeekOfYear,
                "HOUR_OF_DAY" => Self::HourOfDay,
                _ => Self::UnknownValue(time_part::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimePart {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Year => serializer.serialize_i32(1),
                Self::Month => serializer.serialize_i32(2),
                Self::DayOfMonth => serializer.serialize_i32(3),
                Self::DayOfWeek => serializer.serialize_i32(4),
                Self::WeekOfYear => serializer.serialize_i32(5),
                Self::HourOfDay => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimePart {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimePart>::new(
                ".google.privacy.dlp.v2.TimePartConfig.TimePart",
            ))
        }
    }
}

/// Pseudonymization method that generates surrogates via cryptographic hashing.
/// Uses SHA-256.
/// The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output
/// (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See <https://cloud.google.com/sensitive-data-protection/docs/pseudonymization>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoHashConfig {
    /// The key used by the hash function.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoHashConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key][crate::model::CryptoHashConfig::crypto_key].
    pub fn set_crypto_key<T: std::convert::Into<std::option::Option<crate::model::CryptoKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key = v.into();
        self
    }
}

impl wkt::message::Message for CryptoHashConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoHashConfig"
    }
}

/// Pseudonymization method that generates deterministic encryption for the given
/// input. Outputs a base64 encoded representation of the encrypted output.
/// Uses AES-SIV based on the RFC <https://tools.ietf.org/html/rfc5297>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoDeterministicConfig {
    /// The key used by the encryption function. For deterministic encryption
    /// using AES-SIV, the provided key is internally expanded to 64 bytes prior to
    /// use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    /// The custom info type to annotate the surrogate with.
    /// This annotation will be applied to the surrogate by prefixing it with
    /// the name of the custom info type followed by the number of
    /// characters comprising the surrogate. The following scheme defines the
    /// format: {info type name}({surrogate character count}):{surrogate}
    ///
    /// For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and
    /// the surrogate is 'abc', the full replacement value
    /// will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    ///
    /// This annotation identifies the surrogate when inspecting content using the
    /// custom info type 'Surrogate'. This facilitates reversal of the
    /// surrogate when it occurs in free text.
    ///
    /// Note: For record transformations where the entire cell in a table is being
    /// transformed, surrogates are not mandatory. Surrogates are used to denote
    /// the location of the token and are necessary for re-identification in free
    /// form text.
    ///
    /// In order for inspection to work properly, the name of this info type must
    /// not occur naturally anywhere in your data; otherwise, inspection may either
    ///
    /// - reverse a surrogate that does not correspond to an actual identifier
    /// - be unable to parse the surrogate and result in an error
    ///
    /// Therefore, choose your custom info type name carefully after considering
    /// what your data looks like. One way to select a name that has a high chance
    /// of yielding reliable detection is to include one or more unicode characters
    /// that are highly improbable to exist in your data.
    /// For example, assuming your data is entered from a regular ASCII keyboard,
    /// the symbol with the hex code point 29DD might be used like so:
    /// ⧝MY_TOKEN_TYPE.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub surrogate_info_type: std::option::Option<crate::model::InfoType>,

    /// A context may be used for higher security and maintaining
    /// referential integrity such that the same identifier in two different
    /// contexts will be given a distinct surrogate. The context is appended to
    /// plaintext value being encrypted. On decryption the provided context is
    /// validated against the value used during encryption. If a context was
    /// provided during encryption, same context must be provided during decryption
    /// as well.
    ///
    /// If the context is not set, plaintext would be used as is for encryption.
    /// If the context is set but:
    ///
    /// . there is no record present when transforming a given value or
    /// . the field is not present when transforming a given value,
    ///
    /// plaintext would be used as is for encryption.
    ///
    /// Note that case (1) is expected when an `InfoTypeTransformation` is
    /// applied to both structured and unstructured `ContentItem`s.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::FieldId>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoDeterministicConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key][crate::model::CryptoDeterministicConfig::crypto_key].
    pub fn set_crypto_key<T: std::convert::Into<std::option::Option<crate::model::CryptoKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key = v.into();
        self
    }

    /// Sets the value of [surrogate_info_type][crate::model::CryptoDeterministicConfig::surrogate_info_type].
    pub fn set_surrogate_info_type<
        T: std::convert::Into<std::option::Option<crate::model::InfoType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.surrogate_info_type = v.into();
        self
    }

    /// Sets the value of [context][crate::model::CryptoDeterministicConfig::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }
}

impl wkt::message::Message for CryptoDeterministicConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoDeterministicConfig"
    }
}

/// Replace each input value with a given `Value`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplaceValueConfig {
    /// Value to replace it with.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub new_value: std::option::Option<crate::model::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplaceValueConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_value][crate::model::ReplaceValueConfig::new_value].
    pub fn set_new_value<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_value = v.into();
        self
    }
}

impl wkt::message::Message for ReplaceValueConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReplaceValueConfig"
    }
}

/// Replace each input value with a value randomly selected from the dictionary.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplaceDictionaryConfig {
    /// Type of dictionary.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::replace_dictionary_config::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplaceDictionaryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::ReplaceDictionaryConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::replace_dictionary_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::ReplaceDictionaryConfig::r#type]
    /// if it holds a `WordList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn word_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::replace_dictionary_config::Type::WordList(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ReplaceDictionaryConfig::r#type]
    /// to hold a `WordList`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_word_list<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::replace_dictionary_config::Type::WordList(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ReplaceDictionaryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReplaceDictionaryConfig"
    }
}

/// Defines additional types related to [ReplaceDictionaryConfig].
pub mod replace_dictionary_config {
    #[allow(unused_imports)]
    use super::*;

    /// Type of dictionary.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// A list of words to select from for random replacement. The
        /// [limits](https://cloud.google.com/sensitive-data-protection/limits) page
        /// contains details about the size limits of dictionaries.
        WordList(std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>),
    }
}

/// Replace each matching finding with the name of the info_type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplaceWithInfoTypeConfig {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplaceWithInfoTypeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ReplaceWithInfoTypeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReplaceWithInfoTypeConfig"
    }
}

/// Redact a given value. For example, if used with an `InfoTypeTransformation`
/// transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the
/// output would be 'My phone number is '.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RedactConfig {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedactConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RedactConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RedactConfig"
    }
}

/// Characters to skip when doing deidentification of a value. These will be left
/// alone and skipped.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CharsToIgnore {
    /// Type of characters to skip.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub characters: std::option::Option<crate::model::chars_to_ignore::Characters>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CharsToIgnore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [characters][crate::model::CharsToIgnore::characters].
    ///
    /// Note that all the setters affecting `characters` are mutually
    /// exclusive.
    pub fn set_characters<
        T: std::convert::Into<std::option::Option<crate::model::chars_to_ignore::Characters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.characters = v.into();
        self
    }

    /// The value of [characters][crate::model::CharsToIgnore::characters]
    /// if it holds a `CharactersToSkip`, `None` if the field is not set or
    /// holds a different branch.
    pub fn characters_to_skip(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.characters.as_ref().and_then(|v| match v {
            crate::model::chars_to_ignore::Characters::CharactersToSkip(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [characters][crate::model::CharsToIgnore::characters]
    /// to hold a `CharactersToSkip`.
    ///
    /// Note that all the setters affecting `characters` are
    /// mutually exclusive.
    pub fn set_characters_to_skip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.characters = std::option::Option::Some(
            crate::model::chars_to_ignore::Characters::CharactersToSkip(v.into()),
        );
        self
    }

    /// The value of [characters][crate::model::CharsToIgnore::characters]
    /// if it holds a `CommonCharactersToIgnore`, `None` if the field is not set or
    /// holds a different branch.
    pub fn common_characters_to_ignore(
        &self,
    ) -> std::option::Option<&crate::model::chars_to_ignore::CommonCharsToIgnore> {
        #[allow(unreachable_patterns)]
        self.characters.as_ref().and_then(|v| match v {
            crate::model::chars_to_ignore::Characters::CommonCharactersToIgnore(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [characters][crate::model::CharsToIgnore::characters]
    /// to hold a `CommonCharactersToIgnore`.
    ///
    /// Note that all the setters affecting `characters` are
    /// mutually exclusive.
    pub fn set_common_characters_to_ignore<
        T: std::convert::Into<crate::model::chars_to_ignore::CommonCharsToIgnore>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.characters = std::option::Option::Some(
            crate::model::chars_to_ignore::Characters::CommonCharactersToIgnore(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CharsToIgnore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CharsToIgnore"
    }
}

/// Defines additional types related to [CharsToIgnore].
pub mod chars_to_ignore {
    #[allow(unused_imports)]
    use super::*;

    /// Convenience enum for indicating common characters to not transform.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CommonCharsToIgnore {
        /// Unused.
        Unspecified,
        /// 0-9
        Numeric,
        /// A-Z
        AlphaUpperCase,
        /// a-z
        AlphaLowerCase,
        /// US Punctuation, one of !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
        Punctuation,
        /// Whitespace character, one of [ \t\n\x0B\f\r]
        Whitespace,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CommonCharsToIgnore::value] or
        /// [CommonCharsToIgnore::name].
        UnknownValue(common_chars_to_ignore::UnknownValue),
    }

    #[doc(hidden)]
    pub mod common_chars_to_ignore {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CommonCharsToIgnore {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Numeric => std::option::Option::Some(1),
                Self::AlphaUpperCase => std::option::Option::Some(2),
                Self::AlphaLowerCase => std::option::Option::Some(3),
                Self::Punctuation => std::option::Option::Some(4),
                Self::Whitespace => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("COMMON_CHARS_TO_IGNORE_UNSPECIFIED")
                }
                Self::Numeric => std::option::Option::Some("NUMERIC"),
                Self::AlphaUpperCase => std::option::Option::Some("ALPHA_UPPER_CASE"),
                Self::AlphaLowerCase => std::option::Option::Some("ALPHA_LOWER_CASE"),
                Self::Punctuation => std::option::Option::Some("PUNCTUATION"),
                Self::Whitespace => std::option::Option::Some("WHITESPACE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CommonCharsToIgnore {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CommonCharsToIgnore {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CommonCharsToIgnore {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Numeric,
                2 => Self::AlphaUpperCase,
                3 => Self::AlphaLowerCase,
                4 => Self::Punctuation,
                5 => Self::Whitespace,
                _ => Self::UnknownValue(common_chars_to_ignore::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CommonCharsToIgnore {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMMON_CHARS_TO_IGNORE_UNSPECIFIED" => Self::Unspecified,
                "NUMERIC" => Self::Numeric,
                "ALPHA_UPPER_CASE" => Self::AlphaUpperCase,
                "ALPHA_LOWER_CASE" => Self::AlphaLowerCase,
                "PUNCTUATION" => Self::Punctuation,
                "WHITESPACE" => Self::Whitespace,
                _ => Self::UnknownValue(common_chars_to_ignore::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CommonCharsToIgnore {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Numeric => serializer.serialize_i32(1),
                Self::AlphaUpperCase => serializer.serialize_i32(2),
                Self::AlphaLowerCase => serializer.serialize_i32(3),
                Self::Punctuation => serializer.serialize_i32(4),
                Self::Whitespace => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CommonCharsToIgnore {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CommonCharsToIgnore>::new(
                ".google.privacy.dlp.v2.CharsToIgnore.CommonCharsToIgnore",
            ))
        }
    }

    /// Type of characters to skip.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Characters {
        /// Characters to not transform when masking.
        CharactersToSkip(std::string::String),
        /// Common characters to not transform when masking. Useful to avoid removing
        /// punctuation.
        CommonCharactersToIgnore(crate::model::chars_to_ignore::CommonCharsToIgnore),
    }
}

/// Partially mask a string by replacing a given number of characters with a
/// fixed character. Masking can start from the beginning or end of the string.
/// This can be used on data of any type (numbers, longs, and so on) and when
/// de-identifying structured data we'll attempt to preserve the original data's
/// type. (This allows you to take a long like 123 and modify it to a string like
/// **3.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CharacterMaskConfig {
    /// Character to use to mask the sensitive values&mdash;for example, `*` for an
    /// alphabetic string such as a name, or `0` for a numeric string such as ZIP
    /// code or credit card number. This string must have a length of 1. If not
    /// supplied, this value defaults to `*` for strings, and `0` for digits.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub masking_character: std::string::String,

    /// Number of characters to mask. If not set, all matching chars will be
    /// masked. Skipped characters do not count towards this tally.
    ///
    /// If `number_to_mask` is negative, this denotes inverse masking. Cloud DLP
    /// masks all but a number of characters.
    /// For example, suppose you have the following values:
    ///
    /// - `masking_character` is `*`
    /// - `number_to_mask` is `-4`
    /// - `reverse_order` is `false`
    /// - `CharsToIgnore` includes `-`
    /// - Input string is `1234-5678-9012-3456`
    ///
    /// The resulting de-identified string is
    /// `****-****-****-3456`. Cloud DLP masks all but the last four characters.
    /// If `reverse_order` is `true`, all but the first four characters are masked
    /// as `1234-****-****-****`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub number_to_mask: i32,

    /// Mask characters in reverse order. For example, if `masking_character` is
    /// `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the
    /// input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
    /// If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order`
    /// is `true`, then the string `12345` is masked as `12***`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reverse_order: bool,

    /// When masking a string, items in this list will be skipped when replacing
    /// characters. For example, if the input string is `555-555-5555` and you
    /// instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP
    /// returns `***-**5-5555`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub characters_to_ignore: std::vec::Vec<crate::model::CharsToIgnore>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CharacterMaskConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [masking_character][crate::model::CharacterMaskConfig::masking_character].
    pub fn set_masking_character<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.masking_character = v.into();
        self
    }

    /// Sets the value of [number_to_mask][crate::model::CharacterMaskConfig::number_to_mask].
    pub fn set_number_to_mask<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.number_to_mask = v.into();
        self
    }

    /// Sets the value of [reverse_order][crate::model::CharacterMaskConfig::reverse_order].
    pub fn set_reverse_order<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reverse_order = v.into();
        self
    }

    /// Sets the value of [characters_to_ignore][crate::model::CharacterMaskConfig::characters_to_ignore].
    pub fn set_characters_to_ignore<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CharsToIgnore>,
    {
        use std::iter::Iterator;
        self.characters_to_ignore = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CharacterMaskConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CharacterMaskConfig"
    }
}

/// Buckets values based on fixed size ranges. The
/// Bucketing transformation can provide all of this functionality,
/// but requires more configuration. This message is provided as a convenience to
/// the user for simple bucketing strategies.
///
/// The transformed value will be a hyphenated string of
/// {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound
/// = 20, all values that are within this bucket will be replaced with "10-20".
///
/// This can be used on data of type: double, long.
///
/// If the bound Value type differs from the type of data
/// being transformed, we will first attempt converting the type of the data to
/// be transformed to match the type of the bound before comparing.
///
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-bucketing> to
/// learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FixedSizeBucketingConfig {
    /// Required. Lower bound value of buckets. All values less than `lower_bound`
    /// are grouped together into a single bucket; for example if `lower_bound` =
    /// 10, then all values less than 10 are replaced with the value "-10".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lower_bound: std::option::Option<crate::model::Value>,

    /// Required. Upper bound value of buckets. All values greater than upper_bound
    /// are grouped together into a single bucket; for example if `upper_bound` =
    /// 89, then all values greater than 89 are replaced with the value "89+".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upper_bound: std::option::Option<crate::model::Value>,

    /// Required. Size of each bucket (except for minimum and maximum buckets). So
    /// if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the
    /// following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60,
    /// 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub bucket_size: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FixedSizeBucketingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lower_bound][crate::model::FixedSizeBucketingConfig::lower_bound].
    pub fn set_lower_bound<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.lower_bound = v.into();
        self
    }

    /// Sets the value of [upper_bound][crate::model::FixedSizeBucketingConfig::upper_bound].
    pub fn set_upper_bound<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.upper_bound = v.into();
        self
    }

    /// Sets the value of [bucket_size][crate::model::FixedSizeBucketingConfig::bucket_size].
    pub fn set_bucket_size<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.bucket_size = v.into();
        self
    }
}

impl wkt::message::Message for FixedSizeBucketingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FixedSizeBucketingConfig"
    }
}

/// Generalization function that buckets values based on ranges. The ranges and
/// replacement values are dynamically provided by the user for custom behavior,
/// such as 1-30 -> LOW, 31-65 -> MEDIUM, 66-100 -> HIGH.
///
/// This can be used on data of type: number, long, string, timestamp.
///
/// If the bound `Value` type differs from the type of data being transformed, we
/// will first attempt converting the type of the data to be transformed to match
/// the type of the bound before comparing.
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-bucketing> to
/// learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub buckets: std::vec::Vec<crate::model::bucketing_config::Bucket>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BucketingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [buckets][crate::model::BucketingConfig::buckets].
    pub fn set_buckets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::bucketing_config::Bucket>,
    {
        use std::iter::Iterator;
        self.buckets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BucketingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BucketingConfig"
    }
}

/// Defines additional types related to [BucketingConfig].
pub mod bucketing_config {
    #[allow(unused_imports)]
    use super::*;

    /// Bucket is represented as a range, along with replacement values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Bucket {
        /// Lower bound of the range, inclusive. Type should be the same as max if
        /// used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min: std::option::Option<crate::model::Value>,

        /// Upper bound of the range, exclusive; type must match min.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max: std::option::Option<crate::model::Value>,

        /// Required. Replacement value for this bucket.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub replacement_value: std::option::Option<crate::model::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Bucket {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min][crate::model::bucketing_config::Bucket::min].
        pub fn set_min<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min = v.into();
            self
        }

        /// Sets the value of [max][crate::model::bucketing_config::Bucket::max].
        pub fn set_max<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max = v.into();
            self
        }

        /// Sets the value of [replacement_value][crate::model::bucketing_config::Bucket::replacement_value].
        pub fn set_replacement_value<
            T: std::convert::Into<std::option::Option<crate::model::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.replacement_value = v.into();
            self
        }
    }

    impl wkt::message::Message for Bucket {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.BucketingConfig.Bucket"
        }
    }
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption
/// (FPE) with the FFX mode of operation; however when used in the
/// `ReidentifyContent` API method, it serves the opposite function by reversing
/// the surrogate back into the original identifier. The identifier must be
/// encoded as ASCII. For a given crypto key and context, the same identifier
/// will be replaced with the same surrogate. Identifiers must be at least two
/// characters long. In the case that the identifier is the empty string, it will
/// be skipped. See
/// <https://cloud.google.com/sensitive-data-protection/docs/pseudonymization> to
/// learn more.
///
/// Note: We recommend using  CryptoDeterministicConfig for all use cases which
/// do not require preserving the input alphabet space and size, plus warrant
/// referential integrity. FPE incurs significant latency costs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoReplaceFfxFpeConfig {
    /// Required. The key used by the encryption algorithm.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    /// The 'tweak', a context may be used for higher security since the same
    /// identifier in two different contexts won't be given the same surrogate. If
    /// the context is not set, a default tweak will be used.
    ///
    /// If the context is set but:
    ///
    /// . there is no record present when transforming a given value or
    /// . the field is not present when transforming a given value,
    ///
    /// a default tweak will be used.
    ///
    /// Note that case (1) is expected when an `InfoTypeTransformation` is
    /// applied to both structured and unstructured `ContentItem`s.
    /// Currently, the referenced field may be of value type integer or string.
    ///
    /// The tweak is constructed as a sequence of bytes in big endian byte order
    /// such that:
    ///
    /// - a 64 bit integer is encoded followed by a single byte of value 1
    /// - a string is encoded in UTF-8 format followed by a single byte of value 2
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::FieldId>,

    /// The custom infoType to annotate the surrogate with.
    /// This annotation will be applied to the surrogate by prefixing it with
    /// the name of the custom infoType followed by the number of
    /// characters comprising the surrogate. The following scheme defines the
    /// format: info_type_name(surrogate_character_count):surrogate
    ///
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and
    /// the surrogate is 'abc', the full replacement value
    /// will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    ///
    /// This annotation identifies the surrogate when inspecting content using the
    /// custom infoType
    /// [`SurrogateType`](https://cloud.google.com/sensitive-data-protection/docs/reference/rest/v2/InspectConfig#surrogatetype).
    /// This facilitates reversal of the surrogate when it occurs in free text.
    ///
    /// In order for inspection to work properly, the name of this infoType must
    /// not occur naturally anywhere in your data; otherwise, inspection may
    /// find a surrogate that does not correspond to an actual identifier.
    /// Therefore, choose your custom infoType name carefully after considering
    /// what your data looks like. One way to select a name that has a high chance
    /// of yielding reliable detection is to include one or more unicode characters
    /// that are highly improbable to exist in your data.
    /// For example, assuming your data is entered from a regular ASCII keyboard,
    /// the symbol with the hex code point 29DD might be used like so:
    /// ⧝MY_TOKEN_TYPE
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub surrogate_info_type: std::option::Option<crate::model::InfoType>,

    /// Choose an alphabet which the data being transformed will be made up of.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub alphabet: std::option::Option<crate::model::crypto_replace_ffx_fpe_config::Alphabet>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoReplaceFfxFpeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key][crate::model::CryptoReplaceFfxFpeConfig::crypto_key].
    pub fn set_crypto_key<T: std::convert::Into<std::option::Option<crate::model::CryptoKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key = v.into();
        self
    }

    /// Sets the value of [context][crate::model::CryptoReplaceFfxFpeConfig::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [surrogate_info_type][crate::model::CryptoReplaceFfxFpeConfig::surrogate_info_type].
    pub fn set_surrogate_info_type<
        T: std::convert::Into<std::option::Option<crate::model::InfoType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.surrogate_info_type = v.into();
        self
    }

    /// Sets the value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet].
    ///
    /// Note that all the setters affecting `alphabet` are mutually
    /// exclusive.
    pub fn set_alphabet<
        T: std::convert::Into<
                std::option::Option<crate::model::crypto_replace_ffx_fpe_config::Alphabet>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alphabet = v.into();
        self
    }

    /// The value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// if it holds a `CommonAlphabet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn common_alphabet(
        &self,
    ) -> std::option::Option<&crate::model::crypto_replace_ffx_fpe_config::FfxCommonNativeAlphabet>
    {
        #[allow(unreachable_patterns)]
        self.alphabet.as_ref().and_then(|v| match v {
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CommonAlphabet(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// to hold a `CommonAlphabet`.
    ///
    /// Note that all the setters affecting `alphabet` are
    /// mutually exclusive.
    pub fn set_common_alphabet<
        T: std::convert::Into<crate::model::crypto_replace_ffx_fpe_config::FfxCommonNativeAlphabet>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alphabet = std::option::Option::Some(
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CommonAlphabet(v.into()),
        );
        self
    }

    /// The value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// if it holds a `CustomAlphabet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_alphabet(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.alphabet.as_ref().and_then(|v| match v {
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CustomAlphabet(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// to hold a `CustomAlphabet`.
    ///
    /// Note that all the setters affecting `alphabet` are
    /// mutually exclusive.
    pub fn set_custom_alphabet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.alphabet = std::option::Option::Some(
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CustomAlphabet(v.into()),
        );
        self
    }

    /// The value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// if it holds a `Radix`, `None` if the field is not set or
    /// holds a different branch.
    pub fn radix(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.alphabet.as_ref().and_then(|v| match v {
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::Radix(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// to hold a `Radix`.
    ///
    /// Note that all the setters affecting `alphabet` are
    /// mutually exclusive.
    pub fn set_radix<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.alphabet = std::option::Option::Some(
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::Radix(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CryptoReplaceFfxFpeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoReplaceFfxFpeConfig"
    }
}

/// Defines additional types related to [CryptoReplaceFfxFpeConfig].
pub mod crypto_replace_ffx_fpe_config {
    #[allow(unused_imports)]
    use super::*;

    /// These are commonly used subsets of the alphabet that the FFX mode
    /// natively supports. In the algorithm, the alphabet is selected using
    /// the "radix". Therefore each corresponds to a particular radix.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FfxCommonNativeAlphabet {
        /// Unused.
        Unspecified,
        /// `[0-9]` (radix of 10)
        Numeric,
        /// `[0-9A-F]` (radix of 16)
        Hexadecimal,
        /// `[0-9A-Z]` (radix of 36)
        UpperCaseAlphaNumeric,
        /// `[0-9A-Za-z]` (radix of 62)
        AlphaNumeric,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FfxCommonNativeAlphabet::value] or
        /// [FfxCommonNativeAlphabet::name].
        UnknownValue(ffx_common_native_alphabet::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ffx_common_native_alphabet {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FfxCommonNativeAlphabet {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Numeric => std::option::Option::Some(1),
                Self::Hexadecimal => std::option::Option::Some(2),
                Self::UpperCaseAlphaNumeric => std::option::Option::Some(3),
                Self::AlphaNumeric => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED")
                }
                Self::Numeric => std::option::Option::Some("NUMERIC"),
                Self::Hexadecimal => std::option::Option::Some("HEXADECIMAL"),
                Self::UpperCaseAlphaNumeric => {
                    std::option::Option::Some("UPPER_CASE_ALPHA_NUMERIC")
                }
                Self::AlphaNumeric => std::option::Option::Some("ALPHA_NUMERIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FfxCommonNativeAlphabet {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FfxCommonNativeAlphabet {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FfxCommonNativeAlphabet {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Numeric,
                2 => Self::Hexadecimal,
                3 => Self::UpperCaseAlphaNumeric,
                4 => Self::AlphaNumeric,
                _ => Self::UnknownValue(ffx_common_native_alphabet::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FfxCommonNativeAlphabet {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED" => Self::Unspecified,
                "NUMERIC" => Self::Numeric,
                "HEXADECIMAL" => Self::Hexadecimal,
                "UPPER_CASE_ALPHA_NUMERIC" => Self::UpperCaseAlphaNumeric,
                "ALPHA_NUMERIC" => Self::AlphaNumeric,
                _ => Self::UnknownValue(ffx_common_native_alphabet::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FfxCommonNativeAlphabet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Numeric => serializer.serialize_i32(1),
                Self::Hexadecimal => serializer.serialize_i32(2),
                Self::UpperCaseAlphaNumeric => serializer.serialize_i32(3),
                Self::AlphaNumeric => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FfxCommonNativeAlphabet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<FfxCommonNativeAlphabet>::new(
                    ".google.privacy.dlp.v2.CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet",
                ),
            )
        }
    }

    /// Choose an alphabet which the data being transformed will be made up of.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Alphabet {
        /// Common alphabets.
        CommonAlphabet(crate::model::crypto_replace_ffx_fpe_config::FfxCommonNativeAlphabet),
        /// This is supported by mapping these to the alphanumeric characters
        /// that the FFX mode natively supports. This happens before/after
        /// encryption/decryption.
        /// Each character listed must appear only once.
        /// Number of characters must be in the range [2, 95].
        /// This must be encoded as ASCII.
        /// The order of characters does not matter.
        /// The full list of allowed characters is:
        /// ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz~`!@#$%^&*()_-+={[}]|\:;"'<,>.?/``
        CustomAlphabet(std::string::String),
        /// The native way to select the alphabet. Must be in the range [2, 95].
        Radix(i32),
    }
}

/// This is a data encryption key (DEK) (as opposed to
/// a key encryption key (KEK) stored by Cloud Key Management Service
/// (Cloud KMS).
/// When using Cloud KMS to wrap or unwrap a DEK, be sure to set an appropriate
/// IAM policy on the KEK to ensure an attacker cannot
/// unwrap the DEK.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoKey {
    /// Sources of crypto keys.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::crypto_key::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::CryptoKey::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::crypto_key::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::CryptoKey::source]
    /// if it holds a `Transient`, `None` if the field is not set or
    /// holds a different branch.
    pub fn transient(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TransientCryptoKey>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::crypto_key::Source::Transient(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::CryptoKey::source]
    /// to hold a `Transient`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_transient<
        T: std::convert::Into<std::boxed::Box<crate::model::TransientCryptoKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::crypto_key::Source::Transient(v.into()));
        self
    }

    /// The value of [source][crate::model::CryptoKey::source]
    /// if it holds a `Unwrapped`, `None` if the field is not set or
    /// holds a different branch.
    pub fn unwrapped(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UnwrappedCryptoKey>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::crypto_key::Source::Unwrapped(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::CryptoKey::source]
    /// to hold a `Unwrapped`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_unwrapped<
        T: std::convert::Into<std::boxed::Box<crate::model::UnwrappedCryptoKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::crypto_key::Source::Unwrapped(v.into()));
        self
    }

    /// The value of [source][crate::model::CryptoKey::source]
    /// if it holds a `KmsWrapped`, `None` if the field is not set or
    /// holds a different branch.
    pub fn kms_wrapped(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::KmsWrappedCryptoKey>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::crypto_key::Source::KmsWrapped(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::CryptoKey::source]
    /// to hold a `KmsWrapped`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_kms_wrapped<
        T: std::convert::Into<std::boxed::Box<crate::model::KmsWrappedCryptoKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::crypto_key::Source::KmsWrapped(v.into()));
        self
    }
}

impl wkt::message::Message for CryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoKey"
    }
}

/// Defines additional types related to [CryptoKey].
pub mod crypto_key {
    #[allow(unused_imports)]
    use super::*;

    /// Sources of crypto keys.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Transient crypto key
        Transient(std::boxed::Box<crate::model::TransientCryptoKey>),
        /// Unwrapped crypto key
        Unwrapped(std::boxed::Box<crate::model::UnwrappedCryptoKey>),
        /// Key wrapped using Cloud KMS
        KmsWrapped(std::boxed::Box<crate::model::KmsWrappedCryptoKey>),
    }
}

/// Use this to have a random data crypto key generated.
/// It will be discarded after the request finishes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransientCryptoKey {
    /// Required. Name of the key.
    /// This is an arbitrary string used to differentiate different keys.
    /// A unique key is generated per name: two separate `TransientCryptoKey`
    /// protos share the same generated key if their names are the same.
    /// When the data crypto key is generated, this name is not used in any way
    /// (repeating the api call will result in a different key being generated).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransientCryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransientCryptoKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for TransientCryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransientCryptoKey"
    }
}

/// Using raw keys is prone to security risks due to accidentally
/// leaking the key. Choose another type of key if possible.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UnwrappedCryptoKey {
    /// Required. A 128/192/256 bit key.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub key: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnwrappedCryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::UnwrappedCryptoKey::key].
    pub fn set_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for UnwrappedCryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UnwrappedCryptoKey"
    }
}

/// Include to use an existing data crypto key wrapped by KMS.
/// The wrapped key must be a 128-, 192-, or 256-bit key.
/// Authorization requires the following IAM permissions when sending a request
/// to perform a crypto transformation using a KMS-wrapped crypto key:
/// dlp.kms.encrypt
///
/// For more information, see [Creating a wrapped key]
/// (<https://cloud.google.com/sensitive-data-protection/docs/create-wrapped-key>).
///
/// Note: When you use Cloud KMS for cryptographic operations,
/// [charges apply](https://cloud.google.com/kms/pricing).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KmsWrappedCryptoKey {
    /// Required. The wrapped data crypto key.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub wrapped_key: ::bytes::Bytes,

    /// Required. The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KmsWrappedCryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [wrapped_key][crate::model::KmsWrappedCryptoKey::wrapped_key].
    pub fn set_wrapped_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.wrapped_key = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::KmsWrappedCryptoKey::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }
}

impl wkt::message::Message for KmsWrappedCryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.KmsWrappedCryptoKey"
    }
}

/// Shifts dates by random number of days, with option to be consistent for the
/// same context. See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-date-shifting>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DateShiftConfig {
    /// Required. Range of shift in days. Actual shift will be selected at random
    /// within this range (inclusive ends). Negative means shift to earlier in
    /// time. Must not be more than 365250 days (1000 years) each direction.
    ///
    /// For example, 3 means shift date to at most 3 days into the future.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub upper_bound_days: i32,

    /// Required. For example, -5 means shift date to at most 5 days back in the
    /// past.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub lower_bound_days: i32,

    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the
    /// given context.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::FieldId>,

    /// Method for calculating shift that takes context into consideration. If
    /// set, must also set context. Can only be applied to table items.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub method: std::option::Option<crate::model::date_shift_config::Method>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DateShiftConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upper_bound_days][crate::model::DateShiftConfig::upper_bound_days].
    pub fn set_upper_bound_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.upper_bound_days = v.into();
        self
    }

    /// Sets the value of [lower_bound_days][crate::model::DateShiftConfig::lower_bound_days].
    pub fn set_lower_bound_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.lower_bound_days = v.into();
        self
    }

    /// Sets the value of [context][crate::model::DateShiftConfig::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [method][crate::model::DateShiftConfig::method].
    ///
    /// Note that all the setters affecting `method` are mutually
    /// exclusive.
    pub fn set_method<
        T: std::convert::Into<std::option::Option<crate::model::date_shift_config::Method>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }

    /// The value of [method][crate::model::DateShiftConfig::method]
    /// if it holds a `CryptoKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn crypto_key(&self) -> std::option::Option<&std::boxed::Box<crate::model::CryptoKey>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::date_shift_config::Method::CryptoKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::DateShiftConfig::method]
    /// to hold a `CryptoKey`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_crypto_key<T: std::convert::Into<std::boxed::Box<crate::model::CryptoKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.method =
            std::option::Option::Some(crate::model::date_shift_config::Method::CryptoKey(v.into()));
        self
    }
}

impl wkt::message::Message for DateShiftConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DateShiftConfig"
    }
}

/// Defines additional types related to [DateShiftConfig].
pub mod date_shift_config {
    #[allow(unused_imports)]
    use super::*;

    /// Method for calculating shift that takes context into consideration. If
    /// set, must also set context. Can only be applied to table items.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Method {
        /// Causes the shift to be computed based on this key and the context. This
        /// results in the same shift for the same context and crypto_key. If
        /// set, must also set context. Can only be applied to table items.
        CryptoKey(std::boxed::Box<crate::model::CryptoKey>),
    }
}

/// A type of transformation that will scan unstructured text and
/// apply various `PrimitiveTransformation`s to each finding, where the
/// transformation is applied to only values that were identified as a specific
/// info_type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoTypeTransformations {
    /// Required. Transformation for each infoType. Cannot specify more than one
    /// for a given infoType.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub transformations:
        std::vec::Vec<crate::model::info_type_transformations::InfoTypeTransformation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoTypeTransformations {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformations][crate::model::InfoTypeTransformations::transformations].
    pub fn set_transformations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::info_type_transformations::InfoTypeTransformation>,
    {
        use std::iter::Iterator;
        self.transformations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InfoTypeTransformations {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeTransformations"
    }
}

/// Defines additional types related to [InfoTypeTransformations].
pub mod info_type_transformations {
    #[allow(unused_imports)]
    use super::*;

    /// A transformation to apply to text that is identified as a specific
    /// info_type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InfoTypeTransformation {
        /// InfoTypes to apply the transformation to. An empty list will cause
        /// this transformation to apply to all findings that correspond to
        /// infoTypes that were requested in `InspectConfig`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub info_types: std::vec::Vec<crate::model::InfoType>,

        /// Required. Primitive transformation to apply to the infoType.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub primitive_transformation: std::option::Option<crate::model::PrimitiveTransformation>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InfoTypeTransformation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [info_types][crate::model::info_type_transformations::InfoTypeTransformation::info_types].
        pub fn set_info_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::InfoType>,
        {
            use std::iter::Iterator;
            self.info_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [primitive_transformation][crate::model::info_type_transformations::InfoTypeTransformation::primitive_transformation].
        pub fn set_primitive_transformation<
            T: std::convert::Into<std::option::Option<crate::model::PrimitiveTransformation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.primitive_transformation = v.into();
            self
        }
    }

    impl wkt::message::Message for InfoTypeTransformation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InfoTypeTransformations.InfoTypeTransformation"
        }
    }
}

/// The transformation to apply to the field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FieldTransformation {
    /// Required. Input field(s) to apply the transformation to.
    /// When you have columns that reference their position within a list,
    /// omit the index from the FieldId. FieldId name matching ignores the index.
    /// For example, instead of "contact.nums[0].type", use "contact.nums.type".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<crate::model::FieldId>,

    /// Only apply the transformation if the condition evaluates to true for the
    /// given `RecordCondition`. The conditions are allowed to reference fields
    /// that are not used in the actual transformation.
    ///
    /// Example Use Cases:
    ///
    /// - Apply a different bucket transformation to an age column if the zip code
    ///   column for the same record is within a specific range.
    /// - Redact a field if the date of birth field is greater than 85.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<crate::model::RecordCondition>,

    /// Transformation to apply. [required]
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub transformation: std::option::Option<crate::model::field_transformation::Transformation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FieldTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fields][crate::model::FieldTransformation::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [condition][crate::model::FieldTransformation::condition].
    pub fn set_condition<
        T: std::convert::Into<std::option::Option<crate::model::RecordCondition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [transformation][crate::model::FieldTransformation::transformation].
    ///
    /// Note that all the setters affecting `transformation` are mutually
    /// exclusive.
    pub fn set_transformation<
        T: std::convert::Into<std::option::Option<crate::model::field_transformation::Transformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = v.into();
        self
    }

    /// The value of [transformation][crate::model::FieldTransformation::transformation]
    /// if it holds a `PrimitiveTransformation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn primitive_transformation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrimitiveTransformation>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::field_transformation::Transformation::PrimitiveTransformation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::FieldTransformation::transformation]
    /// to hold a `PrimitiveTransformation`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_primitive_transformation<
        T: std::convert::Into<std::boxed::Box<crate::model::PrimitiveTransformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::field_transformation::Transformation::PrimitiveTransformation(v.into()),
        );
        self
    }

    /// The value of [transformation][crate::model::FieldTransformation::transformation]
    /// if it holds a `InfoTypeTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn info_type_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InfoTypeTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::field_transformation::Transformation::InfoTypeTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::FieldTransformation::transformation]
    /// to hold a `InfoTypeTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_info_type_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::InfoTypeTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::field_transformation::Transformation::InfoTypeTransformations(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FieldTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FieldTransformation"
    }
}

/// Defines additional types related to [FieldTransformation].
pub mod field_transformation {
    #[allow(unused_imports)]
    use super::*;

    /// Transformation to apply. [required]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Transformation {
        /// Apply the transformation to the entire field.
        PrimitiveTransformation(std::boxed::Box<crate::model::PrimitiveTransformation>),
        /// Treat the contents of the field as free text, and selectively
        /// transform content that matches an `InfoType`.
        InfoTypeTransformations(std::boxed::Box<crate::model::InfoTypeTransformations>),
    }
}

/// A type of transformation that is applied over structured data such as a
/// table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordTransformations {
    /// Transform the record by applying various field transformations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub field_transformations: std::vec::Vec<crate::model::FieldTransformation>,

    /// Configuration defining which records get suppressed entirely. Records that
    /// match any suppression rule are omitted from the output.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub record_suppressions: std::vec::Vec<crate::model::RecordSuppression>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordTransformations {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field_transformations][crate::model::RecordTransformations::field_transformations].
    pub fn set_field_transformations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldTransformation>,
    {
        use std::iter::Iterator;
        self.field_transformations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [record_suppressions][crate::model::RecordTransformations::record_suppressions].
    pub fn set_record_suppressions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RecordSuppression>,
    {
        use std::iter::Iterator;
        self.record_suppressions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RecordTransformations {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordTransformations"
    }
}

/// Configuration to suppress records whose suppression conditions evaluate to
/// true.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordSuppression {
    /// A condition that when it evaluates to true will result in the record being
    /// evaluated to be suppressed from the transformed content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<crate::model::RecordCondition>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordSuppression {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [condition][crate::model::RecordSuppression::condition].
    pub fn set_condition<
        T: std::convert::Into<std::option::Option<crate::model::RecordCondition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition = v.into();
        self
    }
}

impl wkt::message::Message for RecordSuppression {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordSuppression"
    }
}

/// A condition for determining whether a transformation should be applied to
/// a field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordCondition {
    /// An expression.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expressions: std::option::Option<crate::model::record_condition::Expressions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expressions][crate::model::RecordCondition::expressions].
    pub fn set_expressions<
        T: std::convert::Into<std::option::Option<crate::model::record_condition::Expressions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expressions = v.into();
        self
    }
}

impl wkt::message::Message for RecordCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordCondition"
    }
}

/// Defines additional types related to [RecordCondition].
pub mod record_condition {
    #[allow(unused_imports)]
    use super::*;

    /// The field type of `value` and `field` do not need to match to be
    /// considered equal, but not all comparisons are possible.
    /// EQUAL_TO and NOT_EQUAL_TO attempt to compare even with incompatible types,
    /// but all other comparisons are invalid with incompatible types.
    /// A `value` of type:
    ///
    /// - `string` can be compared against all other types
    /// - `boolean` can only be compared against other booleans
    /// - `integer` can be compared against doubles or a string if the string value
    ///   can be parsed as an integer.
    /// - `double` can be compared against integers or a string if the string can
    ///   be parsed as a double.
    /// - `Timestamp` can be compared against strings in RFC 3339 date string
    ///   format.
    /// - `TimeOfDay` can be compared against timestamps and strings in the format
    ///   of 'HH:mm:ss'.
    ///
    /// If we fail to compare do to type mismatch, a warning will be given and
    /// the condition will evaluate to false.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Condition {
        /// Required. Field within the record this condition is evaluated against.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub field: std::option::Option<crate::model::FieldId>,

        /// Required. Operator used to compare the field or infoType to the value.
        pub operator: crate::model::RelationalOperator,

        /// Value to compare against. [Mandatory, except for `EXISTS` tests.]
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Condition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::record_condition::Condition::field].
        pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
            mut self,
            v: T,
        ) -> Self {
            self.field = v.into();
            self
        }

        /// Sets the value of [operator][crate::model::record_condition::Condition::operator].
        pub fn set_operator<T: std::convert::Into<crate::model::RelationalOperator>>(
            mut self,
            v: T,
        ) -> Self {
            self.operator = v.into();
            self
        }

        /// Sets the value of [value][crate::model::record_condition::Condition::value].
        pub fn set_value<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Condition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RecordCondition.Condition"
        }
    }

    /// A collection of conditions.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Conditions {
        /// A collection of conditions.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub conditions: std::vec::Vec<crate::model::record_condition::Condition>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Conditions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [conditions][crate::model::record_condition::Conditions::conditions].
        pub fn set_conditions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::record_condition::Condition>,
        {
            use std::iter::Iterator;
            self.conditions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Conditions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RecordCondition.Conditions"
        }
    }

    /// An expression, consisting of an operator and conditions.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Expressions {
        /// The operator to apply to the result of conditions. Default and currently
        /// only supported value is `AND`.
        pub logical_operator: crate::model::record_condition::expressions::LogicalOperator,

        /// Expression types.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub r#type: std::option::Option<crate::model::record_condition::expressions::Type>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Expressions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [logical_operator][crate::model::record_condition::Expressions::logical_operator].
        pub fn set_logical_operator<
            T: std::convert::Into<crate::model::record_condition::expressions::LogicalOperator>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.logical_operator = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::record_condition::Expressions::type].
        ///
        /// Note that all the setters affecting `r#type` are mutually
        /// exclusive.
        pub fn set_type<
            T: std::convert::Into<
                    std::option::Option<crate::model::record_condition::expressions::Type>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// The value of [r#type][crate::model::record_condition::Expressions::r#type]
        /// if it holds a `Conditions`, `None` if the field is not set or
        /// holds a different branch.
        pub fn conditions(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::record_condition::Conditions>>
        {
            #[allow(unreachable_patterns)]
            self.r#type.as_ref().and_then(|v| match v {
                crate::model::record_condition::expressions::Type::Conditions(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#type][crate::model::record_condition::Expressions::r#type]
        /// to hold a `Conditions`.
        ///
        /// Note that all the setters affecting `r#type` are
        /// mutually exclusive.
        pub fn set_conditions<
            T: std::convert::Into<std::boxed::Box<crate::model::record_condition::Conditions>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = std::option::Option::Some(
                crate::model::record_condition::expressions::Type::Conditions(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Expressions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RecordCondition.Expressions"
        }
    }

    /// Defines additional types related to [Expressions].
    pub mod expressions {
        #[allow(unused_imports)]
        use super::*;

        /// Logical operators for conditional checks.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum LogicalOperator {
            /// Unused
            Unspecified,
            /// Conditional AND
            And,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [LogicalOperator::value] or
            /// [LogicalOperator::name].
            UnknownValue(logical_operator::UnknownValue),
        }

        #[doc(hidden)]
        pub mod logical_operator {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl LogicalOperator {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::And => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("LOGICAL_OPERATOR_UNSPECIFIED"),
                    Self::And => std::option::Option::Some("AND"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for LogicalOperator {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for LogicalOperator {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for LogicalOperator {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::And,
                    _ => Self::UnknownValue(logical_operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for LogicalOperator {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LOGICAL_OPERATOR_UNSPECIFIED" => Self::Unspecified,
                    "AND" => Self::And,
                    _ => Self::UnknownValue(logical_operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for LogicalOperator {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::And => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for LogicalOperator {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogicalOperator>::new(
                    ".google.privacy.dlp.v2.RecordCondition.Expressions.LogicalOperator",
                ))
            }
        }

        /// Expression types.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Type {
            /// Conditions to apply to the expression.
            Conditions(std::boxed::Box<crate::model::record_condition::Conditions>),
        }
    }
}

/// Overview of the modifications that occurred.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationOverview {
    /// Total size in bytes that were transformed in some way.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformed_bytes: i64,

    /// Transformations applied to the dataset.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub transformation_summaries: std::vec::Vec<crate::model::TransformationSummary>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationOverview {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformed_bytes][crate::model::TransformationOverview::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [transformation_summaries][crate::model::TransformationOverview::transformation_summaries].
    pub fn set_transformation_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransformationSummary>,
    {
        use std::iter::Iterator;
        self.transformation_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TransformationOverview {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationOverview"
    }
}

/// Summary of a single transformation.
/// Only one of 'transformation', 'field_transformation', or 'record_suppress'
/// will be set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationSummary {
    /// Set if the transformation was limited to a specific InfoType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Set if the transformation was limited to a specific FieldId.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<crate::model::FieldId>,

    /// The specific transformation these stats apply to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transformation: std::option::Option<crate::model::PrimitiveTransformation>,

    /// The field transformation that was applied.
    /// If multiple field transformations are requested for a single field,
    /// this list will contain all of them; otherwise, only one is supplied.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub field_transformations: std::vec::Vec<crate::model::FieldTransformation>,

    /// The specific suppression option these stats apply to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub record_suppress: std::option::Option<crate::model::RecordSuppression>,

    /// Collection of all transformations that took place or had an error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub results: std::vec::Vec<crate::model::transformation_summary::SummaryResult>,

    /// Total size in bytes that were transformed in some way.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformed_bytes: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::TransformationSummary::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [field][crate::model::TransformationSummary::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [transformation][crate::model::TransformationSummary::transformation].
    pub fn set_transformation<
        T: std::convert::Into<std::option::Option<crate::model::PrimitiveTransformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = v.into();
        self
    }

    /// Sets the value of [field_transformations][crate::model::TransformationSummary::field_transformations].
    pub fn set_field_transformations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldTransformation>,
    {
        use std::iter::Iterator;
        self.field_transformations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [record_suppress][crate::model::TransformationSummary::record_suppress].
    pub fn set_record_suppress<
        T: std::convert::Into<std::option::Option<crate::model::RecordSuppression>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.record_suppress = v.into();
        self
    }

    /// Sets the value of [results][crate::model::TransformationSummary::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transformation_summary::SummaryResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [transformed_bytes][crate::model::TransformationSummary::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }
}

impl wkt::message::Message for TransformationSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationSummary"
    }
}

/// Defines additional types related to [TransformationSummary].
pub mod transformation_summary {
    #[allow(unused_imports)]
    use super::*;

    /// A collection that informs the user the number of times a particular
    /// `TransformationResultCode` and error details occurred.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SummaryResult {
        /// Number of transformations counted by this result.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub count: i64,

        /// Outcome of the transformation.
        pub code: crate::model::transformation_summary::TransformationResultCode,

        /// A place for warnings or errors to show up if a transformation didn't
        /// work as expected.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub details: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SummaryResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [count][crate::model::transformation_summary::SummaryResult::count].
        pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }

        /// Sets the value of [code][crate::model::transformation_summary::SummaryResult::code].
        pub fn set_code<
            T: std::convert::Into<crate::model::transformation_summary::TransformationResultCode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.code = v.into();
            self
        }

        /// Sets the value of [details][crate::model::transformation_summary::SummaryResult::details].
        pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.details = v.into();
            self
        }
    }

    impl wkt::message::Message for SummaryResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.TransformationSummary.SummaryResult"
        }
    }

    /// Possible outcomes of transformations.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TransformationResultCode {
        /// Unused
        Unspecified,
        /// Transformation completed without an error.
        Success,
        /// Transformation had an error.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TransformationResultCode::value] or
        /// [TransformationResultCode::name].
        UnknownValue(transformation_result_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod transformation_result_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TransformationResultCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Success => std::option::Option::Some(1),
                Self::Error => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("TRANSFORMATION_RESULT_CODE_UNSPECIFIED")
                }
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TransformationResultCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TransformationResultCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TransformationResultCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Success,
                2 => Self::Error,
                _ => Self::UnknownValue(transformation_result_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TransformationResultCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRANSFORMATION_RESULT_CODE_UNSPECIFIED" => Self::Unspecified,
                "SUCCESS" => Self::Success,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(transformation_result_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TransformationResultCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Success => serializer.serialize_i32(1),
                Self::Error => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TransformationResultCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<TransformationResultCode>::new(
                    ".google.privacy.dlp.v2.TransformationSummary.TransformationResultCode",
                ),
            )
        }
    }
}

/// A flattened description of a `PrimitiveTransformation` or
/// `RecordSuppression`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationDescription {
    /// The transformation type.
    #[serde(rename = "type")]
    pub r#type: crate::model::TransformationType,

    /// A description of the transformation. This is empty for a
    /// RECORD_SUPPRESSION, or is the output of calling toString() on the
    /// `PrimitiveTransformation` protocol buffer message for any other type of
    /// transformation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// A human-readable string representation of the `RecordCondition`
    /// corresponding to this transformation. Set if a `RecordCondition` was used
    /// to determine whether or not to apply this transformation.
    ///
    /// Examples:
    /// * (age_field > 85)
    /// * (age_field <= 18)
    /// * (zip_field exists)
    /// * (zip_field == 01234) && (city_field != "Springville")
    /// * (zip_field == 01234) && (age_field <= 18) && (city_field exists)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub condition: std::string::String,

    /// Set if the transformation was limited to a specific `InfoType`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationDescription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TransformationDescription::type].
    pub fn set_type<T: std::convert::Into<crate::model::TransformationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TransformationDescription::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::TransformationDescription::condition].
    pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [info_type][crate::model::TransformationDescription::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }
}

impl wkt::message::Message for TransformationDescription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationDescription"
    }
}

/// Details about a single transformation. This object contains a description of
/// the transformation, information about whether the transformation was
/// successfully applied, and the precise location where the transformation
/// occurred. These details are stored in a user-specified BigQuery table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationDetails {
    /// The name of the job that completed the transformation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_name: std::string::String,

    /// The top level name of the container where the transformation is located
    /// (this will be the source file name or table name).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_name: std::string::String,

    /// Description of transformation. This would only contain more than one
    /// element if there were multiple matching transformations and which one to
    /// apply was ambiguous. Not set for states that contain no transformation,
    /// currently only state that contains no transformation is
    /// TransformationResultStateType.METADATA_UNRETRIEVABLE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub transformation: std::vec::Vec<crate::model::TransformationDescription>,

    /// Status of the transformation, if transformation was not successful, this
    /// will specify what caused it to fail, otherwise it will show that the
    /// transformation was successful.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status_details: std::option::Option<crate::model::TransformationResultStatus>,

    /// The number of bytes that were transformed. If transformation was
    /// unsuccessful or did not take place because there was no content to
    /// transform, this will be zero.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformed_bytes: i64,

    /// The precise location of the transformed content in the original container.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transformation_location: std::option::Option<crate::model::TransformationLocation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_name][crate::model::TransformationDetails::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [container_name][crate::model::TransformationDetails::container_name].
    pub fn set_container_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_name = v.into();
        self
    }

    /// Sets the value of [transformation][crate::model::TransformationDetails::transformation].
    pub fn set_transformation<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransformationDescription>,
    {
        use std::iter::Iterator;
        self.transformation = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [status_details][crate::model::TransformationDetails::status_details].
    pub fn set_status_details<
        T: std::convert::Into<std::option::Option<crate::model::TransformationResultStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status_details = v.into();
        self
    }

    /// Sets the value of [transformed_bytes][crate::model::TransformationDetails::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [transformation_location][crate::model::TransformationDetails::transformation_location].
    pub fn set_transformation_location<
        T: std::convert::Into<std::option::Option<crate::model::TransformationLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation_location = v.into();
        self
    }
}

impl wkt::message::Message for TransformationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationDetails"
    }
}

/// Specifies the location of a transformation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationLocation {
    /// Information about the functionality of the container where this finding
    /// occurred, if available.
    pub container_type: crate::model::TransformationContainerType,

    /// Location type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location_type: std::option::Option<crate::model::transformation_location::LocationType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_type][crate::model::TransformationLocation::container_type].
    pub fn set_container_type<T: std::convert::Into<crate::model::TransformationContainerType>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_type = v.into();
        self
    }

    /// Sets the value of [location_type][crate::model::TransformationLocation::location_type].
    ///
    /// Note that all the setters affecting `location_type` are mutually
    /// exclusive.
    pub fn set_location_type<
        T: std::convert::Into<
                std::option::Option<crate::model::transformation_location::LocationType>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_type = v.into();
        self
    }

    /// The value of [location_type][crate::model::TransformationLocation::location_type]
    /// if it holds a `FindingId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn finding_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.location_type.as_ref().and_then(|v| match v {
            crate::model::transformation_location::LocationType::FindingId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location_type][crate::model::TransformationLocation::location_type]
    /// to hold a `FindingId`.
    ///
    /// Note that all the setters affecting `location_type` are
    /// mutually exclusive.
    pub fn set_finding_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_type = std::option::Option::Some(
            crate::model::transformation_location::LocationType::FindingId(v.into()),
        );
        self
    }

    /// The value of [location_type][crate::model::TransformationLocation::location_type]
    /// if it holds a `RecordTransformation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn record_transformation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecordTransformation>> {
        #[allow(unreachable_patterns)]
        self.location_type.as_ref().and_then(|v| match v {
            crate::model::transformation_location::LocationType::RecordTransformation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location_type][crate::model::TransformationLocation::location_type]
    /// to hold a `RecordTransformation`.
    ///
    /// Note that all the setters affecting `location_type` are
    /// mutually exclusive.
    pub fn set_record_transformation<
        T: std::convert::Into<std::boxed::Box<crate::model::RecordTransformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_type = std::option::Option::Some(
            crate::model::transformation_location::LocationType::RecordTransformation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TransformationLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationLocation"
    }
}

/// Defines additional types related to [TransformationLocation].
pub mod transformation_location {
    #[allow(unused_imports)]
    use super::*;

    /// Location type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum LocationType {
        /// For infotype transformations, link to the corresponding findings ID so
        /// that location information does not need to be duplicated. Each findings
        /// ID correlates to an entry in the findings output table, this table only
        /// gets created when users specify to save findings (add the save findings
        /// action to the request).
        FindingId(std::string::String),
        /// For record transformations, provide a field and container information.
        RecordTransformation(std::boxed::Box<crate::model::RecordTransformation>),
    }
}

/// The field in a record to transform.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordTransformation {
    /// For record transformations, provide a field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field_id: std::option::Option<crate::model::FieldId>,

    /// Findings container modification timestamp, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container_timestamp: std::option::Option<wkt::Timestamp>,

    /// Container version, if available ("generation" for Cloud Storage).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field_id][crate::model::RecordTransformation::field_id].
    pub fn set_field_id<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field_id = v.into();
        self
    }

    /// Sets the value of [container_timestamp][crate::model::RecordTransformation::container_timestamp].
    pub fn set_container_timestamp<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_timestamp = v.into();
        self
    }

    /// Sets the value of [container_version][crate::model::RecordTransformation::container_version].
    pub fn set_container_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_version = v.into();
        self
    }
}

impl wkt::message::Message for RecordTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordTransformation"
    }
}

/// The outcome of a transformation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationResultStatus {
    /// Transformation result status type, this will be either SUCCESS, or it will
    /// be the reason for why the transformation was not completely successful.
    pub result_status_type: crate::model::TransformationResultStatusType,

    /// Detailed error codes and messages
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationResultStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result_status_type][crate::model::TransformationResultStatus::result_status_type].
    pub fn set_result_status_type<
        T: std::convert::Into<crate::model::TransformationResultStatusType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result_status_type = v.into();
        self
    }

    /// Sets the value of [details][crate::model::TransformationResultStatus::details].
    pub fn set_details<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }
}

impl wkt::message::Message for TransformationResultStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationResultStatus"
    }
}

/// Config for storing transformation details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationDetailsStorageConfig {
    /// Location to store the transformation summary.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::transformation_details_storage_config::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationDetailsStorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TransformationDetailsStorageConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<
                std::option::Option<crate::model::transformation_details_storage_config::Type>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::TransformationDetailsStorageConfig::r#type]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table(&self) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTable>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::transformation_details_storage_config::Type::Table(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::TransformationDetailsStorageConfig::r#type]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTable>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::transformation_details_storage_config::Type::Table(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TransformationDetailsStorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationDetailsStorageConfig"
    }
}

/// Defines additional types related to [TransformationDetailsStorageConfig].
pub mod transformation_details_storage_config {
    #[allow(unused_imports)]
    use super::*;

    /// Location to store the transformation summary.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// The BigQuery table in which to store the output. This may be an existing
        /// table or in a new table in an existing dataset.
        /// If table_id is not set a new one will be generated for you with the
        /// following format:
        /// dlp_googleapis_transformation_details_yyyy_mm_dd_[dlp_job_id]. Pacific
        /// time zone will be used for generating the date details.
        Table(std::boxed::Box<crate::model::BigQueryTable>),
    }
}

/// Schedule for inspect job triggers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Schedule {
    /// Type of schedule.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub option: std::option::Option<crate::model::schedule::Option>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [option][crate::model::Schedule::option].
    ///
    /// Note that all the setters affecting `option` are mutually
    /// exclusive.
    pub fn set_option<
        T: std::convert::Into<std::option::Option<crate::model::schedule::Option>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.option = v.into();
        self
    }

    /// The value of [option][crate::model::Schedule::option]
    /// if it holds a `RecurrencePeriodDuration`, `None` if the field is not set or
    /// holds a different branch.
    pub fn recurrence_period_duration(
        &self,
    ) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.option.as_ref().and_then(|v| match v {
            crate::model::schedule::Option::RecurrencePeriodDuration(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [option][crate::model::Schedule::option]
    /// to hold a `RecurrencePeriodDuration`.
    ///
    /// Note that all the setters affecting `option` are
    /// mutually exclusive.
    pub fn set_recurrence_period_duration<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.option = std::option::Option::Some(
            crate::model::schedule::Option::RecurrencePeriodDuration(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Schedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Schedule"
    }
}

/// Defines additional types related to [Schedule].
pub mod schedule {
    #[allow(unused_imports)]
    use super::*;

    /// Type of schedule.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Option {
        /// With this option a job is started on a regular periodic basis. For
        /// example: every day (86400 seconds).
        ///
        /// A scheduled start time will be skipped if the previous
        /// execution has not ended when its scheduled time occurs.
        ///
        /// This value must be set to a time duration greater than or equal
        /// to 1 day and can be no longer than 60 days.
        RecurrencePeriodDuration(std::boxed::Box<wkt::Duration>),
    }
}

/// Job trigger option for hybrid jobs. Jobs must be manually created
/// and finished.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Manual {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Manual {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for Manual {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Manual"
    }
}

/// The inspectTemplate contains a configuration (set of types of sensitive data
/// to be detected) to be used anywhere you otherwise would normally specify
/// InspectConfig. See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-templates> to
/// learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectTemplate {
    /// Output only. The template name.
    ///
    /// The template will have one of the following formats:
    /// `projects/PROJECT_ID/inspectTemplates/TEMPLATE_ID` OR
    /// `organizations/ORGANIZATION_ID/inspectTemplates/TEMPLATE_ID`;
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Display name (max 256 chars).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Short description (max 256 chars).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation timestamp of an inspectTemplate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of an inspectTemplate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The core content of the template. Configuration of the scanning process.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InspectTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InspectTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::InspectTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::InspectTemplate::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::InspectTemplate::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::InspectTemplate::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }
}

impl wkt::message::Message for InspectTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectTemplate"
    }
}

/// DeidentifyTemplates contains instructions on how to de-identify content.
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-templates> to
/// learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyTemplate {
    /// Output only. The template name.
    ///
    /// The template will have one of the following formats:
    /// `projects/PROJECT_ID/deidentifyTemplates/TEMPLATE_ID` OR
    /// `organizations/ORGANIZATION_ID/deidentifyTemplates/TEMPLATE_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Display name (max 256 chars).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Short description (max 256 chars).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation timestamp of an inspectTemplate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of an inspectTemplate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The core content of the template.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deidentify_config: std::option::Option<crate::model::DeidentifyConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeidentifyTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeidentifyTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DeidentifyTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DeidentifyTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeidentifyTemplate::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DeidentifyTemplate::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [deidentify_config][crate::model::DeidentifyTemplate::deidentify_config].
    pub fn set_deidentify_config<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_config = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyTemplate"
    }
}

/// Details information about an error encountered during job execution or
/// the results of an unsuccessful activation of the JobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Error {
    /// Detailed error codes and messages.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<rpc::model::Status>,

    /// The times the error occurred. List includes the oldest timestamp and the
    /// last 9 timestamps.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub timestamps: std::vec::Vec<wkt::Timestamp>,

    /// Additional information about the error.
    pub extra_info: crate::model::error::ErrorExtraInfo,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Error {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::Error::details].
    pub fn set_details<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// Sets the value of [timestamps][crate::model::Error::timestamps].
    pub fn set_timestamps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Timestamp>,
    {
        use std::iter::Iterator;
        self.timestamps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [extra_info][crate::model::Error::extra_info].
    pub fn set_extra_info<T: std::convert::Into<crate::model::error::ErrorExtraInfo>>(
        mut self,
        v: T,
    ) -> Self {
        self.extra_info = v.into();
        self
    }
}

impl wkt::message::Message for Error {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Error"
    }
}

/// Defines additional types related to [Error].
pub mod error {
    #[allow(unused_imports)]
    use super::*;

    /// Additional information about the error.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ErrorExtraInfo {
        /// Unused.
        ErrorInfoUnspecified,
        /// Image scan is not available in the region.
        ImageScanUnavailableInRegion,
        /// File store cluster is not supported for profile generation.
        FileStoreClusterUnsupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ErrorExtraInfo::value] or
        /// [ErrorExtraInfo::name].
        UnknownValue(error_extra_info::UnknownValue),
    }

    #[doc(hidden)]
    pub mod error_extra_info {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ErrorExtraInfo {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ErrorInfoUnspecified => std::option::Option::Some(0),
                Self::ImageScanUnavailableInRegion => std::option::Option::Some(1),
                Self::FileStoreClusterUnsupported => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ErrorInfoUnspecified => std::option::Option::Some("ERROR_INFO_UNSPECIFIED"),
                Self::ImageScanUnavailableInRegion => {
                    std::option::Option::Some("IMAGE_SCAN_UNAVAILABLE_IN_REGION")
                }
                Self::FileStoreClusterUnsupported => {
                    std::option::Option::Some("FILE_STORE_CLUSTER_UNSUPPORTED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ErrorExtraInfo {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ErrorExtraInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ErrorExtraInfo {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ErrorInfoUnspecified,
                1 => Self::ImageScanUnavailableInRegion,
                2 => Self::FileStoreClusterUnsupported,
                _ => Self::UnknownValue(error_extra_info::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ErrorExtraInfo {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_INFO_UNSPECIFIED" => Self::ErrorInfoUnspecified,
                "IMAGE_SCAN_UNAVAILABLE_IN_REGION" => Self::ImageScanUnavailableInRegion,
                "FILE_STORE_CLUSTER_UNSUPPORTED" => Self::FileStoreClusterUnsupported,
                _ => Self::UnknownValue(error_extra_info::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ErrorExtraInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ErrorInfoUnspecified => serializer.serialize_i32(0),
                Self::ImageScanUnavailableInRegion => serializer.serialize_i32(1),
                Self::FileStoreClusterUnsupported => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ErrorExtraInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorExtraInfo>::new(
                ".google.privacy.dlp.v2.Error.ErrorExtraInfo",
            ))
        }
    }
}

/// Contains a configuration to make API calls on a repeating basis.
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-job-triggers>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobTrigger {
    /// Unique resource name for the triggeredJob, assigned by the service when the
    /// triggeredJob is created, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Display name (max 100 chars)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// User provided description (max 256 chars)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// A list of triggers which will be OR'ed together. Only one in the list
    /// needs to trigger for a job to be started. The list may contain only
    /// a single Schedule trigger and must have at least one object.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub triggers: std::vec::Vec<crate::model::job_trigger::Trigger>,

    /// Output only. A stream of errors encountered when the trigger was activated.
    /// Repeated errors may result in the JobTrigger automatically being paused.
    /// Will return the last 100 errors. Whenever the JobTrigger is modified
    /// this list will be cleared.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Output only. The creation timestamp of a triggeredJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of a triggeredJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the last time this trigger executed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_run_time: std::option::Option<wkt::Timestamp>,

    /// Required. A status for this trigger.
    pub status: crate::model::job_trigger::Status,

    /// The configuration details for the specific type of job to run.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::job_trigger::Job>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobTrigger {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::JobTrigger::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::JobTrigger::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::JobTrigger::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [triggers][crate::model::JobTrigger::triggers].
    pub fn set_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::job_trigger::Trigger>,
    {
        use std::iter::Iterator;
        self.triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors][crate::model::JobTrigger::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::JobTrigger::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::JobTrigger::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [last_run_time][crate::model::JobTrigger::last_run_time].
    pub fn set_last_run_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_run_time = v.into();
        self
    }

    /// Sets the value of [status][crate::model::JobTrigger::status].
    pub fn set_status<T: std::convert::Into<crate::model::job_trigger::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [job][crate::model::JobTrigger::job].
    ///
    /// Note that all the setters affecting `job` are mutually
    /// exclusive.
    pub fn set_job<T: std::convert::Into<std::option::Option<crate::model::job_trigger::Job>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }

    /// The value of [job][crate::model::JobTrigger::job]
    /// if it holds a `InspectJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inspect_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InspectJobConfig>> {
        #[allow(unreachable_patterns)]
        self.job.as_ref().and_then(|v| match v {
            crate::model::job_trigger::Job::InspectJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job][crate::model::JobTrigger::job]
    /// to hold a `InspectJob`.
    ///
    /// Note that all the setters affecting `job` are
    /// mutually exclusive.
    pub fn set_inspect_job<
        T: std::convert::Into<std::boxed::Box<crate::model::InspectJobConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job = std::option::Option::Some(crate::model::job_trigger::Job::InspectJob(v.into()));
        self
    }
}

impl wkt::message::Message for JobTrigger {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.JobTrigger"
    }
}

/// Defines additional types related to [JobTrigger].
pub mod job_trigger {
    #[allow(unused_imports)]
    use super::*;

    /// What event needs to occur for a new job to be started.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Trigger {
        /// What event needs to occur for a new job to be started.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub trigger: std::option::Option<crate::model::job_trigger::trigger::Trigger>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Trigger {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trigger][crate::model::job_trigger::Trigger::trigger].
        ///
        /// Note that all the setters affecting `trigger` are mutually
        /// exclusive.
        pub fn set_trigger<
            T: std::convert::Into<std::option::Option<crate::model::job_trigger::trigger::Trigger>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = v.into();
            self
        }

        /// The value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// if it holds a `Schedule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn schedule(&self) -> std::option::Option<&std::boxed::Box<crate::model::Schedule>> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::job_trigger::trigger::Trigger::Schedule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// to hold a `Schedule`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_schedule<T: std::convert::Into<std::boxed::Box<crate::model::Schedule>>>(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::job_trigger::trigger::Trigger::Schedule(v.into()),
            );
            self
        }

        /// The value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// if it holds a `Manual`, `None` if the field is not set or
        /// holds a different branch.
        pub fn manual(&self) -> std::option::Option<&std::boxed::Box<crate::model::Manual>> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::job_trigger::trigger::Trigger::Manual(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// to hold a `Manual`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_manual<T: std::convert::Into<std::boxed::Box<crate::model::Manual>>>(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::job_trigger::trigger::Trigger::Manual(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Trigger {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.JobTrigger.Trigger"
        }
    }

    /// Defines additional types related to [Trigger].
    pub mod trigger {
        #[allow(unused_imports)]
        use super::*;

        /// What event needs to occur for a new job to be started.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Trigger {
            /// Create a job on a repeating basis based on the elapse of time.
            Schedule(std::boxed::Box<crate::model::Schedule>),
            /// For use with hybrid jobs. Jobs must be manually created and finished.
            Manual(std::boxed::Box<crate::model::Manual>),
        }
    }

    /// Whether the trigger is currently active. If PAUSED or CANCELLED, no jobs
    /// will be created with this configuration. The service may automatically
    /// pause triggers experiencing frequent errors. To restart a job, set the
    /// status to HEALTHY after correcting user errors.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Unused.
        Unspecified,
        /// Trigger is healthy.
        Healthy,
        /// Trigger is temporarily paused.
        Paused,
        /// Trigger is cancelled and can not be resumed.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Healthy => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Healthy => std::option::Option::Some("HEALTHY"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Healthy,
                2 => Self::Paused,
                3 => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "HEALTHY" => Self::Healthy,
                "PAUSED" => Self::Paused,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Healthy => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.privacy.dlp.v2.JobTrigger.Status",
            ))
        }
    }

    /// The configuration details for the specific type of job to run.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Job {
        /// For inspect jobs, a snapshot of the configuration.
        InspectJob(std::boxed::Box<crate::model::InspectJobConfig>),
    }
}

/// A task to execute on the completion of a job.
/// See <https://cloud.google.com/sensitive-data-protection/docs/concepts-actions>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Action {
    /// Extra events to execute after the job has finished.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub action: std::option::Option<crate::model::action::Action>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Action {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::Action::action].
    ///
    /// Note that all the setters affecting `action` are mutually
    /// exclusive.
    pub fn set_action<T: std::convert::Into<std::option::Option<crate::model::action::Action>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `SaveFindings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn save_findings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::SaveFindings>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::SaveFindings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `SaveFindings`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_save_findings<
        T: std::convert::Into<std::boxed::Box<crate::model::action::SaveFindings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::action::Action::SaveFindings(v.into()));
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PubSub`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pub_sub(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::PublishToPubSub>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PubSub(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PubSub`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_pub_sub<
        T: std::convert::Into<std::boxed::Box<crate::model::action::PublishToPubSub>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(crate::model::action::Action::PubSub(v.into()));
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PublishSummaryToCscc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn publish_summary_to_cscc(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::PublishSummaryToCscc>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PublishSummaryToCscc(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PublishSummaryToCscc`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_summary_to_cscc<
        T: std::convert::Into<std::boxed::Box<crate::model::action::PublishSummaryToCscc>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::action::Action::PublishSummaryToCscc(v.into()));
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PublishFindingsToCloudDataCatalog`, `None` if the field is not set or
    /// holds a different branch.
    pub fn publish_findings_to_cloud_data_catalog(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::action::PublishFindingsToCloudDataCatalog>,
    > {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PublishFindingsToCloudDataCatalog(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PublishFindingsToCloudDataCatalog`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_findings_to_cloud_data_catalog<
        T: std::convert::Into<
                std::boxed::Box<crate::model::action::PublishFindingsToCloudDataCatalog>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::action::Action::PublishFindingsToCloudDataCatalog(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `Deidentify`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deidentify(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::Deidentify>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::Deidentify(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `Deidentify`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_deidentify<
        T: std::convert::Into<std::boxed::Box<crate::model::action::Deidentify>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(crate::model::action::Action::Deidentify(v.into()));
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `JobNotificationEmails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn job_notification_emails(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::JobNotificationEmails>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::JobNotificationEmails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `JobNotificationEmails`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_job_notification_emails<
        T: std::convert::Into<std::boxed::Box<crate::model::action::JobNotificationEmails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::action::Action::JobNotificationEmails(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PublishToStackdriver`, `None` if the field is not set or
    /// holds a different branch.
    pub fn publish_to_stackdriver(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::PublishToStackdriver>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PublishToStackdriver(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PublishToStackdriver`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_to_stackdriver<
        T: std::convert::Into<std::boxed::Box<crate::model::action::PublishToStackdriver>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::action::Action::PublishToStackdriver(v.into()));
        self
    }
}

impl wkt::message::Message for Action {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Action"
    }
}

/// Defines additional types related to [Action].
pub mod action {
    #[allow(unused_imports)]
    use super::*;

    /// If set, the detailed findings will be persisted to the specified
    /// OutputStorageConfig. Only a single instance of this action can be
    /// specified.
    /// Compatible with: Inspect, Risk
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SaveFindings {
        /// Location to store findings outside of DLP.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub output_config: std::option::Option<crate::model::OutputStorageConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SaveFindings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [output_config][crate::model::action::SaveFindings::output_config].
        pub fn set_output_config<
            T: std::convert::Into<std::option::Option<crate::model::OutputStorageConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.output_config = v.into();
            self
        }
    }

    impl wkt::message::Message for SaveFindings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.SaveFindings"
        }
    }

    /// Publish a message into a given Pub/Sub topic when DlpJob has completed. The
    /// message contains a single field, `DlpJobName`, which is equal to the
    /// finished job's
    /// [`DlpJob.name`](https://cloud.google.com/sensitive-data-protection/docs/reference/rest/v2/projects.dlpJobs#DlpJob).
    /// Compatible with: Inspect, Risk
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishToPubSub {
        /// Cloud Pub/Sub topic to send notifications to. The topic must have given
        /// publishing access rights to the DLP API service account executing
        /// the long running DlpJob sending the notifications.
        /// Format is projects/{project}/topics/{topic}.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub topic: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishToPubSub {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [topic][crate::model::action::PublishToPubSub::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }
    }

    impl wkt::message::Message for PublishToPubSub {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishToPubSub"
        }
    }

    /// Publish the result summary of a DlpJob to [Security Command
    /// Center](https://cloud.google.com/security-command-center). This action is
    /// available for only projects that belong to an organization. This action
    /// publishes the count of finding instances and their infoTypes. The summary
    /// of findings are persisted in Security Command Center and are governed by
    /// [service-specific policies for Security Command
    /// Center](https://cloud.google.com/terms/service-terms). Only a single
    /// instance of this action can be specified. Compatible with: Inspect
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishSummaryToCscc {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishSummaryToCscc {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishSummaryToCscc {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishSummaryToCscc"
        }
    }

    /// Publish findings of a DlpJob to Data Catalog. In Data Catalog, tag
    /// templates are applied to the resource that Cloud DLP scanned. Data
    /// Catalog tag templates are stored in the same project and region where the
    /// BigQuery table exists. For Cloud DLP to create and apply the tag template,
    /// the Cloud DLP service agent must have the
    /// `roles/datacatalog.tagTemplateOwner` permission on the project. The tag
    /// template contains fields summarizing the results of the DlpJob. Any field
    /// values previously written by another DlpJob are deleted. [InfoType naming
    /// patterns][google.privacy.dlp.v2.InfoType] are strictly enforced when using
    /// this feature.
    ///
    /// Findings are persisted in Data Catalog storage and are governed by
    /// service-specific policies for Data Catalog. For more information, see
    /// [Service Specific Terms](https://cloud.google.com/terms/service-terms).
    ///
    /// Only a single instance of this action can be specified. This action is
    /// allowed only if all resources being scanned are BigQuery tables.
    /// Compatible with: Inspect
    ///
    /// [google.privacy.dlp.v2.InfoType]: crate::model::InfoType
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishFindingsToCloudDataCatalog {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishFindingsToCloudDataCatalog {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishFindingsToCloudDataCatalog {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishFindingsToCloudDataCatalog"
        }
    }

    /// Create a de-identified copy of the requested table or files.
    ///
    /// A TransformationDetail will be created for each transformation.
    ///
    /// If any rows in BigQuery are skipped during de-identification
    /// (transformation errors or row size exceeds BigQuery insert API limits) they
    /// are placed in the failure output table. If the original row exceeds
    /// the BigQuery insert API limit it will be truncated when written to the
    /// failure output table. The failure output table can be set in the
    /// action.deidentify.output.big_query_output.deidentified_failure_output_table
    /// field, if no table is set, a table will be automatically created in the
    /// same project and dataset as the original table.
    ///
    /// Compatible with: Inspect
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Deidentify {
        /// User specified deidentify templates and configs for structured,
        /// unstructured, and image files.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub transformation_config: std::option::Option<crate::model::TransformationConfig>,

        /// Config for storing transformation details. This is separate from the
        /// de-identified content, and contains metadata about the successful
        /// transformations and/or failures that occurred while de-identifying. This
        /// needs to be set in order for users to access information about the status
        /// of each transformation (see
        /// [TransformationDetails][google.privacy.dlp.v2.TransformationDetails]
        /// message for more information about what is noted).
        ///
        /// [google.privacy.dlp.v2.TransformationDetails]: crate::model::TransformationDetails
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub transformation_details_storage_config:
            std::option::Option<crate::model::TransformationDetailsStorageConfig>,

        /// List of user-specified file type groups to transform. If specified, only
        /// the files with these file types will be transformed. If empty, all
        /// supported files will be transformed. Supported types may be automatically
        /// added over time. If a file type is set in this field that isn't supported
        /// by the Deidentify action then the job will fail and will not be
        /// successfully created/started. Currently the only file types supported
        /// are: IMAGES, TEXT_FILES, CSV, TSV.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub file_types_to_transform: std::vec::Vec<crate::model::FileType>,

        /// Where to store the output.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub output: std::option::Option<crate::model::action::deidentify::Output>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Deidentify {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [transformation_config][crate::model::action::Deidentify::transformation_config].
        pub fn set_transformation_config<
            T: std::convert::Into<std::option::Option<crate::model::TransformationConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.transformation_config = v.into();
            self
        }

        /// Sets the value of [transformation_details_storage_config][crate::model::action::Deidentify::transformation_details_storage_config].
        pub fn set_transformation_details_storage_config<
            T: std::convert::Into<
                    std::option::Option<crate::model::TransformationDetailsStorageConfig>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.transformation_details_storage_config = v.into();
            self
        }

        /// Sets the value of [file_types_to_transform][crate::model::action::Deidentify::file_types_to_transform].
        pub fn set_file_types_to_transform<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FileType>,
        {
            use std::iter::Iterator;
            self.file_types_to_transform = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [output][crate::model::action::Deidentify::output].
        ///
        /// Note that all the setters affecting `output` are mutually
        /// exclusive.
        pub fn set_output<
            T: std::convert::Into<std::option::Option<crate::model::action::deidentify::Output>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.output = v.into();
            self
        }

        /// The value of [output][crate::model::action::Deidentify::output]
        /// if it holds a `CloudStorageOutput`, `None` if the field is not set or
        /// holds a different branch.
        pub fn cloud_storage_output(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.output.as_ref().and_then(|v| match v {
                crate::model::action::deidentify::Output::CloudStorageOutput(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [output][crate::model::action::Deidentify::output]
        /// to hold a `CloudStorageOutput`.
        ///
        /// Note that all the setters affecting `output` are
        /// mutually exclusive.
        pub fn set_cloud_storage_output<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.output = std::option::Option::Some(
                crate::model::action::deidentify::Output::CloudStorageOutput(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Deidentify {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.Deidentify"
        }
    }

    /// Defines additional types related to [Deidentify].
    pub mod deidentify {
        #[allow(unused_imports)]
        use super::*;

        /// Where to store the output.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Output {
            /// Required. User settable Cloud Storage bucket and folders to store
            /// de-identified files. This field must be set for Cloud Storage
            /// deidentification. The output Cloud Storage bucket must be different
            /// from the input bucket. De-identified files will overwrite files in the
            /// output path.
            ///
            /// Form of: gs://bucket/folder/ or gs://bucket
            CloudStorageOutput(std::string::String),
        }
    }

    /// Sends an email when the job completes. The email goes to IAM project owners
    /// and technical [Essential
    /// Contacts](https://cloud.google.com/resource-manager/docs/managing-notification-contacts).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct JobNotificationEmails {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl JobNotificationEmails {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for JobNotificationEmails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.JobNotificationEmails"
        }
    }

    /// Enable Stackdriver metric dlp.googleapis.com/finding_count. This
    /// will publish a metric to stack driver on each infotype requested and
    /// how many findings were found for it. CustomDetectors will be bucketed
    /// as 'Custom' under the Stackdriver label 'info_type'.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishToStackdriver {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishToStackdriver {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishToStackdriver {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishToStackdriver"
        }
    }

    /// Extra events to execute after the job has finished.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Action {
        /// Save resulting findings in a provided location.
        SaveFindings(std::boxed::Box<crate::model::action::SaveFindings>),
        /// Publish a notification to a Pub/Sub topic.
        PubSub(std::boxed::Box<crate::model::action::PublishToPubSub>),
        /// Publish summary to Cloud Security Command Center (Alpha).
        PublishSummaryToCscc(std::boxed::Box<crate::model::action::PublishSummaryToCscc>),
        /// Publish findings to Cloud Datahub.
        PublishFindingsToCloudDataCatalog(
            std::boxed::Box<crate::model::action::PublishFindingsToCloudDataCatalog>,
        ),
        /// Create a de-identified copy of the input data.
        Deidentify(std::boxed::Box<crate::model::action::Deidentify>),
        /// Sends an email when the job completes. The email goes to IAM project
        /// owners and technical [Essential
        /// Contacts](https://cloud.google.com/resource-manager/docs/managing-notification-contacts).
        JobNotificationEmails(std::boxed::Box<crate::model::action::JobNotificationEmails>),
        /// Enable Stackdriver metric dlp.googleapis.com/finding_count.
        PublishToStackdriver(std::boxed::Box<crate::model::action::PublishToStackdriver>),
    }
}

/// User specified templates and configs for how to deidentify structured,
/// unstructures, and image files. User must provide either a unstructured
/// deidentify template or at least one redact image config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationConfig {
    /// De-identify template.
    /// If this template is specified, it will serve as the default de-identify
    /// template. This template cannot contain `record_transformations` since it
    /// can be used for unstructured content such as free-form text files. If this
    /// template is not set, a default `ReplaceWithInfoTypeConfig` will be used to
    /// de-identify unstructured content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deidentify_template: std::string::String,

    /// Structured de-identify template.
    /// If this template is specified, it will serve as the de-identify template
    /// for structured content such as delimited files and tables. If this template
    /// is not set but the `deidentify_template` is set, then `deidentify_template`
    /// will also apply to the structured content. If neither template is set, a
    /// default `ReplaceWithInfoTypeConfig` will be used to de-identify structured
    /// content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub structured_deidentify_template: std::string::String,

    /// Image redact template.
    /// If this template is specified, it will serve as the de-identify template
    /// for images. If this template is not set, all findings in the image will be
    /// redacted with a black box.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_redact_template: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deidentify_template][crate::model::TransformationConfig::deidentify_template].
    pub fn set_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }

    /// Sets the value of [structured_deidentify_template][crate::model::TransformationConfig::structured_deidentify_template].
    pub fn set_structured_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.structured_deidentify_template = v.into();
        self
    }

    /// Sets the value of [image_redact_template][crate::model::TransformationConfig::image_redact_template].
    pub fn set_image_redact_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.image_redact_template = v.into();
        self
    }
}

impl wkt::message::Message for TransformationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationConfig"
    }
}

/// Request message for CreateInspectTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInspectTemplateRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The InspectTemplate to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template: std::option::Option<crate::model::InspectTemplate>,

    /// The template id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template_id: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInspectTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [inspect_template][crate::model::CreateInspectTemplateRequest::inspect_template].
    pub fn set_inspect_template<
        T: std::convert::Into<std::option::Option<crate::model::InspectTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template = v.into();
        self
    }

    /// Sets the value of [template_id][crate::model::CreateInspectTemplateRequest::template_id].
    pub fn set_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateInspectTemplateRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateInspectTemplateRequest"
    }
}

/// Request message for UpdateInspectTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInspectTemplateRequest {
    /// Required. Resource name of organization and inspectTemplate to be updated,
    /// for example `organizations/433245324/inspectTemplates/432452342` or
    /// projects/project-id/inspectTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// New InspectTemplate value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template: std::option::Option<crate::model::InspectTemplate>,

    /// Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateInspectTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [inspect_template][crate::model::UpdateInspectTemplateRequest::inspect_template].
    pub fn set_inspect_template<
        T: std::convert::Into<std::option::Option<crate::model::InspectTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInspectTemplateRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateInspectTemplateRequest"
    }
}

/// Request message for GetInspectTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInspectTemplateRequest {
    /// Required. Resource name of the organization and inspectTemplate to be read,
    /// for example `organizations/433245324/inspectTemplates/432452342` or
    /// projects/project-id/inspectTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInspectTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetInspectTemplateRequest"
    }
}

/// Request message for ListInspectTemplates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInspectTemplatesRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to `ListInspectTemplates`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero server
    /// returns a page of max size 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the template was created.
    /// - `update_time`: corresponds to the time the template was last updated.
    /// - `name`: corresponds to the template's name.
    /// - `display_name`: corresponds to the template's display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInspectTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInspectTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInspectTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInspectTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInspectTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListInspectTemplatesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListInspectTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInspectTemplatesRequest"
    }
}

/// Response message for ListInspectTemplates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInspectTemplatesResponse {
    /// List of inspectTemplates, up to page_size in ListInspectTemplatesRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inspect_templates: std::vec::Vec<crate::model::InspectTemplate>,

    /// If the next page is available then the next page token to be used in the
    /// following ListInspectTemplates request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInspectTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inspect_templates][crate::model::ListInspectTemplatesResponse::inspect_templates].
    pub fn set_inspect_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InspectTemplate>,
    {
        use std::iter::Iterator;
        self.inspect_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInspectTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInspectTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInspectTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInspectTemplatesResponse {
    type PageItem = crate::model::InspectTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.inspect_templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteInspectTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInspectTemplateRequest {
    /// Required. Resource name of the organization and inspectTemplate to be
    /// deleted, for example `organizations/433245324/inspectTemplates/432452342`
    /// or projects/project-id/inspectTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInspectTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteInspectTemplateRequest"
    }
}

/// Request message for CreateJobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateJobTriggerRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The JobTrigger to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_trigger: std::option::Option<crate::model::JobTrigger>,

    /// The trigger id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_id: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateJobTriggerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job_trigger][crate::model::CreateJobTriggerRequest::job_trigger].
    pub fn set_job_trigger<T: std::convert::Into<std::option::Option<crate::model::JobTrigger>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_trigger = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::CreateJobTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateJobTriggerRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateJobTriggerRequest"
    }
}

/// Request message for ActivateJobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ActivateJobTriggerRequest {
    /// Required. Resource name of the trigger to activate, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ActivateJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ActivateJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ActivateJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ActivateJobTriggerRequest"
    }
}

/// Request message for UpdateJobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateJobTriggerRequest {
    /// Required. Resource name of the project and the triggeredJob, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// New JobTrigger value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_trigger: std::option::Option<crate::model::JobTrigger>,

    /// Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [job_trigger][crate::model::UpdateJobTriggerRequest::job_trigger].
    pub fn set_job_trigger<T: std::convert::Into<std::option::Option<crate::model::JobTrigger>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_trigger = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateJobTriggerRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateJobTriggerRequest"
    }
}

/// Request message for GetJobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetJobTriggerRequest {
    /// Required. Resource name of the project and the triggeredJob, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetJobTriggerRequest"
    }
}

/// Request message for CreateDiscoveryConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDiscoveryConfigRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization):
    ///
    /// + Projects scope:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Organizations scope:
    ///   `organizations/{org_id}/locations/{location_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The DiscoveryConfig to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub discovery_config: std::option::Option<crate::model::DiscoveryConfig>,

    /// The config ID can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub config_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDiscoveryConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [discovery_config][crate::model::CreateDiscoveryConfigRequest::discovery_config].
    pub fn set_discovery_config<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_config = v.into();
        self
    }

    /// Sets the value of [config_id][crate::model::CreateDiscoveryConfigRequest::config_id].
    pub fn set_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateDiscoveryConfigRequest"
    }
}

/// Request message for UpdateDiscoveryConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDiscoveryConfigRequest {
    /// Required. Resource name of the project and the configuration, for example
    /// `projects/dlp-test-project/discoveryConfigs/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. New DiscoveryConfig value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub discovery_config: std::option::Option<crate::model::DiscoveryConfig>,

    /// Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateDiscoveryConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [discovery_config][crate::model::UpdateDiscoveryConfigRequest::discovery_config].
    pub fn set_discovery_config<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDiscoveryConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateDiscoveryConfigRequest"
    }
}

/// Request message for GetDiscoveryConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDiscoveryConfigRequest {
    /// Required. Resource name of the project and the configuration, for example
    /// `projects/dlp-test-project/discoveryConfigs/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDiscoveryConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetDiscoveryConfigRequest"
    }
}

/// Request message for ListDiscoveryConfigs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDiscoveryConfigsRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value is as follows:
    /// `projects/{project_id}/locations/{location_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to ListDiscoveryConfigs. `order_by` field must not
    /// change for subsequent calls.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by a server.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Comma-separated list of config fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `last_run_time`: corresponds to the last time the DiscoveryConfig ran.
    /// - `name`: corresponds to the DiscoveryConfig's name.
    /// - `status`: corresponds to DiscoveryConfig's status.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDiscoveryConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDiscoveryConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDiscoveryConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDiscoveryConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDiscoveryConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDiscoveryConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDiscoveryConfigsRequest"
    }
}

/// Response message for ListDiscoveryConfigs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDiscoveryConfigsResponse {
    /// List of configs, up to page_size in ListDiscoveryConfigsRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub discovery_configs: std::vec::Vec<crate::model::DiscoveryConfig>,

    /// If the next page is available then this value is the next page token to be
    /// used in the following ListDiscoveryConfigs request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDiscoveryConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [discovery_configs][crate::model::ListDiscoveryConfigsResponse::discovery_configs].
    pub fn set_discovery_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveryConfig>,
    {
        use std::iter::Iterator;
        self.discovery_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDiscoveryConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDiscoveryConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDiscoveryConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDiscoveryConfigsResponse {
    type PageItem = crate::model::DiscoveryConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.discovery_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteDiscoveryConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDiscoveryConfigRequest {
    /// Required. Resource name of the project and the config, for example
    /// `projects/dlp-test-project/discoveryConfigs/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDiscoveryConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteDiscoveryConfigRequest"
    }
}

/// Request message for CreateDlpJobRequest. Used to initiate long running
/// jobs such as calculating risk metrics or inspecting Google Cloud
/// Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDlpJobRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The job id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    /// The configuration details for the specific type of job to run.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::create_dlp_job_request::Job>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDlpJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::CreateDlpJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateDlpJobRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [job][crate::model::CreateDlpJobRequest::job].
    ///
    /// Note that all the setters affecting `job` are mutually
    /// exclusive.
    pub fn set_job<
        T: std::convert::Into<std::option::Option<crate::model::create_dlp_job_request::Job>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }

    /// The value of [job][crate::model::CreateDlpJobRequest::job]
    /// if it holds a `InspectJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inspect_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InspectJobConfig>> {
        #[allow(unreachable_patterns)]
        self.job.as_ref().and_then(|v| match v {
            crate::model::create_dlp_job_request::Job::InspectJob(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job][crate::model::CreateDlpJobRequest::job]
    /// to hold a `InspectJob`.
    ///
    /// Note that all the setters affecting `job` are
    /// mutually exclusive.
    pub fn set_inspect_job<
        T: std::convert::Into<std::boxed::Box<crate::model::InspectJobConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job = std::option::Option::Some(
            crate::model::create_dlp_job_request::Job::InspectJob(v.into()),
        );
        self
    }

    /// The value of [job][crate::model::CreateDlpJobRequest::job]
    /// if it holds a `RiskJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn risk_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RiskAnalysisJobConfig>> {
        #[allow(unreachable_patterns)]
        self.job.as_ref().and_then(|v| match v {
            crate::model::create_dlp_job_request::Job::RiskJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job][crate::model::CreateDlpJobRequest::job]
    /// to hold a `RiskJob`.
    ///
    /// Note that all the setters affecting `job` are
    /// mutually exclusive.
    pub fn set_risk_job<
        T: std::convert::Into<std::boxed::Box<crate::model::RiskAnalysisJobConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job =
            std::option::Option::Some(crate::model::create_dlp_job_request::Job::RiskJob(v.into()));
        self
    }
}

impl wkt::message::Message for CreateDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateDlpJobRequest"
    }
}

/// Defines additional types related to [CreateDlpJobRequest].
pub mod create_dlp_job_request {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration details for the specific type of job to run.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Job {
        /// An inspection job scans a storage repository for InfoTypes.
        InspectJob(std::boxed::Box<crate::model::InspectJobConfig>),
        /// A risk analysis job calculates re-identification risk metrics for a
        /// BigQuery table.
        RiskJob(std::boxed::Box<crate::model::RiskAnalysisJobConfig>),
    }
}

/// Request message for ListJobTriggers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobTriggersRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to ListJobTriggers. `order_by` field must not
    /// change for subsequent calls.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by a server.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Comma-separated list of triggeredJob fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the JobTrigger was created.
    /// - `update_time`: corresponds to the time the JobTrigger was last updated.
    /// - `last_run_time`: corresponds to the last time the JobTrigger ran.
    /// - `name`: corresponds to the JobTrigger's name.
    /// - `display_name`: corresponds to the JobTrigger's display name.
    /// - `status`: corresponds to JobTrigger's status.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values for inspect triggers:
    ///   - `status` - HEALTHY|PAUSED|CANCELLED
    ///   - `inspected_storage` - DATASTORE|CLOUD_STORAGE|BIGQUERY
    ///   - 'last_run_time` - RFC 3339 formatted timestamp, surrounded by
    ///     quotation marks. Nanoseconds are ignored.
    ///   - 'error_count' - Number of errors that have occurred while running.
    /// * The operator must be `=` or `!=` for status and inspected_storage.
    ///
    /// Examples:
    ///
    /// * inspected_storage = cloud_storage AND status = HEALTHY
    /// * inspected_storage = cloud_storage OR inspected_storage = bigquery
    /// * inspected_storage = cloud_storage AND (state = PAUSED OR state = HEALTHY)
    /// * last_run_time > \"2017-12-12T00:00:00+00:00\"
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The type of jobs. Will use `DlpJobType.INSPECT` if not set.
    #[serde(rename = "type")]
    pub r#type: crate::model::DlpJobType,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobTriggersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListJobTriggersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobTriggersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobTriggersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListJobTriggersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListJobTriggersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ListJobTriggersRequest::type].
    pub fn set_type<T: std::convert::Into<crate::model::DlpJobType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListJobTriggersRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListJobTriggersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListJobTriggersRequest"
    }
}

/// Response message for ListJobTriggers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobTriggersResponse {
    /// List of triggeredJobs, up to page_size in ListJobTriggersRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub job_triggers: std::vec::Vec<crate::model::JobTrigger>,

    /// If the next page is available then this value is the next page token to be
    /// used in the following ListJobTriggers request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobTriggersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_triggers][crate::model::ListJobTriggersResponse::job_triggers].
    pub fn set_job_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobTrigger>,
    {
        use std::iter::Iterator;
        self.job_triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListJobTriggersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListJobTriggersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListJobTriggersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobTriggersResponse {
    type PageItem = crate::model::JobTrigger;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.job_triggers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteJobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteJobTriggerRequest {
    /// Required. Resource name of the project and the triggeredJob, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteJobTriggerRequest"
    }
}

/// Controls what and how to inspect for findings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectJobConfig {
    /// The data to scan.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub storage_config: std::option::Option<crate::model::StorageConfig>,

    /// How and what to scan for.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// If provided, will be used as the default for all values in InspectConfig.
    /// `inspect_config` will be merged into the values persisted as part of the
    /// template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template_name: std::string::String,

    /// Actions to execute at the completion of the job.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub actions: std::vec::Vec<crate::model::Action>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InspectJobConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_config][crate::model::InspectJobConfig::storage_config].
    pub fn set_storage_config<
        T: std::convert::Into<std::option::Option<crate::model::StorageConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_config = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::InspectJobConfig::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::InspectJobConfig::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [actions][crate::model::InspectJobConfig::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Action>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InspectJobConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectJobConfig"
    }
}

/// A task to execute when a data profile has been generated.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileAction {
    /// Type of action to execute when a profile is generated.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub action: std::option::Option<crate::model::data_profile_action::Action>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action].
    ///
    /// Note that all the setters affecting `action` are mutually
    /// exclusive.
    pub fn set_action<
        T: std::convert::Into<std::option::Option<crate::model::data_profile_action::Action>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `ExportData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn export_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::Export>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::ExportData(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `ExportData`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_export_data<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::Export>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::ExportData(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `PubSubNotification`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pub_sub_notification(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::PubSubNotification>>
    {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::PubSubNotification(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `PubSubNotification`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_pub_sub_notification<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::PubSubNotification>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::PubSubNotification(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `PublishToChronicle`, `None` if the field is not set or
    /// holds a different branch.
    pub fn publish_to_chronicle(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::PublishToChronicle>>
    {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::PublishToChronicle(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `PublishToChronicle`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_to_chronicle<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::PublishToChronicle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::PublishToChronicle(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `PublishToScc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn publish_to_scc(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_profile_action::PublishToSecurityCommandCenter>,
    > {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::PublishToScc(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `PublishToScc`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_to_scc<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_profile_action::PublishToSecurityCommandCenter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::PublishToScc(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `TagResources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tag_resources(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::TagResources>>
    {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::TagResources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `TagResources`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_tag_resources<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::TagResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::TagResources(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataProfileAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction"
    }
}

/// Defines additional types related to [DataProfileAction].
pub mod data_profile_action {
    #[allow(unused_imports)]
    use super::*;

    /// If set, the detailed data profiles will be persisted to the location
    /// of your choice whenever updated.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Export {
        /// Store all profiles to BigQuery.
        ///
        /// * The system will create a new dataset and table for you if none are
        ///   are provided. The dataset will be named
        ///   `sensitive_data_protection_discovery` and table will be named
        ///   `discovery_profiles`. This table will be placed in the same project as
        ///   the container project running the scan. After the first profile is
        ///   generated and the dataset and table are created, the discovery scan
        ///   configuration will be updated with the dataset and table names.
        /// * See [Analyze data profiles stored in
        ///   BigQuery](https://cloud.google.com/sensitive-data-protection/docs/analyze-data-profiles).
        /// * See [Sample queries for your BigQuery
        ///   table](https://cloud.google.com/sensitive-data-protection/docs/analyze-data-profiles#sample_sql_queries).
        /// * Data is inserted using [streaming
        ///   insert](https://cloud.google.com/blog/products/bigquery/life-of-a-bigquery-streaming-insert)
        ///   and so data may be in the buffer for a period of time after the
        ///   profile has finished.
        /// * The Pub/Sub notification is sent before the streaming buffer is
        ///   guaranteed to be written, so data may not be instantly
        ///   visible to queries by the time your topic receives the Pub/Sub
        ///   notification.
        /// * The best practice is to use the same table for an entire organization
        ///   so that you can take advantage of the [provided Looker
        ///   reports](https://cloud.google.com/sensitive-data-protection/docs/analyze-data-profiles#use_a_premade_report).
        ///   If you use VPC Service Controls to define security perimeters, then
        ///   you must use a separate table for each boundary.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub profile_table: std::option::Option<crate::model::BigQueryTable>,

        /// Store sample [data profile
        /// findings][google.privacy.dlp.v2.DataProfileFinding] in an existing table
        /// or a new table in an existing dataset. Each regeneration will result in
        /// new rows in BigQuery. Data is inserted using [streaming
        /// insert](https://cloud.google.com/blog/products/bigquery/life-of-a-bigquery-streaming-insert)
        /// and so data may be in the buffer for a period of time after the profile
        /// has finished.
        ///
        /// [google.privacy.dlp.v2.DataProfileFinding]: crate::model::DataProfileFinding
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub sample_findings_table: std::option::Option<crate::model::BigQueryTable>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Export {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [profile_table][crate::model::data_profile_action::Export::profile_table].
        pub fn set_profile_table<
            T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.profile_table = v.into();
            self
        }

        /// Sets the value of [sample_findings_table][crate::model::data_profile_action::Export::sample_findings_table].
        pub fn set_sample_findings_table<
            T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.sample_findings_table = v.into();
            self
        }
    }

    impl wkt::message::Message for Export {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.Export"
        }
    }

    /// Send a Pub/Sub message into the given Pub/Sub topic to connect other
    /// systems to data profile generation. The message payload data will
    /// be the byte serialization of `DataProfilePubSubMessage`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PubSubNotification {
        /// Cloud Pub/Sub topic to send notifications to.
        /// Format is projects/{project}/topics/{topic}.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub topic: std::string::String,

        /// The type of event that triggers a Pub/Sub. At most one
        /// `PubSubNotification` per EventType is permitted.
        pub event: crate::model::data_profile_action::EventType,

        /// Conditions (e.g., data risk or sensitivity level) for triggering a
        /// Pub/Sub.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub pubsub_condition: std::option::Option<crate::model::DataProfilePubSubCondition>,

        /// How much data to include in the Pub/Sub message. If the user wishes to
        /// limit the size of the message, they can use resource_name and fetch the
        /// profile fields they wish to. Per table profile (not per column).
        pub detail_of_message: crate::model::data_profile_action::pub_sub_notification::DetailLevel,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PubSubNotification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [topic][crate::model::data_profile_action::PubSubNotification::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }

        /// Sets the value of [event][crate::model::data_profile_action::PubSubNotification::event].
        pub fn set_event<T: std::convert::Into<crate::model::data_profile_action::EventType>>(
            mut self,
            v: T,
        ) -> Self {
            self.event = v.into();
            self
        }

        /// Sets the value of [pubsub_condition][crate::model::data_profile_action::PubSubNotification::pubsub_condition].
        pub fn set_pubsub_condition<
            T: std::convert::Into<std::option::Option<crate::model::DataProfilePubSubCondition>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.pubsub_condition = v.into();
            self
        }

        /// Sets the value of [detail_of_message][crate::model::data_profile_action::PubSubNotification::detail_of_message].
        pub fn set_detail_of_message<
            T: std::convert::Into<
                    crate::model::data_profile_action::pub_sub_notification::DetailLevel,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.detail_of_message = v.into();
            self
        }
    }

    impl wkt::message::Message for PubSubNotification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.PubSubNotification"
        }
    }

    /// Defines additional types related to [PubSubNotification].
    pub mod pub_sub_notification {
        #[allow(unused_imports)]
        use super::*;

        /// The levels of detail that can be included in the Pub/Sub message.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum DetailLevel {
            /// Unused.
            Unspecified,
            /// The full table data profile.
            TableProfile,
            /// The name of the profiled resource.
            ResourceName,
            /// The full file store data profile.
            FileStoreProfile,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [DetailLevel::value] or
            /// [DetailLevel::name].
            UnknownValue(detail_level::UnknownValue),
        }

        #[doc(hidden)]
        pub mod detail_level {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl DetailLevel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::TableProfile => std::option::Option::Some(1),
                    Self::ResourceName => std::option::Option::Some(2),
                    Self::FileStoreProfile => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("DETAIL_LEVEL_UNSPECIFIED"),
                    Self::TableProfile => std::option::Option::Some("TABLE_PROFILE"),
                    Self::ResourceName => std::option::Option::Some("RESOURCE_NAME"),
                    Self::FileStoreProfile => std::option::Option::Some("FILE_STORE_PROFILE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for DetailLevel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for DetailLevel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for DetailLevel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::TableProfile,
                    2 => Self::ResourceName,
                    3 => Self::FileStoreProfile,
                    _ => Self::UnknownValue(detail_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for DetailLevel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "DETAIL_LEVEL_UNSPECIFIED" => Self::Unspecified,
                    "TABLE_PROFILE" => Self::TableProfile,
                    "RESOURCE_NAME" => Self::ResourceName,
                    "FILE_STORE_PROFILE" => Self::FileStoreProfile,
                    _ => Self::UnknownValue(detail_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for DetailLevel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::TableProfile => serializer.serialize_i32(1),
                    Self::ResourceName => serializer.serialize_i32(2),
                    Self::FileStoreProfile => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for DetailLevel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<DetailLevel>::new(
                    ".google.privacy.dlp.v2.DataProfileAction.PubSubNotification.DetailLevel",
                ))
            }
        }
    }

    /// Message expressing intention to publish to Google Security Operations.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishToChronicle {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishToChronicle {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishToChronicle {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.PublishToChronicle"
        }
    }

    /// If set, a summary finding will be created or updated in Security Command
    /// Center for each profile.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishToSecurityCommandCenter {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishToSecurityCommandCenter {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishToSecurityCommandCenter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.PublishToSecurityCommandCenter"
        }
    }

    /// If set, attaches the [tags]
    /// (<https://cloud.google.com/resource-manager/docs/tags/tags-overview>)
    /// provided to profiled resources. Tags support [access
    /// control](https://cloud.google.com/iam/docs/tags-access-control). You can
    /// conditionally grant or deny access to a resource based on whether the
    /// resource has a specific tag.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TagResources {
        /// The tags to associate with different conditions.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub tag_conditions:
            std::vec::Vec<crate::model::data_profile_action::tag_resources::TagCondition>,

        /// The profile generations for which the tag should be attached to
        /// resources. If you attach a tag to only new profiles, then if the
        /// sensitivity score of a profile subsequently changes, its tag doesn't
        /// change. By default, this field includes only new profiles. To include
        /// both new and updated profiles for tagging, this field should explicitly
        /// include both `PROFILE_GENERATION_NEW` and `PROFILE_GENERATION_UPDATE`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub profile_generations_to_tag: std::vec::Vec<crate::model::ProfileGeneration>,

        /// Whether applying a tag to a resource should lower the risk of the profile
        /// for that resource. For example, in conjunction with an [IAM deny
        /// policy](https://cloud.google.com/iam/docs/deny-overview), you can deny
        /// all principals a permission if a tag value is present, mitigating the
        /// risk of the resource. This also lowers the data risk of resources at the
        /// lower levels of the resource hierarchy. For example, reducing the data
        /// risk of a table data profile also reduces the data risk of the
        /// constituent column data profiles.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub lower_data_risk_to_low: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TagResources {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tag_conditions][crate::model::data_profile_action::TagResources::tag_conditions].
        pub fn set_tag_conditions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::data_profile_action::tag_resources::TagCondition>,
        {
            use std::iter::Iterator;
            self.tag_conditions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [profile_generations_to_tag][crate::model::data_profile_action::TagResources::profile_generations_to_tag].
        pub fn set_profile_generations_to_tag<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ProfileGeneration>,
        {
            use std::iter::Iterator;
            self.profile_generations_to_tag = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [lower_data_risk_to_low][crate::model::data_profile_action::TagResources::lower_data_risk_to_low].
        pub fn set_lower_data_risk_to_low<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.lower_data_risk_to_low = v.into();
            self
        }
    }

    impl wkt::message::Message for TagResources {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.TagResources"
        }
    }

    /// Defines additional types related to [TagResources].
    pub mod tag_resources {
        #[allow(unused_imports)]
        use super::*;

        /// The tag to attach to profiles matching the condition. At most one
        /// `TagCondition` can be specified per sensitivity level.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TagCondition {
            /// The tag value to attach to resources.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub tag:
                std::option::Option<crate::model::data_profile_action::tag_resources::TagValue>,

            /// The type of condition on which attaching the tag will be predicated.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub r#type: std::option::Option<
                crate::model::data_profile_action::tag_resources::tag_condition::Type,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TagCondition {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [tag][crate::model::data_profile_action::tag_resources::TagCondition::tag].
            pub fn set_tag<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::data_profile_action::tag_resources::TagValue,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.tag = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::data_profile_action::tag_resources::TagCondition::type].
            ///
            /// Note that all the setters affecting `r#type` are mutually
            /// exclusive.
            pub fn set_type<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::data_profile_action::tag_resources::tag_condition::Type,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// The value of [r#type][crate::model::data_profile_action::tag_resources::TagCondition::r#type]
            /// if it holds a `SensitivityScore`, `None` if the field is not set or
            /// holds a different branch.
            pub fn sensitivity_score(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::SensitivityScore>> {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::data_profile_action::tag_resources::tag_condition::Type::SensitivityScore(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::data_profile_action::tag_resources::TagCondition::r#type]
            /// to hold a `SensitivityScore`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_sensitivity_score<
                T: std::convert::Into<std::boxed::Box<crate::model::SensitivityScore>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::data_profile_action::tag_resources::tag_condition::Type::SensitivityScore(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for TagCondition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.TagResources.TagCondition"
            }
        }

        /// Defines additional types related to [TagCondition].
        pub mod tag_condition {
            #[allow(unused_imports)]
            use super::*;

            /// The type of condition on which attaching the tag will be predicated.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Type {
                /// Conditions attaching the tag to a resource on its profile having this
                /// sensitivity score.
                SensitivityScore(std::boxed::Box<crate::model::SensitivityScore>),
            }
        }

        /// A value of a tag.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TagValue {
            /// The format of the tag value.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub format: std::option::Option<
                crate::model::data_profile_action::tag_resources::tag_value::Format,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TagValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [format][crate::model::data_profile_action::tag_resources::TagValue::format].
            ///
            /// Note that all the setters affecting `format` are mutually
            /// exclusive.
            pub fn set_format<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::data_profile_action::tag_resources::tag_value::Format,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.format = v.into();
                self
            }

            /// The value of [format][crate::model::data_profile_action::tag_resources::TagValue::format]
            /// if it holds a `NamespacedValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn namespaced_value(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.format.as_ref().and_then(|v| match v {
                    crate::model::data_profile_action::tag_resources::tag_value::Format::NamespacedValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [format][crate::model::data_profile_action::tag_resources::TagValue::format]
            /// to hold a `NamespacedValue`.
            ///
            /// Note that all the setters affecting `format` are
            /// mutually exclusive.
            pub fn set_namespaced_value<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.format = std::option::Option::Some(
                    crate::model::data_profile_action::tag_resources::tag_value::Format::NamespacedValue(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for TagValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.TagResources.TagValue"
            }
        }

        /// Defines additional types related to [TagValue].
        pub mod tag_value {
            #[allow(unused_imports)]
            use super::*;

            /// The format of the tag value.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Format {
                /// The namespaced name for the tag value to attach to resources. Must be
                /// in the format `{parent_id}/{tag_key_short_name}/{short_name}`, for
                /// example, "123456/environment/prod".
                NamespacedValue(std::string::String),
            }
        }
    }

    /// Types of event that can trigger an action.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// Unused.
        Unspecified,
        /// New profile (not a re-profile).
        NewProfile,
        /// One of the following profile metrics changed: Data risk score,
        /// Sensitivity score, Resource visibility, Encryption type, Predicted
        /// infoTypes, Other infoTypes
        ChangedProfile,
        /// Table data risk score or sensitivity score increased.
        ScoreIncreased,
        /// A user (non-internal) error occurred.
        ErrorChanged,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NewProfile => std::option::Option::Some(1),
                Self::ChangedProfile => std::option::Option::Some(2),
                Self::ScoreIncreased => std::option::Option::Some(3),
                Self::ErrorChanged => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::NewProfile => std::option::Option::Some("NEW_PROFILE"),
                Self::ChangedProfile => std::option::Option::Some("CHANGED_PROFILE"),
                Self::ScoreIncreased => std::option::Option::Some("SCORE_INCREASED"),
                Self::ErrorChanged => std::option::Option::Some("ERROR_CHANGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NewProfile,
                2 => Self::ChangedProfile,
                3 => Self::ScoreIncreased,
                4 => Self::ErrorChanged,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NEW_PROFILE" => Self::NewProfile,
                "CHANGED_PROFILE" => Self::ChangedProfile,
                "SCORE_INCREASED" => Self::ScoreIncreased,
                "ERROR_CHANGED" => Self::ErrorChanged,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NewProfile => serializer.serialize_i32(1),
                Self::ChangedProfile => serializer.serialize_i32(2),
                Self::ScoreIncreased => serializer.serialize_i32(3),
                Self::ErrorChanged => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.privacy.dlp.v2.DataProfileAction.EventType",
            ))
        }
    }

    /// Type of action to execute when a profile is generated.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Action {
        /// Export data profiles into a provided location.
        ExportData(std::boxed::Box<crate::model::data_profile_action::Export>),
        /// Publish a message into the Pub/Sub topic.
        PubSubNotification(std::boxed::Box<crate::model::data_profile_action::PubSubNotification>),
        /// Publishes generated data profiles to Google Security Operations.
        /// For more information, see [Use Sensitive Data Protection data in
        /// context-aware
        /// analytics](https://cloud.google.com/chronicle/docs/detection/usecase-dlp-high-risk-user-download).
        PublishToChronicle(std::boxed::Box<crate::model::data_profile_action::PublishToChronicle>),
        /// Publishes findings to Security Command Center for each data profile.
        PublishToScc(
            std::boxed::Box<crate::model::data_profile_action::PublishToSecurityCommandCenter>,
        ),
        /// Tags the profiled resources with the specified tag values.
        TagResources(std::boxed::Box<crate::model::data_profile_action::TagResources>),
    }
}

/// Details about a piece of potentially sensitive information that was detected
/// when the data resource was profiled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileFinding {
    /// The content that was found. Even if the content is not textual, it
    /// may be converted to a textual representation here. If the finding exceeds
    /// 4096 bytes in length, the quote may be omitted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub quote: std::string::String,

    /// The [type of
    /// content](https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference)
    /// that might have been found.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub infotype: std::option::Option<crate::model::InfoType>,

    /// Contains data parsed from quotes. Currently supported infoTypes: DATE,
    /// DATE_OF_BIRTH, and TIME.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quote_info: std::option::Option<crate::model::QuoteInfo>,

    /// Resource name of the data profile associated with the finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_profile_resource_name: std::string::String,

    /// A unique identifier for the finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub finding_id: std::string::String,

    /// Timestamp when the finding was detected.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timestamp: std::option::Option<wkt::Timestamp>,

    /// Where the content was found.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::DataProfileFindingLocation>,

    /// How broadly a resource has been shared.
    pub resource_visibility: crate::model::ResourceVisibility,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileFinding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quote][crate::model::DataProfileFinding::quote].
    pub fn set_quote<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.quote = v.into();
        self
    }

    /// Sets the value of [infotype][crate::model::DataProfileFinding::infotype].
    pub fn set_infotype<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.infotype = v.into();
        self
    }

    /// Sets the value of [quote_info][crate::model::DataProfileFinding::quote_info].
    pub fn set_quote_info<T: std::convert::Into<std::option::Option<crate::model::QuoteInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.quote_info = v.into();
        self
    }

    /// Sets the value of [data_profile_resource_name][crate::model::DataProfileFinding::data_profile_resource_name].
    pub fn set_data_profile_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile_resource_name = v.into();
        self
    }

    /// Sets the value of [finding_id][crate::model::DataProfileFinding::finding_id].
    pub fn set_finding_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_id = v.into();
        self
    }

    /// Sets the value of [timestamp][crate::model::DataProfileFinding::timestamp].
    pub fn set_timestamp<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timestamp = v.into();
        self
    }

    /// Sets the value of [location][crate::model::DataProfileFinding::location].
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::DataProfileFindingLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [resource_visibility][crate::model::DataProfileFinding::resource_visibility].
    pub fn set_resource_visibility<T: std::convert::Into<crate::model::ResourceVisibility>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_visibility = v.into();
        self
    }
}

impl wkt::message::Message for DataProfileFinding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileFinding"
    }
}

/// Location of a data profile finding within a resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileFindingLocation {
    /// Name of the container where the finding is located.
    /// The top-level name is the source file name or table name. Names of some
    /// common storage containers are formatted as follows:
    ///
    /// * BigQuery tables:  `{project_id}:{dataset_id}.{table_id}`
    /// * Cloud Storage files: `gs://{bucket}/{path}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_name: std::string::String,

    /// Additional location details that may be provided for some types of
    /// profiles. At this time, only findings for table data profiles include such
    /// details.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location_extra_details:
        std::option::Option<crate::model::data_profile_finding_location::LocationExtraDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileFindingLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_name][crate::model::DataProfileFindingLocation::container_name].
    pub fn set_container_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_name = v.into();
        self
    }

    /// Sets the value of [location_extra_details][crate::model::DataProfileFindingLocation::location_extra_details].
    ///
    /// Note that all the setters affecting `location_extra_details` are mutually
    /// exclusive.
    pub fn set_location_extra_details<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::data_profile_finding_location::LocationExtraDetails,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_extra_details = v.into();
        self
    }

    /// The value of [location_extra_details][crate::model::DataProfileFindingLocation::location_extra_details]
    /// if it holds a `DataProfileFindingRecordLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_finding_record_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataProfileFindingRecordLocation>> {
        #[allow(unreachable_patterns)]
        self.location_extra_details.as_ref().and_then(|v| match v {
            crate::model::data_profile_finding_location::LocationExtraDetails::DataProfileFindingRecordLocation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location_extra_details][crate::model::DataProfileFindingLocation::location_extra_details]
    /// to hold a `DataProfileFindingRecordLocation`.
    ///
    /// Note that all the setters affecting `location_extra_details` are
    /// mutually exclusive.
    pub fn set_data_profile_finding_record_location<
        T: std::convert::Into<std::boxed::Box<crate::model::DataProfileFindingRecordLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_extra_details = std::option::Option::Some(
            crate::model::data_profile_finding_location::LocationExtraDetails::DataProfileFindingRecordLocation(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for DataProfileFindingLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileFindingLocation"
    }
}

/// Defines additional types related to [DataProfileFindingLocation].
pub mod data_profile_finding_location {
    #[allow(unused_imports)]
    use super::*;

    /// Additional location details that may be provided for some types of
    /// profiles. At this time, only findings for table data profiles include such
    /// details.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum LocationExtraDetails {
        /// Location of a finding within a resource that produces a table data
        /// profile.
        DataProfileFindingRecordLocation(
            std::boxed::Box<crate::model::DataProfileFindingRecordLocation>,
        ),
    }
}

/// Location of a finding within a resource that produces a table data profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileFindingRecordLocation {
    /// Field ID of the column containing the finding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<crate::model::FieldId>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileFindingRecordLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::DataProfileFindingRecordLocation::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }
}

impl wkt::message::Message for DataProfileFindingRecordLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileFindingRecordLocation"
    }
}

/// Configuration for setting up a job to scan resources for profile generation.
/// Only one data profile configuration may exist per organization, folder,
/// or project.
///
/// The generated data profiles are retained according to the
/// [data retention policy]
/// (<https://cloud.google.com/sensitive-data-protection/docs/data-profiles#retention>).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileJobConfig {
    /// The data to scan.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::DataProfileLocation>,

    /// The project that will run the scan. The DLP service
    /// account that exists within this project must have access to all resources
    /// that are profiled, and the DLP API must be enabled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Must be set only when scanning other clouds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub other_cloud_starting_location:
        std::option::Option<crate::model::OtherCloudDiscoveryStartingLocation>,

    /// Detection logic for profile generation.
    ///
    /// Not all template features are used by profiles. FindingLimits,
    /// include_quote and exclude_info_types have no impact on
    /// data profiling.
    ///
    /// Multiple templates may be provided if there is data in multiple regions.
    /// At most one template must be specified per-region (including "global").
    /// Each region is scanned using the applicable template. If no region-specific
    /// template is specified, but a "global" template is specified, it will be
    /// copied to that region and used instead. If no global or region-specific
    /// template is provided for a region with data, that region's data will not be
    /// scanned.
    ///
    /// For more information, see
    /// <https://cloud.google.com/sensitive-data-protection/docs/data-profiles#data-residency>.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inspect_templates: std::vec::Vec<std::string::String>,

    /// Actions to execute at the completion of the job.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_profile_actions: std::vec::Vec<crate::model::DataProfileAction>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileJobConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::DataProfileJobConfig::location].
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::DataProfileLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DataProfileJobConfig::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [other_cloud_starting_location][crate::model::DataProfileJobConfig::other_cloud_starting_location].
    pub fn set_other_cloud_starting_location<
        T: std::convert::Into<std::option::Option<crate::model::OtherCloudDiscoveryStartingLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.other_cloud_starting_location = v.into();
        self
    }

    /// Sets the value of [inspect_templates][crate::model::DataProfileJobConfig::inspect_templates].
    pub fn set_inspect_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.inspect_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_profile_actions][crate::model::DataProfileJobConfig::data_profile_actions].
    pub fn set_data_profile_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataProfileAction>,
    {
        use std::iter::Iterator;
        self.data_profile_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DataProfileJobConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileJobConfig"
    }
}

/// A pattern to match against one or more tables, datasets, or projects that
/// contain BigQuery tables. At least one pattern must be specified.
/// Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryRegex {
    /// For organizations, if unset, will match all projects. Has no effect
    /// for data profile configurations created within a project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id_regex: std::string::String,

    /// If unset, this property matches all datasets.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id_regex: std::string::String,

    /// If unset, this property matches all tables.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id_regex: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::BigQueryRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }

    /// Sets the value of [dataset_id_regex][crate::model::BigQueryRegex::dataset_id_regex].
    pub fn set_dataset_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_id_regex = v.into();
        self
    }

    /// Sets the value of [table_id_regex][crate::model::BigQueryRegex::table_id_regex].
    pub fn set_table_id_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id_regex = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryRegex"
    }
}

/// A collection of regular expressions to determine what tables to match
/// against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryRegexes {
    /// A single BigQuery regular expression pattern to match against one or more
    /// tables, datasets, or projects that contain BigQuery tables.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patterns: std::vec::Vec<crate::model::BigQueryRegex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::BigQueryRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQueryRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryRegexes"
    }
}

/// The types of BigQuery tables supported by Cloud DLP.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryTableTypes {
    /// A set of BigQuery table types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub types: std::vec::Vec<crate::model::BigQueryTableType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryTableTypes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [types][crate::model::BigQueryTableTypes::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQueryTableType>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryTableTypes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryTableTypes"
    }
}

/// Do not profile the tables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Disabled {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Disabled {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for Disabled {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Disabled"
    }
}

/// The data that will be profiled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileLocation {
    /// The location to be scanned.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::data_profile_location::Location>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::DataProfileLocation::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::data_profile_location::Location>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::DataProfileLocation::location]
    /// if it holds a `OrganizationId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn organization_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::data_profile_location::Location::OrganizationId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::DataProfileLocation::location]
    /// to hold a `OrganizationId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_organization_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::data_profile_location::Location::OrganizationId(v.into()),
        );
        self
    }

    /// The value of [location][crate::model::DataProfileLocation::location]
    /// if it holds a `FolderId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn folder_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::data_profile_location::Location::FolderId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::DataProfileLocation::location]
    /// to hold a `FolderId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::data_profile_location::Location::FolderId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataProfileLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileLocation"
    }
}

/// Defines additional types related to [DataProfileLocation].
pub mod data_profile_location {
    #[allow(unused_imports)]
    use super::*;

    /// The location to be scanned.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Location {
        /// The ID of an organization to scan.
        OrganizationId(i64),
        /// The ID of the folder within an organization to scan.
        FolderId(i64),
    }
}

/// Configuration for discovery to scan resources for profile generation.
/// Only one discovery configuration may exist per organization, folder,
/// or project.
///
/// The generated data profiles are retained according to the
/// [data retention policy]
/// (<https://cloud.google.com/sensitive-data-protection/docs/data-profiles#retention>).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryConfig {
    /// Unique resource name for the DiscoveryConfig, assigned by the service when
    /// the DiscoveryConfig is created, for example
    /// `projects/dlp-test-project/locations/global/discoveryConfigs/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Display name (max 100 chars)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Only set when the parent is an org.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub org_config: std::option::Option<crate::model::discovery_config::OrgConfig>,

    /// Must be set only when scanning other clouds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub other_cloud_starting_location:
        std::option::Option<crate::model::OtherCloudDiscoveryStartingLocation>,

    /// Detection logic for profile generation.
    ///
    /// Not all template features are used by Discovery. FindingLimits,
    /// include_quote and exclude_info_types have no impact on
    /// Discovery.
    ///
    /// Multiple templates may be provided if there is data in multiple regions.
    /// At most one template must be specified per-region (including "global").
    /// Each region is scanned using the applicable template. If no region-specific
    /// template is specified, but a "global" template is specified, it will be
    /// copied to that region and used instead. If no global or region-specific
    /// template is provided for a region with data, that region's data will not be
    /// scanned.
    ///
    /// For more information, see
    /// <https://cloud.google.com/sensitive-data-protection/docs/data-profiles#data-residency>.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inspect_templates: std::vec::Vec<std::string::String>,

    /// Actions to execute at the completion of scanning.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub actions: std::vec::Vec<crate::model::DataProfileAction>,

    /// Target to match against for determining what to scan and how frequently.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub targets: std::vec::Vec<crate::model::DiscoveryTarget>,

    /// Output only. A stream of errors encountered when the config was activated.
    /// Repeated errors may result in the config automatically being paused. Output
    /// only field. Will return the last 100 errors. Whenever the config is
    /// modified this list will be cleared.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Output only. The creation timestamp of a DiscoveryConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of a DiscoveryConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the last time this config was executed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_run_time: std::option::Option<wkt::Timestamp>,

    /// Required. A status for this configuration.
    pub status: crate::model::discovery_config::Status,

    /// Optional. Processing location configuration. Vertex AI dataset scanning
    /// will set processing_location.image_fallback_type to MultiRegionProcessing
    /// by default.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub processing_location: std::option::Option<crate::model::ProcessingLocation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiscoveryConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DiscoveryConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [org_config][crate::model::DiscoveryConfig::org_config].
    pub fn set_org_config<
        T: std::convert::Into<std::option::Option<crate::model::discovery_config::OrgConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.org_config = v.into();
        self
    }

    /// Sets the value of [other_cloud_starting_location][crate::model::DiscoveryConfig::other_cloud_starting_location].
    pub fn set_other_cloud_starting_location<
        T: std::convert::Into<std::option::Option<crate::model::OtherCloudDiscoveryStartingLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.other_cloud_starting_location = v.into();
        self
    }

    /// Sets the value of [inspect_templates][crate::model::DiscoveryConfig::inspect_templates].
    pub fn set_inspect_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.inspect_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [actions][crate::model::DiscoveryConfig::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataProfileAction>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [targets][crate::model::DiscoveryConfig::targets].
    pub fn set_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveryTarget>,
    {
        use std::iter::Iterator;
        self.targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors][crate::model::DiscoveryConfig::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::DiscoveryConfig::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DiscoveryConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [last_run_time][crate::model::DiscoveryConfig::last_run_time].
    pub fn set_last_run_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_run_time = v.into();
        self
    }

    /// Sets the value of [status][crate::model::DiscoveryConfig::status].
    pub fn set_status<T: std::convert::Into<crate::model::discovery_config::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [processing_location][crate::model::DiscoveryConfig::processing_location].
    pub fn set_processing_location<
        T: std::convert::Into<std::option::Option<crate::model::ProcessingLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.processing_location = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryConfig"
    }
}

/// Defines additional types related to [DiscoveryConfig].
pub mod discovery_config {
    #[allow(unused_imports)]
    use super::*;

    /// Project and scan location information. Only set when the parent is an org.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OrgConfig {
        /// The data to scan: folder, org, or project
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub location: std::option::Option<crate::model::DiscoveryStartingLocation>,

        /// The project that will run the scan. The DLP service
        /// account that exists within this project must have access to all resources
        /// that are profiled, and the DLP API must be enabled.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub project_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OrgConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [location][crate::model::discovery_config::OrgConfig::location].
        pub fn set_location<
            T: std::convert::Into<std::option::Option<crate::model::DiscoveryStartingLocation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [project_id][crate::model::discovery_config::OrgConfig::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }
    }

    impl wkt::message::Message for OrgConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryConfig.OrgConfig"
        }
    }

    /// Whether the discovery config is currently active. New options may be added
    /// at a later time.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Unused
        Unspecified,
        /// The discovery config is currently active.
        Running,
        /// The discovery config is paused temporarily.
        Paused,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Paused,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.privacy.dlp.v2.DiscoveryConfig.Status",
            ))
        }
    }
}

/// Target used to match against for Discovery.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryTarget {
    /// A target to match against for Discovery.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::discovery_target::Target>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::discovery_target::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `BigQueryTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::BigQueryTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `BigQueryTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_big_query_target<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::BigQueryTarget(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `CloudSqlTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::CloudSqlTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `CloudSqlTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_cloud_sql_target<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::CloudSqlTarget(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `SecretsTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secrets_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SecretsDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::SecretsTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `SecretsTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_secrets_target<
        T: std::convert::Into<std::boxed::Box<crate::model::SecretsDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::SecretsTarget(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `CloudStorageTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::CloudStorageTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `CloudStorageTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_cloud_storage_target<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::CloudStorageTarget(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `OtherCloudTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn other_cloud_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::OtherCloudTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `OtherCloudTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_other_cloud_target<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::OtherCloudTarget(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `VertexDatasetTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_dataset_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::VertexDatasetTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `VertexDatasetTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_target<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::VertexDatasetTarget(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryTarget"
    }
}

/// Defines additional types related to [DiscoveryTarget].
pub mod discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// A target to match against for Discovery.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Target {
        /// BigQuery target for Discovery. The first target to match a table will be
        /// the one applied.
        BigQueryTarget(std::boxed::Box<crate::model::BigQueryDiscoveryTarget>),
        /// Cloud SQL target for Discovery. The first target to match a table will be
        /// the one applied.
        CloudSqlTarget(std::boxed::Box<crate::model::CloudSqlDiscoveryTarget>),
        /// Discovery target that looks for credentials and secrets stored in cloud
        /// resource metadata and reports them as vulnerabilities to Security Command
        /// Center. Only one target of this type is allowed.
        SecretsTarget(std::boxed::Box<crate::model::SecretsDiscoveryTarget>),
        /// Cloud Storage target for Discovery. The first target to match a table
        /// will be the one applied.
        CloudStorageTarget(std::boxed::Box<crate::model::CloudStorageDiscoveryTarget>),
        /// Other clouds target for discovery. The first target to match a resource
        /// will be the one applied.
        OtherCloudTarget(std::boxed::Box<crate::model::OtherCloudDiscoveryTarget>),
        /// Vertex AI dataset target for Discovery. The first target to match a
        /// dataset will be the one applied. Note that discovery for Vertex AI can
        /// incur Cloud Storage Class B operation charges for storage.objects.get
        /// operations and retrieval fees. For more information, see [Cloud Storage
        /// pricing](https://cloud.google.com/storage/pricing#price-tables).
        /// Note that discovery for Vertex AI dataset will not be able to scan images
        /// unless DiscoveryConfig.processing_location.image_fallback_location has
        /// multi_region_processing or global_processing configured.
        VertexDatasetTarget(std::boxed::Box<crate::model::VertexDatasetDiscoveryTarget>),
    }
}

/// Target used to match against for discovery with BigQuery tables
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryDiscoveryTarget {
    /// Required. The tables the discovery cadence applies to. The first target
    /// with a matching filter will be the one to apply to a table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::DiscoveryBigQueryFilter>,

    /// In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::DiscoveryBigQueryConditions>,

    /// The generation rule includes the logic on how frequently
    /// to update the data profiles. If not specified, discovery will re-run and
    /// update no more than once a month if new columns appear in the table.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub frequency: std::option::Option<crate::model::big_query_discovery_target::Frequency>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::BigQueryDiscoveryTarget::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryBigQueryFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::BigQueryDiscoveryTarget::conditions].
    pub fn set_conditions<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryBigQueryConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// Sets the value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency].
    ///
    /// Note that all the setters affecting `frequency` are mutually
    /// exclusive.
    pub fn set_frequency<
        T: std::convert::Into<
                std::option::Option<crate::model::big_query_discovery_target::Frequency>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }

    /// The value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// if it holds a `Cadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryGenerationCadence>> {
        #[allow(unreachable_patterns)]
        self.frequency.as_ref().and_then(|v| match v {
            crate::model::big_query_discovery_target::Frequency::Cadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// to hold a `Cadence`.
    ///
    /// Note that all the setters affecting `frequency` are
    /// mutually exclusive.
    pub fn set_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = std::option::Option::Some(
            crate::model::big_query_discovery_target::Frequency::Cadence(v.into()),
        );
        self
    }

    /// The value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.frequency.as_ref().and_then(|v| match v {
            crate::model::big_query_discovery_target::Frequency::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `frequency` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = std::option::Option::Some(
            crate::model::big_query_discovery_target::Frequency::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryDiscoveryTarget"
    }
}

/// Defines additional types related to [BigQueryDiscoveryTarget].
pub mod big_query_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// The generation rule includes the logic on how frequently
    /// to update the data profiles. If not specified, discovery will re-run and
    /// update no more than once a month if new columns appear in the table.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Frequency {
        /// How often and when to update profiles. New tables that match both the
        /// filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        Cadence(std::boxed::Box<crate::model::DiscoveryGenerationCadence>),
        /// Tables that match this filter will not have profiles created.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines what tables will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID, dataset ID, and table ID.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryBigQueryFilter {
    /// Whether the filter applies to a specific set of tables or all other tables
    /// within the location being profiled. The first filter to match will be
    /// applied, regardless of the condition. If none is set, will default to
    /// `other_tables`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::discovery_big_query_filter::Filter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryBigQueryFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::DiscoveryBigQueryFilter::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::discovery_big_query_filter::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// if it holds a `Tables`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tables(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTableCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_filter::Filter::Tables(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// to hold a `Tables`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_tables<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTableCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_big_query_filter::Filter::Tables(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// if it holds a `OtherTables`, `None` if the field is not set or
    /// holds a different branch.
    pub fn other_tables(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::discovery_big_query_filter::AllOtherBigQueryTables>,
    > {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_filter::Filter::OtherTables(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// to hold a `OtherTables`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_other_tables<
        T: std::convert::Into<
                std::boxed::Box<crate::model::discovery_big_query_filter::AllOtherBigQueryTables>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_big_query_filter::Filter::OtherTables(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// if it holds a `TableReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TableReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_filter::Filter::TableReference(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// to hold a `TableReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_table_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_big_query_filter::Filter::TableReference(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryBigQueryFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryFilter"
    }
}

/// Defines additional types related to [DiscoveryBigQueryFilter].
pub mod discovery_big_query_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Catch-all for all other tables not specified by other filters. Should
    /// always be last, except for single-table configurations, which will only
    /// have a TableReference target.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AllOtherBigQueryTables {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AllOtherBigQueryTables {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for AllOtherBigQueryTables {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryFilter.AllOtherBigQueryTables"
        }
    }

    /// Whether the filter applies to a specific set of tables or all other tables
    /// within the location being profiled. The first filter to match will be
    /// applied, regardless of the condition. If none is set, will default to
    /// `other_tables`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// A specific set of tables for this filter to apply to. A table collection
        /// must be specified in only one filter per config.
        /// If a table id or dataset is empty, Cloud DLP assumes all tables in that
        /// collection must be profiled. Must specify a project ID.
        Tables(std::boxed::Box<crate::model::BigQueryTableCollection>),
        /// Catch-all. This should always be the last filter in the list because
        /// anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        OtherTables(
            std::boxed::Box<crate::model::discovery_big_query_filter::AllOtherBigQueryTables>,
        ),
        /// The table to scan. Discovery configurations including this can only
        /// include one DiscoveryTarget (the DiscoveryTarget with this
        /// TableReference).
        TableReference(std::boxed::Box<crate::model::TableReference>),
    }
}

/// Specifies a collection of BigQuery tables. Used for Discovery.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryTableCollection {
    /// Maximum of 100 entries.
    /// The first filter containing a pattern that matches a table will be used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub pattern: std::option::Option<crate::model::big_query_table_collection::Pattern>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryTableCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pattern][crate::model::BigQueryTableCollection::pattern].
    ///
    /// Note that all the setters affecting `pattern` are mutually
    /// exclusive.
    pub fn set_pattern<
        T: std::convert::Into<std::option::Option<crate::model::big_query_table_collection::Pattern>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::BigQueryTableCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::big_query_table_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::BigQueryTableCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::big_query_table_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryTableCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryTableCollection"
    }
}

/// Defines additional types related to [BigQueryTableCollection].
pub mod big_query_table_collection {
    #[allow(unused_imports)]
    use super::*;

    /// Maximum of 100 entries.
    /// The first filter containing a pattern that matches a table will be used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Pattern {
        /// A collection of regular expressions to match a BigQuery table against.
        IncludeRegexes(std::boxed::Box<crate::model::BigQueryRegexes>),
    }
}

/// Requirements that must be true before a table is scanned in discovery for the
/// first time. There is an AND relationship between the top-level attributes.
/// Additionally, minimum conditions with an OR relationship that must be met
/// before Cloud DLP scans a table can be set (like a minimum row count or a
/// minimum table age).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryBigQueryConditions {
    /// BigQuery table must have been created after this date. Used to avoid
    /// backfilling.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_after: std::option::Option<wkt::Timestamp>,

    /// At least one of the conditions must be true for a table to be scanned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub or_conditions:
        std::option::Option<crate::model::discovery_big_query_conditions::OrConditions>,

    /// The type of BigQuery tables to scan. If nothing is set the default
    /// behavior is to scan only tables of type TABLE and to give errors
    /// for all unsupported tables.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub included_types:
        std::option::Option<crate::model::discovery_big_query_conditions::IncludedTypes>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryBigQueryConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_after][crate::model::DiscoveryBigQueryConditions::created_after].
    pub fn set_created_after<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.created_after = v.into();
        self
    }

    /// Sets the value of [or_conditions][crate::model::DiscoveryBigQueryConditions::or_conditions].
    pub fn set_or_conditions<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_big_query_conditions::OrConditions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.or_conditions = v.into();
        self
    }

    /// Sets the value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types].
    ///
    /// Note that all the setters affecting `included_types` are mutually
    /// exclusive.
    pub fn set_included_types<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_big_query_conditions::IncludedTypes>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.included_types = v.into();
        self
    }

    /// The value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// if it holds a `Types`, `None` if the field is not set or
    /// holds a different branch.
    pub fn types(&self) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTableTypes>> {
        #[allow(unreachable_patterns)]
        self.included_types.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_conditions::IncludedTypes::Types(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// to hold a `Types`.
    ///
    /// Note that all the setters affecting `included_types` are
    /// mutually exclusive.
    pub fn set_types<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTableTypes>>>(
        mut self,
        v: T,
    ) -> Self {
        self.included_types = std::option::Option::Some(
            crate::model::discovery_big_query_conditions::IncludedTypes::Types(v.into()),
        );
        self
    }

    /// The value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// if it holds a `TypeCollection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn type_collection(
        &self,
    ) -> std::option::Option<&crate::model::BigQueryTableTypeCollection> {
        #[allow(unreachable_patterns)]
        self.included_types.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_conditions::IncludedTypes::TypeCollection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// to hold a `TypeCollection`.
    ///
    /// Note that all the setters affecting `included_types` are
    /// mutually exclusive.
    pub fn set_type_collection<T: std::convert::Into<crate::model::BigQueryTableTypeCollection>>(
        mut self,
        v: T,
    ) -> Self {
        self.included_types = std::option::Option::Some(
            crate::model::discovery_big_query_conditions::IncludedTypes::TypeCollection(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryBigQueryConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryConditions"
    }
}

/// Defines additional types related to [DiscoveryBigQueryConditions].
pub mod discovery_big_query_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// There is an OR relationship between these attributes. They are used to
    /// determine if a table should be scanned or not in Discovery.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OrConditions {
        /// Minimum number of rows that should be present before Cloud DLP
        /// profiles a table
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub min_row_count: i32,

        /// Minimum age a table must have before Cloud DLP can profile it. Value must
        /// be 1 hour or greater.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_age: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OrConditions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_row_count][crate::model::discovery_big_query_conditions::OrConditions::min_row_count].
        pub fn set_min_row_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_row_count = v.into();
            self
        }

        /// Sets the value of [min_age][crate::model::discovery_big_query_conditions::OrConditions::min_age].
        pub fn set_min_age<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_age = v.into();
            self
        }
    }

    impl wkt::message::Message for OrConditions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryConditions.OrConditions"
        }
    }

    /// The type of BigQuery tables to scan. If nothing is set the default
    /// behavior is to scan only tables of type TABLE and to give errors
    /// for all unsupported tables.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum IncludedTypes {
        /// Restrict discovery to specific table types.
        Types(std::boxed::Box<crate::model::BigQueryTableTypes>),
        /// Restrict discovery to categories of table types.
        TypeCollection(crate::model::BigQueryTableTypeCollection),
    }
}

/// What must take place for a profile to be updated and how
/// frequently it should occur.
/// New tables are scanned as quickly as possible depending on system
/// capacity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryGenerationCadence {
    /// Governs when to update data profiles when a schema is modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema_modified_cadence: std::option::Option<crate::model::DiscoverySchemaModifiedCadence>,

    /// Governs when to update data profiles when a table is modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_modified_cadence: std::option::Option<crate::model::DiscoveryTableModifiedCadence>,

    /// Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,

    /// Frequency at which profiles should be updated, regardless of whether the
    /// underlying resource has changed. Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_modified_cadence][crate::model::DiscoveryGenerationCadence::schema_modified_cadence].
    pub fn set_schema_modified_cadence<
        T: std::convert::Into<std::option::Option<crate::model::DiscoverySchemaModifiedCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema_modified_cadence = v.into();
        self
    }

    /// Sets the value of [table_modified_cadence][crate::model::DiscoveryGenerationCadence::table_modified_cadence].
    pub fn set_table_modified_cadence<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryTableModifiedCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_modified_cadence = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<
        T: std::convert::Into<
                std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_cadence = v.into();
        self
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryGenerationCadence"
    }
}

/// The cadence at which to update data profiles when a table is modified.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryTableModifiedCadence {
    /// The type of events to consider when deciding if the table has been
    /// modified and should have the profile updated. Defaults to
    /// MODIFIED_TIMESTAMP.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub types: std::vec::Vec<crate::model::BigQueryTableModification>,

    /// How frequently data profiles can be updated when tables are modified.
    /// Defaults to never.
    pub frequency: crate::model::DataProfileUpdateFrequency,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryTableModifiedCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [types][crate::model::DiscoveryTableModifiedCadence::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQueryTableModification>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [frequency][crate::model::DiscoveryTableModifiedCadence::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryTableModifiedCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryTableModifiedCadence"
    }
}

/// The cadence at which to update data profiles when a schema is modified.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoverySchemaModifiedCadence {
    /// The type of events to consider when deciding if the table's schema
    /// has been modified and should have the profile updated. Defaults to
    /// NEW_COLUMNS.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub types: std::vec::Vec<crate::model::BigQuerySchemaModification>,

    /// How frequently profiles may be updated when schemas are
    /// modified. Defaults to monthly.
    pub frequency: crate::model::DataProfileUpdateFrequency,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoverySchemaModifiedCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [types][crate::model::DiscoverySchemaModifiedCadence::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQuerySchemaModification>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [frequency][crate::model::DiscoverySchemaModifiedCadence::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }
}

impl wkt::message::Message for DiscoverySchemaModifiedCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoverySchemaModifiedCadence"
    }
}

/// The cadence at which to update data profiles when the inspection rules
/// defined by the `InspectTemplate` change.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryInspectTemplateModifiedCadence {
    /// How frequently data profiles can be updated when the template is modified.
    /// Defaults to never.
    pub frequency: crate::model::DataProfileUpdateFrequency,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryInspectTemplateModifiedCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [frequency][crate::model::DiscoveryInspectTemplateModifiedCadence::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryInspectTemplateModifiedCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryInspectTemplateModifiedCadence"
    }
}

/// Target used to match against for discovery with Cloud SQL tables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlDiscoveryTarget {
    /// Required. The tables the discovery cadence applies to. The first target
    /// with a matching filter will be the one to apply to a table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::DiscoveryCloudSqlFilter>,

    /// In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::DiscoveryCloudSqlConditions>,

    /// Type of schedule.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cadence: std::option::Option<crate::model::cloud_sql_discovery_target::Cadence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::CloudSqlDiscoveryTarget::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryCloudSqlFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::CloudSqlDiscoveryTarget::conditions].
    pub fn set_conditions<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryCloudSqlConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// Sets the value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence].
    ///
    /// Note that all the setters affecting `cadence` are mutually
    /// exclusive.
    pub fn set_cadence<
        T: std::convert::Into<std::option::Option<crate::model::cloud_sql_discovery_target::Cadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryCloudSqlGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryCloudSqlGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_sql_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// The value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_sql_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudSqlDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudSqlDiscoveryTarget"
    }
}

/// Defines additional types related to [CloudSqlDiscoveryTarget].
pub mod cloud_sql_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// Type of schedule.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Cadence {
        /// How often and when to update profiles. New tables that match both the
        /// filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryCloudSqlGenerationCadence>),
        /// Disable profiling for database resources that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines what tables will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID, location, instance, database, and database resource name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudSqlFilter {
    /// Whether the filter applies to a specific set of database resources or all
    /// other database resources within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::discovery_cloud_sql_filter::Filter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudSqlFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudSqlFilter::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::discovery_cloud_sql_filter::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseResourceCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_sql_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseResourceCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_sql_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn others(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherDatabaseResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_sql_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<
        T: std::convert::Into<std::boxed::Box<crate::model::AllOtherDatabaseResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_sql_filter::Filter::Others(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// if it holds a `DatabaseResourceReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn database_resource_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseResourceReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_sql_filter::Filter::DatabaseResourceReference(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// to hold a `DatabaseResourceReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_database_resource_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_sql_filter::Filter::DatabaseResourceReference(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryCloudSqlFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlFilter"
    }
}

/// Defines additional types related to [DiscoveryCloudSqlFilter].
pub mod discovery_cloud_sql_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of database resources or all
    /// other database resources within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// A specific set of database resources for this filter to apply to.
        Collection(std::boxed::Box<crate::model::DatabaseResourceCollection>),
        /// Catch-all. This should always be the last target in the list because
        /// anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherDatabaseResources>),
        /// The database resource to scan. Targets including this can only include
        /// one target (the target with this database resource reference).
        DatabaseResourceReference(std::boxed::Box<crate::model::DatabaseResourceReference>),
    }
}

/// Match database resources using regex filters. Examples of database
/// resources are tables, views, and stored procedures.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseResourceCollection {
    /// The first filter containing a pattern that matches a database resource will
    /// be used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub pattern: std::option::Option<crate::model::database_resource_collection::Pattern>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseResourceCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pattern][crate::model::DatabaseResourceCollection::pattern].
    ///
    /// Note that all the setters affecting `pattern` are mutually
    /// exclusive.
    pub fn set_pattern<
        T: std::convert::Into<
                std::option::Option<crate::model::database_resource_collection::Pattern>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::DatabaseResourceCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseResourceRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::database_resource_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::DatabaseResourceCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseResourceRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::database_resource_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DatabaseResourceCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceCollection"
    }
}

/// Defines additional types related to [DatabaseResourceCollection].
pub mod database_resource_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The first filter containing a pattern that matches a database resource will
    /// be used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Pattern {
        /// A collection of regular expressions to match a database resource against.
        IncludeRegexes(std::boxed::Box<crate::model::DatabaseResourceRegexes>),
    }
}

/// A collection of regular expressions to determine what database resources to
/// match against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseResourceRegexes {
    /// A group of regular expression patterns to match against one or more
    /// database resources.
    /// Maximum of 100 entries. The sum of all regular expression's length can't
    /// exceed 10 KiB.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patterns: std::vec::Vec<crate::model::DatabaseResourceRegex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseResourceRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::DatabaseResourceRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseResourceRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatabaseResourceRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceRegexes"
    }
}

/// A pattern to match against one or more database resources. At least one
/// pattern must be specified. Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseResourceRegex {
    /// For organizations, if unset, will match all projects. Has no effect
    /// for configurations created within a project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id_regex: std::string::String,

    /// Regex to test the instance name against. If empty, all instances match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_regex: std::string::String,

    /// Regex to test the database name against. If empty, all databases match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_regex: std::string::String,

    /// Regex to test the database resource's name against. An example of a
    /// database resource name is a table's name. Other database resource names
    /// like view names could be included in the future. If empty, all database
    /// resources match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_resource_name_regex: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseResourceRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::DatabaseResourceRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }

    /// Sets the value of [instance_regex][crate::model::DatabaseResourceRegex::instance_regex].
    pub fn set_instance_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_regex = v.into();
        self
    }

    /// Sets the value of [database_regex][crate::model::DatabaseResourceRegex::database_regex].
    pub fn set_database_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_regex = v.into();
        self
    }

    /// Sets the value of [database_resource_name_regex][crate::model::DatabaseResourceRegex::database_resource_name_regex].
    pub fn set_database_resource_name_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_resource_name_regex = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseResourceRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceRegex"
    }
}

/// Match database resources not covered by any other filter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AllOtherDatabaseResources {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllOtherDatabaseResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AllOtherDatabaseResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AllOtherDatabaseResources"
    }
}

/// Identifies a single database resource, like a table within a database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseResourceReference {
    /// Required. If within a project-level config, then this must match the
    /// config's project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The instance where this resource is located. For example: Cloud
    /// SQL instance ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Required. Name of a database within the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Required. Name of a database resource, for example, a table within the
    /// database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_resource: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DatabaseResourceReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::DatabaseResourceReference::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [database][crate::model::DatabaseResourceReference::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [database_resource][crate::model::DatabaseResourceReference::database_resource].
    pub fn set_database_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_resource = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceReference"
    }
}

/// Requirements that must be true before a table is profiled for the
/// first time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudSqlConditions {
    /// Optional. Database engines that should be profiled.
    /// Optional. Defaults to ALL_SUPPORTED_DATABASE_ENGINES if unspecified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub database_engines:
        std::vec::Vec<crate::model::discovery_cloud_sql_conditions::DatabaseEngine>,

    /// Data profiles will only be generated for the database resource types
    /// specified in this field.
    /// If not specified, defaults to [DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES].
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub types: std::vec::Vec<crate::model::discovery_cloud_sql_conditions::DatabaseResourceType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudSqlConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_engines][crate::model::DiscoveryCloudSqlConditions::database_engines].
    pub fn set_database_engines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::discovery_cloud_sql_conditions::DatabaseEngine>,
    {
        use std::iter::Iterator;
        self.database_engines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [types][crate::model::DiscoveryCloudSqlConditions::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::discovery_cloud_sql_conditions::DatabaseResourceType>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiscoveryCloudSqlConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlConditions"
    }
}

/// Defines additional types related to [DiscoveryCloudSqlConditions].
pub mod discovery_cloud_sql_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// The database engines that should be profiled.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseEngine {
        /// Unused.
        Unspecified,
        /// Include all supported database engines.
        AllSupportedDatabaseEngines,
        /// MySQL database.
        Mysql,
        /// PostgreSQL database.
        Postgres,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseEngine::value] or
        /// [DatabaseEngine::name].
        UnknownValue(database_engine::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_engine {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseEngine {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllSupportedDatabaseEngines => std::option::Option::Some(1),
                Self::Mysql => std::option::Option::Some(2),
                Self::Postgres => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_ENGINE_UNSPECIFIED"),
                Self::AllSupportedDatabaseEngines => {
                    std::option::Option::Some("ALL_SUPPORTED_DATABASE_ENGINES")
                }
                Self::Mysql => std::option::Option::Some("MYSQL"),
                Self::Postgres => std::option::Option::Some("POSTGRES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseEngine {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseEngine {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseEngine {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllSupportedDatabaseEngines,
                2 => Self::Mysql,
                3 => Self::Postgres,
                _ => Self::UnknownValue(database_engine::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseEngine {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_ENGINE_UNSPECIFIED" => Self::Unspecified,
                "ALL_SUPPORTED_DATABASE_ENGINES" => Self::AllSupportedDatabaseEngines,
                "MYSQL" => Self::Mysql,
                "POSTGRES" => Self::Postgres,
                _ => Self::UnknownValue(database_engine::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseEngine {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllSupportedDatabaseEngines => serializer.serialize_i32(1),
                Self::Mysql => serializer.serialize_i32(2),
                Self::Postgres => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseEngine {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEngine>::new(
                ".google.privacy.dlp.v2.DiscoveryCloudSqlConditions.DatabaseEngine",
            ))
        }
    }

    /// Cloud SQL database resource types. New values can be added at a later time.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseResourceType {
        /// Unused.
        Unspecified,
        /// Includes database resource types that become supported at a later time.
        AllSupportedTypes,
        /// Tables.
        Table,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseResourceType::value] or
        /// [DatabaseResourceType::name].
        UnknownValue(database_resource_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_resource_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseResourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllSupportedTypes => std::option::Option::Some(1),
                Self::Table => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DATABASE_RESOURCE_TYPE_UNSPECIFIED")
                }
                Self::AllSupportedTypes => {
                    std::option::Option::Some("DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES")
                }
                Self::Table => std::option::Option::Some("DATABASE_RESOURCE_TYPE_TABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseResourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseResourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseResourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllSupportedTypes,
                2 => Self::Table,
                _ => Self::UnknownValue(database_resource_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseResourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_RESOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES" => Self::AllSupportedTypes,
                "DATABASE_RESOURCE_TYPE_TABLE" => Self::Table,
                _ => Self::UnknownValue(database_resource_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseResourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllSupportedTypes => serializer.serialize_i32(1),
                Self::Table => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseResourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseResourceType>::new(
                ".google.privacy.dlp.v2.DiscoveryCloudSqlConditions.DatabaseResourceType",
            ))
        }
    }
}

/// How often existing tables should have their profiles refreshed.
/// New tables are scanned as quickly as possible depending on system
/// capacity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudSqlGenerationCadence {
    /// When to reprofile if the schema has changed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema_modified_cadence: std::option::Option<
        crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence,
    >,

    /// Data changes (non-schema changes) in Cloud SQL tables can't trigger
    /// reprofiling. If you set this field, profiles are refreshed at this
    /// frequency regardless of whether the underlying tables have changed.
    /// Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudSqlGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_modified_cadence][crate::model::DiscoveryCloudSqlGenerationCadence::schema_modified_cadence].
    pub fn set_schema_modified_cadence<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema_modified_cadence = v.into();
        self
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryCloudSqlGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryCloudSqlGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<
        T: std::convert::Into<
                std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_cadence = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryCloudSqlGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlGenerationCadence"
    }
}

/// Defines additional types related to [DiscoveryCloudSqlGenerationCadence].
pub mod discovery_cloud_sql_generation_cadence {
    #[allow(unused_imports)]
    use super::*;

    /// How frequently to modify the profile when the table's schema is modified.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SchemaModifiedCadence {

        /// The types of schema modifications to consider.
        /// Defaults to NEW_COLUMNS.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub types: std::vec::Vec<crate::model::discovery_cloud_sql_generation_cadence::schema_modified_cadence::CloudSqlSchemaModification>,

        /// Frequency to regenerate data profiles when the schema is modified.
        /// Defaults to monthly.
        pub frequency: crate::model::DataProfileUpdateFrequency,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SchemaModifiedCadence {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [types][crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence::types].
        pub fn set_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::discovery_cloud_sql_generation_cadence::schema_modified_cadence::CloudSqlSchemaModification>
        {
            use std::iter::Iterator;
            self.types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [frequency][crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence::frequency].
        pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
            mut self,
            v: T,
        ) -> Self {
            self.frequency = v.into();
            self
        }
    }

    impl wkt::message::Message for SchemaModifiedCadence {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlGenerationCadence.SchemaModifiedCadence"
        }
    }

    /// Defines additional types related to [SchemaModifiedCadence].
    pub mod schema_modified_cadence {
        #[allow(unused_imports)]
        use super::*;

        /// The type of modification that causes a profile update.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum CloudSqlSchemaModification {
            /// Unused.
            SqlSchemaModificationUnspecified,
            /// New columns have appeared.
            NewColumns,
            /// Columns have been removed from the table.
            RemovedColumns,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [CloudSqlSchemaModification::value] or
            /// [CloudSqlSchemaModification::name].
            UnknownValue(cloud_sql_schema_modification::UnknownValue),
        }

        #[doc(hidden)]
        pub mod cloud_sql_schema_modification {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl CloudSqlSchemaModification {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::SqlSchemaModificationUnspecified => std::option::Option::Some(0),
                    Self::NewColumns => std::option::Option::Some(1),
                    Self::RemovedColumns => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::SqlSchemaModificationUnspecified => {
                        std::option::Option::Some("SQL_SCHEMA_MODIFICATION_UNSPECIFIED")
                    }
                    Self::NewColumns => std::option::Option::Some("NEW_COLUMNS"),
                    Self::RemovedColumns => std::option::Option::Some("REMOVED_COLUMNS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for CloudSqlSchemaModification {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for CloudSqlSchemaModification {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for CloudSqlSchemaModification {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::SqlSchemaModificationUnspecified,
                    1 => Self::NewColumns,
                    2 => Self::RemovedColumns,
                    _ => Self::UnknownValue(cloud_sql_schema_modification::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for CloudSqlSchemaModification {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SQL_SCHEMA_MODIFICATION_UNSPECIFIED" => Self::SqlSchemaModificationUnspecified,
                    "NEW_COLUMNS" => Self::NewColumns,
                    "REMOVED_COLUMNS" => Self::RemovedColumns,
                    _ => Self::UnknownValue(cloud_sql_schema_modification::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for CloudSqlSchemaModification {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::SqlSchemaModificationUnspecified => serializer.serialize_i32(0),
                    Self::NewColumns => serializer.serialize_i32(1),
                    Self::RemovedColumns => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for CloudSqlSchemaModification {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudSqlSchemaModification>::new(
                    ".google.privacy.dlp.v2.DiscoveryCloudSqlGenerationCadence.SchemaModifiedCadence.CloudSqlSchemaModification"))
            }
        }
    }
}

/// Discovery target for credentials and secrets in cloud resource metadata.
///
/// This target does not include any filtering or frequency controls. Cloud
/// DLP will scan cloud resource metadata for secrets daily.
///
/// No inspect template should be included in the discovery config for a
/// security benchmarks scan. Instead, the built-in list of secrets and
/// credentials infoTypes will be used (see
/// <https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference#credentials_and_secrets>).
///
/// Credentials and secrets discovered will be reported as vulnerabilities to
/// Security Command Center.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretsDiscoveryTarget {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretsDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SecretsDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SecretsDiscoveryTarget"
    }
}

/// Target used to match against for discovery with Cloud Storage buckets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageDiscoveryTarget {
    /// Required. The buckets the generation_cadence applies to. The first target
    /// with a matching filter will be the one to apply to a bucket.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::DiscoveryCloudStorageFilter>,

    /// Optional. In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::DiscoveryFileStoreConditions>,

    /// How often and when to update profiles.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cadence: std::option::Option<crate::model::cloud_storage_discovery_target::Cadence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::CloudStorageDiscoveryTarget::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryCloudStorageFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::CloudStorageDiscoveryTarget::conditions].
    pub fn set_conditions<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryFileStoreConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// Sets the value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence].
    ///
    /// Note that all the setters affecting `cadence` are mutually
    /// exclusive.
    pub fn set_cadence<
        T: std::convert::Into<
                std::option::Option<crate::model::cloud_storage_discovery_target::Cadence>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryCloudStorageGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_storage_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryCloudStorageGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_storage_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// The value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_storage_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_storage_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudStorageDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageDiscoveryTarget"
    }
}

/// Defines additional types related to [CloudStorageDiscoveryTarget].
pub mod cloud_storage_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// How often and when to update profiles.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Cadence {
        /// Optional. How often and when to update profiles. New buckets that match
        /// both the filter and conditions are scanned as quickly as possible
        /// depending on system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryCloudStorageGenerationCadence>),
        /// Optional. Disable profiling for buckets that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines which buckets will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID and bucket name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudStorageFilter {
    /// Whether the filter applies to a specific set of buckets or all
    /// other buckets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::discovery_cloud_storage_filter::Filter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudStorageFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudStorageFilter::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_cloud_storage_filter::Filter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileStoreCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_storage_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::FileStoreCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_storage_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// if it holds a `CloudStorageResourceReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_resource_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageResourceReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_storage_filter::Filter::CloudStorageResourceReference(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// to hold a `CloudStorageResourceReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_cloud_storage_resource_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_storage_filter::Filter::CloudStorageResourceReference(
                v.into(),
            ),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn others(&self) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_storage_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<T: std::convert::Into<std::boxed::Box<crate::model::AllOtherResources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_storage_filter::Filter::Others(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryCloudStorageFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudStorageFilter"
    }
}

/// Defines additional types related to [DiscoveryCloudStorageFilter].
pub mod discovery_cloud_storage_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of buckets or all
    /// other buckets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// Optional. A specific set of buckets for this filter to apply to.
        Collection(std::boxed::Box<crate::model::FileStoreCollection>),
        /// Optional. The bucket to scan. Targets including this can only include one
        /// target (the target with this bucket). This enables profiling the contents
        /// of a single bucket, while the other options allow for easy profiling of
        /// many bucets within a project or an organization.
        CloudStorageResourceReference(std::boxed::Box<crate::model::CloudStorageResourceReference>),
        /// Optional. Catch-all. This should always be the last target in the list
        /// because anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherResources>),
    }
}

/// Match file stores (e.g. buckets) using regex filters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStoreCollection {
    /// The first filter containing a pattern that matches a file store will
    /// be used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub pattern: std::option::Option<crate::model::file_store_collection::Pattern>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileStoreCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pattern][crate::model::FileStoreCollection::pattern].
    ///
    /// Note that all the setters affecting `pattern` are mutually
    /// exclusive.
    pub fn set_pattern<
        T: std::convert::Into<std::option::Option<crate::model::file_store_collection::Pattern>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::FileStoreCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileStoreRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::file_store_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::FileStoreCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::FileStoreRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::file_store_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileStoreCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreCollection"
    }
}

/// Defines additional types related to [FileStoreCollection].
pub mod file_store_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The first filter containing a pattern that matches a file store will
    /// be used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Pattern {
        /// Optional. A collection of regular expressions to match a file store
        /// against.
        IncludeRegexes(std::boxed::Box<crate::model::FileStoreRegexes>),
    }
}

/// A collection of regular expressions to determine what file store to match
/// against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStoreRegexes {
    /// Required. The group of regular expression patterns to match against one or
    /// more file stores. Maximum of 100 entries. The sum of all regular
    /// expression's length can't exceed 10 KiB.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patterns: std::vec::Vec<crate::model::FileStoreRegex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileStoreRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::FileStoreRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileStoreRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreRegexes"
    }
}

/// A pattern to match against one or more file stores.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStoreRegex {
    /// The type of resource regex to use.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub resource_regex: std::option::Option<crate::model::file_store_regex::ResourceRegex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileStoreRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_regex][crate::model::FileStoreRegex::resource_regex].
    ///
    /// Note that all the setters affecting `resource_regex` are mutually
    /// exclusive.
    pub fn set_resource_regex<
        T: std::convert::Into<std::option::Option<crate::model::file_store_regex::ResourceRegex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = v.into();
        self
    }

    /// The value of [resource_regex][crate::model::FileStoreRegex::resource_regex]
    /// if it holds a `CloudStorageRegex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageRegex>> {
        #[allow(unreachable_patterns)]
        self.resource_regex.as_ref().and_then(|v| match v {
            crate::model::file_store_regex::ResourceRegex::CloudStorageRegex(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_regex][crate::model::FileStoreRegex::resource_regex]
    /// to hold a `CloudStorageRegex`.
    ///
    /// Note that all the setters affecting `resource_regex` are
    /// mutually exclusive.
    pub fn set_cloud_storage_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageRegex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = std::option::Option::Some(
            crate::model::file_store_regex::ResourceRegex::CloudStorageRegex(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileStoreRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreRegex"
    }
}

/// Defines additional types related to [FileStoreRegex].
pub mod file_store_regex {
    #[allow(unused_imports)]
    use super::*;

    /// The type of resource regex to use.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ResourceRegex {
        /// Optional. Regex for Cloud Storage.
        CloudStorageRegex(std::boxed::Box<crate::model::CloudStorageRegex>),
    }
}

/// A pattern to match against one or more file stores. At least one
/// pattern must be specified. Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageRegex {
    /// Optional. For organizations, if unset, will match all projects.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id_regex: std::string::String,

    /// Optional. Regex to test the bucket name against. If empty, all buckets
    /// match. Example: "marketing2021" or "(marketing)\d{4}" will both match the
    /// bucket gs://marketing2021
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name_regex: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::CloudStorageRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }

    /// Sets the value of [bucket_name_regex][crate::model::CloudStorageRegex::bucket_name_regex].
    pub fn set_bucket_name_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_name_regex = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageRegex"
    }
}

/// Identifies a single Cloud Storage bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageResourceReference {
    /// Required. The bucket to scan.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name: std::string::String,

    /// Required. If within a project-level config, then this must match the
    /// config's project id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::CloudStorageResourceReference::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CloudStorageResourceReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageResourceReference"
    }
}

/// How often existing buckets should have their profiles refreshed.
/// New buckets are scanned as quickly as possible depending on system
/// capacity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudStorageGenerationCadence {
    /// Optional. Data changes in Cloud Storage can't trigger reprofiling. If you
    /// set this field, profiles are refreshed at this frequency regardless of
    /// whether the underlying buckets have changed. Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Optional. Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudStorageGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryCloudStorageGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryCloudStorageGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<
        T: std::convert::Into<
                std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_cadence = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryCloudStorageGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudStorageGenerationCadence"
    }
}

/// Requirements that must be true before a Cloud Storage bucket or object is
/// scanned in discovery for the first time. There is an AND relationship between
/// the top-level attributes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudStorageConditions {
    /// Required. Only objects with the specified attributes will be scanned. If an
    /// object has one of the specified attributes but is inside an excluded
    /// bucket, it will not be scanned. Defaults to [ALL_SUPPORTED_OBJECTS]. A
    /// profile will be created even if no objects match the
    /// included_object_attributes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub included_object_attributes: std::vec::Vec<
        crate::model::discovery_cloud_storage_conditions::CloudStorageObjectAttribute,
    >,

    /// Required. Only objects with the specified attributes will be scanned.
    /// Defaults to [ALL_SUPPORTED_BUCKETS] if unset.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub included_bucket_attributes: std::vec::Vec<
        crate::model::discovery_cloud_storage_conditions::CloudStorageBucketAttribute,
    >,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryCloudStorageConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [included_object_attributes][crate::model::DiscoveryCloudStorageConditions::included_object_attributes].
    pub fn set_included_object_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::discovery_cloud_storage_conditions::CloudStorageObjectAttribute,
            >,
    {
        use std::iter::Iterator;
        self.included_object_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [included_bucket_attributes][crate::model::DiscoveryCloudStorageConditions::included_bucket_attributes].
    pub fn set_included_bucket_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::discovery_cloud_storage_conditions::CloudStorageBucketAttribute,
            >,
    {
        use std::iter::Iterator;
        self.included_bucket_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiscoveryCloudStorageConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudStorageConditions"
    }
}

/// Defines additional types related to [DiscoveryCloudStorageConditions].
pub mod discovery_cloud_storage_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// The attribute of an object. See
    /// <https://cloud.google.com/storage/docs/storage-classes> for more information
    /// on storage classes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CloudStorageObjectAttribute {
        /// Unused.
        Unspecified,
        /// Scan objects regardless of the attribute.
        AllSupportedObjects,
        /// Scan objects with the standard storage class.
        Standard,
        /// Scan objects with the nearline storage class. This will incur retrieval
        /// fees.
        Nearline,
        /// Scan objects with the coldline storage class. This will incur retrieval
        /// fees.
        Coldline,
        /// Scan objects with the archive storage class. This will incur retrieval
        /// fees.
        Archive,
        /// Scan objects with the regional storage class.
        Regional,
        /// Scan objects with the multi-regional storage class.
        MultiRegional,
        /// Scan objects with the dual-regional storage class. This will incur
        /// retrieval fees.
        DurableReducedAvailability,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CloudStorageObjectAttribute::value] or
        /// [CloudStorageObjectAttribute::name].
        UnknownValue(cloud_storage_object_attribute::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cloud_storage_object_attribute {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CloudStorageObjectAttribute {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllSupportedObjects => std::option::Option::Some(1),
                Self::Standard => std::option::Option::Some(2),
                Self::Nearline => std::option::Option::Some(3),
                Self::Coldline => std::option::Option::Some(4),
                Self::Archive => std::option::Option::Some(5),
                Self::Regional => std::option::Option::Some(6),
                Self::MultiRegional => std::option::Option::Some(7),
                Self::DurableReducedAvailability => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CLOUD_STORAGE_OBJECT_ATTRIBUTE_UNSPECIFIED")
                }
                Self::AllSupportedObjects => std::option::Option::Some("ALL_SUPPORTED_OBJECTS"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Nearline => std::option::Option::Some("NEARLINE"),
                Self::Coldline => std::option::Option::Some("COLDLINE"),
                Self::Archive => std::option::Option::Some("ARCHIVE"),
                Self::Regional => std::option::Option::Some("REGIONAL"),
                Self::MultiRegional => std::option::Option::Some("MULTI_REGIONAL"),
                Self::DurableReducedAvailability => {
                    std::option::Option::Some("DURABLE_REDUCED_AVAILABILITY")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CloudStorageObjectAttribute {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CloudStorageObjectAttribute {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CloudStorageObjectAttribute {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllSupportedObjects,
                2 => Self::Standard,
                3 => Self::Nearline,
                4 => Self::Coldline,
                5 => Self::Archive,
                6 => Self::Regional,
                7 => Self::MultiRegional,
                8 => Self::DurableReducedAvailability,
                _ => Self::UnknownValue(cloud_storage_object_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CloudStorageObjectAttribute {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLOUD_STORAGE_OBJECT_ATTRIBUTE_UNSPECIFIED" => Self::Unspecified,
                "ALL_SUPPORTED_OBJECTS" => Self::AllSupportedObjects,
                "STANDARD" => Self::Standard,
                "NEARLINE" => Self::Nearline,
                "COLDLINE" => Self::Coldline,
                "ARCHIVE" => Self::Archive,
                "REGIONAL" => Self::Regional,
                "MULTI_REGIONAL" => Self::MultiRegional,
                "DURABLE_REDUCED_AVAILABILITY" => Self::DurableReducedAvailability,
                _ => Self::UnknownValue(cloud_storage_object_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CloudStorageObjectAttribute {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllSupportedObjects => serializer.serialize_i32(1),
                Self::Standard => serializer.serialize_i32(2),
                Self::Nearline => serializer.serialize_i32(3),
                Self::Coldline => serializer.serialize_i32(4),
                Self::Archive => serializer.serialize_i32(5),
                Self::Regional => serializer.serialize_i32(6),
                Self::MultiRegional => serializer.serialize_i32(7),
                Self::DurableReducedAvailability => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CloudStorageObjectAttribute {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudStorageObjectAttribute>::new(
                ".google.privacy.dlp.v2.DiscoveryCloudStorageConditions.CloudStorageObjectAttribute"))
        }
    }

    /// The attribute of a bucket.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CloudStorageBucketAttribute {
        /// Unused.
        Unspecified,
        /// Scan buckets regardless of the attribute.
        AllSupportedBuckets,
        /// Buckets with [Autoclass](https://cloud.google.com/storage/docs/autoclass)
        /// disabled. Only one of
        /// AUTOCLASS_DISABLED or AUTOCLASS_ENABLED should be set.
        AutoclassDisabled,
        /// Buckets with [Autoclass](https://cloud.google.com/storage/docs/autoclass)
        /// enabled. Only one of
        /// AUTOCLASS_DISABLED or AUTOCLASS_ENABLED should be set. Scanning
        /// Autoclass-enabled buckets can affect object storage classes.
        AutoclassEnabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CloudStorageBucketAttribute::value] or
        /// [CloudStorageBucketAttribute::name].
        UnknownValue(cloud_storage_bucket_attribute::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cloud_storage_bucket_attribute {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CloudStorageBucketAttribute {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllSupportedBuckets => std::option::Option::Some(1),
                Self::AutoclassDisabled => std::option::Option::Some(2),
                Self::AutoclassEnabled => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CLOUD_STORAGE_BUCKET_ATTRIBUTE_UNSPECIFIED")
                }
                Self::AllSupportedBuckets => std::option::Option::Some("ALL_SUPPORTED_BUCKETS"),
                Self::AutoclassDisabled => std::option::Option::Some("AUTOCLASS_DISABLED"),
                Self::AutoclassEnabled => std::option::Option::Some("AUTOCLASS_ENABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CloudStorageBucketAttribute {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CloudStorageBucketAttribute {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CloudStorageBucketAttribute {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllSupportedBuckets,
                2 => Self::AutoclassDisabled,
                3 => Self::AutoclassEnabled,
                _ => Self::UnknownValue(cloud_storage_bucket_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CloudStorageBucketAttribute {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLOUD_STORAGE_BUCKET_ATTRIBUTE_UNSPECIFIED" => Self::Unspecified,
                "ALL_SUPPORTED_BUCKETS" => Self::AllSupportedBuckets,
                "AUTOCLASS_DISABLED" => Self::AutoclassDisabled,
                "AUTOCLASS_ENABLED" => Self::AutoclassEnabled,
                _ => Self::UnknownValue(cloud_storage_bucket_attribute::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CloudStorageBucketAttribute {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllSupportedBuckets => serializer.serialize_i32(1),
                Self::AutoclassDisabled => serializer.serialize_i32(2),
                Self::AutoclassEnabled => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CloudStorageBucketAttribute {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudStorageBucketAttribute>::new(
                ".google.privacy.dlp.v2.DiscoveryCloudStorageConditions.CloudStorageBucketAttribute"))
        }
    }
}

/// Requirements that must be true before a file store is scanned in discovery
/// for the first time. There is an AND relationship between the top-level
/// attributes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryFileStoreConditions {
    /// Optional. File store must have been created after this date. Used to avoid
    /// backfilling.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_after: std::option::Option<wkt::Timestamp>,

    /// Optional. Minimum age a file store must have. If set, the value must be 1
    /// hour or greater.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_age: std::option::Option<wkt::Duration>,

    /// File store specific conditions.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::discovery_file_store_conditions::Conditions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryFileStoreConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_after][crate::model::DiscoveryFileStoreConditions::created_after].
    pub fn set_created_after<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.created_after = v.into();
        self
    }

    /// Sets the value of [min_age][crate::model::DiscoveryFileStoreConditions::min_age].
    pub fn set_min_age<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_age = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::DiscoveryFileStoreConditions::conditions].
    ///
    /// Note that all the setters affecting `conditions` are mutually
    /// exclusive.
    pub fn set_conditions<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_file_store_conditions::Conditions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// The value of [conditions][crate::model::DiscoveryFileStoreConditions::conditions]
    /// if it holds a `CloudStorageConditions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_conditions(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryCloudStorageConditions>> {
        #[allow(unreachable_patterns)]
        self.conditions.as_ref().and_then(|v| match v {
            crate::model::discovery_file_store_conditions::Conditions::CloudStorageConditions(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [conditions][crate::model::DiscoveryFileStoreConditions::conditions]
    /// to hold a `CloudStorageConditions`.
    ///
    /// Note that all the setters affecting `conditions` are
    /// mutually exclusive.
    pub fn set_cloud_storage_conditions<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryCloudStorageConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = std::option::Option::Some(
            crate::model::discovery_file_store_conditions::Conditions::CloudStorageConditions(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryFileStoreConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryFileStoreConditions"
    }
}

/// Defines additional types related to [DiscoveryFileStoreConditions].
pub mod discovery_file_store_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// File store specific conditions.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Conditions {
        /// Optional. Cloud Storage conditions.
        CloudStorageConditions(std::boxed::Box<crate::model::DiscoveryCloudStorageConditions>),
    }
}

/// Target used to match against for discovery of resources from other clouds.
/// An [AWS connector in Security Command Center
/// (Enterprise](https://cloud.google.com/security-command-center/docs/connect-scc-to-aws)
/// is required to use this feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudDiscoveryTarget {
    /// Required. The type of data profiles generated by this discovery target.
    /// Supported values are:
    ///
    /// * aws/s3/bucket
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_source_type: std::option::Option<crate::model::DataSourceType>,

    /// Required. The resources that the discovery cadence applies to. The
    /// first target with a matching filter will be the one to apply to a resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::DiscoveryOtherCloudFilter>,

    /// Optional. In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::DiscoveryOtherCloudConditions>,

    /// Type of cadence.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cadence: std::option::Option<crate::model::other_cloud_discovery_target::Cadence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_source_type][crate::model::OtherCloudDiscoveryTarget::data_source_type].
    pub fn set_data_source_type<
        T: std::convert::Into<std::option::Option<crate::model::DataSourceType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source_type = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::OtherCloudDiscoveryTarget::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryOtherCloudFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::OtherCloudDiscoveryTarget::conditions].
    pub fn set_conditions<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryOtherCloudConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// Sets the value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence].
    ///
    /// Note that all the setters affecting `cadence` are mutually
    /// exclusive.
    pub fn set_cadence<
        T: std::convert::Into<
                std::option::Option<crate::model::other_cloud_discovery_target::Cadence>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryOtherCloudGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::other_cloud_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryOtherCloudGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::other_cloud_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// The value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::other_cloud_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::other_cloud_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudDiscoveryTarget"
    }
}

/// Defines additional types related to [OtherCloudDiscoveryTarget].
pub mod other_cloud_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// Type of cadence.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Cadence {
        /// How often and when to update data profiles. New resources that match both
        /// the filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryOtherCloudGenerationCadence>),
        /// Disable profiling for resources that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines which resources from the other cloud will have profiles generated.
/// Includes the ability to filter by resource names.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryOtherCloudFilter {
    /// Whether the filter applies to a specific set of resources or all
    /// other resources. The first filter to match will be applied, regardless of
    /// the condition. Defaults to `others` if none is set.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::discovery_other_cloud_filter::Filter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryOtherCloudFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::DiscoveryOtherCloudFilter::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::discovery_other_cloud_filter::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudResourceCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudResourceCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_other_cloud_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// if it holds a `SingleResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudSingleResourceReference>>
    {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_filter::Filter::SingleResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// to hold a `SingleResource`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_single_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudSingleResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_other_cloud_filter::Filter::SingleResource(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn others(&self) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<T: std::convert::Into<std::boxed::Box<crate::model::AllOtherResources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_other_cloud_filter::Filter::Others(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryOtherCloudFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryOtherCloudFilter"
    }
}

/// Defines additional types related to [DiscoveryOtherCloudFilter].
pub mod discovery_other_cloud_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of resources or all
    /// other resources. The first filter to match will be applied, regardless of
    /// the condition. Defaults to `others` if none is set.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// A collection of resources for this filter to apply to.
        Collection(std::boxed::Box<crate::model::OtherCloudResourceCollection>),
        /// The resource to scan. Configs using this filter can only have one target
        /// (the target with this single resource reference).
        SingleResource(std::boxed::Box<crate::model::OtherCloudSingleResourceReference>),
        /// Optional. Catch-all. This should always be the last target in the list
        /// because anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherResources>),
    }
}

/// Match resources using regex filters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudResourceCollection {
    /// The first filter containing a pattern that matches a resource will be used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub pattern: std::option::Option<crate::model::other_cloud_resource_collection::Pattern>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudResourceCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pattern][crate::model::OtherCloudResourceCollection::pattern].
    ///
    /// Note that all the setters affecting `pattern` are mutually
    /// exclusive.
    pub fn set_pattern<
        T: std::convert::Into<
                std::option::Option<crate::model::other_cloud_resource_collection::Pattern>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::OtherCloudResourceCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudResourceRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::other_cloud_resource_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::OtherCloudResourceCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudResourceRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::other_cloud_resource_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudResourceCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudResourceCollection"
    }
}

/// Defines additional types related to [OtherCloudResourceCollection].
pub mod other_cloud_resource_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The first filter containing a pattern that matches a resource will be used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Pattern {
        /// A collection of regular expressions to match a resource against.
        IncludeRegexes(std::boxed::Box<crate::model::OtherCloudResourceRegexes>),
    }
}

/// A collection of regular expressions to determine what resources to match
/// against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudResourceRegexes {
    /// A group of regular expression patterns to match against one or more
    /// resources.
    /// Maximum of 100 entries. The sum of all regular expression's length can't
    /// exceed 10 KiB.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patterns: std::vec::Vec<crate::model::OtherCloudResourceRegex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudResourceRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::OtherCloudResourceRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OtherCloudResourceRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OtherCloudResourceRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudResourceRegexes"
    }
}

/// A pattern to match against one or more resources. At least one pattern must
/// be specified. Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudResourceRegex {
    /// The type of resource regex to use.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub resource_regex:
        std::option::Option<crate::model::other_cloud_resource_regex::ResourceRegex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudResourceRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_regex][crate::model::OtherCloudResourceRegex::resource_regex].
    ///
    /// Note that all the setters affecting `resource_regex` are mutually
    /// exclusive.
    pub fn set_resource_regex<
        T: std::convert::Into<
                std::option::Option<crate::model::other_cloud_resource_regex::ResourceRegex>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = v.into();
        self
    }

    /// The value of [resource_regex][crate::model::OtherCloudResourceRegex::resource_regex]
    /// if it holds a `AmazonS3BucketRegex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn amazon_s3_bucket_regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AmazonS3BucketRegex>> {
        #[allow(unreachable_patterns)]
        self.resource_regex.as_ref().and_then(|v| match v {
            crate::model::other_cloud_resource_regex::ResourceRegex::AmazonS3BucketRegex(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_regex][crate::model::OtherCloudResourceRegex::resource_regex]
    /// to hold a `AmazonS3BucketRegex`.
    ///
    /// Note that all the setters affecting `resource_regex` are
    /// mutually exclusive.
    pub fn set_amazon_s3_bucket_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::AmazonS3BucketRegex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = std::option::Option::Some(
            crate::model::other_cloud_resource_regex::ResourceRegex::AmazonS3BucketRegex(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudResourceRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudResourceRegex"
    }
}

/// Defines additional types related to [OtherCloudResourceRegex].
pub mod other_cloud_resource_regex {
    #[allow(unused_imports)]
    use super::*;

    /// The type of resource regex to use.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ResourceRegex {
        /// Regex for Amazon S3 buckets.
        AmazonS3BucketRegex(std::boxed::Box<crate::model::AmazonS3BucketRegex>),
    }
}

/// AWS account regex.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsAccountRegex {
    /// Optional. Regex to test the AWS account ID against.
    /// If empty, all accounts match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub account_id_regex: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsAccountRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [account_id_regex][crate::model::AwsAccountRegex::account_id_regex].
    pub fn set_account_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.account_id_regex = v.into();
        self
    }
}

impl wkt::message::Message for AwsAccountRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AwsAccountRegex"
    }
}

/// Amazon S3 bucket regex.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AmazonS3BucketRegex {
    /// The AWS account regex.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aws_account_regex: std::option::Option<crate::model::AwsAccountRegex>,

    /// Optional. Regex to test the bucket name against.
    /// If empty, all buckets match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name_regex: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AmazonS3BucketRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_account_regex][crate::model::AmazonS3BucketRegex::aws_account_regex].
    pub fn set_aws_account_regex<
        T: std::convert::Into<std::option::Option<crate::model::AwsAccountRegex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aws_account_regex = v.into();
        self
    }

    /// Sets the value of [bucket_name_regex][crate::model::AmazonS3BucketRegex::bucket_name_regex].
    pub fn set_bucket_name_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_name_regex = v.into();
        self
    }
}

impl wkt::message::Message for AmazonS3BucketRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AmazonS3BucketRegex"
    }
}

/// Identifies a single resource, like a single Amazon S3 bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudSingleResourceReference {
    /// The resource to scan.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub resource:
        std::option::Option<crate::model::other_cloud_single_resource_reference::Resource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudSingleResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource][crate::model::OtherCloudSingleResourceReference::resource].
    ///
    /// Note that all the setters affecting `resource` are mutually
    /// exclusive.
    pub fn set_resource<
        T: std::convert::Into<
                std::option::Option<crate::model::other_cloud_single_resource_reference::Resource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// The value of [resource][crate::model::OtherCloudSingleResourceReference::resource]
    /// if it holds a `AmazonS3Bucket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn amazon_s3_bucket(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AmazonS3Bucket>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::other_cloud_single_resource_reference::Resource::AmazonS3Bucket(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::OtherCloudSingleResourceReference::resource]
    /// to hold a `AmazonS3Bucket`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_amazon_s3_bucket<
        T: std::convert::Into<std::boxed::Box<crate::model::AmazonS3Bucket>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::other_cloud_single_resource_reference::Resource::AmazonS3Bucket(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudSingleResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudSingleResourceReference"
    }
}

/// Defines additional types related to [OtherCloudSingleResourceReference].
pub mod other_cloud_single_resource_reference {
    #[allow(unused_imports)]
    use super::*;

    /// The resource to scan.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Resource {
        /// Amazon S3 bucket.
        AmazonS3Bucket(std::boxed::Box<crate::model::AmazonS3Bucket>),
    }
}

/// AWS account.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsAccount {
    /// Required. AWS account ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub account_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [account_id][crate::model::AwsAccount::account_id].
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }
}

impl wkt::message::Message for AwsAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AwsAccount"
    }
}

/// Amazon S3 bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AmazonS3Bucket {
    /// The AWS account.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aws_account: std::option::Option<crate::model::AwsAccount>,

    /// Required. The bucket name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AmazonS3Bucket {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_account][crate::model::AmazonS3Bucket::aws_account].
    pub fn set_aws_account<T: std::convert::Into<std::option::Option<crate::model::AwsAccount>>>(
        mut self,
        v: T,
    ) -> Self {
        self.aws_account = v.into();
        self
    }

    /// Sets the value of [bucket_name][crate::model::AmazonS3Bucket::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }
}

impl wkt::message::Message for AmazonS3Bucket {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AmazonS3Bucket"
    }
}

/// Requirements that must be true before a resource is profiled for the first
/// time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryOtherCloudConditions {
    /// Minimum age a resource must be before Cloud DLP can profile it. Value must
    /// be 1 hour or greater.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_age: std::option::Option<wkt::Duration>,

    /// The conditions to apply.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::discovery_other_cloud_conditions::Conditions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryOtherCloudConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_age][crate::model::DiscoveryOtherCloudConditions::min_age].
    pub fn set_min_age<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_age = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::DiscoveryOtherCloudConditions::conditions].
    ///
    /// Note that all the setters affecting `conditions` are mutually
    /// exclusive.
    pub fn set_conditions<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_other_cloud_conditions::Conditions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// The value of [conditions][crate::model::DiscoveryOtherCloudConditions::conditions]
    /// if it holds a `AmazonS3BucketConditions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn amazon_s3_bucket_conditions(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AmazonS3BucketConditions>> {
        #[allow(unreachable_patterns)]
        self.conditions.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_conditions::Conditions::AmazonS3BucketConditions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [conditions][crate::model::DiscoveryOtherCloudConditions::conditions]
    /// to hold a `AmazonS3BucketConditions`.
    ///
    /// Note that all the setters affecting `conditions` are
    /// mutually exclusive.
    pub fn set_amazon_s3_bucket_conditions<
        T: std::convert::Into<std::boxed::Box<crate::model::AmazonS3BucketConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = std::option::Option::Some(
            crate::model::discovery_other_cloud_conditions::Conditions::AmazonS3BucketConditions(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryOtherCloudConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryOtherCloudConditions"
    }
}

/// Defines additional types related to [DiscoveryOtherCloudConditions].
pub mod discovery_other_cloud_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// The conditions to apply.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Conditions {
        /// Amazon S3 bucket conditions.
        AmazonS3BucketConditions(std::boxed::Box<crate::model::AmazonS3BucketConditions>),
    }
}

/// Amazon S3 bucket conditions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AmazonS3BucketConditions {
    /// Optional. Bucket types that should be profiled.
    /// Optional. Defaults to TYPE_ALL_SUPPORTED if unspecified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bucket_types: std::vec::Vec<crate::model::amazon_s_3_bucket_conditions::BucketType>,

    /// Optional. Object classes that should be profiled.
    /// Optional. Defaults to ALL_SUPPORTED_CLASSES if unspecified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub object_storage_classes:
        std::vec::Vec<crate::model::amazon_s_3_bucket_conditions::ObjectStorageClass>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AmazonS3BucketConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_types][crate::model::AmazonS3BucketConditions::bucket_types].
    pub fn set_bucket_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::amazon_s_3_bucket_conditions::BucketType>,
    {
        use std::iter::Iterator;
        self.bucket_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [object_storage_classes][crate::model::AmazonS3BucketConditions::object_storage_classes].
    pub fn set_object_storage_classes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::amazon_s_3_bucket_conditions::ObjectStorageClass>,
    {
        use std::iter::Iterator;
        self.object_storage_classes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AmazonS3BucketConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AmazonS3BucketConditions"
    }
}

/// Defines additional types related to [AmazonS3BucketConditions].
pub mod amazon_s_3_bucket_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Amazon S3 bucket types.
    /// Defaults to TYPE_ALL_SUPPORTED.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BucketType {
        /// Unused.
        TypeUnspecified,
        /// All supported classes.
        TypeAllSupported,
        /// A general purpose Amazon S3 bucket.
        TypeGeneralPurpose,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BucketType::value] or
        /// [BucketType::name].
        UnknownValue(bucket_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod bucket_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BucketType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some(0),
                Self::TypeAllSupported => std::option::Option::Some(1),
                Self::TypeGeneralPurpose => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::TypeUnspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::TypeAllSupported => std::option::Option::Some("TYPE_ALL_SUPPORTED"),
                Self::TypeGeneralPurpose => std::option::Option::Some("TYPE_GENERAL_PURPOSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BucketType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BucketType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BucketType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::TypeUnspecified,
                1 => Self::TypeAllSupported,
                2 => Self::TypeGeneralPurpose,
                _ => Self::UnknownValue(bucket_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BucketType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::TypeUnspecified,
                "TYPE_ALL_SUPPORTED" => Self::TypeAllSupported,
                "TYPE_GENERAL_PURPOSE" => Self::TypeGeneralPurpose,
                _ => Self::UnknownValue(bucket_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BucketType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::TypeUnspecified => serializer.serialize_i32(0),
                Self::TypeAllSupported => serializer.serialize_i32(1),
                Self::TypeGeneralPurpose => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BucketType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BucketType>::new(
                ".google.privacy.dlp.v2.AmazonS3BucketConditions.BucketType",
            ))
        }
    }

    /// Supported Amazon S3 object storage classes.
    /// Defaults to ALL_SUPPORTED_CLASSES.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ObjectStorageClass {
        /// Unused.
        Unspecified,
        /// All supported classes.
        AllSupportedClasses,
        /// Standard object class.
        Standard,
        /// Standard - infrequent access object class.
        StandardInfrequentAccess,
        /// Glacier - instant retrieval object class.
        GlacierInstantRetrieval,
        /// Objects in the S3 Intelligent-Tiering access tiers.
        IntelligentTiering,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ObjectStorageClass::value] or
        /// [ObjectStorageClass::name].
        UnknownValue(object_storage_class::UnknownValue),
    }

    #[doc(hidden)]
    pub mod object_storage_class {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ObjectStorageClass {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllSupportedClasses => std::option::Option::Some(1),
                Self::Standard => std::option::Option::Some(2),
                Self::StandardInfrequentAccess => std::option::Option::Some(4),
                Self::GlacierInstantRetrieval => std::option::Option::Some(6),
                Self::IntelligentTiering => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::AllSupportedClasses => std::option::Option::Some("ALL_SUPPORTED_CLASSES"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::StandardInfrequentAccess => {
                    std::option::Option::Some("STANDARD_INFREQUENT_ACCESS")
                }
                Self::GlacierInstantRetrieval => {
                    std::option::Option::Some("GLACIER_INSTANT_RETRIEVAL")
                }
                Self::IntelligentTiering => std::option::Option::Some("INTELLIGENT_TIERING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ObjectStorageClass {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ObjectStorageClass {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ObjectStorageClass {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllSupportedClasses,
                2 => Self::Standard,
                4 => Self::StandardInfrequentAccess,
                6 => Self::GlacierInstantRetrieval,
                7 => Self::IntelligentTiering,
                _ => Self::UnknownValue(object_storage_class::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ObjectStorageClass {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "ALL_SUPPORTED_CLASSES" => Self::AllSupportedClasses,
                "STANDARD" => Self::Standard,
                "STANDARD_INFREQUENT_ACCESS" => Self::StandardInfrequentAccess,
                "GLACIER_INSTANT_RETRIEVAL" => Self::GlacierInstantRetrieval,
                "INTELLIGENT_TIERING" => Self::IntelligentTiering,
                _ => Self::UnknownValue(object_storage_class::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ObjectStorageClass {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllSupportedClasses => serializer.serialize_i32(1),
                Self::Standard => serializer.serialize_i32(2),
                Self::StandardInfrequentAccess => serializer.serialize_i32(4),
                Self::GlacierInstantRetrieval => serializer.serialize_i32(6),
                Self::IntelligentTiering => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ObjectStorageClass {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ObjectStorageClass>::new(
                ".google.privacy.dlp.v2.AmazonS3BucketConditions.ObjectStorageClass",
            ))
        }
    }
}

/// How often existing resources should have their profiles refreshed.
/// New resources are scanned as quickly as possible depending on system
/// capacity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryOtherCloudGenerationCadence {
    /// Optional. Frequency to update profiles regardless of whether the underlying
    /// resource has changes. Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Optional. Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryOtherCloudGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryOtherCloudGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryOtherCloudGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<
        T: std::convert::Into<
                std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_cadence = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryOtherCloudGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryOtherCloudGenerationCadence"
    }
}

/// The location to begin a discovery scan. Denotes an organization ID or folder
/// ID within an organization.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryStartingLocation {
    /// The location to be scanned.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::discovery_starting_location::Location>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryStartingLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::DiscoveryStartingLocation::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    pub fn set_location<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_starting_location::Location>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::DiscoveryStartingLocation::location]
    /// if it holds a `OrganizationId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn organization_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::discovery_starting_location::Location::OrganizationId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::DiscoveryStartingLocation::location]
    /// to hold a `OrganizationId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_organization_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::discovery_starting_location::Location::OrganizationId(v.into()),
        );
        self
    }

    /// The value of [location][crate::model::DiscoveryStartingLocation::location]
    /// if it holds a `FolderId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn folder_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::discovery_starting_location::Location::FolderId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::DiscoveryStartingLocation::location]
    /// to hold a `FolderId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::discovery_starting_location::Location::FolderId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryStartingLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryStartingLocation"
    }
}

/// Defines additional types related to [DiscoveryStartingLocation].
pub mod discovery_starting_location {
    #[allow(unused_imports)]
    use super::*;

    /// The location to be scanned.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Location {
        /// The ID of an organization to scan.
        OrganizationId(i64),
        /// The ID of the folder within an organization to be scanned.
        FolderId(i64),
    }
}

/// The other cloud starting location for discovery.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudDiscoveryStartingLocation {
    /// The other cloud starting location for discovery.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location:
        std::option::Option<crate::model::other_cloud_discovery_starting_location::Location>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherCloudDiscoveryStartingLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::OtherCloudDiscoveryStartingLocation::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    pub fn set_location<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::other_cloud_discovery_starting_location::Location,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::OtherCloudDiscoveryStartingLocation::location]
    /// if it holds a `AwsLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_location(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<
            crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation,
        >,
    > {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::other_cloud_discovery_starting_location::Location::AwsLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::OtherCloudDiscoveryStartingLocation::location]
    /// to hold a `AwsLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_aws_location<T: std::convert::Into<std::boxed::Box<crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation>>>(mut self, v: T) -> Self{
        self.location = std::option::Option::Some(
            crate::model::other_cloud_discovery_starting_location::Location::AwsLocation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudDiscoveryStartingLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudDiscoveryStartingLocation"
    }
}

/// Defines additional types related to [OtherCloudDiscoveryStartingLocation].
pub mod other_cloud_discovery_starting_location {
    #[allow(unused_imports)]
    use super::*;

    /// The AWS starting location for discovery.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AwsDiscoveryStartingLocation {

        /// The scope of this starting location.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub scope: std::option::Option<crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AwsDiscoveryStartingLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope].
        ///
        /// Note that all the setters affecting `scope` are mutually
        /// exclusive.
        pub fn set_scope<T: std::convert::Into<std::option::Option<crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope>>>(mut self, v: T) -> Self
        {
            self.scope = v.into();
            self
        }

        /// The value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// if it holds a `AccountId`, `None` if the field is not set or
        /// holds a different branch.
        pub fn account_id(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.scope.as_ref().and_then(|v| match v {
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AccountId(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// to hold a `AccountId`.
        ///
        /// Note that all the setters affecting `scope` are
        /// mutually exclusive.
        pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.scope = std::option::Option::Some(
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AccountId(
                    v.into()
                )
            );
            self
        }

        /// The value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// if it holds a `AllAssetInventoryAssets`, `None` if the field is not set or
        /// holds a different branch.
        pub fn all_asset_inventory_assets(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.scope.as_ref().and_then(|v| match v {
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AllAssetInventoryAssets(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// to hold a `AllAssetInventoryAssets`.
        ///
        /// Note that all the setters affecting `scope` are
        /// mutually exclusive.
        pub fn set_all_asset_inventory_assets<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.scope = std::option::Option::Some(
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AllAssetInventoryAssets(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for AwsDiscoveryStartingLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.OtherCloudDiscoveryStartingLocation.AwsDiscoveryStartingLocation"
        }
    }

    /// Defines additional types related to [AwsDiscoveryStartingLocation].
    pub mod aws_discovery_starting_location {
        #[allow(unused_imports)]
        use super::*;

        /// The scope of this starting location.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Scope {
            /// The AWS account ID that this discovery config applies to.
            /// Within an AWS organization, you can find the AWS account ID inside an
            /// AWS account ARN. Example:
            /// arn:{partition}:organizations::{management_account_id}:account/{org_id}/{account_id}
            AccountId(std::string::String),
            /// All AWS assets stored in Asset Inventory that didn't match other AWS
            /// discovery configs.
            AllAssetInventoryAssets(bool),
        }
    }

    /// The other cloud starting location for discovery.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Location {
        /// The AWS starting location for discovery.
        AwsLocation(
            std::boxed::Box<
                crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation,
            >,
        ),
    }
}

/// Match discovery resources not covered by any other filter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AllOtherResources {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllOtherResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AllOtherResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AllOtherResources"
    }
}

/// Target used to match against for discovery with Vertex AI datasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexDatasetDiscoveryTarget {
    /// Required. The datasets the discovery cadence applies to. The first target
    /// with a matching filter will be the one to apply to a dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::DiscoveryVertexDatasetFilter>,

    /// In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::DiscoveryVertexDatasetConditions>,

    /// Type of schedule.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cadence: std::option::Option<crate::model::vertex_dataset_discovery_target::Cadence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::VertexDatasetDiscoveryTarget::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryVertexDatasetFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::VertexDatasetDiscoveryTarget::conditions].
    pub fn set_conditions<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryVertexDatasetConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// Sets the value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence].
    ///
    /// Note that all the setters affecting `cadence` are mutually
    /// exclusive.
    pub fn set_cadence<
        T: std::convert::Into<
                std::option::Option<crate::model::vertex_dataset_discovery_target::Cadence>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryVertexDatasetGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::vertex_dataset_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryVertexDatasetGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::vertex_dataset_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// The value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::vertex_dataset_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::vertex_dataset_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VertexDatasetDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetDiscoveryTarget"
    }
}

/// Defines additional types related to [VertexDatasetDiscoveryTarget].
pub mod vertex_dataset_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// Type of schedule.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Cadence {
        /// How often and when to update profiles. New datasets that match both the
        /// filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryVertexDatasetGenerationCadence>),
        /// Disable profiling for datasets that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines what datasets will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID or dataset regex.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryVertexDatasetFilter {
    /// Whether the filter applies to a specific set of datasets or all
    /// other datasets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, this field defaults to `others`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::discovery_vertex_dataset_filter::Filter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryVertexDatasetFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<
                std::option::Option<crate::model::discovery_vertex_dataset_filter::Filter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_vertex_dataset_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_vertex_dataset_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// if it holds a `VertexDatasetResourceReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_dataset_resource_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetResourceReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_vertex_dataset_filter::Filter::VertexDatasetResourceReference(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// to hold a `VertexDatasetResourceReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_resource_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_vertex_dataset_filter::Filter::VertexDatasetResourceReference(
                v.into(),
            ),
        );
        self
    }

    /// The value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn others(&self) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_vertex_dataset_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<T: std::convert::Into<std::boxed::Box<crate::model::AllOtherResources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_vertex_dataset_filter::Filter::Others(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryVertexDatasetFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryVertexDatasetFilter"
    }
}

/// Defines additional types related to [DiscoveryVertexDatasetFilter].
pub mod discovery_vertex_dataset_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of datasets or all
    /// other datasets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, this field defaults to `others`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// A specific set of Vertex AI datasets for this filter to apply to.
        Collection(std::boxed::Box<crate::model::VertexDatasetCollection>),
        /// The dataset resource to scan. Targets including this can only include
        /// one target (the target with this dataset resource reference).
        VertexDatasetResourceReference(
            std::boxed::Box<crate::model::VertexDatasetResourceReference>,
        ),
        /// Catch-all. This should always be the last target in the list because
        /// anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherResources>),
    }
}

/// Match dataset resources using regex filters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexDatasetCollection {
    /// The pattern used to filter dataset resources.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub pattern: std::option::Option<crate::model::vertex_dataset_collection::Pattern>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pattern][crate::model::VertexDatasetCollection::pattern].
    ///
    /// Note that all the setters affecting `pattern` are mutually
    /// exclusive.
    pub fn set_pattern<
        T: std::convert::Into<std::option::Option<crate::model::vertex_dataset_collection::Pattern>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::VertexDatasetCollection::pattern]
    /// if it holds a `VertexDatasetRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_dataset_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::vertex_dataset_collection::Pattern::VertexDatasetRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::VertexDatasetCollection::pattern]
    /// to hold a `VertexDatasetRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::vertex_dataset_collection::Pattern::VertexDatasetRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VertexDatasetCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetCollection"
    }
}

/// Defines additional types related to [VertexDatasetCollection].
pub mod vertex_dataset_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The pattern used to filter dataset resources.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Pattern {
        /// The regex used to filter dataset resources.
        VertexDatasetRegexes(std::boxed::Box<crate::model::VertexDatasetRegexes>),
    }
}

/// A collection of regular expressions to determine what datasets to match
/// against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexDatasetRegexes {
    /// Required. The group of regular expression patterns to match against one or
    /// more datasets. Maximum of 100 entries. The sum of the lengths of all
    /// regular expressions can't exceed 10 KiB.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patterns: std::vec::Vec<crate::model::VertexDatasetRegex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::VertexDatasetRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VertexDatasetRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VertexDatasetRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetRegexes"
    }
}

/// A pattern to match against one or more dataset resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexDatasetRegex {
    /// For organizations, if unset, will match all projects. Has no effect
    /// for configurations created within a project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id_regex: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::VertexDatasetRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }
}

impl wkt::message::Message for VertexDatasetRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetRegex"
    }
}

/// Identifies a single Vertex AI dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexDatasetResourceReference {
    /// Required. The name of the dataset resource. If set within a project-level
    /// configuration, the specified resource must be within the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_resource_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexDatasetResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_resource_name][crate::model::VertexDatasetResourceReference::dataset_resource_name].
    pub fn set_dataset_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_resource_name = v.into();
        self
    }
}

impl wkt::message::Message for VertexDatasetResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetResourceReference"
    }
}

/// Requirements that must be true before a dataset is profiled for the
/// first time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryVertexDatasetConditions {
    /// Vertex AI dataset must have been created after this date. Used to avoid
    /// backfilling.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_after: std::option::Option<wkt::Timestamp>,

    /// Minimum age a Vertex AI dataset must have. If set, the value must be 1 hour
    /// or greater.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_age: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryVertexDatasetConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_after][crate::model::DiscoveryVertexDatasetConditions::created_after].
    pub fn set_created_after<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.created_after = v.into();
        self
    }

    /// Sets the value of [min_age][crate::model::DiscoveryVertexDatasetConditions::min_age].
    pub fn set_min_age<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_age = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryVertexDatasetConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryVertexDatasetConditions"
    }
}

/// How often existing datasets should have their profiles refreshed.
/// New datasets are scanned as quickly as possible depending on system
/// capacity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryVertexDatasetGenerationCadence {
    /// If you set this field, profiles are refreshed at this
    /// frequency regardless of whether the underlying datasets have changed.
    /// Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to be
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryVertexDatasetGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryVertexDatasetGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryVertexDatasetGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<
        T: std::convert::Into<
                std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_cadence = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryVertexDatasetGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryVertexDatasetGenerationCadence"
    }
}

/// Combines all of the information about a DLP job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DlpJob {
    /// The server-assigned name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The type of job.
    #[serde(rename = "type")]
    pub r#type: crate::model::DlpJobType,

    /// State of a job.
    pub state: crate::model::dlp_job::JobState,

    /// Time when the job was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time when the job started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Time when the job finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Time when the job was last modified by the system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_modified: std::option::Option<wkt::Timestamp>,

    /// If created by a job trigger, the resource name of the trigger that
    /// instantiated the job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_trigger_name: std::string::String,

    /// A stream of errors encountered running the job.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Events that should occur after the job has completed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub action_details: std::vec::Vec<crate::model::ActionDetails>,

    /// Job details.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::dlp_job::Details>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DlpJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DlpJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DlpJob::type].
    pub fn set_type<T: std::convert::Into<crate::model::DlpJobType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DlpJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::dlp_job::JobState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DlpJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::DlpJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::DlpJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [last_modified][crate::model::DlpJob::last_modified].
    pub fn set_last_modified<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_modified = v.into();
        self
    }

    /// Sets the value of [job_trigger_name][crate::model::DlpJob::job_trigger_name].
    pub fn set_job_trigger_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_trigger_name = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::DlpJob::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [action_details][crate::model::DlpJob::action_details].
    pub fn set_action_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ActionDetails>,
    {
        use std::iter::Iterator;
        self.action_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [details][crate::model::DlpJob::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::dlp_job::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::DlpJob::details]
    /// if it holds a `RiskDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn risk_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AnalyzeDataSourceRiskDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::dlp_job::Details::RiskDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DlpJob::details]
    /// to hold a `RiskDetails`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_risk_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AnalyzeDataSourceRiskDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::dlp_job::Details::RiskDetails(v.into()));
        self
    }

    /// The value of [details][crate::model::DlpJob::details]
    /// if it holds a `InspectDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inspect_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InspectDataSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::dlp_job::Details::InspectDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DlpJob::details]
    /// to hold a `InspectDetails`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_inspect_details<
        T: std::convert::Into<std::boxed::Box<crate::model::InspectDataSourceDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::dlp_job::Details::InspectDetails(v.into()));
        self
    }
}

impl wkt::message::Message for DlpJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DlpJob"
    }
}

/// Defines additional types related to [DlpJob].
pub mod dlp_job {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a job. New items may be added.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobState {
        /// Unused.
        Unspecified,
        /// The job has not yet started.
        Pending,
        /// The job is currently running. Once a job has finished it will transition
        /// to FAILED or DONE.
        Running,
        /// The job is no longer running.
        Done,
        /// The job was canceled before it could be completed.
        Canceled,
        /// The job had an error and did not complete.
        Failed,
        /// The job is currently accepting findings via hybridInspect.
        /// A hybrid job in ACTIVE state may continue to have findings added to it
        /// through the calling of hybridInspect. After the job has finished no more
        /// calls to hybridInspect may be made. ACTIVE jobs can transition to DONE.
        Active,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [JobState::value] or
        /// [JobState::name].
        UnknownValue(job_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod job_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl JobState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::Canceled => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Active => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("JOB_STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::Canceled => std::option::Option::Some("CANCELED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for JobState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for JobState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for JobState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Done,
                4 => Self::Canceled,
                5 => Self::Failed,
                6 => Self::Active,
                _ => Self::UnknownValue(job_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for JobState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "JOB_STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                "CANCELED" => Self::Canceled,
                "FAILED" => Self::Failed,
                "ACTIVE" => Self::Active,
                _ => Self::UnknownValue(job_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for JobState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::Canceled => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Active => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for JobState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobState>::new(
                ".google.privacy.dlp.v2.DlpJob.JobState",
            ))
        }
    }

    /// Job details.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Results from analyzing risk of a data source.
        RiskDetails(std::boxed::Box<crate::model::AnalyzeDataSourceRiskDetails>),
        /// Results from inspecting a data source.
        InspectDetails(std::boxed::Box<crate::model::InspectDataSourceDetails>),
    }
}

/// The request message for
/// [GetDlpJob][google.privacy.dlp.v2.DlpService.GetDlpJob].
///
/// [google.privacy.dlp.v2.DlpService.GetDlpJob]: crate::client::DlpService::get_dlp_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDlpJobRequest {
    /// Required. The name of the DlpJob resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetDlpJobRequest"
    }
}

/// The request message for listing DLP jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDlpJobsRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values for inspect jobs:
    ///   - `state` - PENDING|RUNNING|CANCELED|FINISHED|FAILED
    ///   - `inspected_storage` - DATASTORE|CLOUD_STORAGE|BIGQUERY
    ///   - `trigger_name` - The name of the trigger that created the job.
    ///   - 'end_time` - Corresponds to the time the job finished.
    ///   - 'start_time` - Corresponds to the time the job finished.
    /// * Supported fields for risk analysis jobs:
    ///   - `state` - RUNNING|CANCELED|FINISHED|FAILED
    ///   - 'end_time` - Corresponds to the time the job finished.
    ///   - 'start_time` - Corresponds to the time the job finished.
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * inspected_storage = cloud_storage AND state = done
    /// * inspected_storage = cloud_storage OR inspected_storage = bigquery
    /// * inspected_storage = cloud_storage AND (state = done OR state = canceled)
    /// * end_time > \"2017-12-12T00:00:00+00:00\"
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The type of job. Defaults to `DlpJobType.INSPECT`
    #[serde(rename = "type")]
    pub r#type: crate::model::DlpJobType,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc, end_time asc, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the job was created.
    /// - `end_time`: corresponds to the time the job ended.
    /// - `name`: corresponds to the job's name.
    /// - `state`: corresponds to `state`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDlpJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDlpJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDlpJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDlpJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDlpJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ListDlpJobsRequest::type].
    pub fn set_type<T: std::convert::Into<crate::model::DlpJobType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDlpJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListDlpJobsRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListDlpJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDlpJobsRequest"
    }
}

/// The response message for listing DLP jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDlpJobsResponse {
    /// A list of DlpJobs that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jobs: std::vec::Vec<crate::model::DlpJob>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDlpJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::ListDlpJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DlpJob>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDlpJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDlpJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDlpJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDlpJobsResponse {
    type PageItem = crate::model::DlpJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for canceling a DLP job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelDlpJobRequest {
    /// Required. The name of the DlpJob resource to be cancelled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CancelDlpJobRequest"
    }
}

/// The request message for finishing a DLP hybrid job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FinishDlpJobRequest {
    /// Required. The name of the DlpJob resource to be finished.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FinishDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FinishDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for FinishDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FinishDlpJobRequest"
    }
}

/// The request message for deleting a DLP job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDlpJobRequest {
    /// Required. The name of the DlpJob resource to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteDlpJobRequest"
    }
}

/// Request message for CreateDeidentifyTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDeidentifyTemplateRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The DeidentifyTemplate to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deidentify_template: std::option::Option<crate::model::DeidentifyTemplate>,

    /// The template id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template_id: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeidentifyTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deidentify_template][crate::model::CreateDeidentifyTemplateRequest::deidentify_template].
    pub fn set_deidentify_template<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }

    /// Sets the value of [template_id][crate::model::CreateDeidentifyTemplateRequest::template_id].
    pub fn set_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateDeidentifyTemplateRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateDeidentifyTemplateRequest"
    }
}

/// Request message for UpdateDeidentifyTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDeidentifyTemplateRequest {
    /// Required. Resource name of organization and deidentify template to be
    /// updated, for example
    /// `organizations/433245324/deidentifyTemplates/432452342` or
    /// projects/project-id/deidentifyTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// New DeidentifyTemplate value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deidentify_template: std::option::Option<crate::model::DeidentifyTemplate>,

    /// Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateDeidentifyTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [deidentify_template][crate::model::UpdateDeidentifyTemplateRequest::deidentify_template].
    pub fn set_deidentify_template<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeidentifyTemplateRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest"
    }
}

/// Request message for GetDeidentifyTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDeidentifyTemplateRequest {
    /// Required. Resource name of the organization and deidentify template to be
    /// read, for example `organizations/433245324/deidentifyTemplates/432452342`
    /// or projects/project-id/deidentifyTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeidentifyTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetDeidentifyTemplateRequest"
    }
}

/// Request message for ListDeidentifyTemplates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeidentifyTemplatesRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to `ListDeidentifyTemplates`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero server
    /// returns a page of max size 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the template was created.
    /// - `update_time`: corresponds to the time the template was last updated.
    /// - `name`: corresponds to the template's name.
    /// - `display_name`: corresponds to the template's display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeidentifyTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeidentifyTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeidentifyTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeidentifyTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDeidentifyTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListDeidentifyTemplatesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListDeidentifyTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDeidentifyTemplatesRequest"
    }
}

/// Response message for ListDeidentifyTemplates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeidentifyTemplatesResponse {
    /// List of deidentify templates, up to page_size in
    /// ListDeidentifyTemplatesRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deidentify_templates: std::vec::Vec<crate::model::DeidentifyTemplate>,

    /// If the next page is available then the next page token to be used in the
    /// following ListDeidentifyTemplates request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeidentifyTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deidentify_templates][crate::model::ListDeidentifyTemplatesResponse::deidentify_templates].
    pub fn set_deidentify_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeidentifyTemplate>,
    {
        use std::iter::Iterator;
        self.deidentify_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDeidentifyTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeidentifyTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDeidentifyTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeidentifyTemplatesResponse {
    type PageItem = crate::model::DeidentifyTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deidentify_templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteDeidentifyTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDeidentifyTemplateRequest {
    /// Required. Resource name of the organization and deidentify template to be
    /// deleted, for example
    /// `organizations/433245324/deidentifyTemplates/432452342` or
    /// projects/project-id/deidentifyTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDeidentifyTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest"
    }
}

/// Configuration for a custom dictionary created from a data source of any size
/// up to the maximum size defined in the
/// [limits](https://cloud.google.com/sensitive-data-protection/limits) page. The
/// artifacts of dictionary creation are stored in the specified Cloud Storage
/// location. Consider using `CustomInfoType.Dictionary` for smaller dictionaries
/// that satisfy the size requirements.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LargeCustomDictionaryConfig {
    /// Location to store dictionary artifacts in Cloud Storage. These files
    /// will only be accessible by project owners and the DLP API. If any of these
    /// artifacts are modified, the dictionary is considered invalid and can no
    /// longer be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_path: std::option::Option<crate::model::CloudStoragePath>,

    /// Source of the dictionary.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::large_custom_dictionary_config::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LargeCustomDictionaryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_path][crate::model::LargeCustomDictionaryConfig::output_path].
    pub fn set_output_path<
        T: std::convert::Into<std::option::Option<crate::model::CloudStoragePath>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_path = v.into();
        self
    }

    /// Sets the value of [source][crate::model::LargeCustomDictionaryConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::large_custom_dictionary_config::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// if it holds a `CloudStorageFileSet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_file_set(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageFileSet>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::large_custom_dictionary_config::Source::CloudStorageFileSet(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// to hold a `CloudStorageFileSet`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cloud_storage_file_set<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageFileSet>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::large_custom_dictionary_config::Source::CloudStorageFileSet(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// if it holds a `BigQueryField`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_field(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryField>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::large_custom_dictionary_config::Source::BigQueryField(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// to hold a `BigQueryField`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_big_query_field<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryField>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::large_custom_dictionary_config::Source::BigQueryField(v.into()),
        );
        self
    }
}

impl wkt::message::Message for LargeCustomDictionaryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.LargeCustomDictionaryConfig"
    }
}

/// Defines additional types related to [LargeCustomDictionaryConfig].
pub mod large_custom_dictionary_config {
    #[allow(unused_imports)]
    use super::*;

    /// Source of the dictionary.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Set of files containing newline-delimited lists of dictionary phrases.
        CloudStorageFileSet(std::boxed::Box<crate::model::CloudStorageFileSet>),
        /// Field in a BigQuery table where each cell represents a dictionary phrase.
        BigQueryField(std::boxed::Box<crate::model::BigQueryField>),
    }
}

/// Summary statistics of a custom dictionary.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LargeCustomDictionaryStats {
    /// Approximate number of distinct phrases in the dictionary.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub approx_num_phrases: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LargeCustomDictionaryStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approx_num_phrases][crate::model::LargeCustomDictionaryStats::approx_num_phrases].
    pub fn set_approx_num_phrases<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.approx_num_phrases = v.into();
        self
    }
}

impl wkt::message::Message for LargeCustomDictionaryStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.LargeCustomDictionaryStats"
    }
}

/// Configuration for stored infoTypes. All fields and subfield are provided
/// by the user. For more information, see
/// <https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredInfoTypeConfig {
    /// Display name of the StoredInfoType (max 256 characters).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of the StoredInfoType (max 256 characters).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Stored infotype types.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::stored_info_type_config::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredInfoTypeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::StoredInfoTypeConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::StoredInfoTypeConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::stored_info_type_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// if it holds a `LargeCustomDictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn large_custom_dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LargeCustomDictionaryConfig>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_config::Type::LargeCustomDictionary(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// to hold a `LargeCustomDictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_large_custom_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::LargeCustomDictionaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::stored_info_type_config::Type::LargeCustomDictionary(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// if it holds a `Dictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Dictionary>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_config::Type::Dictionary(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// to hold a `Dictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Dictionary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::stored_info_type_config::Type::Dictionary(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// if it holds a `Regex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Regex>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_config::Type::Regex(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// to hold a `Regex`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Regex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::stored_info_type_config::Type::Regex(v.into()));
        self
    }
}

impl wkt::message::Message for StoredInfoTypeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoTypeConfig"
    }
}

/// Defines additional types related to [StoredInfoTypeConfig].
pub mod stored_info_type_config {
    #[allow(unused_imports)]
    use super::*;

    /// Stored infotype types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// StoredInfoType where findings are defined by a dictionary of phrases.
        LargeCustomDictionary(std::boxed::Box<crate::model::LargeCustomDictionaryConfig>),
        /// Store dictionary-based CustomInfoType.
        Dictionary(std::boxed::Box<crate::model::custom_info_type::Dictionary>),
        /// Store regular expression-based StoredInfoType.
        Regex(std::boxed::Box<crate::model::custom_info_type::Regex>),
    }
}

/// Statistics for a StoredInfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredInfoTypeStats {
    /// Stat types
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::stored_info_type_stats::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredInfoTypeStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeStats::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::stored_info_type_stats::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::StoredInfoTypeStats::r#type]
    /// if it holds a `LargeCustomDictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn large_custom_dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LargeCustomDictionaryStats>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_stats::Type::LargeCustomDictionary(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeStats::r#type]
    /// to hold a `LargeCustomDictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_large_custom_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::LargeCustomDictionaryStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::stored_info_type_stats::Type::LargeCustomDictionary(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StoredInfoTypeStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoTypeStats"
    }
}

/// Defines additional types related to [StoredInfoTypeStats].
pub mod stored_info_type_stats {
    #[allow(unused_imports)]
    use super::*;

    /// Stat types
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// StoredInfoType where findings are defined by a dictionary of phrases.
        LargeCustomDictionary(std::boxed::Box<crate::model::LargeCustomDictionaryStats>),
    }
}

/// Version of a StoredInfoType, including the configuration used to build it,
/// create timestamp, and current state.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredInfoTypeVersion {
    /// StoredInfoType configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::StoredInfoTypeConfig>,

    /// Create timestamp of the version. Read-only, determined by the system
    /// when the version is created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Stored info type version state. Read-only, updated by the system
    /// during dictionary creation.
    pub state: crate::model::StoredInfoTypeState,

    /// Errors that occurred when creating this storedInfoType version, or
    /// anomalies detected in the storedInfoType data that render it unusable. Only
    /// the five most recent errors will be displayed, with the most recent error
    /// appearing first.
    ///
    /// For example, some of the data for stored custom dictionaries is put in
    /// the user's Cloud Storage bucket, and if this data is modified or
    /// deleted by the user or another system, the dictionary becomes invalid.
    ///
    /// If any errors occur, fix the problem indicated by the error message and
    /// use the UpdateStoredInfoType API method to create another version of the
    /// storedInfoType to continue using it, reusing the same `config` if it was
    /// not the source of the error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Statistics about this storedInfoType version.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stats: std::option::Option<crate::model::StoredInfoTypeStats>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredInfoTypeVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::StoredInfoTypeVersion::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::StoredInfoTypeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::StoredInfoTypeVersion::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::StoredInfoTypeVersion::state].
    pub fn set_state<T: std::convert::Into<crate::model::StoredInfoTypeState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::StoredInfoTypeVersion::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [stats][crate::model::StoredInfoTypeVersion::stats].
    pub fn set_stats<
        T: std::convert::Into<std::option::Option<crate::model::StoredInfoTypeStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.stats = v.into();
        self
    }
}

impl wkt::message::Message for StoredInfoTypeVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoTypeVersion"
    }
}

/// StoredInfoType resource message that contains information about the current
/// version and any pending updates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredInfoType {
    /// Resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Current version of the stored info type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub current_version: std::option::Option<crate::model::StoredInfoTypeVersion>,

    /// Pending versions of the stored info type. Empty if no versions are
    /// pending.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pending_versions: std::vec::Vec<crate::model::StoredInfoTypeVersion>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredInfoType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StoredInfoType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [current_version][crate::model::StoredInfoType::current_version].
    pub fn set_current_version<
        T: std::convert::Into<std::option::Option<crate::model::StoredInfoTypeVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.current_version = v.into();
        self
    }

    /// Sets the value of [pending_versions][crate::model::StoredInfoType::pending_versions].
    pub fn set_pending_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StoredInfoTypeVersion>,
    {
        use std::iter::Iterator;
        self.pending_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StoredInfoType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoType"
    }
}

/// Request message for CreateStoredInfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateStoredInfoTypeRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Configuration of the storedInfoType to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::StoredInfoTypeConfig>,

    /// The storedInfoType ID can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub stored_info_type_id: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateStoredInfoTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [config][crate::model::CreateStoredInfoTypeRequest::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::StoredInfoTypeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [stored_info_type_id][crate::model::CreateStoredInfoTypeRequest::stored_info_type_id].
    pub fn set_stored_info_type_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.stored_info_type_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateStoredInfoTypeRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateStoredInfoTypeRequest"
    }
}

/// Request message for UpdateStoredInfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateStoredInfoTypeRequest {
    /// Required. Resource name of organization and storedInfoType to be updated,
    /// for example `organizations/433245324/storedInfoTypes/432452342` or
    /// projects/project-id/storedInfoTypes/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Updated configuration for the storedInfoType. If not provided, a new
    /// version of the storedInfoType will be created with the existing
    /// configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::StoredInfoTypeConfig>,

    /// Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateStoredInfoTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::UpdateStoredInfoTypeRequest::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::StoredInfoTypeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateStoredInfoTypeRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateStoredInfoTypeRequest"
    }
}

/// Request message for GetStoredInfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetStoredInfoTypeRequest {
    /// Required. Resource name of the organization and storedInfoType to be read,
    /// for example `organizations/433245324/storedInfoTypes/432452342` or
    /// projects/project-id/storedInfoTypes/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStoredInfoTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetStoredInfoTypeRequest"
    }
}

/// Request message for ListStoredInfoTypes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStoredInfoTypesRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to `ListStoredInfoTypes`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero server
    /// returns a page of max size 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc, display_name, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the most recent version of the
    ///   resource was created.
    /// - `state`: corresponds to the state of the resource.
    /// - `name`: corresponds to resource name.
    /// - `display_name`: corresponds to info type's display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStoredInfoTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListStoredInfoTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListStoredInfoTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListStoredInfoTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListStoredInfoTypesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListStoredInfoTypesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListStoredInfoTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListStoredInfoTypesRequest"
    }
}

/// Response message for ListStoredInfoTypes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStoredInfoTypesResponse {
    /// List of storedInfoTypes, up to page_size in ListStoredInfoTypesRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stored_info_types: std::vec::Vec<crate::model::StoredInfoType>,

    /// If the next page is available then the next page token to be used
    /// in the following ListStoredInfoTypes request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStoredInfoTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stored_info_types][crate::model::ListStoredInfoTypesResponse::stored_info_types].
    pub fn set_stored_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StoredInfoType>,
    {
        use std::iter::Iterator;
        self.stored_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListStoredInfoTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListStoredInfoTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListStoredInfoTypesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListStoredInfoTypesResponse {
    type PageItem = crate::model::StoredInfoType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.stored_info_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteStoredInfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteStoredInfoTypeRequest {
    /// Required. Resource name of the organization and storedInfoType to be
    /// deleted, for example `organizations/433245324/storedInfoTypes/432452342` or
    /// projects/project-id/storedInfoTypes/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteStoredInfoTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteStoredInfoTypeRequest"
    }
}

/// Request to search for potentially sensitive info in a custom location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridInspectJobTriggerRequest {
    /// Required. Resource name of the trigger to execute a hybrid inspect on, for
    /// example `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The item to inspect.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hybrid_item: std::option::Option<crate::model::HybridContentItem>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridInspectJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HybridInspectJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [hybrid_item][crate::model::HybridInspectJobTriggerRequest::hybrid_item].
    pub fn set_hybrid_item<
        T: std::convert::Into<std::option::Option<crate::model::HybridContentItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hybrid_item = v.into();
        self
    }
}

impl wkt::message::Message for HybridInspectJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectJobTriggerRequest"
    }
}

/// Request to search for potentially sensitive info in a custom location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridInspectDlpJobRequest {
    /// Required. Resource name of the job to execute a hybrid inspect on, for
    /// example `projects/dlp-test-project/dlpJob/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The item to inspect.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hybrid_item: std::option::Option<crate::model::HybridContentItem>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridInspectDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HybridInspectDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [hybrid_item][crate::model::HybridInspectDlpJobRequest::hybrid_item].
    pub fn set_hybrid_item<
        T: std::convert::Into<std::option::Option<crate::model::HybridContentItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hybrid_item = v.into();
        self
    }
}

impl wkt::message::Message for HybridInspectDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectDlpJobRequest"
    }
}

/// An individual hybrid item to inspect. Will be stored temporarily during
/// processing.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridContentItem {
    /// The item to inspect.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Supplementary information that will be added to each finding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finding_details: std::option::Option<crate::model::HybridFindingDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridContentItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [item][crate::model::HybridContentItem::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [finding_details][crate::model::HybridContentItem::finding_details].
    pub fn set_finding_details<
        T: std::convert::Into<std::option::Option<crate::model::HybridFindingDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.finding_details = v.into();
        self
    }
}

impl wkt::message::Message for HybridContentItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridContentItem"
    }
}

/// Populate to associate additional data with each finding.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridFindingDetails {
    /// Details about the container where the content being inspected is from.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container_details: std::option::Option<crate::model::Container>,

    /// Offset in bytes of the line, from the beginning of the file, where the
    /// finding  is located. Populate if the item being scanned is only part of a
    /// bigger item, such as a shard of a file and you want to track the absolute
    /// position of the finding.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub file_offset: i64,

    /// Offset of the row for tables. Populate if the row(s) being scanned are
    /// part of a bigger dataset and you want to keep track of their absolute
    /// position.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub row_offset: i64,

    /// If the container is a table, additional information to make findings
    /// meaningful such as the columns that are primary keys. If not known ahead
    /// of time, can also be set within each inspect hybrid call and the two
    /// will be merged. Note that identifying_fields will only be stored to
    /// BigQuery, and only if the BigQuery action has been included.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_options: std::option::Option<crate::model::TableOptions>,

    /// Labels to represent user provided metadata about the data being inspected.
    /// If configured by the job, some key values may be required.
    /// The labels associated with `Finding`'s produced by hybrid
    /// inspection.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// Label values must be between 0 and 63 characters long and must conform
    /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
    ///
    /// No more than 10 labels can be associated with a given finding.
    ///
    /// Examples:
    ///
    /// * `"environment" : "production"`
    /// * `"pipeline" : "etl"`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridFindingDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_details][crate::model::HybridFindingDetails::container_details].
    pub fn set_container_details<
        T: std::convert::Into<std::option::Option<crate::model::Container>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.container_details = v.into();
        self
    }

    /// Sets the value of [file_offset][crate::model::HybridFindingDetails::file_offset].
    pub fn set_file_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.file_offset = v.into();
        self
    }

    /// Sets the value of [row_offset][crate::model::HybridFindingDetails::row_offset].
    pub fn set_row_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_offset = v.into();
        self
    }

    /// Sets the value of [table_options][crate::model::HybridFindingDetails::table_options].
    pub fn set_table_options<
        T: std::convert::Into<std::option::Option<crate::model::TableOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_options = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::HybridFindingDetails::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for HybridFindingDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridFindingDetails"
    }
}

/// Quota exceeded errors will be thrown once quota has been met.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridInspectResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridInspectResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for HybridInspectResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectResponse"
    }
}

/// Request to list the profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProjectDataProfilesRequest {
    /// Required. organizations/{org_id}/locations/{loc_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero, server
    /// returns a page of max size 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Comma-separated list of fields to order by, followed by `asc` or `desc`
    /// postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: Google Cloud project ID
    /// - `sensitivity_level`: How sensitive the data in a project is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `sensitivity_level` - HIGH|MODERATE|LOW
    ///   - `data_risk_level` - HIGH|MODERATE|LOW
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * `project_id = 12345 AND status_code = 1`
    /// * `project_id = 12345 AND sensitivity_level = HIGH`
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProjectDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProjectDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProjectDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProjectDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListProjectDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListProjectDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListProjectDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListProjectDataProfilesRequest"
    }
}

/// List of profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProjectDataProfilesResponse {
    /// List of data profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub project_data_profiles: std::vec::Vec<crate::model::ProjectDataProfile>,

    /// The next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProjectDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_data_profiles][crate::model::ListProjectDataProfilesResponse::project_data_profiles].
    pub fn set_project_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProjectDataProfile>,
    {
        use std::iter::Iterator;
        self.project_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProjectDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProjectDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListProjectDataProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProjectDataProfilesResponse {
    type PageItem = crate::model::ProjectDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.project_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to list the profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTableDataProfilesRequest {
    /// Required. Resource name of the organization or project, for
    /// example `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero, server
    /// returns a page of max size 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Comma-separated list of fields to order by, followed by `asc` or `desc`
    /// postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id asc`
    /// * `table_id`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: The Google Cloud project ID.
    /// - `dataset_id`: The ID of a BigQuery dataset.
    /// - `table_id`: The ID of a BigQuery table.
    /// - `sensitivity_level`: How sensitive the data in a table is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    /// - `last_modified`: The last time the resource was modified.
    /// - `resource_visibility`: Visibility restriction for this resource.
    /// - `row_count`: Number of rows in this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `project_id` - The Google Cloud project ID.
    ///   - `dataset_id` - The BigQuery dataset ID.
    ///   - `table_id` - The ID of the BigQuery table.
    ///   - `sensitivity_level` - HIGH|MODERATE|LOW
    ///   - `data_risk_level` - HIGH|MODERATE|LOW
    ///   - `resource_visibility`: PUBLIC|RESTRICTED
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * `project_id = 12345 AND status_code = 1`
    /// * `project_id = 12345 AND sensitivity_level = HIGH`
    /// * `project_id = 12345 AND resource_visibility = PUBLIC`
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTableDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTableDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTableDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTableDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTableDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTableDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListTableDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListTableDataProfilesRequest"
    }
}

/// List of profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTableDataProfilesResponse {
    /// List of data profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub table_data_profiles: std::vec::Vec<crate::model::TableDataProfile>,

    /// The next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTableDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_data_profiles][crate::model::ListTableDataProfilesResponse::table_data_profiles].
    pub fn set_table_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableDataProfile>,
    {
        use std::iter::Iterator;
        self.table_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTableDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTableDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListTableDataProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTableDataProfilesResponse {
    type PageItem = crate::model::TableDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.table_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to list the profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListColumnDataProfilesRequest {
    /// Required. Resource name of the organization or project, for
    /// example `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero, server
    /// returns a page of max size 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Comma-separated list of fields to order by, followed by `asc` or `desc`
    /// postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id asc`
    /// * `table_id`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: The Google Cloud project ID.
    /// - `dataset_id`: The ID of a BigQuery dataset.
    /// - `table_id`: The ID of a BigQuery table.
    /// - `sensitivity_level`: How sensitive the data in a column is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `table_data_profile_name` - The name of the related table data
    ///     profile.
    ///   - `project_id` - The Google Cloud project ID. (REQUIRED)
    ///   - `dataset_id` - The BigQuery dataset ID. (REQUIRED)
    ///   - `table_id` - The BigQuery table ID. (REQUIRED)
    ///   - `field_id` - The ID of the BigQuery field.
    ///   - `info_type` - The infotype detected in the resource.
    ///   - `sensitivity_level` - HIGH|MEDIUM|LOW
    ///   - `data_risk_level`: How much risk is associated with this data.
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` for project_id, dataset_id, and table_id. Other
    ///   filters also support `!=`.
    ///
    /// Examples:
    ///
    /// * project_id = 12345 AND status_code = 1
    /// * project_id = 12345 AND sensitivity_level = HIGH
    /// * project_id = 12345 AND info_type = STREET_ADDRESS
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListColumnDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListColumnDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListColumnDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListColumnDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListColumnDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListColumnDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListColumnDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListColumnDataProfilesRequest"
    }
}

/// List of profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListColumnDataProfilesResponse {
    /// List of data profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub column_data_profiles: std::vec::Vec<crate::model::ColumnDataProfile>,

    /// The next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListColumnDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column_data_profiles][crate::model::ListColumnDataProfilesResponse::column_data_profiles].
    pub fn set_column_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnDataProfile>,
    {
        use std::iter::Iterator;
        self.column_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListColumnDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListColumnDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListColumnDataProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListColumnDataProfilesResponse {
    type PageItem = crate::model::ColumnDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.column_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Score is a summary of all elements in the data profile.
/// A higher number means more risk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataRiskLevel {
    /// The score applied to the resource.
    pub score: crate::model::data_risk_level::DataRiskLevelScore,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataRiskLevel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::DataRiskLevel::score].
    pub fn set_score<T: std::convert::Into<crate::model::data_risk_level::DataRiskLevelScore>>(
        mut self,
        v: T,
    ) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for DataRiskLevel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataRiskLevel"
    }
}

/// Defines additional types related to [DataRiskLevel].
pub mod data_risk_level {
    #[allow(unused_imports)]
    use super::*;

    /// Various score levels for resources.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataRiskLevelScore {
        /// Unused.
        RiskScoreUnspecified,
        /// Low risk - Lower indication of sensitive data that appears to have
        /// additional access restrictions in place or no indication of sensitive
        /// data found.
        RiskLow,
        /// Unable to determine risk.
        RiskUnknown,
        /// Medium risk - Sensitive data may be present but additional access or fine
        /// grain access restrictions appear to be present.  Consider limiting
        /// access even further or transform data to mask.
        RiskModerate,
        /// High risk – SPII may be present. Access controls may include public
        /// ACLs. Exfiltration of data may lead to user data loss. Re-identification
        /// of users may be possible. Consider limiting usage and or removing SPII.
        RiskHigh,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataRiskLevelScore::value] or
        /// [DataRiskLevelScore::name].
        UnknownValue(data_risk_level_score::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_risk_level_score {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataRiskLevelScore {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::RiskScoreUnspecified => std::option::Option::Some(0),
                Self::RiskLow => std::option::Option::Some(10),
                Self::RiskUnknown => std::option::Option::Some(12),
                Self::RiskModerate => std::option::Option::Some(20),
                Self::RiskHigh => std::option::Option::Some(30),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::RiskScoreUnspecified => std::option::Option::Some("RISK_SCORE_UNSPECIFIED"),
                Self::RiskLow => std::option::Option::Some("RISK_LOW"),
                Self::RiskUnknown => std::option::Option::Some("RISK_UNKNOWN"),
                Self::RiskModerate => std::option::Option::Some("RISK_MODERATE"),
                Self::RiskHigh => std::option::Option::Some("RISK_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataRiskLevelScore {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataRiskLevelScore {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataRiskLevelScore {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::RiskScoreUnspecified,
                10 => Self::RiskLow,
                12 => Self::RiskUnknown,
                20 => Self::RiskModerate,
                30 => Self::RiskHigh,
                _ => Self::UnknownValue(data_risk_level_score::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataRiskLevelScore {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RISK_SCORE_UNSPECIFIED" => Self::RiskScoreUnspecified,
                "RISK_LOW" => Self::RiskLow,
                "RISK_UNKNOWN" => Self::RiskUnknown,
                "RISK_MODERATE" => Self::RiskModerate,
                "RISK_HIGH" => Self::RiskHigh,
                _ => Self::UnknownValue(data_risk_level_score::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataRiskLevelScore {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::RiskScoreUnspecified => serializer.serialize_i32(0),
                Self::RiskLow => serializer.serialize_i32(10),
                Self::RiskUnknown => serializer.serialize_i32(12),
                Self::RiskModerate => serializer.serialize_i32(20),
                Self::RiskHigh => serializer.serialize_i32(30),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataRiskLevelScore {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataRiskLevelScore>::new(
                ".google.privacy.dlp.v2.DataRiskLevel.DataRiskLevelScore",
            ))
        }
    }
}

/// An aggregated profile for this project, based on the resources profiled
/// within it.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProjectDataProfile {
    /// The resource name of the profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Project ID or account that was profiled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The last time the profile was generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// The sensitivity score of this project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// Success or error status of the last attempt to profile the project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// The number of table data profiles generated for this project.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub table_data_profile_count: i64,

    /// The number of file store data profiles generated for this project.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub file_store_data_profile_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProjectDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProjectDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::ProjectDataProfile::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::ProjectDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_last_generated = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::ProjectDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [data_risk_level][crate::model::ProjectDataProfile::data_risk_level].
    pub fn set_data_risk_level<
        T: std::convert::Into<std::option::Option<crate::model::DataRiskLevel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_risk_level = v.into();
        self
    }

    /// Sets the value of [profile_status][crate::model::ProjectDataProfile::profile_status].
    pub fn set_profile_status<
        T: std::convert::Into<std::option::Option<crate::model::ProfileStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_status = v.into();
        self
    }

    /// Sets the value of [table_data_profile_count][crate::model::ProjectDataProfile::table_data_profile_count].
    pub fn set_table_data_profile_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.table_data_profile_count = v.into();
        self
    }

    /// Sets the value of [file_store_data_profile_count][crate::model::ProjectDataProfile::file_store_data_profile_count].
    pub fn set_file_store_data_profile_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.file_store_data_profile_count = v.into();
        self
    }
}

impl wkt::message::Message for ProjectDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ProjectDataProfile"
    }
}

/// Snapshot of the configurations used to generate the profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileConfigSnapshot {
    /// A copy of the inspection config used to generate this profile. This
    /// is a copy of the inspect_template specified in `DataProfileJobConfig`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// A copy of the configuration used to generate this profile. This is
    /// deprecated, and the DiscoveryConfig field is preferred moving forward.
    /// DataProfileJobConfig will still be written here for Discovery in BigQuery
    /// for backwards compatibility, but will not be updated with new fields, while
    /// DiscoveryConfig will.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub data_profile_job: std::option::Option<crate::model::DataProfileJobConfig>,

    /// A copy of the configuration used to generate this profile.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub discovery_config: std::option::Option<crate::model::DiscoveryConfig>,

    /// Name of the inspection template used to generate this profile
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template_name: std::string::String,

    /// Timestamp when the template was modified
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileConfigSnapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inspect_config][crate::model::DataProfileConfigSnapshot::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [data_profile_job][crate::model::DataProfileConfigSnapshot::data_profile_job].
    #[deprecated]
    pub fn set_data_profile_job<
        T: std::convert::Into<std::option::Option<crate::model::DataProfileJobConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile_job = v.into();
        self
    }

    /// Sets the value of [discovery_config][crate::model::DataProfileConfigSnapshot::discovery_config].
    pub fn set_discovery_config<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_config = v.into();
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::DataProfileConfigSnapshot::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_time][crate::model::DataProfileConfigSnapshot::inspect_template_modified_time].
    pub fn set_inspect_template_modified_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_time = v.into();
        self
    }
}

impl wkt::message::Message for DataProfileConfigSnapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileConfigSnapshot"
    }
}

/// The profile for a scanned table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableDataProfile {
    /// The name of the profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The resource type that was profiled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_source_type: std::option::Option<crate::model::DataSourceType>,

    /// The resource name of the project data profile for this table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_data_profile: std::string::String,

    /// The Google Cloud project ID that owns the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_project_id: std::string::String,

    /// If supported, the location where the dataset's data is stored.
    /// See <https://cloud.google.com/bigquery/docs/locations> for supported
    /// locations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_location: std::string::String,

    /// If the resource is BigQuery, the dataset ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// The table ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// The Cloud Asset Inventory resource that was profiled in order to generate
    /// this TableDataProfile.
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_resource: std::string::String,

    /// Success or error status from the most recent profile generation attempt.
    /// May be empty if the profile is still being generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// State of a profile.
    pub state: crate::model::table_data_profile::State,

    /// The sensitivity score of this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// The infoTypes predicted from this table's data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub predicted_info_types: std::vec::Vec<crate::model::InfoTypeSummary>,

    /// Other infoTypes found in this table's data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub other_info_types: std::vec::Vec<crate::model::OtherInfoTypeSummary>,

    /// The snapshot of the configurations used to generate the profile.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_snapshot: std::option::Option<crate::model::DataProfileConfigSnapshot>,

    /// The time when this table was last modified
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_modified_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The time when this table expires.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// The number of columns profiled in the table.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub scanned_column_count: i64,

    /// The number of columns skipped in the table because of an error.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_column_count: i64,

    /// The size of the table when the profile was generated.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub table_size_bytes: i64,

    /// Number of rows in the table when the profile was generated.
    /// This will not be populated for BigLake tables.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub row_count: i64,

    /// How the table is encrypted.
    pub encryption_status: crate::model::EncryptionStatus,

    /// How broadly a resource has been shared.
    pub resource_visibility: crate::model::ResourceVisibility,

    /// The last time the profile was generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// The labels applied to the resource at the time the profile was generated.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The time at which the table was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The BigQuery table to which the sample findings are written.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sample_findings_table: std::option::Option<crate::model::BigQueryTable>,

    /// The tags attached to the table, including any tags attached during
    /// profiling. Because tags are attached to Cloud SQL instances rather than
    /// Cloud SQL tables, this field is empty for Cloud SQL table profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<crate::model::Tag>,

    /// Resources related to this profile.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_resources: std::vec::Vec<crate::model::RelatedResource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TableDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_source_type][crate::model::TableDataProfile::data_source_type].
    pub fn set_data_source_type<
        T: std::convert::Into<std::option::Option<crate::model::DataSourceType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source_type = v.into();
        self
    }

    /// Sets the value of [project_data_profile][crate::model::TableDataProfile::project_data_profile].
    pub fn set_project_data_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_data_profile = v.into();
        self
    }

    /// Sets the value of [dataset_project_id][crate::model::TableDataProfile::dataset_project_id].
    pub fn set_dataset_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_project_id = v.into();
        self
    }

    /// Sets the value of [dataset_location][crate::model::TableDataProfile::dataset_location].
    pub fn set_dataset_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_location = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::TableDataProfile::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::TableDataProfile::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [full_resource][crate::model::TableDataProfile::full_resource].
    pub fn set_full_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_resource = v.into();
        self
    }

    /// Sets the value of [profile_status][crate::model::TableDataProfile::profile_status].
    pub fn set_profile_status<
        T: std::convert::Into<std::option::Option<crate::model::ProfileStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_status = v.into();
        self
    }

    /// Sets the value of [state][crate::model::TableDataProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::table_data_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::TableDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [data_risk_level][crate::model::TableDataProfile::data_risk_level].
    pub fn set_data_risk_level<
        T: std::convert::Into<std::option::Option<crate::model::DataRiskLevel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_risk_level = v.into();
        self
    }

    /// Sets the value of [predicted_info_types][crate::model::TableDataProfile::predicted_info_types].
    pub fn set_predicted_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.predicted_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [other_info_types][crate::model::TableDataProfile::other_info_types].
    pub fn set_other_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OtherInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.other_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [config_snapshot][crate::model::TableDataProfile::config_snapshot].
    pub fn set_config_snapshot<
        T: std::convert::Into<std::option::Option<crate::model::DataProfileConfigSnapshot>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config_snapshot = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::TableDataProfile::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::TableDataProfile::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [scanned_column_count][crate::model::TableDataProfile::scanned_column_count].
    pub fn set_scanned_column_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.scanned_column_count = v.into();
        self
    }

    /// Sets the value of [failed_column_count][crate::model::TableDataProfile::failed_column_count].
    pub fn set_failed_column_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_column_count = v.into();
        self
    }

    /// Sets the value of [table_size_bytes][crate::model::TableDataProfile::table_size_bytes].
    pub fn set_table_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.table_size_bytes = v.into();
        self
    }

    /// Sets the value of [row_count][crate::model::TableDataProfile::row_count].
    pub fn set_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_count = v.into();
        self
    }

    /// Sets the value of [encryption_status][crate::model::TableDataProfile::encryption_status].
    pub fn set_encryption_status<T: std::convert::Into<crate::model::EncryptionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_status = v.into();
        self
    }

    /// Sets the value of [resource_visibility][crate::model::TableDataProfile::resource_visibility].
    pub fn set_resource_visibility<T: std::convert::Into<crate::model::ResourceVisibility>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_visibility = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::TableDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_last_generated = v.into();
        self
    }

    /// Sets the value of [resource_labels][crate::model::TableDataProfile::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::TableDataProfile::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [sample_findings_table][crate::model::TableDataProfile::sample_findings_table].
    pub fn set_sample_findings_table<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_findings_table = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::TableDataProfile::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [related_resources][crate::model::TableDataProfile::related_resources].
    pub fn set_related_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedResource>,
    {
        use std::iter::Iterator;
        self.related_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableDataProfile"
    }
}

/// Defines additional types related to [TableDataProfile].
pub mod table_data_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a profile. New items may be added.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unspecified,
        /// The profile is currently running. Once a profile has finished it will
        /// transition to DONE.
        Running,
        /// The profile is no longer generating.
        /// If profile_status.status.code is 0, the profile succeeded, otherwise, it
        /// failed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Done => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Done => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.privacy.dlp.v2.TableDataProfile.State",
            ))
        }
    }
}

/// Success or errors for the profile generation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProfileStatus {
    /// Profiling status code and optional message. The `status.code` value is 0
    /// (default value) for OK.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,

    /// Time when the profile generation status was updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timestamp: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProfileStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::ProfileStatus::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [timestamp][crate::model::ProfileStatus::timestamp].
    pub fn set_timestamp<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timestamp = v.into();
        self
    }
}

impl wkt::message::Message for ProfileStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ProfileStatus"
    }
}

/// The infoType details for this column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoTypeSummary {
    /// The infoType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Not populated for predicted infotypes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub estimated_prevalence: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoTypeSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::InfoTypeSummary::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [estimated_prevalence][crate::model::InfoTypeSummary::estimated_prevalence].
    #[deprecated]
    pub fn set_estimated_prevalence<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.estimated_prevalence = v.into();
        self
    }
}

impl wkt::message::Message for InfoTypeSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeSummary"
    }
}

/// Infotype details for other infoTypes found within a column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherInfoTypeSummary {
    /// The other infoType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Approximate percentage of non-null rows that contained data detected by
    /// this infotype.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub estimated_prevalence: i32,

    /// Whether this infoType was excluded from sensitivity and risk analysis due
    /// to factors such as low prevalence (subject to change).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub excluded_from_analysis: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OtherInfoTypeSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::OtherInfoTypeSummary::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [estimated_prevalence][crate::model::OtherInfoTypeSummary::estimated_prevalence].
    pub fn set_estimated_prevalence<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.estimated_prevalence = v.into();
        self
    }

    /// Sets the value of [excluded_from_analysis][crate::model::OtherInfoTypeSummary::excluded_from_analysis].
    pub fn set_excluded_from_analysis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.excluded_from_analysis = v.into();
        self
    }
}

impl wkt::message::Message for OtherInfoTypeSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherInfoTypeSummary"
    }
}

/// The profile for a scanned column within a table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ColumnDataProfile {
    /// The name of the profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Success or error status from the most recent profile generation attempt.
    /// May be empty if the profile is still being generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// State of a profile.
    pub state: crate::model::column_data_profile::State,

    /// The last time the profile was generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// The resource name of the table data profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_data_profile: std::string::String,

    /// The resource name of the resource this column is within.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_full_resource: std::string::String,

    /// The Google Cloud project ID that owns the profiled resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_project_id: std::string::String,

    /// If supported, the location where the dataset's data is stored.
    /// See <https://cloud.google.com/bigquery/docs/locations> for supported
    /// BigQuery locations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_location: std::string::String,

    /// The BigQuery dataset ID, if the resource profiled is a BigQuery table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// The table ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// The name of the column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub column: std::string::String,

    /// The sensitivity of this column.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level for this column.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// If it's been determined this column can be identified as a single type,
    /// this will be set. Otherwise the column either has unidentifiable content
    /// or mixed types.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub column_info_type: std::option::Option<crate::model::InfoTypeSummary>,

    /// Other types found within this column. List will be unordered.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub other_matches: std::vec::Vec<crate::model::OtherInfoTypeSummary>,

    /// Approximate percentage of entries being null in the column.
    pub estimated_null_percentage: crate::model::NullPercentageLevel,

    /// Approximate uniqueness of the column.
    pub estimated_uniqueness_score: crate::model::UniquenessScoreLevel,

    /// The likelihood that this column contains free-form text.
    /// A value close to 1 may indicate the column is likely to contain
    /// free-form or natural language text.
    /// Range in 0-1.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub free_text_score: f64,

    /// The data type of a given column.
    pub column_type: crate::model::column_data_profile::ColumnDataType,

    /// Indicates if a policy tag has been applied to the column.
    pub policy_state: crate::model::column_data_profile::ColumnPolicyState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColumnDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ColumnDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [profile_status][crate::model::ColumnDataProfile::profile_status].
    pub fn set_profile_status<
        T: std::convert::Into<std::option::Option<crate::model::ProfileStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_status = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ColumnDataProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::column_data_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::ColumnDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_last_generated = v.into();
        self
    }

    /// Sets the value of [table_data_profile][crate::model::ColumnDataProfile::table_data_profile].
    pub fn set_table_data_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.table_data_profile = v.into();
        self
    }

    /// Sets the value of [table_full_resource][crate::model::ColumnDataProfile::table_full_resource].
    pub fn set_table_full_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.table_full_resource = v.into();
        self
    }

    /// Sets the value of [dataset_project_id][crate::model::ColumnDataProfile::dataset_project_id].
    pub fn set_dataset_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_project_id = v.into();
        self
    }

    /// Sets the value of [dataset_location][crate::model::ColumnDataProfile::dataset_location].
    pub fn set_dataset_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_location = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ColumnDataProfile::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::ColumnDataProfile::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [column][crate::model::ColumnDataProfile::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::ColumnDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [data_risk_level][crate::model::ColumnDataProfile::data_risk_level].
    pub fn set_data_risk_level<
        T: std::convert::Into<std::option::Option<crate::model::DataRiskLevel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_risk_level = v.into();
        self
    }

    /// Sets the value of [column_info_type][crate::model::ColumnDataProfile::column_info_type].
    pub fn set_column_info_type<
        T: std::convert::Into<std::option::Option<crate::model::InfoTypeSummary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.column_info_type = v.into();
        self
    }

    /// Sets the value of [other_matches][crate::model::ColumnDataProfile::other_matches].
    pub fn set_other_matches<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OtherInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.other_matches = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [estimated_null_percentage][crate::model::ColumnDataProfile::estimated_null_percentage].
    pub fn set_estimated_null_percentage<
        T: std::convert::Into<crate::model::NullPercentageLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.estimated_null_percentage = v.into();
        self
    }

    /// Sets the value of [estimated_uniqueness_score][crate::model::ColumnDataProfile::estimated_uniqueness_score].
    pub fn set_estimated_uniqueness_score<
        T: std::convert::Into<crate::model::UniquenessScoreLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.estimated_uniqueness_score = v.into();
        self
    }

    /// Sets the value of [free_text_score][crate::model::ColumnDataProfile::free_text_score].
    pub fn set_free_text_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.free_text_score = v.into();
        self
    }

    /// Sets the value of [column_type][crate::model::ColumnDataProfile::column_type].
    pub fn set_column_type<
        T: std::convert::Into<crate::model::column_data_profile::ColumnDataType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.column_type = v.into();
        self
    }

    /// Sets the value of [policy_state][crate::model::ColumnDataProfile::policy_state].
    pub fn set_policy_state<
        T: std::convert::Into<crate::model::column_data_profile::ColumnPolicyState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy_state = v.into();
        self
    }
}

impl wkt::message::Message for ColumnDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ColumnDataProfile"
    }
}

/// Defines additional types related to [ColumnDataProfile].
pub mod column_data_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a profile. New items may be added.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unspecified,
        /// The profile is currently running. Once a profile has finished it will
        /// transition to DONE.
        Running,
        /// The profile is no longer generating.
        /// If profile_status.status.code is 0, the profile succeeded, otherwise, it
        /// failed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Done => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Done => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.privacy.dlp.v2.ColumnDataProfile.State",
            ))
        }
    }

    /// Data types of the data in a column. Types may be added over time.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ColumnDataType {
        /// Invalid type.
        Unspecified,
        /// Encoded as a string in decimal format.
        TypeInt64,
        /// Encoded as a boolean "false" or "true".
        TypeBool,
        /// Encoded as a number, or string "NaN", "Infinity" or "-Infinity".
        TypeFloat64,
        /// Encoded as a string value.
        TypeString,
        /// Encoded as a base64 string per RFC 4648, section 4.
        TypeBytes,
        /// Encoded as an RFC 3339 timestamp with mandatory "Z" time zone string:
        /// 1985-04-12T23:20:50.52Z
        TypeTimestamp,
        /// Encoded as RFC 3339 full-date format string: 1985-04-12
        TypeDate,
        /// Encoded as RFC 3339 partial-time format string: 23:20:50.52
        TypeTime,
        /// Encoded as RFC 3339 full-date "T" partial-time: 1985-04-12T23:20:50.52
        TypeDatetime,
        /// Encoded as WKT
        TypeGeography,
        /// Encoded as a decimal string.
        TypeNumeric,
        /// Container of ordered fields, each with a type and field name.
        TypeRecord,
        /// Decimal type.
        TypeBignumeric,
        /// Json type.
        TypeJson,
        /// Interval type.
        TypeInterval,
        /// `Range<Date>` type.
        TypeRangeDate,
        /// `Range<Datetime>` type.
        TypeRangeDatetime,
        /// `Range<Timestamp>` type.
        TypeRangeTimestamp,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ColumnDataType::value] or
        /// [ColumnDataType::name].
        UnknownValue(column_data_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod column_data_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ColumnDataType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TypeInt64 => std::option::Option::Some(1),
                Self::TypeBool => std::option::Option::Some(2),
                Self::TypeFloat64 => std::option::Option::Some(3),
                Self::TypeString => std::option::Option::Some(4),
                Self::TypeBytes => std::option::Option::Some(5),
                Self::TypeTimestamp => std::option::Option::Some(6),
                Self::TypeDate => std::option::Option::Some(7),
                Self::TypeTime => std::option::Option::Some(8),
                Self::TypeDatetime => std::option::Option::Some(9),
                Self::TypeGeography => std::option::Option::Some(10),
                Self::TypeNumeric => std::option::Option::Some(11),
                Self::TypeRecord => std::option::Option::Some(12),
                Self::TypeBignumeric => std::option::Option::Some(13),
                Self::TypeJson => std::option::Option::Some(14),
                Self::TypeInterval => std::option::Option::Some(15),
                Self::TypeRangeDate => std::option::Option::Some(16),
                Self::TypeRangeDatetime => std::option::Option::Some(17),
                Self::TypeRangeTimestamp => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COLUMN_DATA_TYPE_UNSPECIFIED"),
                Self::TypeInt64 => std::option::Option::Some("TYPE_INT64"),
                Self::TypeBool => std::option::Option::Some("TYPE_BOOL"),
                Self::TypeFloat64 => std::option::Option::Some("TYPE_FLOAT64"),
                Self::TypeString => std::option::Option::Some("TYPE_STRING"),
                Self::TypeBytes => std::option::Option::Some("TYPE_BYTES"),
                Self::TypeTimestamp => std::option::Option::Some("TYPE_TIMESTAMP"),
                Self::TypeDate => std::option::Option::Some("TYPE_DATE"),
                Self::TypeTime => std::option::Option::Some("TYPE_TIME"),
                Self::TypeDatetime => std::option::Option::Some("TYPE_DATETIME"),
                Self::TypeGeography => std::option::Option::Some("TYPE_GEOGRAPHY"),
                Self::TypeNumeric => std::option::Option::Some("TYPE_NUMERIC"),
                Self::TypeRecord => std::option::Option::Some("TYPE_RECORD"),
                Self::TypeBignumeric => std::option::Option::Some("TYPE_BIGNUMERIC"),
                Self::TypeJson => std::option::Option::Some("TYPE_JSON"),
                Self::TypeInterval => std::option::Option::Some("TYPE_INTERVAL"),
                Self::TypeRangeDate => std::option::Option::Some("TYPE_RANGE_DATE"),
                Self::TypeRangeDatetime => std::option::Option::Some("TYPE_RANGE_DATETIME"),
                Self::TypeRangeTimestamp => std::option::Option::Some("TYPE_RANGE_TIMESTAMP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ColumnDataType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ColumnDataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ColumnDataType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TypeInt64,
                2 => Self::TypeBool,
                3 => Self::TypeFloat64,
                4 => Self::TypeString,
                5 => Self::TypeBytes,
                6 => Self::TypeTimestamp,
                7 => Self::TypeDate,
                8 => Self::TypeTime,
                9 => Self::TypeDatetime,
                10 => Self::TypeGeography,
                11 => Self::TypeNumeric,
                12 => Self::TypeRecord,
                13 => Self::TypeBignumeric,
                14 => Self::TypeJson,
                15 => Self::TypeInterval,
                16 => Self::TypeRangeDate,
                17 => Self::TypeRangeDatetime,
                18 => Self::TypeRangeTimestamp,
                _ => Self::UnknownValue(column_data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ColumnDataType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COLUMN_DATA_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TYPE_INT64" => Self::TypeInt64,
                "TYPE_BOOL" => Self::TypeBool,
                "TYPE_FLOAT64" => Self::TypeFloat64,
                "TYPE_STRING" => Self::TypeString,
                "TYPE_BYTES" => Self::TypeBytes,
                "TYPE_TIMESTAMP" => Self::TypeTimestamp,
                "TYPE_DATE" => Self::TypeDate,
                "TYPE_TIME" => Self::TypeTime,
                "TYPE_DATETIME" => Self::TypeDatetime,
                "TYPE_GEOGRAPHY" => Self::TypeGeography,
                "TYPE_NUMERIC" => Self::TypeNumeric,
                "TYPE_RECORD" => Self::TypeRecord,
                "TYPE_BIGNUMERIC" => Self::TypeBignumeric,
                "TYPE_JSON" => Self::TypeJson,
                "TYPE_INTERVAL" => Self::TypeInterval,
                "TYPE_RANGE_DATE" => Self::TypeRangeDate,
                "TYPE_RANGE_DATETIME" => Self::TypeRangeDatetime,
                "TYPE_RANGE_TIMESTAMP" => Self::TypeRangeTimestamp,
                _ => Self::UnknownValue(column_data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ColumnDataType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TypeInt64 => serializer.serialize_i32(1),
                Self::TypeBool => serializer.serialize_i32(2),
                Self::TypeFloat64 => serializer.serialize_i32(3),
                Self::TypeString => serializer.serialize_i32(4),
                Self::TypeBytes => serializer.serialize_i32(5),
                Self::TypeTimestamp => serializer.serialize_i32(6),
                Self::TypeDate => serializer.serialize_i32(7),
                Self::TypeTime => serializer.serialize_i32(8),
                Self::TypeDatetime => serializer.serialize_i32(9),
                Self::TypeGeography => serializer.serialize_i32(10),
                Self::TypeNumeric => serializer.serialize_i32(11),
                Self::TypeRecord => serializer.serialize_i32(12),
                Self::TypeBignumeric => serializer.serialize_i32(13),
                Self::TypeJson => serializer.serialize_i32(14),
                Self::TypeInterval => serializer.serialize_i32(15),
                Self::TypeRangeDate => serializer.serialize_i32(16),
                Self::TypeRangeDatetime => serializer.serialize_i32(17),
                Self::TypeRangeTimestamp => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ColumnDataType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ColumnDataType>::new(
                ".google.privacy.dlp.v2.ColumnDataProfile.ColumnDataType",
            ))
        }
    }

    /// The possible policy states for a column.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ColumnPolicyState {
        /// No policy tags.
        Unspecified,
        /// Column has policy tag applied.
        ColumnPolicyTagged,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ColumnPolicyState::value] or
        /// [ColumnPolicyState::name].
        UnknownValue(column_policy_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod column_policy_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ColumnPolicyState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ColumnPolicyTagged => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COLUMN_POLICY_STATE_UNSPECIFIED"),
                Self::ColumnPolicyTagged => std::option::Option::Some("COLUMN_POLICY_TAGGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ColumnPolicyState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ColumnPolicyState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ColumnPolicyState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ColumnPolicyTagged,
                _ => Self::UnknownValue(column_policy_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ColumnPolicyState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COLUMN_POLICY_STATE_UNSPECIFIED" => Self::Unspecified,
                "COLUMN_POLICY_TAGGED" => Self::ColumnPolicyTagged,
                _ => Self::UnknownValue(column_policy_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ColumnPolicyState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ColumnPolicyTagged => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ColumnPolicyState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ColumnPolicyState>::new(
                ".google.privacy.dlp.v2.ColumnDataProfile.ColumnPolicyState",
            ))
        }
    }
}

/// The profile for a file store.
///
/// * Cloud Storage: maps 1:1 with a bucket.
/// * Amazon S3: maps 1:1 with a bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStoreDataProfile {
    /// The name of the profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The resource type that was profiled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_source_type: std::option::Option<crate::model::DataSourceType>,

    /// The resource name of the project data profile for this file store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_data_profile: std::string::String,

    /// The Google Cloud project ID that owns the resource.
    /// For Amazon S3 buckets, this is the AWS Account Id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The location of the file store.
    ///
    /// * Cloud Storage:
    ///   <https://cloud.google.com/storage/docs/locations#available-locations>
    /// * Amazon S3:
    ///   <https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_store_location: std::string::String,

    /// For resources that have multiple storage locations, these are those
    /// regions. For Cloud Storage this is the list of regions chosen for
    /// dual-region storage. `file_store_location` will normally be the
    /// corresponding multi-region for the list of individual locations. The first
    /// region is always picked as the processing and storage location for the data
    /// profile.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_storage_locations: std::vec::Vec<std::string::String>,

    /// The location type of the file store (region, dual-region, multi-region,
    /// etc). If dual-region, expect data_storage_locations to be populated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_type: std::string::String,

    /// The file store path.
    ///
    /// * Cloud Storage: `gs://{bucket}`
    /// * Amazon S3: `s3://{bucket}`
    /// * Vertex AI dataset:
    ///   `projects/{project_number}/locations/{location}/datasets/{dataset_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_store_path: std::string::String,

    /// The resource name of the resource profiled.
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    ///
    /// Example format of an S3 bucket full resource name:
    /// `//cloudasset.googleapis.com/organizations/{org_id}/otherCloudConnections/aws/arn:aws:s3:::{bucket_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_resource: std::string::String,

    /// The snapshot of the configurations used to generate the profile.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_snapshot: std::option::Option<crate::model::DataProfileConfigSnapshot>,

    /// Success or error status from the most recent profile generation attempt.
    /// May be empty if the profile is still being generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// State of a profile.
    pub state: crate::model::file_store_data_profile::State,

    /// The last time the profile was generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// How broadly a resource has been shared.
    pub resource_visibility: crate::model::ResourceVisibility,

    /// The sensitivity score of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// The time the file store was first created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the file store was last modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_modified_time: std::option::Option<wkt::Timestamp>,

    /// FileClusterSummary per each cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_cluster_summaries: std::vec::Vec<crate::model::FileClusterSummary>,

    /// Attributes of the resource being profiled.
    /// Currently used attributes:
    ///
    /// * customer_managed_encryption: boolean
    ///   - true: the resource is encrypted with a customer-managed key.
    ///   - false: the resource is encrypted with a provider-managed key.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_attributes: std::collections::HashMap<std::string::String, crate::model::Value>,

    /// The labels applied to the resource at the time the profile was generated.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// InfoTypes detected in this file store.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_store_info_type_summaries: std::vec::Vec<crate::model::FileStoreInfoTypeSummary>,

    /// The BigQuery table to which the sample findings are written.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sample_findings_table: std::option::Option<crate::model::BigQueryTable>,

    /// The file store does not have any files.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub file_store_is_empty: bool,

    /// The tags attached to the resource, including any tags attached during
    /// profiling.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<crate::model::Tag>,

    /// Resources related to this profile.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_resources: std::vec::Vec<crate::model::RelatedResource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileStoreDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FileStoreDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_source_type][crate::model::FileStoreDataProfile::data_source_type].
    pub fn set_data_source_type<
        T: std::convert::Into<std::option::Option<crate::model::DataSourceType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source_type = v.into();
        self
    }

    /// Sets the value of [project_data_profile][crate::model::FileStoreDataProfile::project_data_profile].
    pub fn set_project_data_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_data_profile = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::FileStoreDataProfile::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [file_store_location][crate::model::FileStoreDataProfile::file_store_location].
    pub fn set_file_store_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_store_location = v.into();
        self
    }

    /// Sets the value of [data_storage_locations][crate::model::FileStoreDataProfile::data_storage_locations].
    pub fn set_data_storage_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_storage_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [location_type][crate::model::FileStoreDataProfile::location_type].
    pub fn set_location_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_type = v.into();
        self
    }

    /// Sets the value of [file_store_path][crate::model::FileStoreDataProfile::file_store_path].
    pub fn set_file_store_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_store_path = v.into();
        self
    }

    /// Sets the value of [full_resource][crate::model::FileStoreDataProfile::full_resource].
    pub fn set_full_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_resource = v.into();
        self
    }

    /// Sets the value of [config_snapshot][crate::model::FileStoreDataProfile::config_snapshot].
    pub fn set_config_snapshot<
        T: std::convert::Into<std::option::Option<crate::model::DataProfileConfigSnapshot>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config_snapshot = v.into();
        self
    }

    /// Sets the value of [profile_status][crate::model::FileStoreDataProfile::profile_status].
    pub fn set_profile_status<
        T: std::convert::Into<std::option::Option<crate::model::ProfileStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_status = v.into();
        self
    }

    /// Sets the value of [state][crate::model::FileStoreDataProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::file_store_data_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::FileStoreDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_last_generated = v.into();
        self
    }

    /// Sets the value of [resource_visibility][crate::model::FileStoreDataProfile::resource_visibility].
    pub fn set_resource_visibility<T: std::convert::Into<crate::model::ResourceVisibility>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_visibility = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::FileStoreDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [data_risk_level][crate::model::FileStoreDataProfile::data_risk_level].
    pub fn set_data_risk_level<
        T: std::convert::Into<std::option::Option<crate::model::DataRiskLevel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_risk_level = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FileStoreDataProfile::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::FileStoreDataProfile::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [file_cluster_summaries][crate::model::FileStoreDataProfile::file_cluster_summaries].
    pub fn set_file_cluster_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileClusterSummary>,
    {
        use std::iter::Iterator;
        self.file_cluster_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_attributes][crate::model::FileStoreDataProfile::resource_attributes].
    pub fn set_resource_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Value>,
    {
        use std::iter::Iterator;
        self.resource_attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [resource_labels][crate::model::FileStoreDataProfile::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [file_store_info_type_summaries][crate::model::FileStoreDataProfile::file_store_info_type_summaries].
    pub fn set_file_store_info_type_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.file_store_info_type_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sample_findings_table][crate::model::FileStoreDataProfile::sample_findings_table].
    pub fn set_sample_findings_table<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_findings_table = v.into();
        self
    }

    /// Sets the value of [file_store_is_empty][crate::model::FileStoreDataProfile::file_store_is_empty].
    pub fn set_file_store_is_empty<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.file_store_is_empty = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::FileStoreDataProfile::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [related_resources][crate::model::FileStoreDataProfile::related_resources].
    pub fn set_related_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedResource>,
    {
        use std::iter::Iterator;
        self.related_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileStoreDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreDataProfile"
    }
}

/// Defines additional types related to [FileStoreDataProfile].
pub mod file_store_data_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a profile. New items may be added.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unspecified,
        /// The profile is currently running. Once a profile has finished it will
        /// transition to DONE.
        Running,
        /// The profile is no longer generating.
        /// If profile_status.status.code is 0, the profile succeeded, otherwise, it
        /// failed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Done => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Done => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.privacy.dlp.v2.FileStoreDataProfile.State",
            ))
        }
    }
}

/// A tag associated with a resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tag {
    /// The namespaced name for the tag value to attach to Google Cloud resources.
    /// Must be in the format `{parent_id}/{tag_key_short_name}/{short_name}`, for
    /// example, "123456/environment/prod". This is only set for Google Cloud
    /// resources.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub namespaced_tag_value: std::string::String,

    /// The key of a tag key-value pair. For Google Cloud resources, this is the
    /// resource name of the key, for example, "tagKeys/123456".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    /// The value of a tag key-value pair. For Google Cloud resources, this is the
    /// resource name of the value, for example, "tagValues/123456".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [namespaced_tag_value][crate::model::Tag::namespaced_tag_value].
    pub fn set_namespaced_tag_value<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.namespaced_tag_value = v.into();
        self
    }

    /// Sets the value of [key][crate::model::Tag::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Tag::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Tag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Tag"
    }
}

/// A related resource.
/// Examples:
///
/// * The source BigQuery table for a Vertex AI dataset.
/// * The source Cloud Storage bucket for a Vertex AI dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RelatedResource {
    /// The full resource name of the related resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_resource: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [full_resource][crate::model::RelatedResource::full_resource].
    pub fn set_full_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_resource = v.into();
        self
    }
}

impl wkt::message::Message for RelatedResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RelatedResource"
    }
}

/// Information regarding the discovered InfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStoreInfoTypeSummary {
    /// The InfoType seen.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileStoreInfoTypeSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::FileStoreInfoTypeSummary::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }
}

impl wkt::message::Message for FileStoreInfoTypeSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreInfoTypeSummary"
    }
}

/// Information regarding the discovered file extension.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileExtensionInfo {
    /// The file extension if set. (aka .pdf, .jpg, .txt)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_extension: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileExtensionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_extension][crate::model::FileExtensionInfo::file_extension].
    pub fn set_file_extension<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_extension = v.into();
        self
    }
}

impl wkt::message::Message for FileExtensionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileExtensionInfo"
    }
}

/// The file cluster summary.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileClusterSummary {
    /// The file cluster type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_cluster_type: std::option::Option<crate::model::FileClusterType>,

    /// InfoTypes detected in this cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_store_info_type_summaries: std::vec::Vec<crate::model::FileStoreInfoTypeSummary>,

    /// The sensitivity score of this cluster. The score will be SENSITIVITY_LOW
    /// if nothing has been scanned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this cluster. RISK_LOW if nothing has been
    /// scanned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// A list of errors detected while scanning this cluster. The list is
    /// truncated to 10 per cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// A sample of file types scanned in this cluster. Empty if no files were
    /// scanned. File extensions can be derived from the file name or the file
    /// content.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_extensions_scanned: std::vec::Vec<crate::model::FileExtensionInfo>,

    /// A sample of file types seen in this cluster. Empty if no files were seen.
    /// File extensions can be derived from the file name or the file content.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_extensions_seen: std::vec::Vec<crate::model::FileExtensionInfo>,

    /// True if no files exist in this cluster. If the file store had more files
    /// than could be listed, this will be false even if no files for this cluster
    /// were seen and file_extensions_seen is empty.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub no_files_exist: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileClusterSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_cluster_type][crate::model::FileClusterSummary::file_cluster_type].
    pub fn set_file_cluster_type<
        T: std::convert::Into<std::option::Option<crate::model::FileClusterType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_cluster_type = v.into();
        self
    }

    /// Sets the value of [file_store_info_type_summaries][crate::model::FileClusterSummary::file_store_info_type_summaries].
    pub fn set_file_store_info_type_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.file_store_info_type_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::FileClusterSummary::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [data_risk_level][crate::model::FileClusterSummary::data_risk_level].
    pub fn set_data_risk_level<
        T: std::convert::Into<std::option::Option<crate::model::DataRiskLevel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_risk_level = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::FileClusterSummary::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_extensions_scanned][crate::model::FileClusterSummary::file_extensions_scanned].
    pub fn set_file_extensions_scanned<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileExtensionInfo>,
    {
        use std::iter::Iterator;
        self.file_extensions_scanned = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_extensions_seen][crate::model::FileClusterSummary::file_extensions_seen].
    pub fn set_file_extensions_seen<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileExtensionInfo>,
    {
        use std::iter::Iterator;
        self.file_extensions_seen = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [no_files_exist][crate::model::FileClusterSummary::no_files_exist].
    pub fn set_no_files_exist<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.no_files_exist = v.into();
        self
    }
}

impl wkt::message::Message for FileClusterSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileClusterSummary"
    }
}

/// Request to get a project data profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetProjectDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/projectDataProfiles/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProjectDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProjectDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProjectDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetProjectDataProfileRequest"
    }
}

/// Request to get a file store data profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFileStoreDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/fileStoreDataProfiles/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFileStoreDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFileStoreDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFileStoreDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetFileStoreDataProfileRequest"
    }
}

/// Request to list the file store profiles generated for a given organization or
/// project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFileStoreDataProfilesRequest {
    /// Required. Resource name of the organization or project, for
    /// example `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Page token to continue retrieval.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Size of the page. This value can be limited by the server. If
    /// zero, server returns a page of max size 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Comma-separated list of fields to order by, followed by `asc` or
    /// `desc` postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id asc`
    /// * `name`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: The Google Cloud project ID.
    /// - `sensitivity_level`: How sensitive the data in a table is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    /// - `last_modified`: The last time the resource was modified.
    /// - `resource_visibility`: Visibility restriction for this resource.
    /// - `name`: The name of the profile.
    /// - `create_time`: The time the file store was first created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `project_id` - The Google Cloud project ID.
    ///   - `account_id` - The AWS account ID.
    ///   - `file_store_path` - The path like "gs://bucket".
    ///   - `data_source_type` - The profile's data source type, like
    ///     "google/storage/bucket".
    ///   - `data_storage_location` - The location where the file store's data is
    ///     stored, like "us-central1".
    ///   - `sensitivity_level` - HIGH|MODERATE|LOW
    ///   - `data_risk_level` - HIGH|MODERATE|LOW
    ///   - `resource_visibility`: PUBLIC|RESTRICTED
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * `project_id = 12345 AND status_code = 1`
    /// * `project_id = 12345 AND sensitivity_level = HIGH`
    /// * `project_id = 12345 AND resource_visibility = PUBLIC`
    /// * `file_store_path = "gs://mybucket"`
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFileStoreDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFileStoreDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFileStoreDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFileStoreDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFileStoreDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFileStoreDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListFileStoreDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListFileStoreDataProfilesRequest"
    }
}

/// List of file store data profiles generated for a given organization or
/// project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFileStoreDataProfilesResponse {
    /// List of data profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_store_data_profiles: std::vec::Vec<crate::model::FileStoreDataProfile>,

    /// The next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFileStoreDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_store_data_profiles][crate::model::ListFileStoreDataProfilesResponse::file_store_data_profiles].
    pub fn set_file_store_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreDataProfile>,
    {
        use std::iter::Iterator;
        self.file_store_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFileStoreDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFileStoreDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListFileStoreDataProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFileStoreDataProfilesResponse {
    type PageItem = crate::model::FileStoreDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.file_store_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteFileStoreProfile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFileStoreDataProfileRequest {
    /// Required. Resource name of the file store data profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFileStoreDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFileStoreDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFileStoreDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteFileStoreDataProfileRequest"
    }
}

/// Request to get a table data profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTableDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/tableDataProfiles/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTableDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTableDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTableDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetTableDataProfileRequest"
    }
}

/// Request to get a column data profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetColumnDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/columnDataProfiles/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetColumnDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetColumnDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetColumnDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetColumnDataProfileRequest"
    }
}

/// A condition for determining whether a Pub/Sub should be triggered.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfilePubSubCondition {
    /// An expression.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expressions:
        std::option::Option<crate::model::data_profile_pub_sub_condition::PubSubExpressions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfilePubSubCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expressions][crate::model::DataProfilePubSubCondition::expressions].
    pub fn set_expressions<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::data_profile_pub_sub_condition::PubSubExpressions,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expressions = v.into();
        self
    }
}

impl wkt::message::Message for DataProfilePubSubCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubCondition"
    }
}

/// Defines additional types related to [DataProfilePubSubCondition].
pub mod data_profile_pub_sub_condition {
    #[allow(unused_imports)]
    use super::*;

    /// A condition consisting of a value.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PubSubCondition {
        /// The value for the condition to trigger.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<
            crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PubSubCondition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// if it holds a `MinimumRiskScore`, `None` if the field is not set or
        /// holds a different branch.
        pub fn minimum_risk_score(
            &self,
        ) -> std::option::Option<&crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>
        {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumRiskScore(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// to hold a `MinimumRiskScore`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_minimum_risk_score<
            T: std::convert::Into<crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumRiskScore(
                    v.into()
                )
            );
            self
        }

        /// The value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// if it holds a `MinimumSensitivityScore`, `None` if the field is not set or
        /// holds a different branch.
        pub fn minimum_sensitivity_score(
            &self,
        ) -> std::option::Option<&crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>
        {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumSensitivityScore(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// to hold a `MinimumSensitivityScore`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_minimum_sensitivity_score<
            T: std::convert::Into<crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumSensitivityScore(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for PubSubCondition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubCondition.PubSubCondition"
        }
    }

    /// Defines additional types related to [PubSubCondition].
    pub mod pub_sub_condition {
        #[allow(unused_imports)]
        use super::*;

        /// The value for the condition to trigger.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// The minimum data risk score that triggers the condition.
            MinimumRiskScore(crate::model::data_profile_pub_sub_condition::ProfileScoreBucket),
            /// The minimum sensitivity level that triggers the condition.
            MinimumSensitivityScore(
                crate::model::data_profile_pub_sub_condition::ProfileScoreBucket,
            ),
        }
    }

    /// An expression, consisting of an operator and conditions.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PubSubExpressions {

        /// The operator to apply to the collection of conditions.
        pub logical_operator: crate::model::data_profile_pub_sub_condition::pub_sub_expressions::PubSubLogicalOperator,

        /// Conditions to apply to the expression.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub conditions: std::vec::Vec<crate::model::data_profile_pub_sub_condition::PubSubCondition>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PubSubExpressions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [logical_operator][crate::model::data_profile_pub_sub_condition::PubSubExpressions::logical_operator].
        pub fn set_logical_operator<T: std::convert::Into<crate::model::data_profile_pub_sub_condition::pub_sub_expressions::PubSubLogicalOperator>>(mut self, v: T) -> Self{
            self.logical_operator = v.into();
            self
        }

        /// Sets the value of [conditions][crate::model::data_profile_pub_sub_condition::PubSubExpressions::conditions].
        pub fn set_conditions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::data_profile_pub_sub_condition::PubSubCondition>,
        {
            use std::iter::Iterator;
            self.conditions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PubSubExpressions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubCondition.PubSubExpressions"
        }
    }

    /// Defines additional types related to [PubSubExpressions].
    pub mod pub_sub_expressions {
        #[allow(unused_imports)]
        use super::*;

        /// Logical operators for conditional checks.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PubSubLogicalOperator {
            /// Unused.
            LogicalOperatorUnspecified,
            /// Conditional OR.
            Or,
            /// Conditional AND.
            And,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PubSubLogicalOperator::value] or
            /// [PubSubLogicalOperator::name].
            UnknownValue(pub_sub_logical_operator::UnknownValue),
        }

        #[doc(hidden)]
        pub mod pub_sub_logical_operator {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PubSubLogicalOperator {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::LogicalOperatorUnspecified => std::option::Option::Some(0),
                    Self::Or => std::option::Option::Some(1),
                    Self::And => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::LogicalOperatorUnspecified => {
                        std::option::Option::Some("LOGICAL_OPERATOR_UNSPECIFIED")
                    }
                    Self::Or => std::option::Option::Some("OR"),
                    Self::And => std::option::Option::Some("AND"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PubSubLogicalOperator {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PubSubLogicalOperator {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PubSubLogicalOperator {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::LogicalOperatorUnspecified,
                    1 => Self::Or,
                    2 => Self::And,
                    _ => Self::UnknownValue(pub_sub_logical_operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PubSubLogicalOperator {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LOGICAL_OPERATOR_UNSPECIFIED" => Self::LogicalOperatorUnspecified,
                    "OR" => Self::Or,
                    "AND" => Self::And,
                    _ => Self::UnknownValue(pub_sub_logical_operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PubSubLogicalOperator {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::LogicalOperatorUnspecified => serializer.serialize_i32(0),
                    Self::Or => serializer.serialize_i32(1),
                    Self::And => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PubSubLogicalOperator {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PubSubLogicalOperator>::new(
                    ".google.privacy.dlp.v2.DataProfilePubSubCondition.PubSubExpressions.PubSubLogicalOperator"))
            }
        }
    }

    /// Various score levels for resources.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProfileScoreBucket {
        /// Unused.
        Unspecified,
        /// High risk/sensitivity detected.
        High,
        /// Medium or high risk/sensitivity detected.
        MediumOrHigh,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ProfileScoreBucket::value] or
        /// [ProfileScoreBucket::name].
        UnknownValue(profile_score_bucket::UnknownValue),
    }

    #[doc(hidden)]
    pub mod profile_score_bucket {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ProfileScoreBucket {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::MediumOrHigh => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROFILE_SCORE_BUCKET_UNSPECIFIED"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::MediumOrHigh => std::option::Option::Some("MEDIUM_OR_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ProfileScoreBucket {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ProfileScoreBucket {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ProfileScoreBucket {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::MediumOrHigh,
                _ => Self::UnknownValue(profile_score_bucket::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ProfileScoreBucket {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROFILE_SCORE_BUCKET_UNSPECIFIED" => Self::Unspecified,
                "HIGH" => Self::High,
                "MEDIUM_OR_HIGH" => Self::MediumOrHigh,
                _ => Self::UnknownValue(profile_score_bucket::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ProfileScoreBucket {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::MediumOrHigh => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ProfileScoreBucket {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProfileScoreBucket>::new(
                ".google.privacy.dlp.v2.DataProfilePubSubCondition.ProfileScoreBucket",
            ))
        }
    }
}

/// Pub/Sub topic message for a DataProfileAction.PubSubNotification event.
/// To receive a message of protocol buffer schema type, convert the message data
/// to an object of this proto class.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfilePubSubMessage {
    /// If `DetailLevel` is `TABLE_PROFILE` this will be fully populated.
    /// Otherwise, if `DetailLevel` is `RESOURCE_NAME`, then only `name` and
    /// `full_resource` will be populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile: std::option::Option<crate::model::TableDataProfile>,

    /// If `DetailLevel` is `FILE_STORE_PROFILE` this will be fully populated.
    /// Otherwise, if `DetailLevel` is `RESOURCE_NAME`, then only `name` and
    /// `file_store_path` will be populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_store_profile: std::option::Option<crate::model::FileStoreDataProfile>,

    /// The event that caused the Pub/Sub message to be sent.
    pub event: crate::model::data_profile_action::EventType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfilePubSubMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [profile][crate::model::DataProfilePubSubMessage::profile].
    pub fn set_profile<
        T: std::convert::Into<std::option::Option<crate::model::TableDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = v.into();
        self
    }

    /// Sets the value of [file_store_profile][crate::model::DataProfilePubSubMessage::file_store_profile].
    pub fn set_file_store_profile<
        T: std::convert::Into<std::option::Option<crate::model::FileStoreDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_store_profile = v.into();
        self
    }

    /// Sets the value of [event][crate::model::DataProfilePubSubMessage::event].
    pub fn set_event<T: std::convert::Into<crate::model::data_profile_action::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.event = v.into();
        self
    }
}

impl wkt::message::Message for DataProfilePubSubMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubMessage"
    }
}

/// Request message for CreateConnection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectionRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization):
    ///
    /// + Projects scope:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Organizations scope:
    ///   `organizations/{org_id}/locations/{location_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The connection resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::option::Option<crate::model::Connection>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateConnectionRequest"
    }
}

/// Request message for GetConnection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectionRequest {
    /// Required. Resource name in the format:
    /// `projects/{project}/locations/{location}/connections/{connection}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetConnectionRequest"
    }
}

/// Request message for ListConnections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Resource name of the organization or project, for
    /// example, `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Number of results per page, max 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token from a previous page to return the next set of
    /// results. If set, all other request fields must match the original request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Supported field/value: `state` - MISSING|AVAILABLE|ERROR
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListConnectionsRequest"
    }
}

/// Request message for SearchConnections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchConnectionsRequest {
    /// Required. Resource name of the organization or project with a wildcard
    /// location, for example, `organizations/433245324/locations/-` or
    /// `projects/project-id/locations/-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Number of results per page, max 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token from a previous page to return the next set of
    /// results. If set, all other request fields must match the original request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Supported field/value: - `state` - MISSING|AVAILABLE|ERROR
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for SearchConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SearchConnectionsRequest"
    }
}

/// Response message for ListConnections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// List of connections.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// Token to retrieve the next page of results. An empty value means there are
    /// no more results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Response message for SearchConnections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchConnectionsResponse {
    /// List of connections that match the search query. Note that only a subset
    /// of the fields will be populated, and only "name" is guaranteed to be set.
    /// For full details of a Connection, call GetConnection with the name.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// Token to retrieve the next page of results. An empty value means there are
    /// no more results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::SearchConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SearchConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for UpdateConnection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectionRequest {
    /// Required. Resource name in the format:
    /// `projects/{project}/locations/{location}/connections/{connection}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The connection with new values for the relevant fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,

    /// Optional. Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::option::Option<crate::model::Connection>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateConnectionRequest"
    }
}

/// Request message for DeleteConnection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectionRequest {
    /// Required. Resource name of the Connection to be deleted, in the format:
    /// `projects/{project}/locations/{location}/connections/{connection}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteConnectionRequest"
    }
}

/// A data connection to allow the DLP API to profile data in locations that
/// require additional configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Connection {
    /// Output only. Name of the connection:
    /// `projects/{project}/locations/{location}/connections/{name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The connection's state in its lifecycle.
    pub state: crate::model::ConnectionState,

    /// Output only. Set if status == ERROR, to provide additional details. Will
    /// store the last 10 errors sorted with the most recent first.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Type of connection.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::connection::Properties>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Connection::state].
    pub fn set_state<T: std::convert::Into<crate::model::ConnectionState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::Connection::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::Connection::properties].
    ///
    /// Note that all the setters affecting `properties` are mutually
    /// exclusive.
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::connection::Properties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `CloudSql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::CloudSql(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `CloudSql`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_cloud_sql<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::CloudSql(v.into()));
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Connection"
    }
}

/// Defines additional types related to [Connection].
pub mod connection {
    #[allow(unused_imports)]
    use super::*;

    /// Type of connection.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Properties {
        /// Connect to a Cloud SQL instance.
        CloudSql(std::boxed::Box<crate::model::CloudSqlProperties>),
    }
}

/// A credential consisting of a username and password, where the password is
/// stored in a Secret Manager resource.
/// Note: Secret Manager [charges
/// apply](https://cloud.google.com/secret-manager/pricing).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretManagerCredential {
    /// Required. The username.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Required. The name of the Secret Manager resource that stores the password,
    /// in the form `projects/project-id/secrets/secret-name/versions/version`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password_secret_version_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretManagerCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::SecretManagerCredential::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password_secret_version_name][crate::model::SecretManagerCredential::password_secret_version_name].
    pub fn set_password_secret_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.password_secret_version_name = v.into();
        self
    }
}

impl wkt::message::Message for SecretManagerCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SecretManagerCredential"
    }
}

/// Use IAM authentication to connect. This requires the Cloud SQL IAM feature
/// to be enabled on the instance, which is not the default for Cloud SQL.
/// See <https://cloud.google.com/sql/docs/postgres/authentication> and
/// <https://cloud.google.com/sql/docs/mysql/authentication>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlIamCredential {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlIamCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CloudSqlIamCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudSqlIamCredential"
    }
}

/// Cloud SQL connection properties.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlProperties {
    /// Optional. Immutable. The Cloud SQL instance for which the connection is
    /// defined. Only one connection per instance is allowed. This can only be set
    /// at creation time, and cannot be updated.
    ///
    /// It is an error to use a connection_name from different project or region
    /// than the one that holds the connection.
    /// For example, a Connection resource for Cloud SQL connection_name
    /// `project-id:us-central1:sql-instance`
    /// must be created under the parent
    /// `projects/project-id/locations/us-central1`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_name: std::string::String,

    /// Required. The DLP API will limit its connections to max_connections.
    /// Must be 2 or greater.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_connections: i32,

    /// Required. The database engine used by the Cloud SQL instance that this
    /// connection configures.
    pub database_engine: crate::model::cloud_sql_properties::DatabaseEngine,

    /// How to authenticate to the instance.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub credential: std::option::Option<crate::model::cloud_sql_properties::Credential>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_name][crate::model::CloudSqlProperties::connection_name].
    pub fn set_connection_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_name = v.into();
        self
    }

    /// Sets the value of [max_connections][crate::model::CloudSqlProperties::max_connections].
    pub fn set_max_connections<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_connections = v.into();
        self
    }

    /// Sets the value of [database_engine][crate::model::CloudSqlProperties::database_engine].
    pub fn set_database_engine<
        T: std::convert::Into<crate::model::cloud_sql_properties::DatabaseEngine>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_engine = v.into();
        self
    }

    /// Sets the value of [credential][crate::model::CloudSqlProperties::credential].
    ///
    /// Note that all the setters affecting `credential` are mutually
    /// exclusive.
    pub fn set_credential<
        T: std::convert::Into<std::option::Option<crate::model::cloud_sql_properties::Credential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credential = v.into();
        self
    }

    /// The value of [credential][crate::model::CloudSqlProperties::credential]
    /// if it holds a `UsernamePassword`, `None` if the field is not set or
    /// holds a different branch.
    pub fn username_password(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SecretManagerCredential>> {
        #[allow(unreachable_patterns)]
        self.credential.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_properties::Credential::UsernamePassword(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credential][crate::model::CloudSqlProperties::credential]
    /// to hold a `UsernamePassword`.
    ///
    /// Note that all the setters affecting `credential` are
    /// mutually exclusive.
    pub fn set_username_password<
        T: std::convert::Into<std::boxed::Box<crate::model::SecretManagerCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credential = std::option::Option::Some(
            crate::model::cloud_sql_properties::Credential::UsernamePassword(v.into()),
        );
        self
    }

    /// The value of [credential][crate::model::CloudSqlProperties::credential]
    /// if it holds a `CloudSqlIam`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql_iam(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlIamCredential>> {
        #[allow(unreachable_patterns)]
        self.credential.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_properties::Credential::CloudSqlIam(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credential][crate::model::CloudSqlProperties::credential]
    /// to hold a `CloudSqlIam`.
    ///
    /// Note that all the setters affecting `credential` are
    /// mutually exclusive.
    pub fn set_cloud_sql_iam<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlIamCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credential = std::option::Option::Some(
            crate::model::cloud_sql_properties::Credential::CloudSqlIam(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudSqlProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudSqlProperties"
    }
}

/// Defines additional types related to [CloudSqlProperties].
pub mod cloud_sql_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Database engine of a Cloud SQL instance.
    /// New values may be added over time.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseEngine {
        /// An engine that is not currently supported by Sensitive Data Protection.
        Unknown,
        /// Cloud SQL for MySQL instance.
        Mysql,
        /// Cloud SQL for PostgreSQL instance.
        Postgres,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseEngine::value] or
        /// [DatabaseEngine::name].
        UnknownValue(database_engine::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_engine {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseEngine {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Mysql => std::option::Option::Some(1),
                Self::Postgres => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("DATABASE_ENGINE_UNKNOWN"),
                Self::Mysql => std::option::Option::Some("DATABASE_ENGINE_MYSQL"),
                Self::Postgres => std::option::Option::Some("DATABASE_ENGINE_POSTGRES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseEngine {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseEngine {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseEngine {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Mysql,
                2 => Self::Postgres,
                _ => Self::UnknownValue(database_engine::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseEngine {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_ENGINE_UNKNOWN" => Self::Unknown,
                "DATABASE_ENGINE_MYSQL" => Self::Mysql,
                "DATABASE_ENGINE_POSTGRES" => Self::Postgres,
                _ => Self::UnknownValue(database_engine::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseEngine {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Mysql => serializer.serialize_i32(1),
                Self::Postgres => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseEngine {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEngine>::new(
                ".google.privacy.dlp.v2.CloudSqlProperties.DatabaseEngine",
            ))
        }
    }

    /// How to authenticate to the instance.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Credential {
        /// A username and password stored in Secret Manager.
        UsernamePassword(std::boxed::Box<crate::model::SecretManagerCredential>),
        /// Built-in IAM authentication (must be configured in Cloud SQL).
        CloudSqlIam(std::boxed::Box<crate::model::CloudSqlIamCredential>),
    }
}

/// Request message for DeleteTableProfile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTableDataProfileRequest {
    /// Required. Resource name of the table data profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTableDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTableDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTableDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteTableDataProfileRequest"
    }
}

/// Message used to identify the type of resource being profiled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataSourceType {
    /// Output only. An identifying string to the type of resource being profiled.
    /// Current values:
    ///
    /// * google/bigquery/table
    /// * google/project
    /// * google/sql/table
    /// * google/gcs/bucket
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_source: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSourceType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_source][crate::model::DataSourceType::data_source].
    pub fn set_data_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source = v.into();
        self
    }
}

impl wkt::message::Message for DataSourceType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataSourceType"
    }
}

/// Message used to identify file cluster type being profiled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileClusterType {
    /// File cluster type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub file_cluster_type: std::option::Option<crate::model::file_cluster_type::FileClusterType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileClusterType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_cluster_type][crate::model::FileClusterType::file_cluster_type].
    ///
    /// Note that all the setters affecting `file_cluster_type` are mutually
    /// exclusive.
    pub fn set_file_cluster_type<
        T: std::convert::Into<std::option::Option<crate::model::file_cluster_type::FileClusterType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_cluster_type = v.into();
        self
    }

    /// The value of [file_cluster_type][crate::model::FileClusterType::file_cluster_type]
    /// if it holds a `Cluster`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cluster(&self) -> std::option::Option<&crate::model::file_cluster_type::Cluster> {
        #[allow(unreachable_patterns)]
        self.file_cluster_type.as_ref().and_then(|v| match v {
            crate::model::file_cluster_type::FileClusterType::Cluster(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [file_cluster_type][crate::model::FileClusterType::file_cluster_type]
    /// to hold a `Cluster`.
    ///
    /// Note that all the setters affecting `file_cluster_type` are
    /// mutually exclusive.
    pub fn set_cluster<T: std::convert::Into<crate::model::file_cluster_type::Cluster>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_cluster_type = std::option::Option::Some(
            crate::model::file_cluster_type::FileClusterType::Cluster(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileClusterType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileClusterType"
    }
}

/// Defines additional types related to [FileClusterType].
pub mod file_cluster_type {
    #[allow(unused_imports)]
    use super::*;

    /// Cluster type. Each cluster corresponds to a set of file types.
    /// Over time, new types may be added and files may move between clusters.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Cluster {
        /// Unused.
        Unspecified,
        /// Unsupported files.
        Unknown,
        /// Plain text.
        Text,
        /// Structured data like CSV, TSV etc.
        StructuredData,
        /// Source code.
        SourceCode,
        /// Rich document like docx, xlsx etc.
        RichDocument,
        /// Images like jpeg, bmp.
        Image,
        /// Archives and containers like .zip, .tar etc.
        Archive,
        /// Multimedia like .mp4, .avi etc.
        Multimedia,
        /// Executable files like .exe, .class, .apk etc.
        Executable,
        /// AI models like .tflite etc.
        AiModel,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Cluster::value] or
        /// [Cluster::name].
        UnknownValue(cluster::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cluster {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Cluster {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::Text => std::option::Option::Some(2),
                Self::StructuredData => std::option::Option::Some(3),
                Self::SourceCode => std::option::Option::Some(4),
                Self::RichDocument => std::option::Option::Some(5),
                Self::Image => std::option::Option::Some(6),
                Self::Archive => std::option::Option::Some(7),
                Self::Multimedia => std::option::Option::Some(8),
                Self::Executable => std::option::Option::Some(9),
                Self::AiModel => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLUSTER_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("CLUSTER_UNKNOWN"),
                Self::Text => std::option::Option::Some("CLUSTER_TEXT"),
                Self::StructuredData => std::option::Option::Some("CLUSTER_STRUCTURED_DATA"),
                Self::SourceCode => std::option::Option::Some("CLUSTER_SOURCE_CODE"),
                Self::RichDocument => std::option::Option::Some("CLUSTER_RICH_DOCUMENT"),
                Self::Image => std::option::Option::Some("CLUSTER_IMAGE"),
                Self::Archive => std::option::Option::Some("CLUSTER_ARCHIVE"),
                Self::Multimedia => std::option::Option::Some("CLUSTER_MULTIMEDIA"),
                Self::Executable => std::option::Option::Some("CLUSTER_EXECUTABLE"),
                Self::AiModel => std::option::Option::Some("CLUSTER_AI_MODEL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Cluster {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Cluster {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Cluster {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unknown,
                2 => Self::Text,
                3 => Self::StructuredData,
                4 => Self::SourceCode,
                5 => Self::RichDocument,
                6 => Self::Image,
                7 => Self::Archive,
                8 => Self::Multimedia,
                9 => Self::Executable,
                10 => Self::AiModel,
                _ => Self::UnknownValue(cluster::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Cluster {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLUSTER_UNSPECIFIED" => Self::Unspecified,
                "CLUSTER_UNKNOWN" => Self::Unknown,
                "CLUSTER_TEXT" => Self::Text,
                "CLUSTER_STRUCTURED_DATA" => Self::StructuredData,
                "CLUSTER_SOURCE_CODE" => Self::SourceCode,
                "CLUSTER_RICH_DOCUMENT" => Self::RichDocument,
                "CLUSTER_IMAGE" => Self::Image,
                "CLUSTER_ARCHIVE" => Self::Archive,
                "CLUSTER_MULTIMEDIA" => Self::Multimedia,
                "CLUSTER_EXECUTABLE" => Self::Executable,
                "CLUSTER_AI_MODEL" => Self::AiModel,
                _ => Self::UnknownValue(cluster::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Cluster {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::Text => serializer.serialize_i32(2),
                Self::StructuredData => serializer.serialize_i32(3),
                Self::SourceCode => serializer.serialize_i32(4),
                Self::RichDocument => serializer.serialize_i32(5),
                Self::Image => serializer.serialize_i32(6),
                Self::Archive => serializer.serialize_i32(7),
                Self::Multimedia => serializer.serialize_i32(8),
                Self::Executable => serializer.serialize_i32(9),
                Self::AiModel => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Cluster {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Cluster>::new(
                ".google.privacy.dlp.v2.FileClusterType.Cluster",
            ))
        }
    }

    /// File cluster type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FileClusterType {
        /// Cluster type.
        Cluster(crate::model::file_cluster_type::Cluster),
    }
}

/// Configure processing location for discovery and inspection. For example,
/// image OCR is only provided in limited regions but configuring
/// ProcessingLocation will redirect OCR to a location where OCR is provided.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProcessingLocation {
    /// Image processing will fall back using this configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub image_fallback_location:
        std::option::Option<crate::model::processing_location::ImageFallbackLocation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessingLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_fallback_location][crate::model::ProcessingLocation::image_fallback_location].
    pub fn set_image_fallback_location<
        T: std::convert::Into<
                std::option::Option<crate::model::processing_location::ImageFallbackLocation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.image_fallback_location = v.into();
        self
    }
}

impl wkt::message::Message for ProcessingLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation"
    }
}

/// Defines additional types related to [ProcessingLocation].
pub mod processing_location {
    #[allow(unused_imports)]
    use super::*;

    /// Processing will happen in a multi-region that contains the current region
    /// if available.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MultiRegionProcessing {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MultiRegionProcessing {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for MultiRegionProcessing {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation.MultiRegionProcessing"
        }
    }

    /// Processing will happen in the global region.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GlobalProcessing {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GlobalProcessing {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for GlobalProcessing {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation.GlobalProcessing"
        }
    }

    /// Configure image processing to fall back to the configured processing option
    /// below if unavailable in the request location.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImageFallbackLocation {
        /// Processing will happen in a multi-region that contains the current region
        /// if available.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub multi_region_processing:
            std::option::Option<crate::model::processing_location::MultiRegionProcessing>,

        /// Processing will happen in the global region.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub global_processing:
            std::option::Option<crate::model::processing_location::GlobalProcessing>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImageFallbackLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [multi_region_processing][crate::model::processing_location::ImageFallbackLocation::multi_region_processing].
        pub fn set_multi_region_processing<
            T: std::convert::Into<
                    std::option::Option<crate::model::processing_location::MultiRegionProcessing>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.multi_region_processing = v.into();
            self
        }

        /// Sets the value of [global_processing][crate::model::processing_location::ImageFallbackLocation::global_processing].
        pub fn set_global_processing<
            T: std::convert::Into<
                    std::option::Option<crate::model::processing_location::GlobalProcessing>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.global_processing = v.into();
            self
        }
    }

    impl wkt::message::Message for ImageFallbackLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation.ImageFallbackLocation"
        }
    }
}

/// Type of information detected by the API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoType {
    /// Name of the information type. Either a name of your choosing when
    /// creating a CustomInfoType, or one of the names listed
    /// at
    /// <https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference>
    /// when specifying a built-in type.  When sending Cloud DLP results to Data
    /// Catalog, infoType names should conform to the pattern
    /// `[A-Za-z0-9$_-]{1,64}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional version name for this InfoType.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Optional custom sensitivity for this InfoType.
    /// This only applies to data profiling.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InfoType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InfoType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::InfoType::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::InfoType::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }
}

impl wkt::message::Message for InfoType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoType"
    }
}

/// Score is calculated from of all elements in the data profile.
/// A higher level means the data is more sensitive.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SensitivityScore {
    /// The sensitivity score applied to the resource.
    pub score: crate::model::sensitivity_score::SensitivityScoreLevel,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SensitivityScore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SensitivityScore::score].
    pub fn set_score<
        T: std::convert::Into<crate::model::sensitivity_score::SensitivityScoreLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for SensitivityScore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SensitivityScore"
    }
}

/// Defines additional types related to [SensitivityScore].
pub mod sensitivity_score {
    #[allow(unused_imports)]
    use super::*;

    /// Various sensitivity score levels for resources.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SensitivityScoreLevel {
        /// Unused.
        SensitivityScoreUnspecified,
        /// No sensitive information detected. The resource isn't publicly
        /// accessible.
        SensitivityLow,
        /// Unable to determine sensitivity.
        SensitivityUnknown,
        /// Medium risk. Contains personally identifiable information (PII),
        /// potentially sensitive data, or fields with free-text data that are at a
        /// higher risk of having intermittent sensitive data. Consider limiting
        /// access.
        SensitivityModerate,
        /// High risk. Sensitive personally identifiable information (SPII) can be
        /// present. Exfiltration of data can lead to user data loss.
        /// Re-identification of users might be possible. Consider limiting usage and
        /// or removing SPII.
        SensitivityHigh,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SensitivityScoreLevel::value] or
        /// [SensitivityScoreLevel::name].
        UnknownValue(sensitivity_score_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sensitivity_score_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SensitivityScoreLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::SensitivityScoreUnspecified => std::option::Option::Some(0),
                Self::SensitivityLow => std::option::Option::Some(10),
                Self::SensitivityUnknown => std::option::Option::Some(12),
                Self::SensitivityModerate => std::option::Option::Some(20),
                Self::SensitivityHigh => std::option::Option::Some(30),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::SensitivityScoreUnspecified => {
                    std::option::Option::Some("SENSITIVITY_SCORE_UNSPECIFIED")
                }
                Self::SensitivityLow => std::option::Option::Some("SENSITIVITY_LOW"),
                Self::SensitivityUnknown => std::option::Option::Some("SENSITIVITY_UNKNOWN"),
                Self::SensitivityModerate => std::option::Option::Some("SENSITIVITY_MODERATE"),
                Self::SensitivityHigh => std::option::Option::Some("SENSITIVITY_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SensitivityScoreLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SensitivityScoreLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SensitivityScoreLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::SensitivityScoreUnspecified,
                10 => Self::SensitivityLow,
                12 => Self::SensitivityUnknown,
                20 => Self::SensitivityModerate,
                30 => Self::SensitivityHigh,
                _ => Self::UnknownValue(sensitivity_score_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SensitivityScoreLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SENSITIVITY_SCORE_UNSPECIFIED" => Self::SensitivityScoreUnspecified,
                "SENSITIVITY_LOW" => Self::SensitivityLow,
                "SENSITIVITY_UNKNOWN" => Self::SensitivityUnknown,
                "SENSITIVITY_MODERATE" => Self::SensitivityModerate,
                "SENSITIVITY_HIGH" => Self::SensitivityHigh,
                _ => Self::UnknownValue(sensitivity_score_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SensitivityScoreLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::SensitivityScoreUnspecified => serializer.serialize_i32(0),
                Self::SensitivityLow => serializer.serialize_i32(10),
                Self::SensitivityUnknown => serializer.serialize_i32(12),
                Self::SensitivityModerate => serializer.serialize_i32(20),
                Self::SensitivityHigh => serializer.serialize_i32(30),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SensitivityScoreLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SensitivityScoreLevel>::new(
                ".google.privacy.dlp.v2.SensitivityScore.SensitivityScoreLevel",
            ))
        }
    }
}

/// A reference to a StoredInfoType to use with scanning.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredType {
    /// Resource name of the requested `StoredInfoType`, for example
    /// `organizations/433245324/storedInfoTypes/432452342` or
    /// `projects/project-id/storedInfoTypes/432452342`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Timestamp indicating when the version of the `StoredInfoType` used for
    /// inspection was created. Output-only field, populated by the system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StoredType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::StoredType::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }
}

impl wkt::message::Message for StoredType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredType"
    }
}

/// Custom information type provided by the user. Used to find domain-specific
/// sensitive information configurable to the data in question.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomInfoType {
    /// CustomInfoType can either be a new infoType, or an extension of built-in
    /// infoType, when the name matches one of existing infoTypes and that infoType
    /// is specified in `InspectContent.info_types` field. Specifying the latter
    /// adds findings to the one detected by the system. If built-in info type is
    /// not specified in `InspectContent.info_types` list then the name is treated
    /// as a custom info type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Likelihood to return for this CustomInfoType. This base value can be
    /// altered by a detection rule if the finding meets the criteria specified by
    /// the rule. Defaults to `VERY_LIKELY` if not specified.
    pub likelihood: crate::model::Likelihood,

    /// Set of detection rules to apply to all findings of this CustomInfoType.
    /// Rules are applied in order that they are specified. Not supported for the
    /// `surrogate_type` CustomInfoType.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub detection_rules: std::vec::Vec<crate::model::custom_info_type::DetectionRule>,

    /// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding
    /// to be returned. It still can be used for rules matching.
    pub exclusion_type: crate::model::custom_info_type::ExclusionType,

    /// Sensitivity for this CustomInfoType. If this CustomInfoType extends an
    /// existing InfoType, the sensitivity here will take precedence over that of
    /// the original InfoType. If unset for a CustomInfoType, it will default to
    /// HIGH.
    /// This only applies to data profiling.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// Type of custom detector.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::custom_info_type::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomInfoType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::CustomInfoType::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [likelihood][crate::model::CustomInfoType::likelihood].
    pub fn set_likelihood<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.likelihood = v.into();
        self
    }

    /// Sets the value of [detection_rules][crate::model::CustomInfoType::detection_rules].
    pub fn set_detection_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::custom_info_type::DetectionRule>,
    {
        use std::iter::Iterator;
        self.detection_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclusion_type][crate::model::CustomInfoType::exclusion_type].
    pub fn set_exclusion_type<
        T: std::convert::Into<crate::model::custom_info_type::ExclusionType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.exclusion_type = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::CustomInfoType::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::custom_info_type::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `Dictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Dictionary>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::Dictionary(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `Dictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Dictionary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::custom_info_type::Type::Dictionary(v.into()));
        self
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `Regex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Regex>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::Regex(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `Regex`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Regex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::custom_info_type::Type::Regex(v.into()));
        self
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `SurrogateType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn surrogate_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::SurrogateType>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::SurrogateType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `SurrogateType`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_surrogate_type<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::SurrogateType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::custom_info_type::Type::SurrogateType(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `StoredType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stored_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::StoredType>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::StoredType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `StoredType`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_stored_type<T: std::convert::Into<std::boxed::Box<crate::model::StoredType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::custom_info_type::Type::StoredType(v.into()));
        self
    }
}

impl wkt::message::Message for CustomInfoType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType"
    }
}

/// Defines additional types related to [CustomInfoType].
pub mod custom_info_type {
    #[allow(unused_imports)]
    use super::*;

    /// Custom information type based on a dictionary of words or phrases. This can
    /// be used to match sensitive information specific to the data, such as a list
    /// of employee IDs or job titles.
    ///
    /// Dictionary words are case-insensitive and all characters other than letters
    /// and digits in the unicode [Basic Multilingual
    /// Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane)
    /// will be replaced with whitespace when scanning for matches, so the
    /// dictionary phrase "Sam Johnson" will match all three phrases "sam johnson",
    /// "Sam, Johnson", and "Sam (Johnson)". Additionally, the characters
    /// surrounding any match must be of a different type than the adjacent
    /// characters within the word, so letters must be next to non-letters and
    /// digits next to non-digits. For example, the dictionary word "jen" will
    /// match the first three letters of the text "jen123" but will return no
    /// matches for "jennifer".
    ///
    /// Dictionary words containing a large number of characters that are not
    /// letters or digits may result in unexpected findings because such characters
    /// are treated as whitespace. The
    /// [limits](https://cloud.google.com/sensitive-data-protection/limits) page
    /// contains details about the size limits of dictionaries. For dictionaries
    /// that do not fit within these constraints, consider using
    /// `LargeCustomDictionaryConfig` in the `StoredInfoType` API.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Dictionary {
        /// The potential places the data can be read from.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub source: std::option::Option<crate::model::custom_info_type::dictionary::Source>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Dictionary {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source][crate::model::custom_info_type::Dictionary::source].
        ///
        /// Note that all the setters affecting `source` are mutually
        /// exclusive.
        pub fn set_source<
            T: std::convert::Into<
                    std::option::Option<crate::model::custom_info_type::dictionary::Source>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::custom_info_type::Dictionary::source]
        /// if it holds a `WordList`, `None` if the field is not set or
        /// holds a different branch.
        pub fn word_list(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>,
        > {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::custom_info_type::dictionary::Source::WordList(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::custom_info_type::Dictionary::source]
        /// to hold a `WordList`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_word_list<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::custom_info_type::dictionary::Source::WordList(v.into()),
            );
            self
        }

        /// The value of [source][crate::model::custom_info_type::Dictionary::source]
        /// if it holds a `CloudStoragePath`, `None` if the field is not set or
        /// holds a different branch.
        pub fn cloud_storage_path(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStoragePath>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::custom_info_type::dictionary::Source::CloudStoragePath(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::custom_info_type::Dictionary::source]
        /// to hold a `CloudStoragePath`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_cloud_storage_path<
            T: std::convert::Into<std::boxed::Box<crate::model::CloudStoragePath>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::custom_info_type::dictionary::Source::CloudStoragePath(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Dictionary {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.Dictionary"
        }
    }

    /// Defines additional types related to [Dictionary].
    pub mod dictionary {
        #[allow(unused_imports)]
        use super::*;

        /// Message defining a list of words or phrases to search for in the data.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct WordList {
            /// Words or phrases defining the dictionary. The dictionary must contain
            /// at least one phrase and every phrase must contain at least 2 characters
            /// that are letters or digits. [required]
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub words: std::vec::Vec<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl WordList {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [words][crate::model::custom_info_type::dictionary::WordList::words].
            pub fn set_words<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.words = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for WordList {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList"
            }
        }

        /// The potential places the data can be read from.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Source {
            /// List of words or phrases to search for.
            WordList(std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>),
            /// Newline-delimited file of words in Cloud Storage. Only a single file
            /// is accepted.
            CloudStoragePath(std::boxed::Box<crate::model::CloudStoragePath>),
        }
    }

    /// Message defining a custom regular expression.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Regex {
        /// Pattern defining the regular expression. Its syntax
        /// (<https://github.com/google/re2/wiki/Syntax>) can be found under the
        /// google/re2 repository on GitHub.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pattern: std::string::String,

        /// The index of the submatch to extract as findings. When not
        /// specified, the entire match is returned. No more than 3 may be included.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub group_indexes: std::vec::Vec<i32>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Regex {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pattern][crate::model::custom_info_type::Regex::pattern].
        pub fn set_pattern<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.pattern = v.into();
            self
        }

        /// Sets the value of [group_indexes][crate::model::custom_info_type::Regex::group_indexes].
        pub fn set_group_indexes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i32>,
        {
            use std::iter::Iterator;
            self.group_indexes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Regex {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.Regex"
        }
    }

    /// Message for detecting output from deidentification transformations
    /// such as
    /// [`CryptoReplaceFfxFpeConfig`](https://cloud.google.com/sensitive-data-protection/docs/reference/rest/v2/organizations.deidentifyTemplates#cryptoreplaceffxfpeconfig).
    /// These types of transformations are
    /// those that perform pseudonymization, thereby producing a "surrogate" as
    /// output. This should be used in conjunction with a field on the
    /// transformation such as `surrogate_info_type`. This CustomInfoType does
    /// not support the use of `detection_rules`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SurrogateType {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SurrogateType {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for SurrogateType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.SurrogateType"
        }
    }

    /// Deprecated; use `InspectionRuleSet` instead. Rule for modifying a
    /// `CustomInfoType` to alter behavior under certain circumstances, depending
    /// on the specific details of the rule. Not supported for the `surrogate_type`
    /// custom infoType.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DetectionRule {
        /// Type of hotword rule.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub r#type: std::option::Option<crate::model::custom_info_type::detection_rule::Type>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DetectionRule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::custom_info_type::DetectionRule::type].
        ///
        /// Note that all the setters affecting `r#type` are mutually
        /// exclusive.
        pub fn set_type<
            T: std::convert::Into<
                    std::option::Option<crate::model::custom_info_type::detection_rule::Type>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// The value of [r#type][crate::model::custom_info_type::DetectionRule::r#type]
        /// if it holds a `HotwordRule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn hotword_rule(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
        > {
            #[allow(unreachable_patterns)]
            self.r#type.as_ref().and_then(|v| match v {
                crate::model::custom_info_type::detection_rule::Type::HotwordRule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#type][crate::model::custom_info_type::DetectionRule::r#type]
        /// to hold a `HotwordRule`.
        ///
        /// Note that all the setters affecting `r#type` are
        /// mutually exclusive.
        pub fn set_hotword_rule<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = std::option::Option::Some(
                crate::model::custom_info_type::detection_rule::Type::HotwordRule(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for DetectionRule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule"
        }
    }

    /// Defines additional types related to [DetectionRule].
    pub mod detection_rule {
        #[allow(unused_imports)]
        use super::*;

        /// Message for specifying a window around a finding to apply a detection
        /// rule.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Proximity {
            /// Number of characters before the finding to consider. For tabular data,
            /// if you want to modify the likelihood of an entire column of findngs,
            /// set this to 1. For more information, see
            /// [Hotword example: Set the match likelihood of a table column]
            /// (<https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes-likelihood#match-column-values>).
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub window_before: i32,

            /// Number of characters after the finding to consider.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub window_after: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Proximity {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [window_before][crate::model::custom_info_type::detection_rule::Proximity::window_before].
            pub fn set_window_before<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.window_before = v.into();
                self
            }

            /// Sets the value of [window_after][crate::model::custom_info_type::detection_rule::Proximity::window_after].
            pub fn set_window_after<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.window_after = v.into();
                self
            }
        }

        impl wkt::message::Message for Proximity {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity"
            }
        }

        /// Message for specifying an adjustment to the likelihood of a finding as
        /// part of a detection rule.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct LikelihoodAdjustment {
            /// How the likelihood will be modified.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub adjustment: std::option::Option<
                crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl LikelihoodAdjustment {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment].
            ///
            /// Note that all the setters affecting `adjustment` are mutually
            /// exclusive.
            pub fn set_adjustment<T: std::convert::Into<std::option::Option<crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment>>>(mut self, v: T) -> Self
            {
                self.adjustment = v.into();
                self
            }

            /// The value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// if it holds a `FixedLikelihood`, `None` if the field is not set or
            /// holds a different branch.
            pub fn fixed_likelihood(&self) -> std::option::Option<&crate::model::Likelihood> {
                #[allow(unreachable_patterns)]
                self.adjustment.as_ref().and_then(|v| match v {
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::FixedLikelihood(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// to hold a `FixedLikelihood`.
            ///
            /// Note that all the setters affecting `adjustment` are
            /// mutually exclusive.
            pub fn set_fixed_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
                mut self,
                v: T,
            ) -> Self {
                self.adjustment = std::option::Option::Some(
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::FixedLikelihood(
                        v.into()
                    )
                );
                self
            }

            /// The value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// if it holds a `RelativeLikelihood`, `None` if the field is not set or
            /// holds a different branch.
            pub fn relative_likelihood(&self) -> std::option::Option<&i32> {
                #[allow(unreachable_patterns)]
                self.adjustment.as_ref().and_then(|v| match v {
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::RelativeLikelihood(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// to hold a `RelativeLikelihood`.
            ///
            /// Note that all the setters affecting `adjustment` are
            /// mutually exclusive.
            pub fn set_relative_likelihood<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.adjustment = std::option::Option::Some(
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::RelativeLikelihood(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for LikelihoodAdjustment {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment"
            }
        }

        /// Defines additional types related to [LikelihoodAdjustment].
        pub mod likelihood_adjustment {
            #[allow(unused_imports)]
            use super::*;

            /// How the likelihood will be modified.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Adjustment {
                /// Set the likelihood of a finding to a fixed value.
                FixedLikelihood(crate::model::Likelihood),
                /// Increase or decrease the likelihood by the specified number of
                /// levels. For example, if a finding would be `POSSIBLE` without the
                /// detection rule and `relative_likelihood` is 1, then it is upgraded to
                /// `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`.
                /// Likelihood may never drop below `VERY_UNLIKELY` or exceed
                /// `VERY_LIKELY`, so applying an adjustment of 1 followed by an
                /// adjustment of -1 when base likelihood is `VERY_LIKELY` will result in
                /// a final likelihood of `LIKELY`.
                RelativeLikelihood(i32),
            }
        }

        /// The rule that adjusts the likelihood of findings within a certain
        /// proximity of hotwords.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct HotwordRule {
            /// Regular expression pattern defining what qualifies as a hotword.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub hotword_regex: std::option::Option<crate::model::custom_info_type::Regex>,

            /// Range of characters within which the entire hotword must reside.
            /// The total length of the window cannot exceed 1000 characters.
            /// The finding itself will be included in the window, so that hotwords can
            /// be used to match substrings of the finding itself. Suppose you
            /// want Cloud DLP to promote the likelihood of the phone number
            /// regex "\(\d{3}\) \d{3}-\d{4}" if the area code is known to be the
            /// area code of a company's office. In this case, use the hotword regex
            /// "\(xxx\)", where "xxx" is the area code in question.
            ///
            /// For tabular data, if you want to modify the likelihood of an entire
            /// column of findngs, see
            /// [Hotword example: Set the match likelihood of a table column]
            /// (<https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes-likelihood#match-column-values>).
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub proximity:
                std::option::Option<crate::model::custom_info_type::detection_rule::Proximity>,

            /// Likelihood adjustment to apply to all matching findings.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub likelihood_adjustment: std::option::Option<
                crate::model::custom_info_type::detection_rule::LikelihoodAdjustment,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl HotwordRule {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [hotword_regex][crate::model::custom_info_type::detection_rule::HotwordRule::hotword_regex].
            pub fn set_hotword_regex<
                T: std::convert::Into<std::option::Option<crate::model::custom_info_type::Regex>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.hotword_regex = v.into();
                self
            }

            /// Sets the value of [proximity][crate::model::custom_info_type::detection_rule::HotwordRule::proximity].
            pub fn set_proximity<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::custom_info_type::detection_rule::Proximity,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.proximity = v.into();
                self
            }

            /// Sets the value of [likelihood_adjustment][crate::model::custom_info_type::detection_rule::HotwordRule::likelihood_adjustment].
            pub fn set_likelihood_adjustment<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::custom_info_type::detection_rule::LikelihoodAdjustment,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.likelihood_adjustment = v.into();
                self
            }
        }

        impl wkt::message::Message for HotwordRule {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule"
            }
        }

        /// Type of hotword rule.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Type {
            /// Hotword-based detection rule.
            HotwordRule(
                std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
            ),
        }
    }

    /// Type of exclusion rule.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExclusionType {
        /// A finding of this custom info type will not be excluded from results.
        Unspecified,
        /// A finding of this custom info type will be excluded from final results,
        /// but can still affect rule execution.
        Exclude,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExclusionType::value] or
        /// [ExclusionType::name].
        UnknownValue(exclusion_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod exclusion_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExclusionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Exclude => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXCLUSION_TYPE_UNSPECIFIED"),
                Self::Exclude => std::option::Option::Some("EXCLUSION_TYPE_EXCLUDE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExclusionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExclusionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExclusionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Exclude,
                _ => Self::UnknownValue(exclusion_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExclusionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXCLUSION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "EXCLUSION_TYPE_EXCLUDE" => Self::Exclude,
                _ => Self::UnknownValue(exclusion_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExclusionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Exclude => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExclusionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExclusionType>::new(
                ".google.privacy.dlp.v2.CustomInfoType.ExclusionType",
            ))
        }
    }

    /// Type of custom detector.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// A list of phrases to detect as a CustomInfoType.
        Dictionary(std::boxed::Box<crate::model::custom_info_type::Dictionary>),
        /// Regular expression based CustomInfoType.
        Regex(std::boxed::Box<crate::model::custom_info_type::Regex>),
        /// Message for detecting output from deidentification transformations that
        /// support reversing.
        SurrogateType(std::boxed::Box<crate::model::custom_info_type::SurrogateType>),
        /// Load an existing `StoredInfoType` resource for use in
        /// `InspectDataSource`. Not currently supported in `InspectContent`.
        StoredType(std::boxed::Box<crate::model::StoredType>),
    }
}

/// General identifier of a data field in a storage service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FieldId {
    /// Name describing the field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FieldId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FieldId::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for FieldId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FieldId"
    }
}

/// Datastore partition ID.
/// A partition ID identifies a grouping of entities. The grouping is always
/// by project and namespace, however the namespace ID may be empty.
///
/// A partition ID contains several dimensions:
/// project ID and namespace ID.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PartitionId {
    /// The ID of the project to which the entities belong.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// If not empty, the ID of the namespace to which the entities belong.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub namespace_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PartitionId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PartitionId::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [namespace_id][crate::model::PartitionId::namespace_id].
    pub fn set_namespace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace_id = v.into();
        self
    }
}

impl wkt::message::Message for PartitionId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.PartitionId"
    }
}

/// A representation of a Datastore kind.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KindExpression {
    /// The name of the kind.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KindExpression {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KindExpression::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for KindExpression {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.KindExpression"
    }
}

/// Options defining a data set within Google Cloud Datastore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatastoreOptions {
    /// A partition ID identifies a grouping of entities. The grouping is always
    /// by project and namespace, however the namespace ID may be empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub partition_id: std::option::Option<crate::model::PartitionId>,

    /// The kind to process.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kind: std::option::Option<crate::model::KindExpression>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatastoreOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partition_id][crate::model::DatastoreOptions::partition_id].
    pub fn set_partition_id<
        T: std::convert::Into<std::option::Option<crate::model::PartitionId>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partition_id = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::DatastoreOptions::kind].
    pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::KindExpression>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for DatastoreOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatastoreOptions"
    }
}

/// Message representing a set of files in a Cloud Storage bucket. Regular
/// expressions are used to allow fine-grained control over which files in the
/// bucket to include.
///
/// Included files are those that match at least one item in `include_regex` and
/// do not match any items in `exclude_regex`. Note that a file that matches
/// items from both lists will _not_ be included. For a match to occur, the
/// entire file path (i.e., everything in the url after the bucket name) must
/// match the regular expression.
///
/// For example, given the input `{bucket_name: "mybucket", include_regex:
/// ["directory1/.*"], exclude_regex:
/// ["directory1/excluded.*"]}`:
///
/// * `gs://mybucket/directory1/myfile` will be included
/// * `gs://mybucket/directory1/directory2/myfile` will be included (`.*` matches
///   across `/`)
/// * `gs://mybucket/directory0/directory1/myfile` will _not_ be included (the
///   full path doesn't match any items in `include_regex`)
/// * `gs://mybucket/directory1/excludedfile` will _not_ be included (the path
///   matches an item in `exclude_regex`)
///
/// If `include_regex` is left empty, it will match all files by default
/// (this is equivalent to setting `include_regex: [".*"]`).
///
/// Some other common use cases:
///
/// * `{bucket_name: "mybucket", exclude_regex: [".*\.pdf"]}` will include all
///   files in `mybucket` except for .pdf files
/// * `{bucket_name: "mybucket", include_regex: ["directory/[^/]+"]}` will
///   include all files directly under `gs://mybucket/directory/`, without matching
///   across `/`
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageRegexFileSet {
    /// The name of a Cloud Storage bucket. Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name: std::string::String,

    /// A list of regular expressions matching file paths to include. All files in
    /// the bucket that match at least one of these regular expressions will be
    /// included in the set of files, except for those that also match an item in
    /// `exclude_regex`. Leaving this field empty will match all files by default
    /// (this is equivalent to including `.*` in the list).
    ///
    /// Regular expressions use RE2
    /// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
    /// under the google/re2 repository on GitHub.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub include_regex: std::vec::Vec<std::string::String>,

    /// A list of regular expressions matching file paths to exclude. All files in
    /// the bucket that match at least one of these regular expressions will be
    /// excluded from the scan.
    ///
    /// Regular expressions use RE2
    /// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
    /// under the google/re2 repository on GitHub.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exclude_regex: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageRegexFileSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::CloudStorageRegexFileSet::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [include_regex][crate::model::CloudStorageRegexFileSet::include_regex].
    pub fn set_include_regex<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.include_regex = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclude_regex][crate::model::CloudStorageRegexFileSet::exclude_regex].
    pub fn set_exclude_regex<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclude_regex = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudStorageRegexFileSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageRegexFileSet"
    }
}

/// Options defining a file or a set of files within a Cloud Storage
/// bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageOptions {
    /// The set of one or more files to scan.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_set: std::option::Option<crate::model::cloud_storage_options::FileSet>,

    /// Max number of bytes to scan from a file. If a scanned file's size is bigger
    /// than this value then the rest of the bytes are omitted. Only one of
    /// `bytes_limit_per_file` and `bytes_limit_per_file_percent` can be specified.
    /// This field can't be set if de-identification is requested. For certain file
    /// types, setting this field has no effect. For more information, see [Limits
    /// on bytes scanned per
    /// file](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types#max-byte-size-per-file).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub bytes_limit_per_file: i64,

    /// Max percentage of bytes to scan from a file. The rest are omitted. The
    /// number of bytes scanned is rounded down. Must be between 0 and 100,
    /// inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
    /// bytes_limit_per_file and bytes_limit_per_file_percent can be specified.
    /// This field can't be set if de-identification is requested. For certain file
    /// types, setting this field has no effect. For more information, see [Limits
    /// on bytes scanned per
    /// file](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types#max-byte-size-per-file).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub bytes_limit_per_file_percent: i32,

    /// List of file type groups to include in the scan.
    /// If empty, all files are scanned and available data format processors
    /// are applied. In addition, the binary content of the selected files
    /// is always scanned as well.
    /// Images are scanned only as binary if the specified region
    /// does not support image inspection and no file_types were specified.
    /// Image inspection is restricted to 'global', 'us', 'asia', and 'europe'.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_types: std::vec::Vec<crate::model::FileType>,

    /// How to sample the data.
    pub sample_method: crate::model::cloud_storage_options::SampleMethod,

    /// Limits the number of files to scan to this percentage of the input FileSet.
    /// Number of files scanned is rounded down. Must be between 0 and 100,
    /// inclusively. Both 0 and 100 means no limit. Defaults to 0.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub files_limit_percent: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_set][crate::model::CloudStorageOptions::file_set].
    pub fn set_file_set<
        T: std::convert::Into<std::option::Option<crate::model::cloud_storage_options::FileSet>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_set = v.into();
        self
    }

    /// Sets the value of [bytes_limit_per_file][crate::model::CloudStorageOptions::bytes_limit_per_file].
    pub fn set_bytes_limit_per_file<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_limit_per_file = v.into();
        self
    }

    /// Sets the value of [bytes_limit_per_file_percent][crate::model::CloudStorageOptions::bytes_limit_per_file_percent].
    pub fn set_bytes_limit_per_file_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.bytes_limit_per_file_percent = v.into();
        self
    }

    /// Sets the value of [file_types][crate::model::CloudStorageOptions::file_types].
    pub fn set_file_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileType>,
    {
        use std::iter::Iterator;
        self.file_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sample_method][crate::model::CloudStorageOptions::sample_method].
    pub fn set_sample_method<
        T: std::convert::Into<crate::model::cloud_storage_options::SampleMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_method = v.into();
        self
    }

    /// Sets the value of [files_limit_percent][crate::model::CloudStorageOptions::files_limit_percent].
    pub fn set_files_limit_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.files_limit_percent = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageOptions"
    }
}

/// Defines additional types related to [CloudStorageOptions].
pub mod cloud_storage_options {
    #[allow(unused_imports)]
    use super::*;

    /// Set of files to scan.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FileSet {
        /// The Cloud Storage url of the file(s) to scan, in the format
        /// `gs://<bucket>/<path>`. Trailing wildcard in the path is allowed.
        ///
        /// If the url ends in a trailing slash, the bucket or directory represented
        /// by the url will be scanned non-recursively (content in sub-directories
        /// will not be scanned). This means that `gs://mybucket/` is equivalent to
        /// `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to
        /// `gs://mybucket/directory/*`.
        ///
        /// Exactly one of `url` or `regex_file_set` must be set.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub url: std::string::String,

        /// The regex-filtered set of files to scan. Exactly one of `url` or
        /// `regex_file_set` must be set.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub regex_file_set: std::option::Option<crate::model::CloudStorageRegexFileSet>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FileSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [url][crate::model::cloud_storage_options::FileSet::url].
        pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.url = v.into();
            self
        }

        /// Sets the value of [regex_file_set][crate::model::cloud_storage_options::FileSet::regex_file_set].
        pub fn set_regex_file_set<
            T: std::convert::Into<std::option::Option<crate::model::CloudStorageRegexFileSet>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.regex_file_set = v.into();
            self
        }
    }

    impl wkt::message::Message for FileSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CloudStorageOptions.FileSet"
        }
    }

    /// How to sample bytes if not all bytes are scanned. Meaningful only when used
    /// in conjunction with bytes_limit_per_file. If not specified, scanning would
    /// start from the top.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SampleMethod {
        /// No sampling.
        Unspecified,
        /// Scan from the top (default).
        Top,
        /// For each file larger than bytes_limit_per_file, randomly pick the offset
        /// to start scanning. The scanned bytes are contiguous.
        RandomStart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SampleMethod::value] or
        /// [SampleMethod::name].
        UnknownValue(sample_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sample_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SampleMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Top => std::option::Option::Some(1),
                Self::RandomStart => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SAMPLE_METHOD_UNSPECIFIED"),
                Self::Top => std::option::Option::Some("TOP"),
                Self::RandomStart => std::option::Option::Some("RANDOM_START"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SampleMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SampleMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SampleMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Top,
                2 => Self::RandomStart,
                _ => Self::UnknownValue(sample_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SampleMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SAMPLE_METHOD_UNSPECIFIED" => Self::Unspecified,
                "TOP" => Self::Top,
                "RANDOM_START" => Self::RandomStart,
                _ => Self::UnknownValue(sample_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SampleMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Top => serializer.serialize_i32(1),
                Self::RandomStart => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SampleMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SampleMethod>::new(
                ".google.privacy.dlp.v2.CloudStorageOptions.SampleMethod",
            ))
        }
    }
}

/// Message representing a set of files in Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageFileSet {
    /// The url, in the format `gs://<bucket>/<path>`. Trailing wildcard in the
    /// path is allowed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageFileSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::CloudStorageFileSet::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageFileSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageFileSet"
    }
}

/// Message representing a single file or path in Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStoragePath {
    /// A URL representing a file or path (no wildcards) in Cloud Storage.
    /// Example: `gs://[BUCKET_NAME]/dictionary.txt`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStoragePath {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::CloudStoragePath::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for CloudStoragePath {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStoragePath"
    }
}

/// Options defining BigQuery table and row identifiers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryOptions {
    /// Complete BigQuery table reference.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_reference: std::option::Option<crate::model::BigQueryTable>,

    /// Table fields that may uniquely identify a row within the table. When
    /// `actions.saveFindings.outputConfig.table` is specified, the values of
    /// columns specified here are available in the output table under
    /// `location.content_locations.record_location.record_key.id_values`. Nested
    /// fields such as `person.birthdate.year` are allowed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub identifying_fields: std::vec::Vec<crate::model::FieldId>,

    /// Max number of rows to scan. If the table has more rows than this value, the
    /// rest of the rows are omitted. If not set, or if set to 0, all rows will be
    /// scanned. Only one of rows_limit and rows_limit_percent can be specified.
    /// Cannot be used in conjunction with TimespanConfig.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub rows_limit: i64,

    /// Max percentage of rows to scan. The rest are omitted. The number of rows
    /// scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and
    /// 100 means no limit. Defaults to 0. Only one of rows_limit and
    /// rows_limit_percent can be specified. Cannot be used in conjunction with
    /// TimespanConfig.
    ///
    /// Caution: A [known
    /// issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#bq-sampling)
    /// is causing the `rowsLimitPercent` field to behave unexpectedly. We
    /// recommend using `rowsLimit` instead.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub rows_limit_percent: i32,

    /// How to sample the data.
    pub sample_method: crate::model::big_query_options::SampleMethod,

    /// References to fields excluded from scanning. This allows you to skip
    /// inspection of entire columns which you know have no findings.
    /// When inspecting a table, we recommend that you inspect all columns.
    /// Otherwise, findings might be affected because hints from excluded columns
    /// will not be used.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub excluded_fields: std::vec::Vec<crate::model::FieldId>,

    /// Limit scanning only to these fields.
    /// When inspecting a table, we recommend that you inspect all columns.
    /// Otherwise, findings might be affected because hints from excluded columns
    /// will not be used.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub included_fields: std::vec::Vec<crate::model::FieldId>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_reference][crate::model::BigQueryOptions::table_reference].
    pub fn set_table_reference<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_reference = v.into();
        self
    }

    /// Sets the value of [identifying_fields][crate::model::BigQueryOptions::identifying_fields].
    pub fn set_identifying_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.identifying_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rows_limit][crate::model::BigQueryOptions::rows_limit].
    pub fn set_rows_limit<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.rows_limit = v.into();
        self
    }

    /// Sets the value of [rows_limit_percent][crate::model::BigQueryOptions::rows_limit_percent].
    pub fn set_rows_limit_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rows_limit_percent = v.into();
        self
    }

    /// Sets the value of [sample_method][crate::model::BigQueryOptions::sample_method].
    pub fn set_sample_method<
        T: std::convert::Into<crate::model::big_query_options::SampleMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_method = v.into();
        self
    }

    /// Sets the value of [excluded_fields][crate::model::BigQueryOptions::excluded_fields].
    pub fn set_excluded_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.excluded_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [included_fields][crate::model::BigQueryOptions::included_fields].
    pub fn set_included_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.included_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryOptions"
    }
}

/// Defines additional types related to [BigQueryOptions].
pub mod big_query_options {
    #[allow(unused_imports)]
    use super::*;

    /// How to sample rows if not all rows are scanned. Meaningful only when used
    /// in conjunction with either rows_limit or rows_limit_percent. If not
    /// specified, rows are scanned in the order BigQuery reads them.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SampleMethod {
        /// No sampling.
        Unspecified,
        /// Scan groups of rows in the order BigQuery provides (default). Multiple
        /// groups of rows may be scanned in parallel, so results may not appear in
        /// the same order the rows are read.
        Top,
        /// Randomly pick groups of rows to scan.
        RandomStart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SampleMethod::value] or
        /// [SampleMethod::name].
        UnknownValue(sample_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sample_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SampleMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Top => std::option::Option::Some(1),
                Self::RandomStart => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SAMPLE_METHOD_UNSPECIFIED"),
                Self::Top => std::option::Option::Some("TOP"),
                Self::RandomStart => std::option::Option::Some("RANDOM_START"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SampleMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SampleMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SampleMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Top,
                2 => Self::RandomStart,
                _ => Self::UnknownValue(sample_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SampleMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SAMPLE_METHOD_UNSPECIFIED" => Self::Unspecified,
                "TOP" => Self::Top,
                "RANDOM_START" => Self::RandomStart,
                _ => Self::UnknownValue(sample_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SampleMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Top => serializer.serialize_i32(1),
                Self::RandomStart => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SampleMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SampleMethod>::new(
                ".google.privacy.dlp.v2.BigQueryOptions.SampleMethod",
            ))
        }
    }
}

/// Shared message indicating Cloud storage type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageConfig {
    /// Configuration of the timespan of the items to include in scanning.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timespan_config: std::option::Option<crate::model::storage_config::TimespanConfig>,

    /// Type of storage system to inspect.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::storage_config::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timespan_config][crate::model::StorageConfig::timespan_config].
    pub fn set_timespan_config<
        T: std::convert::Into<std::option::Option<crate::model::storage_config::TimespanConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.timespan_config = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::storage_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `DatastoreOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn datastore_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatastoreOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::DatastoreOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `DatastoreOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_datastore_options<
        T: std::convert::Into<std::boxed::Box<crate::model::DatastoreOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::storage_config::Type::DatastoreOptions(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `CloudStorageOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::CloudStorageOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `CloudStorageOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_cloud_storage_options<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::storage_config::Type::CloudStorageOptions(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `BigQueryOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::BigQueryOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `BigQueryOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_big_query_options<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::storage_config::Type::BigQueryOptions(v.into()),
        );
        self
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `HybridOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hybrid_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HybridOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::HybridOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `HybridOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_hybrid_options<
        T: std::convert::Into<std::boxed::Box<crate::model::HybridOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::storage_config::Type::HybridOptions(v.into()));
        self
    }
}

impl wkt::message::Message for StorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StorageConfig"
    }
}

/// Defines additional types related to [StorageConfig].
pub mod storage_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of the timespan of the items to include in scanning.
    /// Currently only supported when inspecting Cloud Storage and BigQuery.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TimespanConfig {
        /// Exclude files, tables, or rows older than this value.
        /// If not set, no lower time limit is applied.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Exclude files, tables, or rows newer than this value.
        /// If not set, no upper time limit is applied.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub end_time: std::option::Option<wkt::Timestamp>,

        /// Specification of the field containing the timestamp of scanned items.
        /// Used for data sources like Datastore and BigQuery.
        ///
        /// **For BigQuery**
        ///
        /// If this value is not specified and the table was modified between the
        /// given start and end times, the entire table will be scanned. If this
        /// value is specified, then rows are filtered based on the given start and
        /// end times. Rows with a `NULL` value in the provided BigQuery column are
        /// skipped.
        /// Valid data types of the provided BigQuery column are: `INTEGER`, `DATE`,
        /// `TIMESTAMP`, and `DATETIME`.
        ///
        /// If your BigQuery table is [partitioned at ingestion
        /// time](https://cloud.google.com/bigquery/docs/partitioned-tables#ingestion_time),
        /// you can use any of the following pseudo-columns as your timestamp field.
        /// When used with Cloud DLP, these pseudo-column names are case sensitive.
        ///
        /// - `_PARTITIONTIME`
        /// - `_PARTITIONDATE`
        /// - `_PARTITION_LOAD_TIME`
        ///
        /// **For Datastore**
        ///
        /// If this value is specified, then entities are filtered based on the given
        /// start and end times. If an entity does not contain the provided timestamp
        /// property or contains empty or invalid values, then it is included.
        /// Valid data types of the provided timestamp property are: `TIMESTAMP`.
        ///
        /// See the
        /// [known
        /// issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#bq-timespan)
        /// related to this operation.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub timestamp_field: std::option::Option<crate::model::FieldId>,

        /// When the job is started by a JobTrigger we will automatically figure out
        /// a valid start_time to avoid scanning files that have not been modified
        /// since the last time the JobTrigger executed. This will be based on the
        /// time of the execution of the last run of the JobTrigger or the timespan
        /// end_time used in the last run of the JobTrigger.
        ///
        /// **For BigQuery**
        ///
        /// Inspect jobs triggered by automatic population will scan data that is at
        /// least three hours old when the job starts. This is because streaming
        /// buffer rows are not read during inspection and reading up to the current
        /// timestamp will result in skipped rows.
        ///
        /// See the [known
        /// issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#recently-streamed-data)
        /// related to this operation.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enable_auto_population_of_timespan_config: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimespanConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::storage_config::TimespanConfig::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }

        /// Sets the value of [end_time][crate::model::storage_config::TimespanConfig::end_time].
        pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.end_time = v.into();
            self
        }

        /// Sets the value of [timestamp_field][crate::model::storage_config::TimespanConfig::timestamp_field].
        pub fn set_timestamp_field<
            T: std::convert::Into<std::option::Option<crate::model::FieldId>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.timestamp_field = v.into();
            self
        }

        /// Sets the value of [enable_auto_population_of_timespan_config][crate::model::storage_config::TimespanConfig::enable_auto_population_of_timespan_config].
        pub fn set_enable_auto_population_of_timespan_config<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.enable_auto_population_of_timespan_config = v.into();
            self
        }
    }

    impl wkt::message::Message for TimespanConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.StorageConfig.TimespanConfig"
        }
    }

    /// Type of storage system to inspect.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// Google Cloud Datastore options.
        DatastoreOptions(std::boxed::Box<crate::model::DatastoreOptions>),
        /// Cloud Storage options.
        CloudStorageOptions(std::boxed::Box<crate::model::CloudStorageOptions>),
        /// BigQuery options.
        BigQueryOptions(std::boxed::Box<crate::model::BigQueryOptions>),
        /// Hybrid inspection options.
        HybridOptions(std::boxed::Box<crate::model::HybridOptions>),
    }
}

/// Configuration to control jobs where the content being inspected is outside
/// of Google Cloud Platform.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridOptions {
    /// A short description of where the data is coming from. Will be stored once
    /// in the job. 256 max length.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// These are labels that each inspection request must include within their
    /// 'finding_labels' map. Request may contain others, but any missing one of
    /// these will be rejected.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// No more than 10 keys can be required.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub required_finding_label_keys: std::vec::Vec<std::string::String>,

    /// To organize findings, these labels will be added to each finding.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// Label values must be between 0 and 63 characters long and must conform
    /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
    ///
    /// No more than 10 labels can be associated with a given finding.
    ///
    /// Examples:
    ///
    /// * `"environment" : "production"`
    /// * `"pipeline" : "etl"`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// If the container is a table, additional information to make findings
    /// meaningful such as the columns that are primary keys.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_options: std::option::Option<crate::model::TableOptions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::HybridOptions::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [required_finding_label_keys][crate::model::HybridOptions::required_finding_label_keys].
    pub fn set_required_finding_label_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.required_finding_label_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::HybridOptions::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [table_options][crate::model::HybridOptions::table_options].
    pub fn set_table_options<
        T: std::convert::Into<std::option::Option<crate::model::TableOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_options = v.into();
        self
    }
}

impl wkt::message::Message for HybridOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridOptions"
    }
}

/// Row key for identifying a record in BigQuery table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryKey {
    /// Complete BigQuery table reference.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_reference: std::option::Option<crate::model::BigQueryTable>,

    /// Row number inferred at the time the table was scanned. This value is
    /// nondeterministic, cannot be queried, and may be null for inspection
    /// jobs. To locate findings within a table, specify
    /// `inspect_job.storage_config.big_query_options.identifying_fields` in
    /// `CreateDlpJobRequest`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub row_number: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_reference][crate::model::BigQueryKey::table_reference].
    pub fn set_table_reference<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_reference = v.into();
        self
    }

    /// Sets the value of [row_number][crate::model::BigQueryKey::row_number].
    pub fn set_row_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_number = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryKey"
    }
}

/// Record key for a finding in Cloud Datastore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatastoreKey {
    /// Datastore entity key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_key: std::option::Option<crate::model::Key>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatastoreKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_key][crate::model::DatastoreKey::entity_key].
    pub fn set_entity_key<T: std::convert::Into<std::option::Option<crate::model::Key>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_key = v.into();
        self
    }
}

impl wkt::message::Message for DatastoreKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatastoreKey"
    }
}

/// A unique identifier for a Datastore entity.
/// If a key's partition ID or any of its path kinds or names are
/// reserved/read-only, the key is reserved/read-only.
/// A reserved/read-only key is forbidden in certain documented contexts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Key {
    /// Entities are partitioned into subsets, currently identified by a project
    /// ID and namespace ID.
    /// Queries are scoped to a single partition.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub partition_id: std::option::Option<crate::model::PartitionId>,

    /// The entity path.
    /// An entity path consists of one or more elements composed of a kind and a
    /// string or numerical identifier, which identify entities. The first
    /// element identifies a _root entity_, the second element identifies
    /// a _child_ of the root entity, the third element identifies a child of the
    /// second entity, and so forth. The entities identified by all prefixes of
    /// the path are called the element's _ancestors_.
    ///
    /// A path can never be empty, and a path can have at most 100 elements.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub path: std::vec::Vec<crate::model::key::PathElement>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Key {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partition_id][crate::model::Key::partition_id].
    pub fn set_partition_id<
        T: std::convert::Into<std::option::Option<crate::model::PartitionId>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partition_id = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Key::path].
    pub fn set_path<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::key::PathElement>,
    {
        use std::iter::Iterator;
        self.path = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Key {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Key"
    }
}

/// Defines additional types related to [Key].
pub mod key {
    #[allow(unused_imports)]
    use super::*;

    /// A (kind, ID/name) pair used to construct a key path.
    ///
    /// If either name or ID is set, the element is complete.
    /// If neither is set, the element is incomplete.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PathElement {
        /// The kind of the entity.
        /// A kind matching regex `__.*__` is reserved/read-only.
        /// A kind must not contain more than 1500 bytes when UTF-8 encoded.
        /// Cannot be `""`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kind: std::string::String,

        /// The type of ID.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub id_type: std::option::Option<crate::model::key::path_element::IdType>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PathElement {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::key::PathElement::kind].
        pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kind = v.into();
            self
        }

        /// Sets the value of [id_type][crate::model::key::PathElement::id_type].
        ///
        /// Note that all the setters affecting `id_type` are mutually
        /// exclusive.
        pub fn set_id_type<
            T: std::convert::Into<std::option::Option<crate::model::key::path_element::IdType>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.id_type = v.into();
            self
        }

        /// The value of [id_type][crate::model::key::PathElement::id_type]
        /// if it holds a `Id`, `None` if the field is not set or
        /// holds a different branch.
        pub fn id(&self) -> std::option::Option<&i64> {
            #[allow(unreachable_patterns)]
            self.id_type.as_ref().and_then(|v| match v {
                crate::model::key::path_element::IdType::Id(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [id_type][crate::model::key::PathElement::id_type]
        /// to hold a `Id`.
        ///
        /// Note that all the setters affecting `id_type` are
        /// mutually exclusive.
        pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.id_type =
                std::option::Option::Some(crate::model::key::path_element::IdType::Id(v.into()));
            self
        }

        /// The value of [id_type][crate::model::key::PathElement::id_type]
        /// if it holds a `Name`, `None` if the field is not set or
        /// holds a different branch.
        pub fn name(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.id_type.as_ref().and_then(|v| match v {
                crate::model::key::path_element::IdType::Name(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [id_type][crate::model::key::PathElement::id_type]
        /// to hold a `Name`.
        ///
        /// Note that all the setters affecting `id_type` are
        /// mutually exclusive.
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id_type =
                std::option::Option::Some(crate::model::key::path_element::IdType::Name(v.into()));
            self
        }
    }

    impl wkt::message::Message for PathElement {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Key.PathElement"
        }
    }

    /// Defines additional types related to [PathElement].
    pub mod path_element {
        #[allow(unused_imports)]
        use super::*;

        /// The type of ID.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum IdType {
            /// The auto-allocated ID of the entity.
            /// Never equal to zero. Values less than zero are discouraged and may not
            /// be supported in the future.
            Id(i64),
            /// The name of the entity.
            /// A name matching regex `__.*__` is reserved/read-only.
            /// A name must not be more than 1500 bytes when UTF-8 encoded.
            /// Cannot be `""`.
            Name(std::string::String),
        }
    }
}

/// Message for a unique key indicating a record that contains a finding.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordKey {
    /// Values of identifying columns in the given row. Order of values matches
    /// the order of `identifying_fields` specified in the scanning request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub id_values: std::vec::Vec<std::string::String>,

    /// Type of key
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::record_key::Type>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecordKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id_values][crate::model::RecordKey::id_values].
    pub fn set_id_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.id_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [r#type][crate::model::RecordKey::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::record_key::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::RecordKey::r#type]
    /// if it holds a `DatastoreKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn datastore_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatastoreKey>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::record_key::Type::DatastoreKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::RecordKey::r#type]
    /// to hold a `DatastoreKey`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_datastore_key<T: std::convert::Into<std::boxed::Box<crate::model::DatastoreKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::record_key::Type::DatastoreKey(v.into()));
        self
    }

    /// The value of [r#type][crate::model::RecordKey::r#type]
    /// if it holds a `BigQueryKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryKey>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::record_key::Type::BigQueryKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::RecordKey::r#type]
    /// to hold a `BigQueryKey`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_big_query_key<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::record_key::Type::BigQueryKey(v.into()));
        self
    }
}

impl wkt::message::Message for RecordKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordKey"
    }
}

/// Defines additional types related to [RecordKey].
pub mod record_key {
    #[allow(unused_imports)]
    use super::*;

    /// Type of key
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// BigQuery key
        DatastoreKey(std::boxed::Box<crate::model::DatastoreKey>),
        /// Datastore key
        BigQueryKey(std::boxed::Box<crate::model::BigQueryKey>),
    }
}

/// Message defining the location of a BigQuery table. A table is uniquely
/// identified  by its project_id, dataset_id, and table_name. Within a query
/// a table is often referenced with a string in the format of:
/// `<project_id>:<dataset_id>.<table_id>` or
/// `<project_id>.<dataset_id>.<table_id>`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryTable {
    /// The Google Cloud project ID of the project containing the table.
    /// If omitted, project ID is inferred from the API call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Dataset ID of the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Name of the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::BigQueryTable::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::BigQueryTable::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::BigQueryTable::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryTable"
    }
}

/// Message defining the location of a BigQuery table with the projectId inferred
/// from the parent project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableReference {
    /// Dataset ID of the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Name of the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_id][crate::model::TableReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::TableReference::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }
}

impl wkt::message::Message for TableReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableReference"
    }
}

/// Message defining a field of a BigQuery table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryField {
    /// Source table of the field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table: std::option::Option<crate::model::BigQueryTable>,

    /// Designated field in the BigQuery table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<crate::model::FieldId>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::BigQueryField::table].
    pub fn set_table<T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>>(
        mut self,
        v: T,
    ) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [field][crate::model::BigQueryField::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryField"
    }
}

/// An entity in a dataset is a field or set of fields that correspond to a
/// single person. For example, in medical records the `EntityId` might be a
/// patient identifier, or for financial records it might be an account
/// identifier. This message is used when generalizations or analysis must take
/// into account that multiple rows correspond to the same entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityId {
    /// Composite key indicating which field contains the entity identifier.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<crate::model::FieldId>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::EntityId::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }
}

impl wkt::message::Message for EntityId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.EntityId"
    }
}

/// Instructions regarding the table content being inspected.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableOptions {
    /// The columns that are the primary keys for table objects included in
    /// ContentItem. A copy of this cell's value will stored alongside alongside
    /// each finding so that the finding can be traced to the specific row it came
    /// from. No more than 3 may be provided.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub identifying_fields: std::vec::Vec<crate::model::FieldId>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [identifying_fields][crate::model::TableOptions::identifying_fields].
    pub fn set_identifying_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.identifying_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableOptions"
    }
}

/// Enum of possible outcomes of transformations. SUCCESS if transformation and
/// storing of transformation was successful, otherwise, reason for not
/// transforming.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TransformationResultStatusType {
    /// Unused.
    StateTypeUnspecified,
    /// This will be set when a finding could not be transformed (i.e. outside user
    /// set bucket range).
    InvalidTransform,
    /// This will be set when a BigQuery transformation was successful but could
    /// not be stored back in BigQuery because the transformed row exceeds
    /// BigQuery's max row size.
    BigqueryMaxRowSizeExceeded,
    /// This will be set when there is a finding in the custom metadata of a file,
    /// but at the write time of the transformed file, this key / value pair is
    /// unretrievable.
    MetadataUnretrievable,
    /// This will be set when the transformation and storing of it is successful.
    Success,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TransformationResultStatusType::value] or
    /// [TransformationResultStatusType::name].
    UnknownValue(transformation_result_status_type::UnknownValue),
}

#[doc(hidden)]
pub mod transformation_result_status_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TransformationResultStatusType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::StateTypeUnspecified => std::option::Option::Some(0),
            Self::InvalidTransform => std::option::Option::Some(1),
            Self::BigqueryMaxRowSizeExceeded => std::option::Option::Some(2),
            Self::MetadataUnretrievable => std::option::Option::Some(3),
            Self::Success => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::StateTypeUnspecified => std::option::Option::Some("STATE_TYPE_UNSPECIFIED"),
            Self::InvalidTransform => std::option::Option::Some("INVALID_TRANSFORM"),
            Self::BigqueryMaxRowSizeExceeded => {
                std::option::Option::Some("BIGQUERY_MAX_ROW_SIZE_EXCEEDED")
            }
            Self::MetadataUnretrievable => std::option::Option::Some("METADATA_UNRETRIEVABLE"),
            Self::Success => std::option::Option::Some("SUCCESS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TransformationResultStatusType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TransformationResultStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TransformationResultStatusType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::StateTypeUnspecified,
            1 => Self::InvalidTransform,
            2 => Self::BigqueryMaxRowSizeExceeded,
            3 => Self::MetadataUnretrievable,
            4 => Self::Success,
            _ => Self::UnknownValue(transformation_result_status_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TransformationResultStatusType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STATE_TYPE_UNSPECIFIED" => Self::StateTypeUnspecified,
            "INVALID_TRANSFORM" => Self::InvalidTransform,
            "BIGQUERY_MAX_ROW_SIZE_EXCEEDED" => Self::BigqueryMaxRowSizeExceeded,
            "METADATA_UNRETRIEVABLE" => Self::MetadataUnretrievable,
            "SUCCESS" => Self::Success,
            _ => Self::UnknownValue(transformation_result_status_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TransformationResultStatusType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::StateTypeUnspecified => serializer.serialize_i32(0),
            Self::InvalidTransform => serializer.serialize_i32(1),
            Self::BigqueryMaxRowSizeExceeded => serializer.serialize_i32(2),
            Self::MetadataUnretrievable => serializer.serialize_i32(3),
            Self::Success => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TransformationResultStatusType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<TransformationResultStatusType>::new(
                ".google.privacy.dlp.v2.TransformationResultStatusType",
            ),
        )
    }
}

/// Describes functionality of a given container in its original format.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TransformationContainerType {
    /// Unused.
    TransformUnknownContainer,
    /// Body of a file.
    TransformBody,
    /// Metadata for a file.
    TransformMetadata,
    /// A table.
    TransformTable,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TransformationContainerType::value] or
    /// [TransformationContainerType::name].
    UnknownValue(transformation_container_type::UnknownValue),
}

#[doc(hidden)]
pub mod transformation_container_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TransformationContainerType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::TransformUnknownContainer => std::option::Option::Some(0),
            Self::TransformBody => std::option::Option::Some(1),
            Self::TransformMetadata => std::option::Option::Some(2),
            Self::TransformTable => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::TransformUnknownContainer => {
                std::option::Option::Some("TRANSFORM_UNKNOWN_CONTAINER")
            }
            Self::TransformBody => std::option::Option::Some("TRANSFORM_BODY"),
            Self::TransformMetadata => std::option::Option::Some("TRANSFORM_METADATA"),
            Self::TransformTable => std::option::Option::Some("TRANSFORM_TABLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TransformationContainerType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TransformationContainerType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TransformationContainerType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::TransformUnknownContainer,
            1 => Self::TransformBody,
            2 => Self::TransformMetadata,
            3 => Self::TransformTable,
            _ => Self::UnknownValue(transformation_container_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TransformationContainerType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRANSFORM_UNKNOWN_CONTAINER" => Self::TransformUnknownContainer,
            "TRANSFORM_BODY" => Self::TransformBody,
            "TRANSFORM_METADATA" => Self::TransformMetadata,
            "TRANSFORM_TABLE" => Self::TransformTable,
            _ => Self::UnknownValue(transformation_container_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TransformationContainerType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::TransformUnknownContainer => serializer.serialize_i32(0),
            Self::TransformBody => serializer.serialize_i32(1),
            Self::TransformMetadata => serializer.serialize_i32(2),
            Self::TransformTable => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TransformationContainerType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<TransformationContainerType>::new(
                ".google.privacy.dlp.v2.TransformationContainerType",
            ),
        )
    }
}

/// An enum of rules that can be used to transform a value. Can be a
/// record suppression, or one of the transformation rules specified under
/// `PrimitiveTransformation`.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TransformationType {
    /// Unused
    Unspecified,
    /// Record suppression
    RecordSuppression,
    /// Replace value
    ReplaceValue,
    /// Replace value using a dictionary.
    ReplaceDictionary,
    /// Redact
    Redact,
    /// Character mask
    CharacterMask,
    /// FFX-FPE
    CryptoReplaceFfxFpe,
    /// Fixed size bucketing
    FixedSizeBucketing,
    /// Bucketing
    Bucketing,
    /// Replace with info type
    ReplaceWithInfoType,
    /// Time part
    TimePart,
    /// Crypto hash
    CryptoHash,
    /// Date shift
    DateShift,
    /// Deterministic crypto
    CryptoDeterministicConfig,
    /// Redact image
    RedactImage,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TransformationType::value] or
    /// [TransformationType::name].
    UnknownValue(transformation_type::UnknownValue),
}

#[doc(hidden)]
pub mod transformation_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TransformationType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::RecordSuppression => std::option::Option::Some(1),
            Self::ReplaceValue => std::option::Option::Some(2),
            Self::ReplaceDictionary => std::option::Option::Some(15),
            Self::Redact => std::option::Option::Some(3),
            Self::CharacterMask => std::option::Option::Some(4),
            Self::CryptoReplaceFfxFpe => std::option::Option::Some(5),
            Self::FixedSizeBucketing => std::option::Option::Some(6),
            Self::Bucketing => std::option::Option::Some(7),
            Self::ReplaceWithInfoType => std::option::Option::Some(8),
            Self::TimePart => std::option::Option::Some(9),
            Self::CryptoHash => std::option::Option::Some(10),
            Self::DateShift => std::option::Option::Some(12),
            Self::CryptoDeterministicConfig => std::option::Option::Some(13),
            Self::RedactImage => std::option::Option::Some(14),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TRANSFORMATION_TYPE_UNSPECIFIED"),
            Self::RecordSuppression => std::option::Option::Some("RECORD_SUPPRESSION"),
            Self::ReplaceValue => std::option::Option::Some("REPLACE_VALUE"),
            Self::ReplaceDictionary => std::option::Option::Some("REPLACE_DICTIONARY"),
            Self::Redact => std::option::Option::Some("REDACT"),
            Self::CharacterMask => std::option::Option::Some("CHARACTER_MASK"),
            Self::CryptoReplaceFfxFpe => std::option::Option::Some("CRYPTO_REPLACE_FFX_FPE"),
            Self::FixedSizeBucketing => std::option::Option::Some("FIXED_SIZE_BUCKETING"),
            Self::Bucketing => std::option::Option::Some("BUCKETING"),
            Self::ReplaceWithInfoType => std::option::Option::Some("REPLACE_WITH_INFO_TYPE"),
            Self::TimePart => std::option::Option::Some("TIME_PART"),
            Self::CryptoHash => std::option::Option::Some("CRYPTO_HASH"),
            Self::DateShift => std::option::Option::Some("DATE_SHIFT"),
            Self::CryptoDeterministicConfig => {
                std::option::Option::Some("CRYPTO_DETERMINISTIC_CONFIG")
            }
            Self::RedactImage => std::option::Option::Some("REDACT_IMAGE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TransformationType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TransformationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TransformationType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::RecordSuppression,
            2 => Self::ReplaceValue,
            3 => Self::Redact,
            4 => Self::CharacterMask,
            5 => Self::CryptoReplaceFfxFpe,
            6 => Self::FixedSizeBucketing,
            7 => Self::Bucketing,
            8 => Self::ReplaceWithInfoType,
            9 => Self::TimePart,
            10 => Self::CryptoHash,
            12 => Self::DateShift,
            13 => Self::CryptoDeterministicConfig,
            14 => Self::RedactImage,
            15 => Self::ReplaceDictionary,
            _ => Self::UnknownValue(transformation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TransformationType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRANSFORMATION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "RECORD_SUPPRESSION" => Self::RecordSuppression,
            "REPLACE_VALUE" => Self::ReplaceValue,
            "REPLACE_DICTIONARY" => Self::ReplaceDictionary,
            "REDACT" => Self::Redact,
            "CHARACTER_MASK" => Self::CharacterMask,
            "CRYPTO_REPLACE_FFX_FPE" => Self::CryptoReplaceFfxFpe,
            "FIXED_SIZE_BUCKETING" => Self::FixedSizeBucketing,
            "BUCKETING" => Self::Bucketing,
            "REPLACE_WITH_INFO_TYPE" => Self::ReplaceWithInfoType,
            "TIME_PART" => Self::TimePart,
            "CRYPTO_HASH" => Self::CryptoHash,
            "DATE_SHIFT" => Self::DateShift,
            "CRYPTO_DETERMINISTIC_CONFIG" => Self::CryptoDeterministicConfig,
            "REDACT_IMAGE" => Self::RedactImage,
            _ => Self::UnknownValue(transformation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TransformationType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::RecordSuppression => serializer.serialize_i32(1),
            Self::ReplaceValue => serializer.serialize_i32(2),
            Self::ReplaceDictionary => serializer.serialize_i32(15),
            Self::Redact => serializer.serialize_i32(3),
            Self::CharacterMask => serializer.serialize_i32(4),
            Self::CryptoReplaceFfxFpe => serializer.serialize_i32(5),
            Self::FixedSizeBucketing => serializer.serialize_i32(6),
            Self::Bucketing => serializer.serialize_i32(7),
            Self::ReplaceWithInfoType => serializer.serialize_i32(8),
            Self::TimePart => serializer.serialize_i32(9),
            Self::CryptoHash => serializer.serialize_i32(10),
            Self::DateShift => serializer.serialize_i32(12),
            Self::CryptoDeterministicConfig => serializer.serialize_i32(13),
            Self::RedactImage => serializer.serialize_i32(14),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TransformationType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransformationType>::new(
            ".google.privacy.dlp.v2.TransformationType",
        ))
    }
}

/// Whether a profile being created is the first generation or an update.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ProfileGeneration {
    /// Unused.
    Unspecified,
    /// The profile is the first profile for the resource.
    New,
    /// The profile is an update to a previous profile.
    Update,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ProfileGeneration::value] or
    /// [ProfileGeneration::name].
    UnknownValue(profile_generation::UnknownValue),
}

#[doc(hidden)]
pub mod profile_generation {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ProfileGeneration {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::New => std::option::Option::Some(1),
            Self::Update => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PROFILE_GENERATION_UNSPECIFIED"),
            Self::New => std::option::Option::Some("PROFILE_GENERATION_NEW"),
            Self::Update => std::option::Option::Some("PROFILE_GENERATION_UPDATE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ProfileGeneration {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ProfileGeneration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ProfileGeneration {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::New,
            2 => Self::Update,
            _ => Self::UnknownValue(profile_generation::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ProfileGeneration {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PROFILE_GENERATION_UNSPECIFIED" => Self::Unspecified,
            "PROFILE_GENERATION_NEW" => Self::New,
            "PROFILE_GENERATION_UPDATE" => Self::Update,
            _ => Self::UnknownValue(profile_generation::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ProfileGeneration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::New => serializer.serialize_i32(1),
            Self::Update => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ProfileGeneration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProfileGeneration>::new(
            ".google.privacy.dlp.v2.ProfileGeneration",
        ))
    }
}

/// Over time new types may be added. Currently VIEW, MATERIALIZED_VIEW, and
/// non-BigLake external tables are not supported.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BigQueryTableTypeCollection {
    /// Unused.
    BigQueryCollectionUnspecified,
    /// Automatically generate profiles for all tables, even if the table type is
    /// not yet fully supported for analysis. Profiles for unsupported tables will
    /// be generated with errors to indicate their partial support. When full
    /// support is added, the tables will automatically be profiled during the next
    /// scheduled run.
    BigQueryCollectionAllTypes,
    /// Only those types fully supported will be profiled. Will expand
    /// automatically as Cloud DLP adds support for new table types. Unsupported
    /// table types will not have partial profiles generated.
    BigQueryCollectionOnlySupportedTypes,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BigQueryTableTypeCollection::value] or
    /// [BigQueryTableTypeCollection::name].
    UnknownValue(big_query_table_type_collection::UnknownValue),
}

#[doc(hidden)]
pub mod big_query_table_type_collection {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BigQueryTableTypeCollection {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::BigQueryCollectionUnspecified => std::option::Option::Some(0),
            Self::BigQueryCollectionAllTypes => std::option::Option::Some(1),
            Self::BigQueryCollectionOnlySupportedTypes => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::BigQueryCollectionUnspecified => {
                std::option::Option::Some("BIG_QUERY_COLLECTION_UNSPECIFIED")
            }
            Self::BigQueryCollectionAllTypes => {
                std::option::Option::Some("BIG_QUERY_COLLECTION_ALL_TYPES")
            }
            Self::BigQueryCollectionOnlySupportedTypes => {
                std::option::Option::Some("BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BigQueryTableTypeCollection {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BigQueryTableTypeCollection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BigQueryTableTypeCollection {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::BigQueryCollectionUnspecified,
            1 => Self::BigQueryCollectionAllTypes,
            2 => Self::BigQueryCollectionOnlySupportedTypes,
            _ => Self::UnknownValue(big_query_table_type_collection::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BigQueryTableTypeCollection {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BIG_QUERY_COLLECTION_UNSPECIFIED" => Self::BigQueryCollectionUnspecified,
            "BIG_QUERY_COLLECTION_ALL_TYPES" => Self::BigQueryCollectionAllTypes,
            "BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES" => {
                Self::BigQueryCollectionOnlySupportedTypes
            }
            _ => Self::UnknownValue(big_query_table_type_collection::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BigQueryTableTypeCollection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::BigQueryCollectionUnspecified => serializer.serialize_i32(0),
            Self::BigQueryCollectionAllTypes => serializer.serialize_i32(1),
            Self::BigQueryCollectionOnlySupportedTypes => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BigQueryTableTypeCollection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<BigQueryTableTypeCollection>::new(
                ".google.privacy.dlp.v2.BigQueryTableTypeCollection",
            ),
        )
    }
}

/// Over time new types may be added. Currently VIEW, MATERIALIZED_VIEW, and
/// non-BigLake external tables are not supported.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BigQueryTableType {
    /// Unused.
    Unspecified,
    /// A normal BigQuery table.
    Table,
    /// A table that references data stored in Cloud Storage.
    ExternalBigLake,
    /// A snapshot of a BigQuery table.
    Snapshot,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BigQueryTableType::value] or
    /// [BigQueryTableType::name].
    UnknownValue(big_query_table_type::UnknownValue),
}

#[doc(hidden)]
pub mod big_query_table_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BigQueryTableType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Table => std::option::Option::Some(1),
            Self::ExternalBigLake => std::option::Option::Some(2),
            Self::Snapshot => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BIG_QUERY_TABLE_TYPE_UNSPECIFIED"),
            Self::Table => std::option::Option::Some("BIG_QUERY_TABLE_TYPE_TABLE"),
            Self::ExternalBigLake => {
                std::option::Option::Some("BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE")
            }
            Self::Snapshot => std::option::Option::Some("BIG_QUERY_TABLE_TYPE_SNAPSHOT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BigQueryTableType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BigQueryTableType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BigQueryTableType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Table,
            2 => Self::ExternalBigLake,
            3 => Self::Snapshot,
            _ => Self::UnknownValue(big_query_table_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BigQueryTableType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BIG_QUERY_TABLE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BIG_QUERY_TABLE_TYPE_TABLE" => Self::Table,
            "BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE" => Self::ExternalBigLake,
            "BIG_QUERY_TABLE_TYPE_SNAPSHOT" => Self::Snapshot,
            _ => Self::UnknownValue(big_query_table_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BigQueryTableType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Table => serializer.serialize_i32(1),
            Self::ExternalBigLake => serializer.serialize_i32(2),
            Self::Snapshot => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BigQueryTableType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BigQueryTableType>::new(
            ".google.privacy.dlp.v2.BigQueryTableType",
        ))
    }
}

/// How frequently data profiles can be updated. New options can be added at a
/// later time.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DataProfileUpdateFrequency {
    /// Unspecified.
    UpdateFrequencyUnspecified,
    /// After the data profile is created, it will never be updated.
    UpdateFrequencyNever,
    /// The data profile can be updated up to once every 24 hours.
    UpdateFrequencyDaily,
    /// The data profile can be updated up to once every 30 days. Default.
    UpdateFrequencyMonthly,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DataProfileUpdateFrequency::value] or
    /// [DataProfileUpdateFrequency::name].
    UnknownValue(data_profile_update_frequency::UnknownValue),
}

#[doc(hidden)]
pub mod data_profile_update_frequency {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DataProfileUpdateFrequency {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::UpdateFrequencyUnspecified => std::option::Option::Some(0),
            Self::UpdateFrequencyNever => std::option::Option::Some(1),
            Self::UpdateFrequencyDaily => std::option::Option::Some(2),
            Self::UpdateFrequencyMonthly => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::UpdateFrequencyUnspecified => {
                std::option::Option::Some("UPDATE_FREQUENCY_UNSPECIFIED")
            }
            Self::UpdateFrequencyNever => std::option::Option::Some("UPDATE_FREQUENCY_NEVER"),
            Self::UpdateFrequencyDaily => std::option::Option::Some("UPDATE_FREQUENCY_DAILY"),
            Self::UpdateFrequencyMonthly => std::option::Option::Some("UPDATE_FREQUENCY_MONTHLY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DataProfileUpdateFrequency {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DataProfileUpdateFrequency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DataProfileUpdateFrequency {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::UpdateFrequencyUnspecified,
            1 => Self::UpdateFrequencyNever,
            2 => Self::UpdateFrequencyDaily,
            4 => Self::UpdateFrequencyMonthly,
            _ => Self::UnknownValue(data_profile_update_frequency::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DataProfileUpdateFrequency {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UPDATE_FREQUENCY_UNSPECIFIED" => Self::UpdateFrequencyUnspecified,
            "UPDATE_FREQUENCY_NEVER" => Self::UpdateFrequencyNever,
            "UPDATE_FREQUENCY_DAILY" => Self::UpdateFrequencyDaily,
            "UPDATE_FREQUENCY_MONTHLY" => Self::UpdateFrequencyMonthly,
            _ => Self::UnknownValue(data_profile_update_frequency::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DataProfileUpdateFrequency {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::UpdateFrequencyUnspecified => serializer.serialize_i32(0),
            Self::UpdateFrequencyNever => serializer.serialize_i32(1),
            Self::UpdateFrequencyDaily => serializer.serialize_i32(2),
            Self::UpdateFrequencyMonthly => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DataProfileUpdateFrequency {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<DataProfileUpdateFrequency>::new(
                ".google.privacy.dlp.v2.DataProfileUpdateFrequency",
            ),
        )
    }
}

/// Attributes evaluated to determine if a table has been modified. New values
/// may be added at a later time.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BigQueryTableModification {
    /// Unused.
    TableModificationUnspecified,
    /// A table will be considered modified when the last_modified_time from
    /// BigQuery has been updated.
    TableModifiedTimestamp,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BigQueryTableModification::value] or
    /// [BigQueryTableModification::name].
    UnknownValue(big_query_table_modification::UnknownValue),
}

#[doc(hidden)]
pub mod big_query_table_modification {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BigQueryTableModification {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::TableModificationUnspecified => std::option::Option::Some(0),
            Self::TableModifiedTimestamp => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::TableModificationUnspecified => {
                std::option::Option::Some("TABLE_MODIFICATION_UNSPECIFIED")
            }
            Self::TableModifiedTimestamp => std::option::Option::Some("TABLE_MODIFIED_TIMESTAMP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BigQueryTableModification {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BigQueryTableModification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BigQueryTableModification {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::TableModificationUnspecified,
            1 => Self::TableModifiedTimestamp,
            _ => Self::UnknownValue(big_query_table_modification::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BigQueryTableModification {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TABLE_MODIFICATION_UNSPECIFIED" => Self::TableModificationUnspecified,
            "TABLE_MODIFIED_TIMESTAMP" => Self::TableModifiedTimestamp,
            _ => Self::UnknownValue(big_query_table_modification::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BigQueryTableModification {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::TableModificationUnspecified => serializer.serialize_i32(0),
            Self::TableModifiedTimestamp => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BigQueryTableModification {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<BigQueryTableModification>::new(
                ".google.privacy.dlp.v2.BigQueryTableModification",
            ),
        )
    }
}

/// Attributes evaluated to determine if a schema has been modified. New values
/// may be added at a later time.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BigQuerySchemaModification {
    /// Unused
    SchemaModificationUnspecified,
    /// Profiles should be regenerated when new columns are added to the table.
    /// Default.
    SchemaNewColumns,
    /// Profiles should be regenerated when columns are removed from the table.
    SchemaRemovedColumns,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BigQuerySchemaModification::value] or
    /// [BigQuerySchemaModification::name].
    UnknownValue(big_query_schema_modification::UnknownValue),
}

#[doc(hidden)]
pub mod big_query_schema_modification {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BigQuerySchemaModification {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::SchemaModificationUnspecified => std::option::Option::Some(0),
            Self::SchemaNewColumns => std::option::Option::Some(1),
            Self::SchemaRemovedColumns => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::SchemaModificationUnspecified => {
                std::option::Option::Some("SCHEMA_MODIFICATION_UNSPECIFIED")
            }
            Self::SchemaNewColumns => std::option::Option::Some("SCHEMA_NEW_COLUMNS"),
            Self::SchemaRemovedColumns => std::option::Option::Some("SCHEMA_REMOVED_COLUMNS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BigQuerySchemaModification {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BigQuerySchemaModification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BigQuerySchemaModification {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::SchemaModificationUnspecified,
            1 => Self::SchemaNewColumns,
            2 => Self::SchemaRemovedColumns,
            _ => Self::UnknownValue(big_query_schema_modification::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BigQuerySchemaModification {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SCHEMA_MODIFICATION_UNSPECIFIED" => Self::SchemaModificationUnspecified,
            "SCHEMA_NEW_COLUMNS" => Self::SchemaNewColumns,
            "SCHEMA_REMOVED_COLUMNS" => Self::SchemaRemovedColumns,
            _ => Self::UnknownValue(big_query_schema_modification::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BigQuerySchemaModification {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::SchemaModificationUnspecified => serializer.serialize_i32(0),
            Self::SchemaNewColumns => serializer.serialize_i32(1),
            Self::SchemaRemovedColumns => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BigQuerySchemaModification {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<BigQuerySchemaModification>::new(
                ".google.privacy.dlp.v2.BigQuerySchemaModification",
            ),
        )
    }
}

/// Operators available for comparing the value of fields.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RelationalOperator {
    /// Unused
    Unspecified,
    /// Equal. Attempts to match even with incompatible types.
    EqualTo,
    /// Not equal to. Attempts to match even with incompatible types.
    NotEqualTo,
    /// Greater than.
    GreaterThan,
    /// Less than.
    LessThan,
    /// Greater than or equals.
    GreaterThanOrEquals,
    /// Less than or equals.
    LessThanOrEquals,
    /// Exists
    Exists,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RelationalOperator::value] or
    /// [RelationalOperator::name].
    UnknownValue(relational_operator::UnknownValue),
}

#[doc(hidden)]
pub mod relational_operator {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RelationalOperator {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::EqualTo => std::option::Option::Some(1),
            Self::NotEqualTo => std::option::Option::Some(2),
            Self::GreaterThan => std::option::Option::Some(3),
            Self::LessThan => std::option::Option::Some(4),
            Self::GreaterThanOrEquals => std::option::Option::Some(5),
            Self::LessThanOrEquals => std::option::Option::Some(6),
            Self::Exists => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RELATIONAL_OPERATOR_UNSPECIFIED"),
            Self::EqualTo => std::option::Option::Some("EQUAL_TO"),
            Self::NotEqualTo => std::option::Option::Some("NOT_EQUAL_TO"),
            Self::GreaterThan => std::option::Option::Some("GREATER_THAN"),
            Self::LessThan => std::option::Option::Some("LESS_THAN"),
            Self::GreaterThanOrEquals => std::option::Option::Some("GREATER_THAN_OR_EQUALS"),
            Self::LessThanOrEquals => std::option::Option::Some("LESS_THAN_OR_EQUALS"),
            Self::Exists => std::option::Option::Some("EXISTS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RelationalOperator {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RelationalOperator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RelationalOperator {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::EqualTo,
            2 => Self::NotEqualTo,
            3 => Self::GreaterThan,
            4 => Self::LessThan,
            5 => Self::GreaterThanOrEquals,
            6 => Self::LessThanOrEquals,
            7 => Self::Exists,
            _ => Self::UnknownValue(relational_operator::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RelationalOperator {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RELATIONAL_OPERATOR_UNSPECIFIED" => Self::Unspecified,
            "EQUAL_TO" => Self::EqualTo,
            "NOT_EQUAL_TO" => Self::NotEqualTo,
            "GREATER_THAN" => Self::GreaterThan,
            "LESS_THAN" => Self::LessThan,
            "GREATER_THAN_OR_EQUALS" => Self::GreaterThanOrEquals,
            "LESS_THAN_OR_EQUALS" => Self::LessThanOrEquals,
            "EXISTS" => Self::Exists,
            _ => Self::UnknownValue(relational_operator::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RelationalOperator {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::EqualTo => serializer.serialize_i32(1),
            Self::NotEqualTo => serializer.serialize_i32(2),
            Self::GreaterThan => serializer.serialize_i32(3),
            Self::LessThan => serializer.serialize_i32(4),
            Self::GreaterThanOrEquals => serializer.serialize_i32(5),
            Self::LessThanOrEquals => serializer.serialize_i32(6),
            Self::Exists => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RelationalOperator {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<RelationalOperator>::new(
            ".google.privacy.dlp.v2.RelationalOperator",
        ))
    }
}

/// Type of the match which can be applied to different ways of matching, like
/// Dictionary, regular expression and intersecting with findings of another
/// info type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MatchingType {
    /// Invalid.
    Unspecified,
    /// Full match.
    ///
    /// - Dictionary: join of Dictionary results matched complete finding quote
    /// - Regex: all regex matches fill a finding quote start to end
    /// - Exclude info type: completely inside affecting info types findings
    FullMatch,
    /// Partial match.
    ///
    /// - Dictionary: at least one of the tokens in the finding matches
    /// - Regex: substring of the finding matches
    /// - Exclude info type: intersects with affecting info types findings
    PartialMatch,
    /// Inverse match.
    ///
    /// - Dictionary: no tokens in the finding match the dictionary
    /// - Regex: finding doesn't match the regex
    /// - Exclude info type: no intersection with affecting info types findings
    InverseMatch,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MatchingType::value] or
    /// [MatchingType::name].
    UnknownValue(matching_type::UnknownValue),
}

#[doc(hidden)]
pub mod matching_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MatchingType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::FullMatch => std::option::Option::Some(1),
            Self::PartialMatch => std::option::Option::Some(2),
            Self::InverseMatch => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MATCHING_TYPE_UNSPECIFIED"),
            Self::FullMatch => std::option::Option::Some("MATCHING_TYPE_FULL_MATCH"),
            Self::PartialMatch => std::option::Option::Some("MATCHING_TYPE_PARTIAL_MATCH"),
            Self::InverseMatch => std::option::Option::Some("MATCHING_TYPE_INVERSE_MATCH"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MatchingType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MatchingType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MatchingType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::FullMatch,
            2 => Self::PartialMatch,
            3 => Self::InverseMatch,
            _ => Self::UnknownValue(matching_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MatchingType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MATCHING_TYPE_UNSPECIFIED" => Self::Unspecified,
            "MATCHING_TYPE_FULL_MATCH" => Self::FullMatch,
            "MATCHING_TYPE_PARTIAL_MATCH" => Self::PartialMatch,
            "MATCHING_TYPE_INVERSE_MATCH" => Self::InverseMatch,
            _ => Self::UnknownValue(matching_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MatchingType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::FullMatch => serializer.serialize_i32(1),
            Self::PartialMatch => serializer.serialize_i32(2),
            Self::InverseMatch => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MatchingType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MatchingType>::new(
            ".google.privacy.dlp.v2.MatchingType",
        ))
    }
}

/// Deprecated and unused.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ContentOption {
    /// Includes entire content of a file or a data stream.
    ContentUnspecified,
    /// Text content within the data, excluding any metadata.
    ContentText,
    /// Images found in the data.
    ContentImage,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ContentOption::value] or
    /// [ContentOption::name].
    UnknownValue(content_option::UnknownValue),
}

#[doc(hidden)]
pub mod content_option {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ContentOption {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::ContentUnspecified => std::option::Option::Some(0),
            Self::ContentText => std::option::Option::Some(1),
            Self::ContentImage => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::ContentUnspecified => std::option::Option::Some("CONTENT_UNSPECIFIED"),
            Self::ContentText => std::option::Option::Some("CONTENT_TEXT"),
            Self::ContentImage => std::option::Option::Some("CONTENT_IMAGE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ContentOption {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ContentOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ContentOption {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::ContentUnspecified,
            1 => Self::ContentText,
            2 => Self::ContentImage,
            _ => Self::UnknownValue(content_option::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ContentOption {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONTENT_UNSPECIFIED" => Self::ContentUnspecified,
            "CONTENT_TEXT" => Self::ContentText,
            "CONTENT_IMAGE" => Self::ContentImage,
            _ => Self::UnknownValue(content_option::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ContentOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::ContentUnspecified => serializer.serialize_i32(0),
            Self::ContentText => serializer.serialize_i32(1),
            Self::ContentImage => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ContentOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContentOption>::new(
            ".google.privacy.dlp.v2.ContentOption",
        ))
    }
}

/// Type of metadata containing the finding.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MetadataType {
    /// Unused
    MetadatatypeUnspecified,
    /// General file metadata provided by Cloud Storage.
    StorageMetadata,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MetadataType::value] or
    /// [MetadataType::name].
    UnknownValue(metadata_type::UnknownValue),
}

#[doc(hidden)]
pub mod metadata_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MetadataType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::MetadatatypeUnspecified => std::option::Option::Some(0),
            Self::StorageMetadata => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::MetadatatypeUnspecified => std::option::Option::Some("METADATATYPE_UNSPECIFIED"),
            Self::StorageMetadata => std::option::Option::Some("STORAGE_METADATA"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MetadataType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MetadataType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MetadataType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::MetadatatypeUnspecified,
            2 => Self::StorageMetadata,
            _ => Self::UnknownValue(metadata_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MetadataType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "METADATATYPE_UNSPECIFIED" => Self::MetadatatypeUnspecified,
            "STORAGE_METADATA" => Self::StorageMetadata,
            _ => Self::UnknownValue(metadata_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MetadataType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::MetadatatypeUnspecified => serializer.serialize_i32(0),
            Self::StorageMetadata => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MetadataType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MetadataType>::new(
            ".google.privacy.dlp.v2.MetadataType",
        ))
    }
}

/// Parts of the APIs which use certain infoTypes.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InfoTypeSupportedBy {
    /// Unused.
    EnumTypeUnspecified,
    /// Supported by the inspect operations.
    Inspect,
    /// Supported by the risk analysis operations.
    RiskAnalysis,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InfoTypeSupportedBy::value] or
    /// [InfoTypeSupportedBy::name].
    UnknownValue(info_type_supported_by::UnknownValue),
}

#[doc(hidden)]
pub mod info_type_supported_by {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InfoTypeSupportedBy {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::EnumTypeUnspecified => std::option::Option::Some(0),
            Self::Inspect => std::option::Option::Some(1),
            Self::RiskAnalysis => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::EnumTypeUnspecified => std::option::Option::Some("ENUM_TYPE_UNSPECIFIED"),
            Self::Inspect => std::option::Option::Some("INSPECT"),
            Self::RiskAnalysis => std::option::Option::Some("RISK_ANALYSIS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InfoTypeSupportedBy {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InfoTypeSupportedBy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InfoTypeSupportedBy {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::EnumTypeUnspecified,
            1 => Self::Inspect,
            2 => Self::RiskAnalysis,
            _ => Self::UnknownValue(info_type_supported_by::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InfoTypeSupportedBy {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENUM_TYPE_UNSPECIFIED" => Self::EnumTypeUnspecified,
            "INSPECT" => Self::Inspect,
            "RISK_ANALYSIS" => Self::RiskAnalysis,
            _ => Self::UnknownValue(info_type_supported_by::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InfoTypeSupportedBy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::EnumTypeUnspecified => serializer.serialize_i32(0),
            Self::Inspect => serializer.serialize_i32(1),
            Self::RiskAnalysis => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InfoTypeSupportedBy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<InfoTypeSupportedBy>::new(
            ".google.privacy.dlp.v2.InfoTypeSupportedBy",
        ))
    }
}

/// An enum to represent the various types of DLP jobs.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DlpJobType {
    /// Defaults to INSPECT_JOB.
    Unspecified,
    /// The job inspected Google Cloud for sensitive data.
    InspectJob,
    /// The job executed a Risk Analysis computation.
    RiskAnalysisJob,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DlpJobType::value] or
    /// [DlpJobType::name].
    UnknownValue(dlp_job_type::UnknownValue),
}

#[doc(hidden)]
pub mod dlp_job_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DlpJobType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::InspectJob => std::option::Option::Some(1),
            Self::RiskAnalysisJob => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DLP_JOB_TYPE_UNSPECIFIED"),
            Self::InspectJob => std::option::Option::Some("INSPECT_JOB"),
            Self::RiskAnalysisJob => std::option::Option::Some("RISK_ANALYSIS_JOB"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DlpJobType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DlpJobType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DlpJobType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::InspectJob,
            2 => Self::RiskAnalysisJob,
            _ => Self::UnknownValue(dlp_job_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DlpJobType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DLP_JOB_TYPE_UNSPECIFIED" => Self::Unspecified,
            "INSPECT_JOB" => Self::InspectJob,
            "RISK_ANALYSIS_JOB" => Self::RiskAnalysisJob,
            _ => Self::UnknownValue(dlp_job_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DlpJobType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::InspectJob => serializer.serialize_i32(1),
            Self::RiskAnalysisJob => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DlpJobType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DlpJobType>::new(
            ".google.privacy.dlp.v2.DlpJobType",
        ))
    }
}

/// State of a StoredInfoType version.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum StoredInfoTypeState {
    /// Unused
    Unspecified,
    /// StoredInfoType version is being created.
    Pending,
    /// StoredInfoType version is ready for use.
    Ready,
    /// StoredInfoType creation failed. All relevant error messages are returned in
    /// the `StoredInfoTypeVersion` message.
    Failed,
    /// StoredInfoType is no longer valid because artifacts stored in
    /// user-controlled storage were modified. To fix an invalid StoredInfoType,
    /// use the `UpdateStoredInfoType` method to create a new version.
    Invalid,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [StoredInfoTypeState::value] or
    /// [StoredInfoTypeState::name].
    UnknownValue(stored_info_type_state::UnknownValue),
}

#[doc(hidden)]
pub mod stored_info_type_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl StoredInfoTypeState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Pending => std::option::Option::Some(1),
            Self::Ready => std::option::Option::Some(2),
            Self::Failed => std::option::Option::Some(3),
            Self::Invalid => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STORED_INFO_TYPE_STATE_UNSPECIFIED"),
            Self::Pending => std::option::Option::Some("PENDING"),
            Self::Ready => std::option::Option::Some("READY"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::Invalid => std::option::Option::Some("INVALID"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for StoredInfoTypeState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for StoredInfoTypeState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for StoredInfoTypeState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Pending,
            2 => Self::Ready,
            3 => Self::Failed,
            4 => Self::Invalid,
            _ => Self::UnknownValue(stored_info_type_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for StoredInfoTypeState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STORED_INFO_TYPE_STATE_UNSPECIFIED" => Self::Unspecified,
            "PENDING" => Self::Pending,
            "READY" => Self::Ready,
            "FAILED" => Self::Failed,
            "INVALID" => Self::Invalid,
            _ => Self::UnknownValue(stored_info_type_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for StoredInfoTypeState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Pending => serializer.serialize_i32(1),
            Self::Ready => serializer.serialize_i32(2),
            Self::Failed => serializer.serialize_i32(3),
            Self::Invalid => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for StoredInfoTypeState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<StoredInfoTypeState>::new(
            ".google.privacy.dlp.v2.StoredInfoTypeState",
        ))
    }
}

/// How broadly the data in the resource has been shared. New items may be added
/// over time. A higher number means more restricted.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ResourceVisibility {
    /// Unused.
    Unspecified,
    /// Visible to any user.
    Public,
    /// May contain public items.
    /// For example, if a Cloud Storage bucket has uniform bucket level access
    /// disabled, some objects inside it may be public, but none are known yet.
    Inconclusive,
    /// Visible only to specific users.
    Restricted,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ResourceVisibility::value] or
    /// [ResourceVisibility::name].
    UnknownValue(resource_visibility::UnknownValue),
}

#[doc(hidden)]
pub mod resource_visibility {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ResourceVisibility {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Public => std::option::Option::Some(10),
            Self::Inconclusive => std::option::Option::Some(15),
            Self::Restricted => std::option::Option::Some(20),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RESOURCE_VISIBILITY_UNSPECIFIED"),
            Self::Public => std::option::Option::Some("RESOURCE_VISIBILITY_PUBLIC"),
            Self::Inconclusive => std::option::Option::Some("RESOURCE_VISIBILITY_INCONCLUSIVE"),
            Self::Restricted => std::option::Option::Some("RESOURCE_VISIBILITY_RESTRICTED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ResourceVisibility {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ResourceVisibility {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ResourceVisibility {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            10 => Self::Public,
            15 => Self::Inconclusive,
            20 => Self::Restricted,
            _ => Self::UnknownValue(resource_visibility::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ResourceVisibility {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RESOURCE_VISIBILITY_UNSPECIFIED" => Self::Unspecified,
            "RESOURCE_VISIBILITY_PUBLIC" => Self::Public,
            "RESOURCE_VISIBILITY_INCONCLUSIVE" => Self::Inconclusive,
            "RESOURCE_VISIBILITY_RESTRICTED" => Self::Restricted,
            _ => Self::UnknownValue(resource_visibility::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ResourceVisibility {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Public => serializer.serialize_i32(10),
            Self::Inconclusive => serializer.serialize_i32(15),
            Self::Restricted => serializer.serialize_i32(20),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ResourceVisibility {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResourceVisibility>::new(
            ".google.privacy.dlp.v2.ResourceVisibility",
        ))
    }
}

/// How a resource is encrypted.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EncryptionStatus {
    /// Unused.
    Unspecified,
    /// Google manages server-side encryption keys on your behalf.
    EncryptionGoogleManaged,
    /// Customer provides the key.
    EncryptionCustomerManaged,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EncryptionStatus::value] or
    /// [EncryptionStatus::name].
    UnknownValue(encryption_status::UnknownValue),
}

#[doc(hidden)]
pub mod encryption_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EncryptionStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::EncryptionGoogleManaged => std::option::Option::Some(1),
            Self::EncryptionCustomerManaged => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENCRYPTION_STATUS_UNSPECIFIED"),
            Self::EncryptionGoogleManaged => std::option::Option::Some("ENCRYPTION_GOOGLE_MANAGED"),
            Self::EncryptionCustomerManaged => {
                std::option::Option::Some("ENCRYPTION_CUSTOMER_MANAGED")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EncryptionStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EncryptionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EncryptionStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::EncryptionGoogleManaged,
            2 => Self::EncryptionCustomerManaged,
            _ => Self::UnknownValue(encryption_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EncryptionStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENCRYPTION_STATUS_UNSPECIFIED" => Self::Unspecified,
            "ENCRYPTION_GOOGLE_MANAGED" => Self::EncryptionGoogleManaged,
            "ENCRYPTION_CUSTOMER_MANAGED" => Self::EncryptionCustomerManaged,
            _ => Self::UnknownValue(encryption_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EncryptionStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::EncryptionGoogleManaged => serializer.serialize_i32(1),
            Self::EncryptionCustomerManaged => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EncryptionStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncryptionStatus>::new(
            ".google.privacy.dlp.v2.EncryptionStatus",
        ))
    }
}

/// Bucketized nullness percentage levels. A higher level means a higher
/// percentage of the column is null.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NullPercentageLevel {
    /// Unused.
    Unspecified,
    /// Very few null entries.
    NullPercentageVeryLow,
    /// Some null entries.
    NullPercentageLow,
    /// A few null entries.
    NullPercentageMedium,
    /// A lot of null entries.
    NullPercentageHigh,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NullPercentageLevel::value] or
    /// [NullPercentageLevel::name].
    UnknownValue(null_percentage_level::UnknownValue),
}

#[doc(hidden)]
pub mod null_percentage_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NullPercentageLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NullPercentageVeryLow => std::option::Option::Some(1),
            Self::NullPercentageLow => std::option::Option::Some(2),
            Self::NullPercentageMedium => std::option::Option::Some(3),
            Self::NullPercentageHigh => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NULL_PERCENTAGE_LEVEL_UNSPECIFIED"),
            Self::NullPercentageVeryLow => std::option::Option::Some("NULL_PERCENTAGE_VERY_LOW"),
            Self::NullPercentageLow => std::option::Option::Some("NULL_PERCENTAGE_LOW"),
            Self::NullPercentageMedium => std::option::Option::Some("NULL_PERCENTAGE_MEDIUM"),
            Self::NullPercentageHigh => std::option::Option::Some("NULL_PERCENTAGE_HIGH"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NullPercentageLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NullPercentageLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NullPercentageLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NullPercentageVeryLow,
            2 => Self::NullPercentageLow,
            3 => Self::NullPercentageMedium,
            4 => Self::NullPercentageHigh,
            _ => Self::UnknownValue(null_percentage_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for NullPercentageLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NULL_PERCENTAGE_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "NULL_PERCENTAGE_VERY_LOW" => Self::NullPercentageVeryLow,
            "NULL_PERCENTAGE_LOW" => Self::NullPercentageLow,
            "NULL_PERCENTAGE_MEDIUM" => Self::NullPercentageMedium,
            "NULL_PERCENTAGE_HIGH" => Self::NullPercentageHigh,
            _ => Self::UnknownValue(null_percentage_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for NullPercentageLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NullPercentageVeryLow => serializer.serialize_i32(1),
            Self::NullPercentageLow => serializer.serialize_i32(2),
            Self::NullPercentageMedium => serializer.serialize_i32(3),
            Self::NullPercentageHigh => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NullPercentageLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NullPercentageLevel>::new(
            ".google.privacy.dlp.v2.NullPercentageLevel",
        ))
    }
}

/// Bucketized uniqueness score levels. A higher uniqueness score is a strong
/// signal that the column may contain a unique identifier like user id. A low
/// value indicates that the column contains few unique values like booleans or
/// other classifiers.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum UniquenessScoreLevel {
    /// Some columns do not have estimated uniqueness. Possible reasons include
    /// having too few values.
    Unspecified,
    /// Low uniqueness, possibly a boolean, enum or similiarly typed column.
    UniquenessScoreLow,
    /// Medium uniqueness.
    UniquenessScoreMedium,
    /// High uniqueness, possibly a column of free text or unique identifiers.
    UniquenessScoreHigh,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [UniquenessScoreLevel::value] or
    /// [UniquenessScoreLevel::name].
    UnknownValue(uniqueness_score_level::UnknownValue),
}

#[doc(hidden)]
pub mod uniqueness_score_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl UniquenessScoreLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::UniquenessScoreLow => std::option::Option::Some(1),
            Self::UniquenessScoreMedium => std::option::Option::Some(2),
            Self::UniquenessScoreHigh => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("UNIQUENESS_SCORE_LEVEL_UNSPECIFIED"),
            Self::UniquenessScoreLow => std::option::Option::Some("UNIQUENESS_SCORE_LOW"),
            Self::UniquenessScoreMedium => std::option::Option::Some("UNIQUENESS_SCORE_MEDIUM"),
            Self::UniquenessScoreHigh => std::option::Option::Some("UNIQUENESS_SCORE_HIGH"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for UniquenessScoreLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for UniquenessScoreLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for UniquenessScoreLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::UniquenessScoreLow,
            2 => Self::UniquenessScoreMedium,
            3 => Self::UniquenessScoreHigh,
            _ => Self::UnknownValue(uniqueness_score_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for UniquenessScoreLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UNIQUENESS_SCORE_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "UNIQUENESS_SCORE_LOW" => Self::UniquenessScoreLow,
            "UNIQUENESS_SCORE_MEDIUM" => Self::UniquenessScoreMedium,
            "UNIQUENESS_SCORE_HIGH" => Self::UniquenessScoreHigh,
            _ => Self::UnknownValue(uniqueness_score_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for UniquenessScoreLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::UniquenessScoreLow => serializer.serialize_i32(1),
            Self::UniquenessScoreMedium => serializer.serialize_i32(2),
            Self::UniquenessScoreHigh => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for UniquenessScoreLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<UniquenessScoreLevel>::new(
            ".google.privacy.dlp.v2.UniquenessScoreLevel",
        ))
    }
}

/// State of the connection.
/// New values may be added over time.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ConnectionState {
    /// Unused
    Unspecified,
    /// The DLP API automatically created this connection during an initial scan,
    /// and it is awaiting full configuration by a user.
    MissingCredentials,
    /// A configured connection that has not encountered any errors.
    Available,
    /// A configured connection that encountered errors during its last use. It
    /// will not be used again until it is set to AVAILABLE.
    ///
    /// If the resolution requires external action, then the client must send a
    /// request to set the status to AVAILABLE when the connection is ready for
    /// use. If the resolution doesn't require external action, then any changes to
    /// the connection properties will automatically mark it as AVAILABLE.
    Error,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ConnectionState::value] or
    /// [ConnectionState::name].
    UnknownValue(connection_state::UnknownValue),
}

#[doc(hidden)]
pub mod connection_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ConnectionState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::MissingCredentials => std::option::Option::Some(1),
            Self::Available => std::option::Option::Some(2),
            Self::Error => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONNECTION_STATE_UNSPECIFIED"),
            Self::MissingCredentials => std::option::Option::Some("MISSING_CREDENTIALS"),
            Self::Available => std::option::Option::Some("AVAILABLE"),
            Self::Error => std::option::Option::Some("ERROR"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ConnectionState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ConnectionState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ConnectionState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::MissingCredentials,
            2 => Self::Available,
            3 => Self::Error,
            _ => Self::UnknownValue(connection_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ConnectionState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONNECTION_STATE_UNSPECIFIED" => Self::Unspecified,
            "MISSING_CREDENTIALS" => Self::MissingCredentials,
            "AVAILABLE" => Self::Available,
            "ERROR" => Self::Error,
            _ => Self::UnknownValue(connection_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ConnectionState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::MissingCredentials => serializer.serialize_i32(1),
            Self::Available => serializer.serialize_i32(2),
            Self::Error => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ConnectionState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionState>::new(
            ".google.privacy.dlp.v2.ConnectionState",
        ))
    }
}

/// Coarse-grained confidence level of how well a particular finding
/// satisfies the criteria to match a particular infoType.
///
/// Likelihood is calculated based on the number of signals a
/// finding has that implies that the finding matches the infoType. For
/// example, a string that has an '@' and a '.com' is more likely to be a
/// match for an email address than a string that only has an '@'.
///
/// In general, the highest likelihood level has the strongest signals that
/// indicate a match. That is, a finding with a high likelihood has a low chance
/// of being a false positive.
///
/// For more information about each likelihood level
/// and how likelihood works, see [Match
/// likelihood](https://cloud.google.com/sensitive-data-protection/docs/likelihood).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Likelihood {
    /// Default value; same as POSSIBLE.
    Unspecified,
    /// Highest chance of a false positive.
    VeryUnlikely,
    /// High chance of a false positive.
    Unlikely,
    /// Some matching signals. The default value.
    Possible,
    /// Low chance of a false positive.
    Likely,
    /// Confidence level is high. Lowest chance of a false positive.
    VeryLikely,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Likelihood::value] or
    /// [Likelihood::name].
    UnknownValue(likelihood::UnknownValue),
}

#[doc(hidden)]
pub mod likelihood {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Likelihood {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::VeryUnlikely => std::option::Option::Some(1),
            Self::Unlikely => std::option::Option::Some(2),
            Self::Possible => std::option::Option::Some(3),
            Self::Likely => std::option::Option::Some(4),
            Self::VeryLikely => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LIKELIHOOD_UNSPECIFIED"),
            Self::VeryUnlikely => std::option::Option::Some("VERY_UNLIKELY"),
            Self::Unlikely => std::option::Option::Some("UNLIKELY"),
            Self::Possible => std::option::Option::Some("POSSIBLE"),
            Self::Likely => std::option::Option::Some("LIKELY"),
            Self::VeryLikely => std::option::Option::Some("VERY_LIKELY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Likelihood {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Likelihood {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Likelihood {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::VeryUnlikely,
            2 => Self::Unlikely,
            3 => Self::Possible,
            4 => Self::Likely,
            5 => Self::VeryLikely,
            _ => Self::UnknownValue(likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Likelihood {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LIKELIHOOD_UNSPECIFIED" => Self::Unspecified,
            "VERY_UNLIKELY" => Self::VeryUnlikely,
            "UNLIKELY" => Self::Unlikely,
            "POSSIBLE" => Self::Possible,
            "LIKELY" => Self::Likely,
            "VERY_LIKELY" => Self::VeryLikely,
            _ => Self::UnknownValue(likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Likelihood {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::VeryUnlikely => serializer.serialize_i32(1),
            Self::Unlikely => serializer.serialize_i32(2),
            Self::Possible => serializer.serialize_i32(3),
            Self::Likely => serializer.serialize_i32(4),
            Self::VeryLikely => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Likelihood {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Likelihood>::new(
            ".google.privacy.dlp.v2.Likelihood",
        ))
    }
}

/// Definitions of file type groups to scan. New types will be added to this
/// list.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FileType {
    /// Includes all files.
    Unspecified,
    /// Includes all file extensions not covered by another entry. Binary
    /// scanning attempts to convert the content of the file to utf_8 to scan
    /// the file.
    /// If you wish to avoid this fall back, specify one or more of the other
    /// file types in your storage scan.
    BinaryFile,
    /// Included file extensions:
    /// asc,asp, aspx, brf, c, cc,cfm, cgi, cpp, csv, cxx, c++, cs, css, dart,
    /// dat, dot, eml,, epbub, ged, go, h, hh, hpp, hxx, h++, hs, html, htm,
    /// mkd, markdown, m, ml, mli, perl, pl, plist, pm, php, phtml, pht,
    /// properties, py, pyw, rb, rbw, rs, rss,  rc, scala, sh, sql, swift, tex,
    /// shtml, shtm, xhtml, lhs, ics, ini, java, js, json, jsonl, kix, kml,
    /// ocaml, md, txt, text, tsv, vb, vcard, vcs, wml, xcodeproj, xml, xsl, xsd,
    /// yml, yaml.
    TextFile,
    /// Included file extensions:
    /// bmp, gif, jpg, jpeg, jpe, png. Setting
    /// [bytes_limit_per_file][google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file]
    /// or
    /// [bytes_limit_per_file_percent][google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file]
    /// has no effect on image files. Image inspection is restricted to the
    /// `global`, `us`, `asia`, and `europe` regions.
    ///
    /// [google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file]: crate::model::CloudStorageOptions::bytes_limit_per_file
    Image,
    /// Microsoft Word files larger than 30 MB will be scanned as binary files.
    /// Included file extensions:
    /// docx, dotx, docm, dotm. Setting `bytes_limit_per_file` or
    /// `bytes_limit_per_file_percent` has no effect on Word files.
    Word,
    /// PDF files larger than 30 MB will be scanned as binary files.
    /// Included file extensions:
    /// pdf. Setting `bytes_limit_per_file` or `bytes_limit_per_file_percent`
    /// has no effect on PDF files.
    Pdf,
    /// Included file extensions:
    /// avro
    Avro,
    /// Included file extensions:
    /// csv
    Csv,
    /// Included file extensions:
    /// tsv
    Tsv,
    /// Microsoft PowerPoint files larger than 30 MB will be scanned as binary
    /// files. Included file extensions:
    /// pptx, pptm, potx, potm, pot. Setting `bytes_limit_per_file` or
    /// `bytes_limit_per_file_percent` has no effect on PowerPoint files.
    Powerpoint,
    /// Microsoft Excel files larger than 30 MB will be scanned as binary files.
    /// Included file extensions:
    /// xlsx, xlsm, xltx, xltm. Setting `bytes_limit_per_file` or
    /// `bytes_limit_per_file_percent` has no effect on Excel files.
    Excel,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FileType::value] or
    /// [FileType::name].
    UnknownValue(file_type::UnknownValue),
}

#[doc(hidden)]
pub mod file_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FileType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::BinaryFile => std::option::Option::Some(1),
            Self::TextFile => std::option::Option::Some(2),
            Self::Image => std::option::Option::Some(3),
            Self::Word => std::option::Option::Some(5),
            Self::Pdf => std::option::Option::Some(6),
            Self::Avro => std::option::Option::Some(7),
            Self::Csv => std::option::Option::Some(8),
            Self::Tsv => std::option::Option::Some(9),
            Self::Powerpoint => std::option::Option::Some(11),
            Self::Excel => std::option::Option::Some(12),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FILE_TYPE_UNSPECIFIED"),
            Self::BinaryFile => std::option::Option::Some("BINARY_FILE"),
            Self::TextFile => std::option::Option::Some("TEXT_FILE"),
            Self::Image => std::option::Option::Some("IMAGE"),
            Self::Word => std::option::Option::Some("WORD"),
            Self::Pdf => std::option::Option::Some("PDF"),
            Self::Avro => std::option::Option::Some("AVRO"),
            Self::Csv => std::option::Option::Some("CSV"),
            Self::Tsv => std::option::Option::Some("TSV"),
            Self::Powerpoint => std::option::Option::Some("POWERPOINT"),
            Self::Excel => std::option::Option::Some("EXCEL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FileType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FileType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FileType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::BinaryFile,
            2 => Self::TextFile,
            3 => Self::Image,
            5 => Self::Word,
            6 => Self::Pdf,
            7 => Self::Avro,
            8 => Self::Csv,
            9 => Self::Tsv,
            11 => Self::Powerpoint,
            12 => Self::Excel,
            _ => Self::UnknownValue(file_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FileType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FILE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BINARY_FILE" => Self::BinaryFile,
            "TEXT_FILE" => Self::TextFile,
            "IMAGE" => Self::Image,
            "WORD" => Self::Word,
            "PDF" => Self::Pdf,
            "AVRO" => Self::Avro,
            "CSV" => Self::Csv,
            "TSV" => Self::Tsv,
            "POWERPOINT" => Self::Powerpoint,
            "EXCEL" => Self::Excel,
            _ => Self::UnknownValue(file_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FileType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::BinaryFile => serializer.serialize_i32(1),
            Self::TextFile => serializer.serialize_i32(2),
            Self::Image => serializer.serialize_i32(3),
            Self::Word => serializer.serialize_i32(5),
            Self::Pdf => serializer.serialize_i32(6),
            Self::Avro => serializer.serialize_i32(7),
            Self::Csv => serializer.serialize_i32(8),
            Self::Tsv => serializer.serialize_i32(9),
            Self::Powerpoint => serializer.serialize_i32(11),
            Self::Excel => serializer.serialize_i32(12),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FileType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FileType>::new(
            ".google.privacy.dlp.v2.FileType",
        ))
    }
}
