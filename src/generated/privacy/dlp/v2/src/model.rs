// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// List of excluded infoTypes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExcludeInfoTypes {
    /// InfoType list in ExclusionRule rule drops a finding when it overlaps or
    /// contained within with a finding of an infoType from this list. For
    /// example, for `InspectionRuleSet.info_types` containing "PHONE_NUMBER"` and
    /// `exclusion_rule` containing `exclude_info_types.info_types` with
    /// "EMAIL_ADDRESS" the phone number findings are dropped if they overlap
    /// with EMAIL_ADDRESS finding.
    /// That leads to "555-222-2222@example.org" to generate only a single
    /// finding, namely email address.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub info_types: std::vec::Vec<crate::model::InfoType>,
}

impl ExcludeInfoTypes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_types][crate::model::ExcludeInfoTypes::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoType>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExcludeInfoTypes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ExcludeInfoTypes"
    }
}

/// The rule to exclude findings based on a hotword. For record inspection of
/// tables, column names are considered hotwords. An example of this is to
/// exclude a finding if it belongs to a BigQuery column that matches a specific
/// pattern.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExcludeByHotword {
    /// Regular expression pattern defining what qualifies as a hotword.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hotword_regex: std::option::Option<crate::model::custom_info_type::Regex>,

    /// Range of characters within which the entire hotword must reside.
    /// The total length of the window cannot exceed 1000 characters.
    /// The windowBefore property in proximity should be set to 1 if the hotword
    /// needs to be included in a column header.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub proximity: std::option::Option<crate::model::custom_info_type::detection_rule::Proximity>,
}

impl ExcludeByHotword {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hotword_regex][crate::model::ExcludeByHotword::hotword_regex].
    pub fn set_hotword_regex<
        T: std::convert::Into<std::option::Option<crate::model::custom_info_type::Regex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hotword_regex = v.into();
        self
    }

    /// Sets the value of [proximity][crate::model::ExcludeByHotword::proximity].
    pub fn set_proximity<
        T: std::convert::Into<
            std::option::Option<crate::model::custom_info_type::detection_rule::Proximity>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.proximity = v.into();
        self
    }
}

impl wkt::message::Message for ExcludeByHotword {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ExcludeByHotword"
    }
}

/// The rule that specifies conditions when findings of infoTypes specified in
/// `InspectionRuleSet` are removed from results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExclusionRule {
    /// How the rule is applied, see MatchingType documentation for details.
    pub matching_type: crate::model::MatchingType,

    /// Exclusion rule types.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::exclusion_rule::Type>,
}

impl ExclusionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [matching_type][crate::model::ExclusionRule::matching_type].
    pub fn set_matching_type<T: std::convert::Into<crate::model::MatchingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.matching_type = v.into();
        self
    }

    /// Sets the value of `r#type`.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::exclusion_rule::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `Dictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Dictionary>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::Dictionary(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `Regex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Regex>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::Regex(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `ExcludeInfoTypes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_exclude_info_types(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExcludeInfoTypes>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::ExcludeInfoTypes(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::ExclusionRule::r#type]
    /// if it holds a `ExcludeByHotword`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_exclude_by_hotword(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExcludeByHotword>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::exclusion_rule::Type::ExcludeByHotword(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `Dictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Dictionary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::exclusion_rule::Type::Dictionary(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `Regex`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Regex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::exclusion_rule::Type::Regex(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `ExcludeInfoTypes`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_exclude_info_types<
        T: std::convert::Into<std::boxed::Box<crate::model::ExcludeInfoTypes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::exclusion_rule::Type::ExcludeInfoTypes(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::ExclusionRule::r#type]
    /// to hold a `ExcludeByHotword`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_exclude_by_hotword<
        T: std::convert::Into<std::boxed::Box<crate::model::ExcludeByHotword>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::exclusion_rule::Type::ExcludeByHotword(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExclusionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ExclusionRule"
    }
}

/// Defines additional types related to ExclusionRule
pub mod exclusion_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Exclusion rule types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// Dictionary which defines the rule.
        Dictionary(std::boxed::Box<crate::model::custom_info_type::Dictionary>),
        /// Regular expression which defines the rule.
        Regex(std::boxed::Box<crate::model::custom_info_type::Regex>),
        /// Set of infoTypes for which findings would affect this rule.
        ExcludeInfoTypes(std::boxed::Box<crate::model::ExcludeInfoTypes>),
        /// Drop if the hotword rule is contained in the proximate context. For
        /// tabular data, the context includes the column name.
        ExcludeByHotword(std::boxed::Box<crate::model::ExcludeByHotword>),
    }
}

/// A single inspection rule to be applied to infoTypes, specified in
/// `InspectionRuleSet`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectionRule {
    /// Inspection rule types.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::inspection_rule::Type>,
}

impl InspectionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `r#type`.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::inspection_rule::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::InspectionRule::r#type]
    /// if it holds a `HotwordRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_hotword_rule(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
    > {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::inspection_rule::Type::HotwordRule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::InspectionRule::r#type]
    /// if it holds a `ExclusionRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_exclusion_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExclusionRule>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::inspection_rule::Type::ExclusionRule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::InspectionRule::r#type]
    /// to hold a `HotwordRule`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_hotword_rule<
        T: std::convert::Into<
            std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::inspection_rule::Type::HotwordRule(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::InspectionRule::r#type]
    /// to hold a `ExclusionRule`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_exclusion_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::ExclusionRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::inspection_rule::Type::ExclusionRule(v.into()));
        self
    }
}

impl wkt::message::Message for InspectionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectionRule"
    }
}

/// Defines additional types related to InspectionRule
pub mod inspection_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Inspection rule types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// Hotword-based detection rule.
        HotwordRule(std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>),
        /// Exclusion rule.
        ExclusionRule(std::boxed::Box<crate::model::ExclusionRule>),
    }
}

/// Rule set for modifying a set of infoTypes to alter behavior under certain
/// circumstances, depending on the specific details of the rules within the set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectionRuleSet {
    /// List of infoTypes this rule set is applied to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub info_types: std::vec::Vec<crate::model::InfoType>,

    /// Set of rules to be applied to infoTypes. The rules are applied in order.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rules: std::vec::Vec<crate::model::InspectionRule>,
}

impl InspectionRuleSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_types][crate::model::InspectionRuleSet::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoType>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rules][crate::model::InspectionRuleSet::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InspectionRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InspectionRuleSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectionRuleSet"
    }
}

/// Configuration description of the scanning process.
/// When used with redactContent only info_types and min_likelihood are currently
/// used.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectConfig {
    /// Restricts what info_types to look for. The values must correspond to
    /// InfoType values returned by ListInfoTypes or listed at
    /// <https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference>.
    ///
    /// When no InfoTypes or CustomInfoTypes are specified in a request, the
    /// system may automatically choose a default list of detectors to run, which
    /// may change over time.
    ///
    /// If you need precise control and predictability as to what detectors are
    /// run you should specify specific InfoTypes listed in the reference,
    /// otherwise a default list will be used, which may change over time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub info_types: std::vec::Vec<crate::model::InfoType>,

    /// Only returns findings equal to or above this threshold. The default is
    /// POSSIBLE.
    ///
    /// In general, the highest likelihood setting yields the fewest findings in
    /// results and the lowest chance of a false positive. For more information,
    /// see [Match
    /// likelihood](https://cloud.google.com/sensitive-data-protection/docs/likelihood).
    pub min_likelihood: crate::model::Likelihood,

    /// Minimum likelihood per infotype. For each infotype, a user can specify a
    /// minimum likelihood. The system only returns a finding if its likelihood is
    /// above this threshold. If this field is not set, the system uses the
    /// InspectConfig min_likelihood.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub min_likelihood_per_info_type:
        std::vec::Vec<crate::model::inspect_config::InfoTypeLikelihood>,

    /// Configuration to control the number of findings returned.
    /// This is not used for data profiling.
    ///
    /// When redacting sensitive data from images, finding limits don't apply. They
    /// can cause unexpected or inconsistent results, where only some data is
    /// redacted. Don't include finding limits in
    /// [RedactImage][google.privacy.dlp.v2.DlpService.RedactImage]
    /// requests. Otherwise, Cloud DLP returns an error.
    ///
    /// When set within an
    /// [InspectJobConfig][google.privacy.dlp.v2.InspectJobConfig], the specified
    /// maximum values aren't hard limits. If an inspection job reaches these
    /// limits, the job ends gradually, not abruptly. Therefore, the actual number
    /// of findings that Cloud DLP returns can be multiple times higher than these
    /// maximum values.
    ///
    /// [google.privacy.dlp.v2.DlpService.RedactImage]: crate::client::DlpService::redact_image
    /// [google.privacy.dlp.v2.InspectJobConfig]: crate::model::InspectJobConfig
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub limits: std::option::Option<crate::model::inspect_config::FindingLimits>,

    /// When true, a contextual quote from the data that triggered a finding is
    /// included in the response; see
    /// [Finding.quote][google.privacy.dlp.v2.Finding.quote]. This is not used for
    /// data profiling.
    ///
    /// [google.privacy.dlp.v2.Finding.quote]: crate::model::Finding::quote
    pub include_quote: bool,

    /// When true, excludes type information of the findings.
    /// This is not used for data profiling.
    pub exclude_info_types: bool,

    /// CustomInfoTypes provided by the user. See
    /// <https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes>
    /// to learn more.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub custom_info_types: std::vec::Vec<crate::model::CustomInfoType>,

    /// Deprecated and unused.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub content_options: std::vec::Vec<crate::model::ContentOption>,

    /// Set of rules to apply to the findings for this InspectConfig.
    /// Exclusion rules, contained in the set are executed in the end, other
    /// rules are executed in the order they are specified for each info type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rule_set: std::vec::Vec<crate::model::InspectionRuleSet>,
}

impl InspectConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_likelihood][crate::model::InspectConfig::min_likelihood].
    pub fn set_min_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_likelihood = v.into();
        self
    }

    /// Sets the value of [limits][crate::model::InspectConfig::limits].
    pub fn set_limits<
        T: std::convert::Into<std::option::Option<crate::model::inspect_config::FindingLimits>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.limits = v.into();
        self
    }

    /// Sets the value of [include_quote][crate::model::InspectConfig::include_quote].
    pub fn set_include_quote<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_quote = v.into();
        self
    }

    /// Sets the value of [exclude_info_types][crate::model::InspectConfig::exclude_info_types].
    pub fn set_exclude_info_types<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.exclude_info_types = v.into();
        self
    }

    /// Sets the value of [info_types][crate::model::InspectConfig::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoType>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_likelihood_per_info_type][crate::model::InspectConfig::min_likelihood_per_info_type].
    pub fn set_min_likelihood_per_info_type<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::inspect_config::InfoTypeLikelihood>,
    {
        use std::iter::Iterator;
        self.min_likelihood_per_info_type = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_info_types][crate::model::InspectConfig::custom_info_types].
    pub fn set_custom_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomInfoType>,
    {
        use std::iter::Iterator;
        self.custom_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [content_options][crate::model::InspectConfig::content_options].
    pub fn set_content_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ContentOption>,
    {
        use std::iter::Iterator;
        self.content_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rule_set][crate::model::InspectConfig::rule_set].
    pub fn set_rule_set<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InspectionRuleSet>,
    {
        use std::iter::Iterator;
        self.rule_set = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InspectConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectConfig"
    }
}

/// Defines additional types related to InspectConfig
pub mod inspect_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for setting a minimum likelihood per infotype. Used to
    /// customize the minimum likelihood level for specific infotypes in the
    /// request. For example, use this if you want to lower the precision for
    /// PERSON_NAME without lowering the precision for the other infotypes in the
    /// request.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InfoTypeLikelihood {
        /// Type of information the likelihood threshold applies to. Only one
        /// likelihood per info_type should be provided. If InfoTypeLikelihood does
        /// not have an info_type, the configuration fails.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub info_type: std::option::Option<crate::model::InfoType>,

        /// Only returns findings equal to or above this threshold. This field is
        /// required or else the configuration fails.
        pub min_likelihood: crate::model::Likelihood,
    }

    impl InfoTypeLikelihood {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [info_type][crate::model::inspect_config::InfoTypeLikelihood::info_type].
        pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
            mut self,
            v: T,
        ) -> Self {
            self.info_type = v.into();
            self
        }

        /// Sets the value of [min_likelihood][crate::model::inspect_config::InfoTypeLikelihood::min_likelihood].
        pub fn set_min_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_likelihood = v.into();
            self
        }
    }

    impl wkt::message::Message for InfoTypeLikelihood {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectConfig.InfoTypeLikelihood"
        }
    }

    /// Configuration to control the number of findings returned for inspection.
    /// This is not used for de-identification or data profiling.
    ///
    /// When redacting sensitive data from images, finding limits don't apply. They
    /// can cause unexpected or inconsistent results, where only some data is
    /// redacted. Don't include finding limits in
    /// [RedactImage][google.privacy.dlp.v2.DlpService.RedactImage]
    /// requests. Otherwise, Cloud DLP returns an error.
    ///
    /// [google.privacy.dlp.v2.DlpService.RedactImage]: crate::client::DlpService::redact_image
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FindingLimits {
        /// Max number of findings that are returned for each item scanned.
        ///
        /// When set within an
        /// [InspectContentRequest][google.privacy.dlp.v2.InspectContentRequest],
        /// this field is ignored.
        ///
        /// This value isn't a hard limit. If the number of findings for an item
        /// reaches this limit, the inspection of that item ends gradually, not
        /// abruptly. Therefore, the actual number of findings that Cloud DLP returns
        /// for the item can be multiple times higher than this value.
        ///
        /// [google.privacy.dlp.v2.InspectContentRequest]: crate::model::InspectContentRequest
        pub max_findings_per_item: i32,

        /// Max number of findings that are returned per request or job.
        ///
        /// If you set this field in an
        /// [InspectContentRequest][google.privacy.dlp.v2.InspectContentRequest], the
        /// resulting maximum value is the value that you set or 3,000, whichever is
        /// lower.
        ///
        /// This value isn't a hard limit. If an inspection reaches this limit, the
        /// inspection ends gradually, not abruptly. Therefore, the actual number of
        /// findings that Cloud DLP returns can be multiple times higher than this
        /// value.
        ///
        /// [google.privacy.dlp.v2.InspectContentRequest]: crate::model::InspectContentRequest
        pub max_findings_per_request: i32,

        /// Configuration of findings limit given for specified infoTypes.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub max_findings_per_info_type:
            std::vec::Vec<crate::model::inspect_config::finding_limits::InfoTypeLimit>,
    }

    impl FindingLimits {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_findings_per_item][crate::model::inspect_config::FindingLimits::max_findings_per_item].
        pub fn set_max_findings_per_item<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_findings_per_item = v.into();
            self
        }

        /// Sets the value of [max_findings_per_request][crate::model::inspect_config::FindingLimits::max_findings_per_request].
        pub fn set_max_findings_per_request<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_findings_per_request = v.into();
            self
        }

        /// Sets the value of [max_findings_per_info_type][crate::model::inspect_config::FindingLimits::max_findings_per_info_type].
        pub fn set_max_findings_per_info_type<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::inspect_config::finding_limits::InfoTypeLimit>,
        {
            use std::iter::Iterator;
            self.max_findings_per_info_type = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for FindingLimits {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectConfig.FindingLimits"
        }
    }

    /// Defines additional types related to FindingLimits
    pub mod finding_limits {
        #[allow(unused_imports)]
        use super::*;

        /// Max findings configuration per infoType, per content item or long
        /// running DlpJob.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct InfoTypeLimit {
            /// Type of information the findings limit applies to. Only one limit per
            /// info_type should be provided. If InfoTypeLimit does not have an
            /// info_type, the DLP API applies the limit against all info_types that
            /// are found but not specified in another InfoTypeLimit.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub info_type: std::option::Option<crate::model::InfoType>,

            /// Max findings limit for the given infoType.
            pub max_findings: i32,
        }

        impl InfoTypeLimit {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [info_type][crate::model::inspect_config::finding_limits::InfoTypeLimit::info_type].
            pub fn set_info_type<
                T: std::convert::Into<std::option::Option<crate::model::InfoType>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.info_type = v.into();
                self
            }

            /// Sets the value of [max_findings][crate::model::inspect_config::finding_limits::InfoTypeLimit::max_findings].
            pub fn set_max_findings<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_findings = v.into();
                self
            }
        }

        impl wkt::message::Message for InfoTypeLimit {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.InspectConfig.FindingLimits.InfoTypeLimit"
            }
        }
    }
}

/// Container for bytes to inspect or redact.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ByteContentItem {
    /// The type of data stored in the bytes string. Default will be TEXT_UTF8.
    #[serde(rename = "type")]
    pub r#type: crate::model::byte_content_item::BytesType,

    /// Content data to inspect or redact.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub data: ::bytes::Bytes,
}

impl ByteContentItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::ByteContentItem::type].
    pub fn set_type<T: std::convert::Into<crate::model::byte_content_item::BytesType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [data][crate::model::ByteContentItem::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }
}

impl wkt::message::Message for ByteContentItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ByteContentItem"
    }
}

/// Defines additional types related to ByteContentItem
pub mod byte_content_item {
    #[allow(unused_imports)]
    use super::*;

    /// The type of data being sent for inspection. To learn more, see
    /// [Supported file
    /// types](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct BytesType(i32);

    impl BytesType {
        /// Unused
        pub const BYTES_TYPE_UNSPECIFIED: BytesType = BytesType::new(0);

        /// Any image type.
        pub const IMAGE: BytesType = BytesType::new(6);

        /// jpeg
        pub const IMAGE_JPEG: BytesType = BytesType::new(1);

        /// bmp
        pub const IMAGE_BMP: BytesType = BytesType::new(2);

        /// png
        pub const IMAGE_PNG: BytesType = BytesType::new(3);

        /// svg
        pub const IMAGE_SVG: BytesType = BytesType::new(4);

        /// plain text
        pub const TEXT_UTF8: BytesType = BytesType::new(5);

        /// docx, docm, dotx, dotm
        pub const WORD_DOCUMENT: BytesType = BytesType::new(7);

        /// pdf
        pub const PDF: BytesType = BytesType::new(8);

        /// pptx, pptm, potx, potm, pot
        pub const POWERPOINT_DOCUMENT: BytesType = BytesType::new(9);

        /// xlsx, xlsm, xltx, xltm
        pub const EXCEL_DOCUMENT: BytesType = BytesType::new(10);

        /// avro
        pub const AVRO: BytesType = BytesType::new(11);

        /// csv
        pub const CSV: BytesType = BytesType::new(12);

        /// tsv
        pub const TSV: BytesType = BytesType::new(13);

        /// Audio file types. Only used for profiling.
        pub const AUDIO: BytesType = BytesType::new(15);

        /// Video file types. Only used for profiling.
        pub const VIDEO: BytesType = BytesType::new(16);

        /// Executable file types. Only used for profiling.
        pub const EXECUTABLE: BytesType = BytesType::new(17);

        /// AI model file types. Only used for profiling.
        pub const AI_MODEL: BytesType = BytesType::new(18);

        /// Creates a new BytesType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("BYTES_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("IMAGE_JPEG"),
                2 => std::borrow::Cow::Borrowed("IMAGE_BMP"),
                3 => std::borrow::Cow::Borrowed("IMAGE_PNG"),
                4 => std::borrow::Cow::Borrowed("IMAGE_SVG"),
                5 => std::borrow::Cow::Borrowed("TEXT_UTF8"),
                6 => std::borrow::Cow::Borrowed("IMAGE"),
                7 => std::borrow::Cow::Borrowed("WORD_DOCUMENT"),
                8 => std::borrow::Cow::Borrowed("PDF"),
                9 => std::borrow::Cow::Borrowed("POWERPOINT_DOCUMENT"),
                10 => std::borrow::Cow::Borrowed("EXCEL_DOCUMENT"),
                11 => std::borrow::Cow::Borrowed("AVRO"),
                12 => std::borrow::Cow::Borrowed("CSV"),
                13 => std::borrow::Cow::Borrowed("TSV"),
                15 => std::borrow::Cow::Borrowed("AUDIO"),
                16 => std::borrow::Cow::Borrowed("VIDEO"),
                17 => std::borrow::Cow::Borrowed("EXECUTABLE"),
                18 => std::borrow::Cow::Borrowed("AI_MODEL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "BYTES_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::BYTES_TYPE_UNSPECIFIED),
                "IMAGE" => std::option::Option::Some(Self::IMAGE),
                "IMAGE_JPEG" => std::option::Option::Some(Self::IMAGE_JPEG),
                "IMAGE_BMP" => std::option::Option::Some(Self::IMAGE_BMP),
                "IMAGE_PNG" => std::option::Option::Some(Self::IMAGE_PNG),
                "IMAGE_SVG" => std::option::Option::Some(Self::IMAGE_SVG),
                "TEXT_UTF8" => std::option::Option::Some(Self::TEXT_UTF8),
                "WORD_DOCUMENT" => std::option::Option::Some(Self::WORD_DOCUMENT),
                "PDF" => std::option::Option::Some(Self::PDF),
                "POWERPOINT_DOCUMENT" => std::option::Option::Some(Self::POWERPOINT_DOCUMENT),
                "EXCEL_DOCUMENT" => std::option::Option::Some(Self::EXCEL_DOCUMENT),
                "AVRO" => std::option::Option::Some(Self::AVRO),
                "CSV" => std::option::Option::Some(Self::CSV),
                "TSV" => std::option::Option::Some(Self::TSV),
                "AUDIO" => std::option::Option::Some(Self::AUDIO),
                "VIDEO" => std::option::Option::Some(Self::VIDEO),
                "EXECUTABLE" => std::option::Option::Some(Self::EXECUTABLE),
                "AI_MODEL" => std::option::Option::Some(Self::AI_MODEL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for BytesType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for BytesType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Type of content to inspect.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContentItem {
    /// Data of the item either in the byte array or UTF-8 string form, or table.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_item: std::option::Option<crate::model::content_item::DataItem>,
}

impl ContentItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `data_item`.
    pub fn set_data_item<
        T: std::convert::Into<std::option::Option<crate::model::content_item::DataItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_item = v.into();
        self
    }

    /// The value of [data_item][crate::model::ContentItem::data_item]
    /// if it holds a `Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::content_item::DataItem::Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data_item][crate::model::ContentItem::data_item]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_table(&self) -> std::option::Option<&std::boxed::Box<crate::model::Table>> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::content_item::DataItem::Table(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data_item][crate::model::ContentItem::data_item]
    /// if it holds a `ByteItem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_byte_item(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ByteContentItem>> {
        #[allow(unreachable_patterns)]
        self.data_item.as_ref().and_then(|v| match v {
            crate::model::content_item::DataItem::ByteItem(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_item][crate::model::ContentItem::data_item]
    /// to hold a `Value`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::content_item::DataItem::Value(v.into()));
        self
    }

    /// Sets the value of [data_item][crate::model::ContentItem::data_item]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::Table>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::content_item::DataItem::Table(v.into()));
        self
    }

    /// Sets the value of [data_item][crate::model::ContentItem::data_item]
    /// to hold a `ByteItem`.
    ///
    /// Note that all the setters affecting `data_item` are
    /// mutually exclusive.
    pub fn set_byte_item<T: std::convert::Into<std::boxed::Box<crate::model::ByteContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item =
            std::option::Option::Some(crate::model::content_item::DataItem::ByteItem(v.into()));
        self
    }
}

impl wkt::message::Message for ContentItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ContentItem"
    }
}

/// Defines additional types related to ContentItem
pub mod content_item {
    #[allow(unused_imports)]
    use super::*;

    /// Data of the item either in the byte array or UTF-8 string form, or table.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataItem {
        /// String data to inspect or redact.
        Value(std::string::String),
        /// Structured content for inspection. See
        /// <https://cloud.google.com/sensitive-data-protection/docs/inspecting-text#inspecting_a_table>
        /// to learn more.
        Table(std::boxed::Box<crate::model::Table>),
        /// Content data to inspect or redact. Replaces `type` and `data`.
        ByteItem(std::boxed::Box<crate::model::ByteContentItem>),
    }
}

/// Structured content to inspect. Up to 50,000 `Value`s per request allowed. See
/// <https://cloud.google.com/sensitive-data-protection/docs/inspecting-structured-text#inspecting_a_table>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Table {
    /// Headers of the table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub headers: std::vec::Vec<crate::model::FieldId>,

    /// Rows of the table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rows: std::vec::Vec<crate::model::table::Row>,
}

impl Table {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [headers][crate::model::Table::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rows][crate::model::Table::rows].
    pub fn set_rows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::table::Row>,
    {
        use std::iter::Iterator;
        self.rows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Table {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Table"
    }
}

/// Defines additional types related to Table
pub mod table {
    #[allow(unused_imports)]
    use super::*;

    /// Values of the row.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Row {
        /// Individual cells.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub values: std::vec::Vec<crate::model::Value>,
    }

    impl Row {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::table::Row::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Value>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Row {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Table.Row"
        }
    }
}

/// All the findings for a single scanned item.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectResult {
    /// List of findings for an item.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub findings: std::vec::Vec<crate::model::Finding>,

    /// If true, then this item might have more findings than were returned,
    /// and the findings returned are an arbitrary subset of all findings.
    /// The findings list might be truncated because the input items were too
    /// large, or because the server reached the maximum amount of resources
    /// allowed for a single API call. For best results, divide the input into
    /// smaller batches.
    pub findings_truncated: bool,
}

impl InspectResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [findings_truncated][crate::model::InspectResult::findings_truncated].
    pub fn set_findings_truncated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.findings_truncated = v.into();
        self
    }

    /// Sets the value of [findings][crate::model::InspectResult::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Finding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InspectResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectResult"
    }
}

/// Represents a piece of potentially sensitive content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Finding {
    /// Resource name in format
    /// projects/{project}/locations/{location}/findings/{finding} Populated only
    /// when viewing persisted findings.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The content that was found. Even if the content is not textual, it
    /// may be converted to a textual representation here.
    /// Provided if `include_quote` is true and the finding is
    /// less than or equal to 4096 bytes long. If the finding exceeds 4096 bytes
    /// in length, the quote may be omitted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub quote: std::string::String,

    /// The type of content that might have been found.
    /// Provided if `excluded_types` is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Confidence of how likely it is that the `info_type` is correct.
    pub likelihood: crate::model::Likelihood,

    /// Where the content was found.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::Location>,

    /// Timestamp when finding was detected.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Contains data parsed from quotes. Only populated if include_quote was set
    /// to true and a supported infoType was requested. Currently supported
    /// infoTypes: DATE, DATE_OF_BIRTH and TIME.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quote_info: std::option::Option<crate::model::QuoteInfo>,

    /// The job that stored the finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_name: std::string::String,

    /// Job trigger name, if applicable, for this finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_name: std::string::String,

    /// The labels associated with this `Finding`.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// Label values must be between 0 and 63 characters long and must conform
    /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
    ///
    /// No more than 10 labels can be associated with a given finding.
    ///
    /// Examples:
    ///
    /// * `"environment" : "production"`
    /// * `"pipeline" : "etl"`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Time the job started that produced this finding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_create_time: std::option::Option<wkt::Timestamp>,

    /// The job that stored the finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_name: std::string::String,

    /// The unique finding id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub finding_id: std::string::String,
}

impl Finding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Finding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [quote][crate::model::Finding::quote].
    pub fn set_quote<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.quote = v.into();
        self
    }

    /// Sets the value of [info_type][crate::model::Finding::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [likelihood][crate::model::Finding::likelihood].
    pub fn set_likelihood<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.likelihood = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Finding::location].
    pub fn set_location<T: std::convert::Into<std::option::Option<crate::model::Location>>>(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Finding::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [quote_info][crate::model::Finding::quote_info].
    pub fn set_quote_info<T: std::convert::Into<std::option::Option<crate::model::QuoteInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.quote_info = v.into();
        self
    }

    /// Sets the value of [resource_name][crate::model::Finding::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [trigger_name][crate::model::Finding::trigger_name].
    pub fn set_trigger_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_name = v.into();
        self
    }

    /// Sets the value of [job_create_time][crate::model::Finding::job_create_time].
    pub fn set_job_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_create_time = v.into();
        self
    }

    /// Sets the value of [job_name][crate::model::Finding::job_name].
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_name = v.into();
        self
    }

    /// Sets the value of [finding_id][crate::model::Finding::finding_id].
    pub fn set_finding_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Finding::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Finding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Finding"
    }
}

/// Specifies the location of the finding.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Location {
    /// Zero-based byte offsets delimiting the finding.
    /// These are relative to the finding's containing element.
    /// Note that when the content is not textual, this references
    /// the UTF-8 encoded textual representation of the content.
    /// Omitted if content is an image.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub byte_range: std::option::Option<crate::model::Range>,

    /// Unicode character offsets delimiting the finding.
    /// These are relative to the finding's containing element.
    /// Provided when the content is text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub codepoint_range: std::option::Option<crate::model::Range>,

    /// List of nested objects pointing to the precise location of the finding
    /// within the file or record.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub content_locations: std::vec::Vec<crate::model::ContentLocation>,

    /// Information about the container where this finding occurred, if available.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container: std::option::Option<crate::model::Container>,
}

impl Location {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [byte_range][crate::model::Location::byte_range].
    pub fn set_byte_range<T: std::convert::Into<std::option::Option<crate::model::Range>>>(
        mut self,
        v: T,
    ) -> Self {
        self.byte_range = v.into();
        self
    }

    /// Sets the value of [codepoint_range][crate::model::Location::codepoint_range].
    pub fn set_codepoint_range<T: std::convert::Into<std::option::Option<crate::model::Range>>>(
        mut self,
        v: T,
    ) -> Self {
        self.codepoint_range = v.into();
        self
    }

    /// Sets the value of [container][crate::model::Location::container].
    pub fn set_container<T: std::convert::Into<std::option::Option<crate::model::Container>>>(
        mut self,
        v: T,
    ) -> Self {
        self.container = v.into();
        self
    }

    /// Sets the value of [content_locations][crate::model::Location::content_locations].
    pub fn set_content_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ContentLocation>,
    {
        use std::iter::Iterator;
        self.content_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Location {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Location"
    }
}

/// Precise location of the finding within a document, record, image, or metadata
/// container.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContentLocation {
    /// Name of the container where the finding is located.
    /// The top level name is the source file name or table name. Names of some
    /// common storage containers are formatted as follows:
    ///
    /// * BigQuery tables:  `{project_id}:{dataset_id}.{table_id}`
    /// * Cloud Storage files: `gs://{bucket}/{path}`
    /// * Datastore namespace: {namespace}
    ///
    /// Nested names could be absent if the embedded object has no string
    /// identifier (for example, an image contained within a document).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_name: std::string::String,

    /// Finding container modification timestamp, if applicable. For Cloud Storage,
    /// this field contains the last file modification timestamp. For a BigQuery
    /// table, this field contains the last_modified_time property. For Datastore,
    /// this field isn't populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container_timestamp: std::option::Option<wkt::Timestamp>,

    /// Finding container version, if available
    /// ("generation" for Cloud Storage).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_version: std::string::String,

    /// Type of the container within the file with location of the finding.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::content_location::Location>,
}

impl ContentLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_name][crate::model::ContentLocation::container_name].
    pub fn set_container_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_name = v.into();
        self
    }

    /// Sets the value of [container_timestamp][crate::model::ContentLocation::container_timestamp].
    pub fn set_container_timestamp<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_timestamp = v.into();
        self
    }

    /// Sets the value of [container_version][crate::model::ContentLocation::container_version].
    pub fn set_container_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_version = v.into();
        self
    }

    /// Sets the value of `location`.
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::content_location::Location>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `RecordLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_record_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecordLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::RecordLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `ImageLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_image_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImageLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::ImageLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `DocumentLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_document_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DocumentLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::DocumentLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [location][crate::model::ContentLocation::location]
    /// if it holds a `MetadataLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_metadata_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MetadataLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::content_location::Location::MetadataLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `RecordLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_record_location<
        T: std::convert::Into<std::boxed::Box<crate::model::RecordLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::RecordLocation(v.into()),
        );
        self
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `ImageLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_image_location<
        T: std::convert::Into<std::boxed::Box<crate::model::ImageLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::ImageLocation(v.into()),
        );
        self
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `DocumentLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_document_location<
        T: std::convert::Into<std::boxed::Box<crate::model::DocumentLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::DocumentLocation(v.into()),
        );
        self
    }

    /// Sets the value of [location][crate::model::ContentLocation::location]
    /// to hold a `MetadataLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_metadata_location<
        T: std::convert::Into<std::boxed::Box<crate::model::MetadataLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::content_location::Location::MetadataLocation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ContentLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ContentLocation"
    }
}

/// Defines additional types related to ContentLocation
pub mod content_location {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the container within the file with location of the finding.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Location {
        /// Location within a row or record of a database table.
        RecordLocation(std::boxed::Box<crate::model::RecordLocation>),
        /// Location within an image's pixels.
        ImageLocation(std::boxed::Box<crate::model::ImageLocation>),
        /// Location data for document files.
        DocumentLocation(std::boxed::Box<crate::model::DocumentLocation>),
        /// Location within the metadata for inspected content.
        MetadataLocation(std::boxed::Box<crate::model::MetadataLocation>),
    }
}

/// Metadata Location
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetadataLocation {
    /// Type of metadata containing the finding.
    #[serde(rename = "type")]
    pub r#type: crate::model::MetadataType,

    /// Label of the piece of metadata containing the finding, for example -
    /// latitude, author, caption.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub label: std::option::Option<crate::model::metadata_location::Label>,
}

impl MetadataLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::MetadataLocation::type].
    pub fn set_type<T: std::convert::Into<crate::model::MetadataType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of `label`.
    pub fn set_label<
        T: std::convert::Into<std::option::Option<crate::model::metadata_location::Label>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.label = v.into();
        self
    }

    /// The value of [label][crate::model::MetadataLocation::label]
    /// if it holds a `StorageLabel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_storage_label(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageMetadataLabel>> {
        #[allow(unreachable_patterns)]
        self.label.as_ref().and_then(|v| match v {
            crate::model::metadata_location::Label::StorageLabel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [label][crate::model::MetadataLocation::label]
    /// to hold a `StorageLabel`.
    ///
    /// Note that all the setters affecting `label` are
    /// mutually exclusive.
    pub fn set_storage_label<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageMetadataLabel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.label = std::option::Option::Some(
            crate::model::metadata_location::Label::StorageLabel(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MetadataLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.MetadataLocation"
    }
}

/// Defines additional types related to MetadataLocation
pub mod metadata_location {
    #[allow(unused_imports)]
    use super::*;

    /// Label of the piece of metadata containing the finding, for example -
    /// latitude, author, caption.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Label {
        /// Storage metadata.
        StorageLabel(std::boxed::Box<crate::model::StorageMetadataLabel>),
    }
}

/// Storage metadata label to indicate which metadata entry contains findings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageMetadataLabel {
    /// Label name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,
}

impl StorageMetadataLabel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::StorageMetadataLabel::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for StorageMetadataLabel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StorageMetadataLabel"
    }
}

/// Location of a finding within a document.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DocumentLocation {
    /// Offset of the line, from the beginning of the file, where the finding
    /// is located.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub file_offset: i64,
}

impl DocumentLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_offset][crate::model::DocumentLocation::file_offset].
    pub fn set_file_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.file_offset = v.into();
        self
    }
}

impl wkt::message::Message for DocumentLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DocumentLocation"
    }
}

/// Location of a finding within a row or record.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordLocation {
    /// Key of the finding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub record_key: std::option::Option<crate::model::RecordKey>,

    /// Field id of the field containing the finding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field_id: std::option::Option<crate::model::FieldId>,

    /// Location within a `ContentItem.Table`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_location: std::option::Option<crate::model::TableLocation>,
}

impl RecordLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [record_key][crate::model::RecordLocation::record_key].
    pub fn set_record_key<T: std::convert::Into<std::option::Option<crate::model::RecordKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.record_key = v.into();
        self
    }

    /// Sets the value of [field_id][crate::model::RecordLocation::field_id].
    pub fn set_field_id<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field_id = v.into();
        self
    }

    /// Sets the value of [table_location][crate::model::RecordLocation::table_location].
    pub fn set_table_location<
        T: std::convert::Into<std::option::Option<crate::model::TableLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_location = v.into();
        self
    }
}

impl wkt::message::Message for RecordLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordLocation"
    }
}

/// Location of a finding within a table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableLocation {
    /// The zero-based index of the row where the finding is located. Only
    /// populated for resources that have a natural ordering, not BigQuery. In
    /// BigQuery, to identify the row a finding came from, populate
    /// BigQueryOptions.identifying_fields with your primary key column names and
    /// when you store the findings the value of those columns will be stored
    /// inside of Finding.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub row_index: i64,
}

impl TableLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [row_index][crate::model::TableLocation::row_index].
    pub fn set_row_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_index = v.into();
        self
    }
}

impl wkt::message::Message for TableLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableLocation"
    }
}

/// Represents a container that may contain DLP findings.
/// Examples of a container include a file, table, or database record.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Container {
    /// Container type, for example BigQuery or Cloud Storage.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Project where the finding was found.
    /// Can be different from the project that owns the finding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// A string representation of the full container name.
    /// Examples:
    ///
    /// - BigQuery: 'Project:DataSetId.TableId'
    /// - Cloud Storage: 'gs://Bucket/folders/filename.txt'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_path: std::string::String,

    /// The root of the container.
    /// Examples:
    ///
    /// - For BigQuery table `project_id:dataset_id.table_id`, the root is
    ///   `dataset_id`
    /// - For Cloud Storage file `gs://bucket/folder/filename.txt`, the root
    ///   is `gs://bucket`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub root_path: std::string::String,

    /// The rest of the path after the root.
    /// Examples:
    ///
    /// - For BigQuery table `project_id:dataset_id.table_id`, the relative path is
    ///   `table_id`
    /// - For Cloud Storage file `gs://bucket/folder/filename.txt`, the relative
    ///   path is `folder/filename.txt`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub relative_path: std::string::String,

    /// Findings container modification timestamp, if applicable. For Cloud
    /// Storage, this field contains the last file modification timestamp. For a
    /// BigQuery table, this field contains the last_modified_time property. For
    /// Datastore, this field isn't populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Findings container version, if available
    /// ("generation" for Cloud Storage).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,
}

impl Container {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Container::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::Container::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [full_path][crate::model::Container::full_path].
    pub fn set_full_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_path = v.into();
        self
    }

    /// Sets the value of [root_path][crate::model::Container::root_path].
    pub fn set_root_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_path = v.into();
        self
    }

    /// Sets the value of [relative_path][crate::model::Container::relative_path].
    pub fn set_relative_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_path = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Container::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Container::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for Container {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Container"
    }
}

/// Generic half-open interval [start, end)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Range {
    /// Index of the first character of the range (inclusive).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub start: i64,

    /// Index of the last character of the range (exclusive).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub end: i64,
}

impl Range {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start][crate::model::Range::start].
    pub fn set_start<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.start = v.into();
        self
    }

    /// Sets the value of [end][crate::model::Range::end].
    pub fn set_end<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.end = v.into();
        self
    }
}

impl wkt::message::Message for Range {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Range"
    }
}

/// Location of the finding within an image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImageLocation {
    /// Bounding boxes locating the pixels within the image containing the finding.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bounding_boxes: std::vec::Vec<crate::model::BoundingBox>,
}

impl ImageLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bounding_boxes][crate::model::ImageLocation::bounding_boxes].
    pub fn set_bounding_boxes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BoundingBox>,
    {
        use std::iter::Iterator;
        self.bounding_boxes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImageLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ImageLocation"
    }
}

/// Bounding box encompassing detected text within an image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BoundingBox {
    /// Top coordinate of the bounding box. (0,0) is upper left.
    pub top: i32,

    /// Left coordinate of the bounding box. (0,0) is upper left.
    pub left: i32,

    /// Width of the bounding box in pixels.
    pub width: i32,

    /// Height of the bounding box in pixels.
    pub height: i32,
}

impl BoundingBox {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [top][crate::model::BoundingBox::top].
    pub fn set_top<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.top = v.into();
        self
    }

    /// Sets the value of [left][crate::model::BoundingBox::left].
    pub fn set_left<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.left = v.into();
        self
    }

    /// Sets the value of [width][crate::model::BoundingBox::width].
    pub fn set_width<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.width = v.into();
        self
    }

    /// Sets the value of [height][crate::model::BoundingBox::height].
    pub fn set_height<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.height = v.into();
        self
    }
}

impl wkt::message::Message for BoundingBox {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BoundingBox"
    }
}

/// Request to search for potentially sensitive info in an image and redact it
/// by covering it with a colored rectangle.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RedactImageRequest {
    /// Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    /// Configuration for the inspector.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The configuration for specifying what content to redact from images.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub image_redaction_configs:
        std::vec::Vec<crate::model::redact_image_request::ImageRedactionConfig>,

    /// Whether the response should include findings along with the redacted
    /// image.
    pub include_findings: bool,

    /// The content must be PNG, JPEG, SVG or BMP.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub byte_item: std::option::Option<crate::model::ByteContentItem>,
}

impl RedactImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RedactImageRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::RedactImageRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::RedactImageRequest::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [include_findings][crate::model::RedactImageRequest::include_findings].
    pub fn set_include_findings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_findings = v.into();
        self
    }

    /// Sets the value of [byte_item][crate::model::RedactImageRequest::byte_item].
    pub fn set_byte_item<
        T: std::convert::Into<std::option::Option<crate::model::ByteContentItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.byte_item = v.into();
        self
    }

    /// Sets the value of [image_redaction_configs][crate::model::RedactImageRequest::image_redaction_configs].
    pub fn set_image_redaction_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::redact_image_request::ImageRedactionConfig>,
    {
        use std::iter::Iterator;
        self.image_redaction_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RedactImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RedactImageRequest"
    }
}

/// Defines additional types related to RedactImageRequest
pub mod redact_image_request {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for determining how redaction of images should occur.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImageRedactionConfig {
        /// The color to use when redacting content from an image. If not specified,
        /// the default is black.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub redaction_color: std::option::Option<crate::model::Color>,

        /// Type of information to redact from images.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub target:
            std::option::Option<crate::model::redact_image_request::image_redaction_config::Target>,
    }

    impl ImageRedactionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [redaction_color][crate::model::redact_image_request::ImageRedactionConfig::redaction_color].
        pub fn set_redaction_color<
            T: std::convert::Into<std::option::Option<crate::model::Color>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.redaction_color = v.into();
            self
        }

        /// Sets the value of `target`.
        pub fn set_target<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::redact_image_request::image_redaction_config::Target,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = v.into();
            self
        }

        /// The value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// if it holds a `InfoType`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_info_type(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::InfoType>> {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::redact_image_request::image_redaction_config::Target::InfoType(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// if it holds a `RedactAllText`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_redact_all_text(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::redact_image_request::image_redaction_config::Target::RedactAllText(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// to hold a `InfoType`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_info_type<T: std::convert::Into<std::boxed::Box<crate::model::InfoType>>>(
            mut self,
            v: T,
        ) -> Self {
            self.target = std::option::Option::Some(
                crate::model::redact_image_request::image_redaction_config::Target::InfoType(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [target][crate::model::redact_image_request::ImageRedactionConfig::target]
        /// to hold a `RedactAllText`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_redact_all_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.target = std::option::Option::Some(
                crate::model::redact_image_request::image_redaction_config::Target::RedactAllText(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for ImageRedactionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RedactImageRequest.ImageRedactionConfig"
        }
    }

    /// Defines additional types related to ImageRedactionConfig
    pub mod image_redaction_config {
        #[allow(unused_imports)]
        use super::*;

        /// Type of information to redact from images.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Target {
            /// Only one per info_type should be provided per request. If not
            /// specified, and redact_all_text is false, the DLP API will redact all
            /// text that it matches against all info_types that are found, but not
            /// specified in another ImageRedactionConfig.
            InfoType(std::boxed::Box<crate::model::InfoType>),
            /// If true, all text found in the image, regardless whether it matches an
            /// info_type, is redacted. Only one should be provided.
            RedactAllText(bool),
        }
    }
}

/// Represents a color in the RGB color space.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Color {
    /// The amount of red in the color as a value in the interval [0, 1].
    pub red: f32,

    /// The amount of green in the color as a value in the interval [0, 1].
    pub green: f32,

    /// The amount of blue in the color as a value in the interval [0, 1].
    pub blue: f32,
}

impl Color {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [red][crate::model::Color::red].
    pub fn set_red<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.red = v.into();
        self
    }

    /// Sets the value of [green][crate::model::Color::green].
    pub fn set_green<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.green = v.into();
        self
    }

    /// Sets the value of [blue][crate::model::Color::blue].
    pub fn set_blue<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.blue = v.into();
        self
    }
}

impl wkt::message::Message for Color {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Color"
    }
}

/// Results of redacting an image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RedactImageResponse {
    /// The redacted image. The type will be the same as the original image.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub redacted_image: ::bytes::Bytes,

    /// If an image was being inspected and the InspectConfig's include_quote was
    /// set to true, then this field will include all text, if any, that was found
    /// in the image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub extracted_text: std::string::String,

    /// The findings. Populated when include_findings in the request is true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_result: std::option::Option<crate::model::InspectResult>,
}

impl RedactImageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [redacted_image][crate::model::RedactImageResponse::redacted_image].
    pub fn set_redacted_image<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.redacted_image = v.into();
        self
    }

    /// Sets the value of [extracted_text][crate::model::RedactImageResponse::extracted_text].
    pub fn set_extracted_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.extracted_text = v.into();
        self
    }

    /// Sets the value of [inspect_result][crate::model::RedactImageResponse::inspect_result].
    pub fn set_inspect_result<
        T: std::convert::Into<std::option::Option<crate::model::InspectResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_result = v.into();
        self
    }
}

impl wkt::message::Message for RedactImageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RedactImageResponse"
    }
}

/// Request to de-identify a ContentItem.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyContentRequest {
    /// Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Configuration for the de-identification of the content item.
    /// Items specified here will override the template referenced by the
    /// deidentify_template_name argument.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deidentify_config: std::option::Option<crate::model::DeidentifyConfig>,

    /// Configuration for the inspector.
    /// Items specified here will override the template referenced by the
    /// inspect_template_name argument.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The item to de-identify. Will be treated as text.
    ///
    /// This value must be of type
    /// [Table][google.privacy.dlp.v2.Table] if your
    /// [deidentify_config][google.privacy.dlp.v2.DeidentifyContentRequest.deidentify_config]
    /// is a
    /// [RecordTransformations][google.privacy.dlp.v2.RecordTransformations]
    /// object.
    ///
    /// [google.privacy.dlp.v2.DeidentifyContentRequest.deidentify_config]: crate::model::DeidentifyContentRequest::deidentify_config
    /// [google.privacy.dlp.v2.RecordTransformations]: crate::model::RecordTransformations
    /// [google.privacy.dlp.v2.Table]: crate::model::Table
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Template to use. Any configuration directly specified in
    /// inspect_config will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template_name: std::string::String,

    /// Template to use. Any configuration directly specified in
    /// deidentify_config will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deidentify_template_name: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl DeidentifyContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::DeidentifyContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deidentify_config][crate::model::DeidentifyContentRequest::deidentify_config].
    pub fn set_deidentify_config<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_config = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::DeidentifyContentRequest::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [item][crate::model::DeidentifyContentRequest::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::DeidentifyContentRequest::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [deidentify_template_name][crate::model::DeidentifyContentRequest::deidentify_template_name].
    pub fn set_deidentify_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template_name = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::DeidentifyContentRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyContentRequest"
    }
}

/// Results of de-identifying a ContentItem.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyContentResponse {
    /// The de-identified item.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// An overview of the changes that were made on the `item`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub overview: std::option::Option<crate::model::TransformationOverview>,
}

impl DeidentifyContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [item][crate::model::DeidentifyContentResponse::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [overview][crate::model::DeidentifyContentResponse::overview].
    pub fn set_overview<
        T: std::convert::Into<std::option::Option<crate::model::TransformationOverview>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.overview = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyContentResponse"
    }
}

/// Request to re-identify an item.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReidentifyContentRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Configuration for the re-identification of the content item.
    /// This field shares the same proto message type that is used for
    /// de-identification, however its usage here is for the reversal of the
    /// previous de-identification. Re-identification is performed by examining
    /// the transformations used to de-identify the items and executing the
    /// reverse. This requires that only reversible transformations
    /// be provided here. The reversible transformations are:
    ///
    /// - `CryptoDeterministicConfig`
    /// - `CryptoReplaceFfxFpeConfig`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reidentify_config: std::option::Option<crate::model::DeidentifyConfig>,

    /// Configuration for the inspector.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The item to re-identify. Will be treated as text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Template to use. Any configuration directly specified in
    /// `inspect_config` will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template_name: std::string::String,

    /// Template to use. References an instance of `DeidentifyTemplate`.
    /// Any configuration directly specified in `reidentify_config` or
    /// `inspect_config` will override those set in the template. The
    /// `DeidentifyTemplate` used must include only reversible transformations.
    /// Singular fields that are set in this request will replace their
    /// corresponding fields in the template. Repeated fields are appended.
    /// Singular sub-messages and groups are recursively merged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reidentify_template_name: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl ReidentifyContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ReidentifyContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [reidentify_config][crate::model::ReidentifyContentRequest::reidentify_config].
    pub fn set_reidentify_config<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reidentify_config = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::ReidentifyContentRequest::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [item][crate::model::ReidentifyContentRequest::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::ReidentifyContentRequest::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [reidentify_template_name][crate::model::ReidentifyContentRequest::reidentify_template_name].
    pub fn set_reidentify_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reidentify_template_name = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ReidentifyContentRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ReidentifyContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReidentifyContentRequest"
    }
}

/// Results of re-identifying an item.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReidentifyContentResponse {
    /// The re-identified item.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// An overview of the changes that were made to the `item`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub overview: std::option::Option<crate::model::TransformationOverview>,
}

impl ReidentifyContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [item][crate::model::ReidentifyContentResponse::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [overview][crate::model::ReidentifyContentResponse::overview].
    pub fn set_overview<
        T: std::convert::Into<std::option::Option<crate::model::TransformationOverview>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.overview = v.into();
        self
    }
}

impl wkt::message::Message for ReidentifyContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReidentifyContentResponse"
    }
}

/// Request to search for potentially sensitive info in a ContentItem.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectContentRequest {
    /// Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Configuration for the inspector. What specified here will override
    /// the template referenced by the inspect_template_name argument.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// The item to inspect.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Template to use. Any configuration directly specified in
    /// inspect_config will override those set in the template. Singular fields
    /// that are set in this request will replace their corresponding fields in the
    /// template. Repeated fields are appended. Singular sub-messages and groups
    /// are recursively merged.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template_name: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl InspectContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::InspectContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::InspectContentRequest::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [item][crate::model::InspectContentRequest::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::InspectContentRequest::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::InspectContentRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for InspectContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectContentRequest"
    }
}

/// Results of inspecting an item.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectContentResponse {
    /// The findings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::InspectResult>,
}

impl InspectContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::InspectContentResponse::result].
    pub fn set_result<T: std::convert::Into<std::option::Option<crate::model::InspectResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }
}

impl wkt::message::Message for InspectContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectContentResponse"
    }
}

/// Cloud repository for storing output.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OutputStorageConfig {
    /// Schema used for writing the findings for Inspect jobs. This field is only
    /// used for Inspect and must be unspecified for Risk jobs. Columns are derived
    /// from the `Finding` object. If appending to an existing table, any columns
    /// from the predefined schema that are missing will be added. No columns in
    /// the existing table will be deleted.
    ///
    /// If unspecified, then all available columns will be used for a new table or
    /// an (existing) table with no schema, and no changes will be made to an
    /// existing table that has a schema.
    /// Only for use with external storage.
    pub output_schema: crate::model::output_storage_config::OutputSchema,

    /// Output storage types.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::output_storage_config::Type>,
}

impl OutputStorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_schema][crate::model::OutputStorageConfig::output_schema].
    pub fn set_output_schema<
        T: std::convert::Into<crate::model::output_storage_config::OutputSchema>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_schema = v.into();
        self
    }

    /// Sets the value of `r#type`.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::output_storage_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::OutputStorageConfig::r#type]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_table(&self) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTable>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::output_storage_config::Type::Table(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::OutputStorageConfig::r#type]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTable>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::output_storage_config::Type::Table(v.into()));
        self
    }
}

impl wkt::message::Message for OutputStorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OutputStorageConfig"
    }
}

/// Defines additional types related to OutputStorageConfig
pub mod output_storage_config {
    #[allow(unused_imports)]
    use super::*;

    /// Predefined schemas for storing findings.
    /// Only for use with external storage.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct OutputSchema(i32);

    impl OutputSchema {
        /// Unused.
        pub const OUTPUT_SCHEMA_UNSPECIFIED: OutputSchema = OutputSchema::new(0);

        /// Basic schema including only `info_type`, `quote`, `certainty`, and
        /// `timestamp`.
        pub const BASIC_COLUMNS: OutputSchema = OutputSchema::new(1);

        /// Schema tailored to findings from scanning Cloud Storage.
        pub const GCS_COLUMNS: OutputSchema = OutputSchema::new(2);

        /// Schema tailored to findings from scanning Google Datastore.
        pub const DATASTORE_COLUMNS: OutputSchema = OutputSchema::new(3);

        /// Schema tailored to findings from scanning Google BigQuery.
        pub const BIG_QUERY_COLUMNS: OutputSchema = OutputSchema::new(4);

        /// Schema containing all columns.
        pub const ALL_COLUMNS: OutputSchema = OutputSchema::new(5);

        /// Creates a new OutputSchema instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("OUTPUT_SCHEMA_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BASIC_COLUMNS"),
                2 => std::borrow::Cow::Borrowed("GCS_COLUMNS"),
                3 => std::borrow::Cow::Borrowed("DATASTORE_COLUMNS"),
                4 => std::borrow::Cow::Borrowed("BIG_QUERY_COLUMNS"),
                5 => std::borrow::Cow::Borrowed("ALL_COLUMNS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "OUTPUT_SCHEMA_UNSPECIFIED" => {
                    std::option::Option::Some(Self::OUTPUT_SCHEMA_UNSPECIFIED)
                }
                "BASIC_COLUMNS" => std::option::Option::Some(Self::BASIC_COLUMNS),
                "GCS_COLUMNS" => std::option::Option::Some(Self::GCS_COLUMNS),
                "DATASTORE_COLUMNS" => std::option::Option::Some(Self::DATASTORE_COLUMNS),
                "BIG_QUERY_COLUMNS" => std::option::Option::Some(Self::BIG_QUERY_COLUMNS),
                "ALL_COLUMNS" => std::option::Option::Some(Self::ALL_COLUMNS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for OutputSchema {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for OutputSchema {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Output storage types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// Store findings in an existing table or a new table in an existing
        /// dataset. If table_id is not set a new one will be generated
        /// for you with the following format:
        /// dlp_googleapis_yyyy_mm_dd_[dlp_job_id]. Pacific time zone will be used
        /// for generating the date details.
        ///
        /// For Inspect, each column in an existing output table must have the same
        /// name, type, and mode of a field in the `Finding` object.
        ///
        /// For Risk, an existing output table should be the output of a previous
        /// Risk analysis job run on the same source table, with the same privacy
        /// metric and quasi-identifiers. Risk jobs that analyze the same table but
        /// compute a different privacy metric, or use different sets of
        /// quasi-identifiers, cannot store their results in the same table.
        Table(std::boxed::Box<crate::model::BigQueryTable>),
    }
}

/// Statistics regarding a specific InfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoTypeStats {
    /// The type of finding this stat is for.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Number of findings for this infoType.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub count: i64,
}

impl InfoTypeStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::InfoTypeStats::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [count][crate::model::InfoTypeStats::count].
    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.count = v.into();
        self
    }
}

impl wkt::message::Message for InfoTypeStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeStats"
    }
}

/// The results of an inspect DataSource job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectDataSourceDetails {
    /// The configuration used for this job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_options:
        std::option::Option<crate::model::inspect_data_source_details::RequestedOptions>,

    /// A summary of the outcome of this inspection job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::inspect_data_source_details::Result>,
}

impl InspectDataSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_options][crate::model::InspectDataSourceDetails::requested_options].
    pub fn set_requested_options<
        T: std::convert::Into<
            std::option::Option<crate::model::inspect_data_source_details::RequestedOptions>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_options = v.into();
        self
    }

    /// Sets the value of [result][crate::model::InspectDataSourceDetails::result].
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::inspect_data_source_details::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }
}

impl wkt::message::Message for InspectDataSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectDataSourceDetails"
    }
}

/// Defines additional types related to InspectDataSourceDetails
pub mod inspect_data_source_details {
    #[allow(unused_imports)]
    use super::*;

    /// Snapshot of the inspection configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RequestedOptions {
        /// If run with an InspectTemplate, a snapshot of its state at the time of
        /// this run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub snapshot_inspect_template: std::option::Option<crate::model::InspectTemplate>,

        /// Inspect config.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub job_config: std::option::Option<crate::model::InspectJobConfig>,
    }

    impl RequestedOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [snapshot_inspect_template][crate::model::inspect_data_source_details::RequestedOptions::snapshot_inspect_template].
        pub fn set_snapshot_inspect_template<
            T: std::convert::Into<std::option::Option<crate::model::InspectTemplate>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.snapshot_inspect_template = v.into();
            self
        }

        /// Sets the value of [job_config][crate::model::inspect_data_source_details::RequestedOptions::job_config].
        pub fn set_job_config<
            T: std::convert::Into<std::option::Option<crate::model::InspectJobConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.job_config = v.into();
            self
        }
    }

    impl wkt::message::Message for RequestedOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectDataSourceDetails.RequestedOptions"
        }
    }

    /// All result fields mentioned below are updated while the job is processing.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Result {
        /// Total size in bytes that were processed.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub processed_bytes: i64,

        /// Estimate of the number of bytes to process.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub total_estimated_bytes: i64,

        /// Statistics of how many instances of each info type were found during
        /// inspect job.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub info_type_stats: std::vec::Vec<crate::model::InfoTypeStats>,

        /// Number of rows scanned after sampling and time filtering (applicable for
        /// row based stores such as BigQuery).
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub num_rows_processed: i64,

        /// Statistics related to the processing of hybrid inspect.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub hybrid_stats: std::option::Option<crate::model::HybridInspectStatistics>,
    }

    impl Result {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [processed_bytes][crate::model::inspect_data_source_details::Result::processed_bytes].
        pub fn set_processed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.processed_bytes = v.into();
            self
        }

        /// Sets the value of [total_estimated_bytes][crate::model::inspect_data_source_details::Result::total_estimated_bytes].
        pub fn set_total_estimated_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_estimated_bytes = v.into();
            self
        }

        /// Sets the value of [num_rows_processed][crate::model::inspect_data_source_details::Result::num_rows_processed].
        pub fn set_num_rows_processed<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.num_rows_processed = v.into();
            self
        }

        /// Sets the value of [hybrid_stats][crate::model::inspect_data_source_details::Result::hybrid_stats].
        pub fn set_hybrid_stats<
            T: std::convert::Into<std::option::Option<crate::model::HybridInspectStatistics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.hybrid_stats = v.into();
            self
        }

        /// Sets the value of [info_type_stats][crate::model::inspect_data_source_details::Result::info_type_stats].
        pub fn set_info_type_stats<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::InfoTypeStats>,
        {
            use std::iter::Iterator;
            self.info_type_stats = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Result {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InspectDataSourceDetails.Result"
        }
    }
}

/// The schema of data to be saved to the BigQuery table when the
/// `DataProfileAction` is enabled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileBigQueryRowSchema {
    /// Data profile type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_profile:
        std::option::Option<crate::model::data_profile_big_query_row_schema::DataProfile>,
}

impl DataProfileBigQueryRowSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `data_profile`.
    pub fn set_data_profile<
        T: std::convert::Into<
            std::option::Option<crate::model::data_profile_big_query_row_schema::DataProfile>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = v.into();
        self
    }

    /// The value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// if it holds a `TableProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_table_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TableDataProfile>> {
        #[allow(unreachable_patterns)]
        self.data_profile.as_ref().and_then(|v| match v {
            crate::model::data_profile_big_query_row_schema::DataProfile::TableProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// if it holds a `ColumnProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_column_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ColumnDataProfile>> {
        #[allow(unreachable_patterns)]
        self.data_profile.as_ref().and_then(|v| match v {
            crate::model::data_profile_big_query_row_schema::DataProfile::ColumnProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// if it holds a `FileStoreProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_file_store_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileStoreDataProfile>> {
        #[allow(unreachable_patterns)]
        self.data_profile.as_ref().and_then(|v| match v {
            crate::model::data_profile_big_query_row_schema::DataProfile::FileStoreProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// to hold a `TableProfile`.
    ///
    /// Note that all the setters affecting `data_profile` are
    /// mutually exclusive.
    pub fn set_table_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::TableDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = std::option::Option::Some(
            crate::model::data_profile_big_query_row_schema::DataProfile::TableProfile(v.into()),
        );
        self
    }

    /// Sets the value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// to hold a `ColumnProfile`.
    ///
    /// Note that all the setters affecting `data_profile` are
    /// mutually exclusive.
    pub fn set_column_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::ColumnDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = std::option::Option::Some(
            crate::model::data_profile_big_query_row_schema::DataProfile::ColumnProfile(v.into()),
        );
        self
    }

    /// Sets the value of [data_profile][crate::model::DataProfileBigQueryRowSchema::data_profile]
    /// to hold a `FileStoreProfile`.
    ///
    /// Note that all the setters affecting `data_profile` are
    /// mutually exclusive.
    pub fn set_file_store_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::FileStoreDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile = std::option::Option::Some(
            crate::model::data_profile_big_query_row_schema::DataProfile::FileStoreProfile(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DataProfileBigQueryRowSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileBigQueryRowSchema"
    }
}

/// Defines additional types related to DataProfileBigQueryRowSchema
pub mod data_profile_big_query_row_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Data profile type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataProfile {
        /// Table data profile column
        TableProfile(std::boxed::Box<crate::model::TableDataProfile>),
        /// Column data profile column
        ColumnProfile(std::boxed::Box<crate::model::ColumnDataProfile>),
        /// File store data profile column.
        FileStoreProfile(std::boxed::Box<crate::model::FileStoreDataProfile>),
    }
}

/// Statistics related to processing hybrid inspect requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridInspectStatistics {
    /// The number of hybrid inspection requests processed within this job.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub processed_count: i64,

    /// The number of hybrid inspection requests aborted because the job ran
    /// out of quota or was ended before they could be processed.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub aborted_count: i64,

    /// The number of hybrid requests currently being processed. Only populated
    /// when called via method `getDlpJob`.
    /// A burst of traffic may cause hybrid inspect requests to be enqueued.
    /// Processing will take place as quickly as possible, but resource limitations
    /// may impact how long a request is enqueued for.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub pending_count: i64,
}

impl HybridInspectStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [processed_count][crate::model::HybridInspectStatistics::processed_count].
    pub fn set_processed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.processed_count = v.into();
        self
    }

    /// Sets the value of [aborted_count][crate::model::HybridInspectStatistics::aborted_count].
    pub fn set_aborted_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.aborted_count = v.into();
        self
    }

    /// Sets the value of [pending_count][crate::model::HybridInspectStatistics::pending_count].
    pub fn set_pending_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pending_count = v.into();
        self
    }
}

impl wkt::message::Message for HybridInspectStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectStatistics"
    }
}

/// The results of an [Action][google.privacy.dlp.v2.Action].
///
/// [google.privacy.dlp.v2.Action]: crate::model::Action
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ActionDetails {
    /// Summary of what occurred in the actions.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::action_details::Details>,
}

impl ActionDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `details`.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::action_details::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::ActionDetails::details]
    /// if it holds a `DeidentifyDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_deidentify_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeidentifyDataSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action_details::Details::DeidentifyDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::ActionDetails::details]
    /// to hold a `DeidentifyDetails`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_deidentify_details<
        T: std::convert::Into<std::boxed::Box<crate::model::DeidentifyDataSourceDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action_details::Details::DeidentifyDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ActionDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ActionDetails"
    }
}

/// Defines additional types related to ActionDetails
pub mod action_details {
    #[allow(unused_imports)]
    use super::*;

    /// Summary of what occurred in the actions.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Outcome of a de-identification action.
        DeidentifyDetails(std::boxed::Box<crate::model::DeidentifyDataSourceDetails>),
    }
}

/// Summary of what was modified during a transformation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyDataSourceStats {
    /// Total size in bytes that were transformed in some way.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformed_bytes: i64,

    /// Number of successfully applied transformations.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformation_count: i64,

    /// Number of errors encountered while trying to apply transformations.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformation_error_count: i64,
}

impl DeidentifyDataSourceStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformed_bytes][crate::model::DeidentifyDataSourceStats::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [transformation_count][crate::model::DeidentifyDataSourceStats::transformation_count].
    pub fn set_transformation_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformation_count = v.into();
        self
    }

    /// Sets the value of [transformation_error_count][crate::model::DeidentifyDataSourceStats::transformation_error_count].
    pub fn set_transformation_error_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformation_error_count = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyDataSourceStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyDataSourceStats"
    }
}

/// The results of a [Deidentify][google.privacy.dlp.v2.Action.Deidentify] action
/// from an inspect job.
///
/// [google.privacy.dlp.v2.Action.Deidentify]: crate::model::action::Deidentify
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyDataSourceDetails {
    /// De-identification config used for the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_options: std::option::Option<
        crate::model::deidentify_data_source_details::RequestedDeidentifyOptions,
    >,

    /// Stats about the de-identification operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deidentify_stats: std::option::Option<crate::model::DeidentifyDataSourceStats>,
}

impl DeidentifyDataSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_options][crate::model::DeidentifyDataSourceDetails::requested_options].
    pub fn set_requested_options<
        T: std::convert::Into<
            std::option::Option<
                crate::model::deidentify_data_source_details::RequestedDeidentifyOptions,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_options = v.into();
        self
    }

    /// Sets the value of [deidentify_stats][crate::model::DeidentifyDataSourceDetails::deidentify_stats].
    pub fn set_deidentify_stats<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyDataSourceStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_stats = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyDataSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyDataSourceDetails"
    }
}

/// Defines additional types related to DeidentifyDataSourceDetails
pub mod deidentify_data_source_details {
    #[allow(unused_imports)]
    use super::*;

    /// De-identification options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RequestedDeidentifyOptions {
        /// Snapshot of the state of the `DeidentifyTemplate` from the
        /// [Deidentify][google.privacy.dlp.v2.Action.Deidentify] action at the time
        /// this job was run.
        ///
        /// [google.privacy.dlp.v2.Action.Deidentify]: crate::model::action::Deidentify
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub snapshot_deidentify_template: std::option::Option<crate::model::DeidentifyTemplate>,

        /// Snapshot of the state of the structured `DeidentifyTemplate` from the
        /// `Deidentify` action at the time this job was run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub snapshot_structured_deidentify_template:
            std::option::Option<crate::model::DeidentifyTemplate>,

        /// Snapshot of the state of the image transformation `DeidentifyTemplate`
        /// from the `Deidentify` action at the time this job was run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub snapshot_image_redact_template: std::option::Option<crate::model::DeidentifyTemplate>,
    }

    impl RequestedDeidentifyOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [snapshot_deidentify_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_deidentify_template].
        pub fn set_snapshot_deidentify_template<
            T: std::convert::Into<std::option::Option<crate::model::DeidentifyTemplate>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.snapshot_deidentify_template = v.into();
            self
        }

        /// Sets the value of [snapshot_structured_deidentify_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_structured_deidentify_template].
        pub fn set_snapshot_structured_deidentify_template<
            T: std::convert::Into<std::option::Option<crate::model::DeidentifyTemplate>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.snapshot_structured_deidentify_template = v.into();
            self
        }

        /// Sets the value of [snapshot_image_redact_template][crate::model::deidentify_data_source_details::RequestedDeidentifyOptions::snapshot_image_redact_template].
        pub fn set_snapshot_image_redact_template<
            T: std::convert::Into<std::option::Option<crate::model::DeidentifyTemplate>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.snapshot_image_redact_template = v.into();
            self
        }
    }

    impl wkt::message::Message for RequestedDeidentifyOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DeidentifyDataSourceDetails.RequestedDeidentifyOptions"
        }
    }
}

/// InfoType description.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoTypeDescription {
    /// Internal name of the infoType.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Human readable form of the infoType name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Which parts of the API supports this InfoType.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_by: std::vec::Vec<crate::model::InfoTypeSupportedBy>,

    /// Description of the infotype. Translated when language is provided in the
    /// request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// A sample that is a true positive for this infoType.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub example: std::string::String,

    /// A list of available versions for the infotype.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub versions: std::vec::Vec<crate::model::VersionDescription>,

    /// The category of the infoType.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub categories: std::vec::Vec<crate::model::InfoTypeCategory>,

    /// The default sensitivity of the infoType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,
}

impl InfoTypeDescription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InfoTypeDescription::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InfoTypeDescription::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::InfoTypeDescription::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [example][crate::model::InfoTypeDescription::example].
    pub fn set_example<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.example = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::InfoTypeDescription::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [supported_by][crate::model::InfoTypeDescription::supported_by].
    pub fn set_supported_by<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeSupportedBy>,
    {
        use std::iter::Iterator;
        self.supported_by = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [versions][crate::model::InfoTypeDescription::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VersionDescription>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [categories][crate::model::InfoTypeDescription::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InfoTypeDescription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeDescription"
    }
}

/// Classification of infoTypes to organize them according to geographic
/// location, industry, and data type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoTypeCategory {
    /// Categories of infotypes.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub category: std::option::Option<crate::model::info_type_category::Category>,
}

impl InfoTypeCategory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `category`.
    pub fn set_category<
        T: std::convert::Into<std::option::Option<crate::model::info_type_category::Category>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = v.into();
        self
    }

    /// The value of [category][crate::model::InfoTypeCategory::category]
    /// if it holds a `LocationCategory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_location_category(
        &self,
    ) -> std::option::Option<&crate::model::info_type_category::LocationCategory> {
        #[allow(unreachable_patterns)]
        self.category.as_ref().and_then(|v| match v {
            crate::model::info_type_category::Category::LocationCategory(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [category][crate::model::InfoTypeCategory::category]
    /// if it holds a `IndustryCategory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_industry_category(
        &self,
    ) -> std::option::Option<&crate::model::info_type_category::IndustryCategory> {
        #[allow(unreachable_patterns)]
        self.category.as_ref().and_then(|v| match v {
            crate::model::info_type_category::Category::IndustryCategory(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [category][crate::model::InfoTypeCategory::category]
    /// if it holds a `TypeCategory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_type_category(
        &self,
    ) -> std::option::Option<&crate::model::info_type_category::TypeCategory> {
        #[allow(unreachable_patterns)]
        self.category.as_ref().and_then(|v| match v {
            crate::model::info_type_category::Category::TypeCategory(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [category][crate::model::InfoTypeCategory::category]
    /// to hold a `LocationCategory`.
    ///
    /// Note that all the setters affecting `category` are
    /// mutually exclusive.
    pub fn set_location_category<
        T: std::convert::Into<crate::model::info_type_category::LocationCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = std::option::Option::Some(
            crate::model::info_type_category::Category::LocationCategory(v.into()),
        );
        self
    }

    /// Sets the value of [category][crate::model::InfoTypeCategory::category]
    /// to hold a `IndustryCategory`.
    ///
    /// Note that all the setters affecting `category` are
    /// mutually exclusive.
    pub fn set_industry_category<
        T: std::convert::Into<crate::model::info_type_category::IndustryCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = std::option::Option::Some(
            crate::model::info_type_category::Category::IndustryCategory(v.into()),
        );
        self
    }

    /// Sets the value of [category][crate::model::InfoTypeCategory::category]
    /// to hold a `TypeCategory`.
    ///
    /// Note that all the setters affecting `category` are
    /// mutually exclusive.
    pub fn set_type_category<
        T: std::convert::Into<crate::model::info_type_category::TypeCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.category = std::option::Option::Some(
            crate::model::info_type_category::Category::TypeCategory(v.into()),
        );
        self
    }
}

impl wkt::message::Message for InfoTypeCategory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeCategory"
    }
}

/// Defines additional types related to InfoTypeCategory
pub mod info_type_category {
    #[allow(unused_imports)]
    use super::*;

    /// Enum of the current locations.
    /// We might add more locations in the future.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LocationCategory(i32);

    impl LocationCategory {
        /// Unused location
        pub const LOCATION_UNSPECIFIED: LocationCategory = LocationCategory::new(0);

        /// The infoType is not issued by or tied to a specific region, but is used
        /// almost everywhere.
        pub const GLOBAL: LocationCategory = LocationCategory::new(1);

        /// The infoType is typically used in Argentina.
        pub const ARGENTINA: LocationCategory = LocationCategory::new(2);

        /// The infoType is typically used in Armenia.
        pub const ARMENIA: LocationCategory = LocationCategory::new(51);

        /// The infoType is typically used in Australia.
        pub const AUSTRALIA: LocationCategory = LocationCategory::new(3);

        /// The infoType is typically used in Azerbaijan.
        pub const AZERBAIJAN: LocationCategory = LocationCategory::new(48);

        /// The infoType is typically used in Belarus.
        pub const BELARUS: LocationCategory = LocationCategory::new(50);

        /// The infoType is typically used in Belgium.
        pub const BELGIUM: LocationCategory = LocationCategory::new(4);

        /// The infoType is typically used in Brazil.
        pub const BRAZIL: LocationCategory = LocationCategory::new(5);

        /// The infoType is typically used in Canada.
        pub const CANADA: LocationCategory = LocationCategory::new(6);

        /// The infoType is typically used in Chile.
        pub const CHILE: LocationCategory = LocationCategory::new(7);

        /// The infoType is typically used in China.
        pub const CHINA: LocationCategory = LocationCategory::new(8);

        /// The infoType is typically used in Colombia.
        pub const COLOMBIA: LocationCategory = LocationCategory::new(9);

        /// The infoType is typically used in Croatia.
        pub const CROATIA: LocationCategory = LocationCategory::new(42);

        /// The infoType is typically used in Denmark.
        pub const DENMARK: LocationCategory = LocationCategory::new(10);

        /// The infoType is typically used in France.
        pub const FRANCE: LocationCategory = LocationCategory::new(11);

        /// The infoType is typically used in Finland.
        pub const FINLAND: LocationCategory = LocationCategory::new(12);

        /// The infoType is typically used in Germany.
        pub const GERMANY: LocationCategory = LocationCategory::new(13);

        /// The infoType is typically used in Hong Kong.
        pub const HONG_KONG: LocationCategory = LocationCategory::new(14);

        /// The infoType is typically used in India.
        pub const INDIA: LocationCategory = LocationCategory::new(15);

        /// The infoType is typically used in Indonesia.
        pub const INDONESIA: LocationCategory = LocationCategory::new(16);

        /// The infoType is typically used in Ireland.
        pub const IRELAND: LocationCategory = LocationCategory::new(17);

        /// The infoType is typically used in Israel.
        pub const ISRAEL: LocationCategory = LocationCategory::new(18);

        /// The infoType is typically used in Italy.
        pub const ITALY: LocationCategory = LocationCategory::new(19);

        /// The infoType is typically used in Japan.
        pub const JAPAN: LocationCategory = LocationCategory::new(20);

        /// The infoType is typically used in Kazakhstan.
        pub const KAZAKHSTAN: LocationCategory = LocationCategory::new(47);

        /// The infoType is typically used in Korea.
        pub const KOREA: LocationCategory = LocationCategory::new(21);

        /// The infoType is typically used in Mexico.
        pub const MEXICO: LocationCategory = LocationCategory::new(22);

        /// The infoType is typically used in the Netherlands.
        pub const THE_NETHERLANDS: LocationCategory = LocationCategory::new(23);

        /// The infoType is typically used in New Zealand.
        pub const NEW_ZEALAND: LocationCategory = LocationCategory::new(41);

        /// The infoType is typically used in Norway.
        pub const NORWAY: LocationCategory = LocationCategory::new(24);

        /// The infoType is typically used in Paraguay.
        pub const PARAGUAY: LocationCategory = LocationCategory::new(25);

        /// The infoType is typically used in Peru.
        pub const PERU: LocationCategory = LocationCategory::new(26);

        /// The infoType is typically used in Poland.
        pub const POLAND: LocationCategory = LocationCategory::new(27);

        /// The infoType is typically used in Portugal.
        pub const PORTUGAL: LocationCategory = LocationCategory::new(28);

        /// The infoType is typically used in Russia.
        pub const RUSSIA: LocationCategory = LocationCategory::new(44);

        /// The infoType is typically used in Singapore.
        pub const SINGAPORE: LocationCategory = LocationCategory::new(29);

        /// The infoType is typically used in South Africa.
        pub const SOUTH_AFRICA: LocationCategory = LocationCategory::new(30);

        /// The infoType is typically used in Spain.
        pub const SPAIN: LocationCategory = LocationCategory::new(31);

        /// The infoType is typically used in Sweden.
        pub const SWEDEN: LocationCategory = LocationCategory::new(32);

        /// The infoType is typically used in Switzerland.
        pub const SWITZERLAND: LocationCategory = LocationCategory::new(43);

        /// The infoType is typically used in Taiwan.
        pub const TAIWAN: LocationCategory = LocationCategory::new(33);

        /// The infoType is typically used in Thailand.
        pub const THAILAND: LocationCategory = LocationCategory::new(34);

        /// The infoType is typically used in Turkey.
        pub const TURKEY: LocationCategory = LocationCategory::new(35);

        /// The infoType is typically used in Ukraine.
        pub const UKRAINE: LocationCategory = LocationCategory::new(45);

        /// The infoType is typically used in the United Kingdom.
        pub const UNITED_KINGDOM: LocationCategory = LocationCategory::new(36);

        /// The infoType is typically used in the United States.
        pub const UNITED_STATES: LocationCategory = LocationCategory::new(37);

        /// The infoType is typically used in Uruguay.
        pub const URUGUAY: LocationCategory = LocationCategory::new(38);

        /// The infoType is typically used in Uzbekistan.
        pub const UZBEKISTAN: LocationCategory = LocationCategory::new(46);

        /// The infoType is typically used in Venezuela.
        pub const VENEZUELA: LocationCategory = LocationCategory::new(39);

        /// The infoType is typically used in Google internally.
        pub const INTERNAL: LocationCategory = LocationCategory::new(40);

        /// Creates a new LocationCategory instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("LOCATION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("GLOBAL"),
                2 => std::borrow::Cow::Borrowed("ARGENTINA"),
                3 => std::borrow::Cow::Borrowed("AUSTRALIA"),
                4 => std::borrow::Cow::Borrowed("BELGIUM"),
                5 => std::borrow::Cow::Borrowed("BRAZIL"),
                6 => std::borrow::Cow::Borrowed("CANADA"),
                7 => std::borrow::Cow::Borrowed("CHILE"),
                8 => std::borrow::Cow::Borrowed("CHINA"),
                9 => std::borrow::Cow::Borrowed("COLOMBIA"),
                10 => std::borrow::Cow::Borrowed("DENMARK"),
                11 => std::borrow::Cow::Borrowed("FRANCE"),
                12 => std::borrow::Cow::Borrowed("FINLAND"),
                13 => std::borrow::Cow::Borrowed("GERMANY"),
                14 => std::borrow::Cow::Borrowed("HONG_KONG"),
                15 => std::borrow::Cow::Borrowed("INDIA"),
                16 => std::borrow::Cow::Borrowed("INDONESIA"),
                17 => std::borrow::Cow::Borrowed("IRELAND"),
                18 => std::borrow::Cow::Borrowed("ISRAEL"),
                19 => std::borrow::Cow::Borrowed("ITALY"),
                20 => std::borrow::Cow::Borrowed("JAPAN"),
                21 => std::borrow::Cow::Borrowed("KOREA"),
                22 => std::borrow::Cow::Borrowed("MEXICO"),
                23 => std::borrow::Cow::Borrowed("THE_NETHERLANDS"),
                24 => std::borrow::Cow::Borrowed("NORWAY"),
                25 => std::borrow::Cow::Borrowed("PARAGUAY"),
                26 => std::borrow::Cow::Borrowed("PERU"),
                27 => std::borrow::Cow::Borrowed("POLAND"),
                28 => std::borrow::Cow::Borrowed("PORTUGAL"),
                29 => std::borrow::Cow::Borrowed("SINGAPORE"),
                30 => std::borrow::Cow::Borrowed("SOUTH_AFRICA"),
                31 => std::borrow::Cow::Borrowed("SPAIN"),
                32 => std::borrow::Cow::Borrowed("SWEDEN"),
                33 => std::borrow::Cow::Borrowed("TAIWAN"),
                34 => std::borrow::Cow::Borrowed("THAILAND"),
                35 => std::borrow::Cow::Borrowed("TURKEY"),
                36 => std::borrow::Cow::Borrowed("UNITED_KINGDOM"),
                37 => std::borrow::Cow::Borrowed("UNITED_STATES"),
                38 => std::borrow::Cow::Borrowed("URUGUAY"),
                39 => std::borrow::Cow::Borrowed("VENEZUELA"),
                40 => std::borrow::Cow::Borrowed("INTERNAL"),
                41 => std::borrow::Cow::Borrowed("NEW_ZEALAND"),
                42 => std::borrow::Cow::Borrowed("CROATIA"),
                43 => std::borrow::Cow::Borrowed("SWITZERLAND"),
                44 => std::borrow::Cow::Borrowed("RUSSIA"),
                45 => std::borrow::Cow::Borrowed("UKRAINE"),
                46 => std::borrow::Cow::Borrowed("UZBEKISTAN"),
                47 => std::borrow::Cow::Borrowed("KAZAKHSTAN"),
                48 => std::borrow::Cow::Borrowed("AZERBAIJAN"),
                50 => std::borrow::Cow::Borrowed("BELARUS"),
                51 => std::borrow::Cow::Borrowed("ARMENIA"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "LOCATION_UNSPECIFIED" => std::option::Option::Some(Self::LOCATION_UNSPECIFIED),
                "GLOBAL" => std::option::Option::Some(Self::GLOBAL),
                "ARGENTINA" => std::option::Option::Some(Self::ARGENTINA),
                "ARMENIA" => std::option::Option::Some(Self::ARMENIA),
                "AUSTRALIA" => std::option::Option::Some(Self::AUSTRALIA),
                "AZERBAIJAN" => std::option::Option::Some(Self::AZERBAIJAN),
                "BELARUS" => std::option::Option::Some(Self::BELARUS),
                "BELGIUM" => std::option::Option::Some(Self::BELGIUM),
                "BRAZIL" => std::option::Option::Some(Self::BRAZIL),
                "CANADA" => std::option::Option::Some(Self::CANADA),
                "CHILE" => std::option::Option::Some(Self::CHILE),
                "CHINA" => std::option::Option::Some(Self::CHINA),
                "COLOMBIA" => std::option::Option::Some(Self::COLOMBIA),
                "CROATIA" => std::option::Option::Some(Self::CROATIA),
                "DENMARK" => std::option::Option::Some(Self::DENMARK),
                "FRANCE" => std::option::Option::Some(Self::FRANCE),
                "FINLAND" => std::option::Option::Some(Self::FINLAND),
                "GERMANY" => std::option::Option::Some(Self::GERMANY),
                "HONG_KONG" => std::option::Option::Some(Self::HONG_KONG),
                "INDIA" => std::option::Option::Some(Self::INDIA),
                "INDONESIA" => std::option::Option::Some(Self::INDONESIA),
                "IRELAND" => std::option::Option::Some(Self::IRELAND),
                "ISRAEL" => std::option::Option::Some(Self::ISRAEL),
                "ITALY" => std::option::Option::Some(Self::ITALY),
                "JAPAN" => std::option::Option::Some(Self::JAPAN),
                "KAZAKHSTAN" => std::option::Option::Some(Self::KAZAKHSTAN),
                "KOREA" => std::option::Option::Some(Self::KOREA),
                "MEXICO" => std::option::Option::Some(Self::MEXICO),
                "THE_NETHERLANDS" => std::option::Option::Some(Self::THE_NETHERLANDS),
                "NEW_ZEALAND" => std::option::Option::Some(Self::NEW_ZEALAND),
                "NORWAY" => std::option::Option::Some(Self::NORWAY),
                "PARAGUAY" => std::option::Option::Some(Self::PARAGUAY),
                "PERU" => std::option::Option::Some(Self::PERU),
                "POLAND" => std::option::Option::Some(Self::POLAND),
                "PORTUGAL" => std::option::Option::Some(Self::PORTUGAL),
                "RUSSIA" => std::option::Option::Some(Self::RUSSIA),
                "SINGAPORE" => std::option::Option::Some(Self::SINGAPORE),
                "SOUTH_AFRICA" => std::option::Option::Some(Self::SOUTH_AFRICA),
                "SPAIN" => std::option::Option::Some(Self::SPAIN),
                "SWEDEN" => std::option::Option::Some(Self::SWEDEN),
                "SWITZERLAND" => std::option::Option::Some(Self::SWITZERLAND),
                "TAIWAN" => std::option::Option::Some(Self::TAIWAN),
                "THAILAND" => std::option::Option::Some(Self::THAILAND),
                "TURKEY" => std::option::Option::Some(Self::TURKEY),
                "UKRAINE" => std::option::Option::Some(Self::UKRAINE),
                "UNITED_KINGDOM" => std::option::Option::Some(Self::UNITED_KINGDOM),
                "UNITED_STATES" => std::option::Option::Some(Self::UNITED_STATES),
                "URUGUAY" => std::option::Option::Some(Self::URUGUAY),
                "UZBEKISTAN" => std::option::Option::Some(Self::UZBEKISTAN),
                "VENEZUELA" => std::option::Option::Some(Self::VENEZUELA),
                "INTERNAL" => std::option::Option::Some(Self::INTERNAL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for LocationCategory {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for LocationCategory {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Enum of the current industries in the category.
    /// We might add more industries in the future.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct IndustryCategory(i32);

    impl IndustryCategory {
        /// Unused industry
        pub const INDUSTRY_UNSPECIFIED: IndustryCategory = IndustryCategory::new(0);

        /// The infoType is typically used in the finance industry.
        pub const FINANCE: IndustryCategory = IndustryCategory::new(1);

        /// The infoType is typically used in the health industry.
        pub const HEALTH: IndustryCategory = IndustryCategory::new(2);

        /// The infoType is typically used in the telecommunications industry.
        pub const TELECOMMUNICATIONS: IndustryCategory = IndustryCategory::new(3);

        /// Creates a new IndustryCategory instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("INDUSTRY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("FINANCE"),
                2 => std::borrow::Cow::Borrowed("HEALTH"),
                3 => std::borrow::Cow::Borrowed("TELECOMMUNICATIONS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "INDUSTRY_UNSPECIFIED" => std::option::Option::Some(Self::INDUSTRY_UNSPECIFIED),
                "FINANCE" => std::option::Option::Some(Self::FINANCE),
                "HEALTH" => std::option::Option::Some(Self::HEALTH),
                "TELECOMMUNICATIONS" => std::option::Option::Some(Self::TELECOMMUNICATIONS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for IndustryCategory {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for IndustryCategory {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Enum of the current types in the category.
    /// We might add more types in the future.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TypeCategory(i32);

    impl TypeCategory {
        /// Unused type
        pub const TYPE_UNSPECIFIED: TypeCategory = TypeCategory::new(0);

        /// Personally identifiable information, for example, a
        /// name or phone number
        pub const PII: TypeCategory = TypeCategory::new(1);

        /// Personally identifiable information that is especially sensitive, for
        /// example, a passport number.
        pub const SPII: TypeCategory = TypeCategory::new(2);

        /// Attributes that can partially identify someone, especially in
        /// combination with other attributes, like age, height, and gender.
        pub const DEMOGRAPHIC: TypeCategory = TypeCategory::new(3);

        /// Confidential or secret information, for example, a password.
        pub const CREDENTIAL: TypeCategory = TypeCategory::new(4);

        /// An identification document issued by a government.
        pub const GOVERNMENT_ID: TypeCategory = TypeCategory::new(5);

        /// A document, for example, a resume or source code.
        pub const DOCUMENT: TypeCategory = TypeCategory::new(6);

        /// Information that is not sensitive on its own, but provides details about
        /// the circumstances surrounding an entity or an event.
        pub const CONTEXTUAL_INFORMATION: TypeCategory = TypeCategory::new(7);

        /// Category for `CustomInfoType` types.
        pub const CUSTOM: TypeCategory = TypeCategory::new(8);

        /// Creates a new TypeCategory instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PII"),
                2 => std::borrow::Cow::Borrowed("SPII"),
                3 => std::borrow::Cow::Borrowed("DEMOGRAPHIC"),
                4 => std::borrow::Cow::Borrowed("CREDENTIAL"),
                5 => std::borrow::Cow::Borrowed("GOVERNMENT_ID"),
                6 => std::borrow::Cow::Borrowed("DOCUMENT"),
                7 => std::borrow::Cow::Borrowed("CONTEXTUAL_INFORMATION"),
                8 => std::borrow::Cow::Borrowed("CUSTOM"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "PII" => std::option::Option::Some(Self::PII),
                "SPII" => std::option::Option::Some(Self::SPII),
                "DEMOGRAPHIC" => std::option::Option::Some(Self::DEMOGRAPHIC),
                "CREDENTIAL" => std::option::Option::Some(Self::CREDENTIAL),
                "GOVERNMENT_ID" => std::option::Option::Some(Self::GOVERNMENT_ID),
                "DOCUMENT" => std::option::Option::Some(Self::DOCUMENT),
                "CONTEXTUAL_INFORMATION" => std::option::Option::Some(Self::CONTEXTUAL_INFORMATION),
                "CUSTOM" => std::option::Option::Some(Self::CUSTOM),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TypeCategory {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TypeCategory {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Categories of infotypes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Category {
        /// The region or country that issued the ID or document represented by the
        /// infoType.
        LocationCategory(crate::model::info_type_category::LocationCategory),
        /// The group of relevant businesses where this infoType is commonly used
        IndustryCategory(crate::model::info_type_category::IndustryCategory),
        /// The class of identifiers where this infoType belongs
        TypeCategory(crate::model::info_type_category::TypeCategory),
    }
}

/// Details about each available version for an infotype.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VersionDescription {
    /// Name of the version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Description of the version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,
}

impl VersionDescription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::VersionDescription::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [description][crate::model::VersionDescription::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for VersionDescription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VersionDescription"
    }
}

/// Request for the list of infoTypes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInfoTypesRequest {
    /// The parent resource name.
    ///
    /// The format of this value is as follows:
    ///
    /// ```norust
    /// `locations/{location_id}`
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// BCP-47 language code for localized infoType friendly
    /// names. If omitted, or if localized strings are not available,
    /// en-US strings will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// filter to only return infoTypes supported by certain parts of the
    /// API. Defaults to supported_by=INSPECT.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl ListInfoTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInfoTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ListInfoTypesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInfoTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListInfoTypesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListInfoTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInfoTypesRequest"
    }
}

/// Response to the ListInfoTypes request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInfoTypesResponse {
    /// Set of sensitive infoTypes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub info_types: std::vec::Vec<crate::model::InfoTypeDescription>,
}

impl ListInfoTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_types][crate::model::ListInfoTypesResponse::info_types].
    pub fn set_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeDescription>,
    {
        use std::iter::Iterator;
        self.info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInfoTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInfoTypesResponse"
    }
}

/// Configuration for a risk analysis job. See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-risk-analysis>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RiskAnalysisJobConfig {
    /// Privacy metric to compute.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub privacy_metric: std::option::Option<crate::model::PrivacyMetric>,

    /// Input dataset to compute metrics over.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_table: std::option::Option<crate::model::BigQueryTable>,

    /// Actions to execute at the completion of the job. Are executed in the order
    /// provided.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub actions: std::vec::Vec<crate::model::Action>,
}

impl RiskAnalysisJobConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [privacy_metric][crate::model::RiskAnalysisJobConfig::privacy_metric].
    pub fn set_privacy_metric<
        T: std::convert::Into<std::option::Option<crate::model::PrivacyMetric>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privacy_metric = v.into();
        self
    }

    /// Sets the value of [source_table][crate::model::RiskAnalysisJobConfig::source_table].
    pub fn set_source_table<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_table = v.into();
        self
    }

    /// Sets the value of [actions][crate::model::RiskAnalysisJobConfig::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Action>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RiskAnalysisJobConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RiskAnalysisJobConfig"
    }
}

/// A column with a semantic tag attached.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuasiId {
    /// Required. Identifies the column.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<crate::model::FieldId>,

    /// Semantic tag that identifies what a column contains, to determine which
    /// statistical model to use to estimate the reidentifiability of each
    /// value. [required]
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub tag: std::option::Option<crate::model::quasi_id::Tag>,
}

impl QuasiId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::QuasiId::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of `tag`.
    pub fn set_tag<T: std::convert::Into<std::option::Option<crate::model::quasi_id::Tag>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = v.into();
        self
    }

    /// The value of [tag][crate::model::QuasiId::tag]
    /// if it holds a `InfoType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_info_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::InfoType>> {
        #[allow(unreachable_patterns)]
        self.tag.as_ref().and_then(|v| match v {
            crate::model::quasi_id::Tag::InfoType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [tag][crate::model::QuasiId::tag]
    /// if it holds a `CustomTag`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_custom_tag(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.tag.as_ref().and_then(|v| match v {
            crate::model::quasi_id::Tag::CustomTag(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [tag][crate::model::QuasiId::tag]
    /// if it holds a `Inferred`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_inferred(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.tag.as_ref().and_then(|v| match v {
            crate::model::quasi_id::Tag::Inferred(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tag][crate::model::QuasiId::tag]
    /// to hold a `InfoType`.
    ///
    /// Note that all the setters affecting `tag` are
    /// mutually exclusive.
    pub fn set_info_type<T: std::convert::Into<std::boxed::Box<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = std::option::Option::Some(crate::model::quasi_id::Tag::InfoType(v.into()));
        self
    }

    /// Sets the value of [tag][crate::model::QuasiId::tag]
    /// to hold a `CustomTag`.
    ///
    /// Note that all the setters affecting `tag` are
    /// mutually exclusive.
    pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = std::option::Option::Some(crate::model::quasi_id::Tag::CustomTag(v.into()));
        self
    }

    /// Sets the value of [tag][crate::model::QuasiId::tag]
    /// to hold a `Inferred`.
    ///
    /// Note that all the setters affecting `tag` are
    /// mutually exclusive.
    pub fn set_inferred<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = std::option::Option::Some(crate::model::quasi_id::Tag::Inferred(v.into()));
        self
    }
}

impl wkt::message::Message for QuasiId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.QuasiId"
    }
}

/// Defines additional types related to QuasiId
pub mod quasi_id {
    #[allow(unused_imports)]
    use super::*;

    /// Semantic tag that identifies what a column contains, to determine which
    /// statistical model to use to estimate the reidentifiability of each
    /// value. [required]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Tag {
        /// A column can be tagged with a InfoType to use the relevant public
        /// dataset as a statistical model of population, if available. We
        /// currently support US ZIP codes, region codes, ages and genders.
        /// To programmatically obtain the list of supported InfoTypes, use
        /// ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
        InfoType(std::boxed::Box<crate::model::InfoType>),
        /// A column can be tagged with a custom tag. In this case, the user must
        /// indicate an auxiliary table that contains statistical information on
        /// the possible values of this column (below).
        CustomTag(std::string::String),
        /// If no semantic tag is indicated, we infer the statistical model from
        /// the distribution of values in the input data
        Inferred(std::boxed::Box<wkt::Empty>),
    }
}

/// An auxiliary table containing statistical information on the relative
/// frequency of different quasi-identifiers values. It has one or several
/// quasi-identifiers columns, and one column that indicates the relative
/// frequency of each quasi-identifier tuple.
/// If a tuple is present in the data but not in the auxiliary table, the
/// corresponding relative frequency is assumed to be zero (and thus, the
/// tuple is highly reidentifiable).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StatisticalTable {
    /// Required. Auxiliary table location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table: std::option::Option<crate::model::BigQueryTable>,

    /// Required. Quasi-identifier columns.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub quasi_ids: std::vec::Vec<crate::model::statistical_table::QuasiIdentifierField>,

    /// Required. The relative frequency column must contain a floating-point
    /// number between 0 and 1 (inclusive). Null values are assumed to be zero.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub relative_frequency: std::option::Option<crate::model::FieldId>,
}

impl StatisticalTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::StatisticalTable::table].
    pub fn set_table<T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>>(
        mut self,
        v: T,
    ) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [relative_frequency][crate::model::StatisticalTable::relative_frequency].
    pub fn set_relative_frequency<
        T: std::convert::Into<std::option::Option<crate::model::FieldId>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.relative_frequency = v.into();
        self
    }

    /// Sets the value of [quasi_ids][crate::model::StatisticalTable::quasi_ids].
    pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::statistical_table::QuasiIdentifierField>,
    {
        use std::iter::Iterator;
        self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StatisticalTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StatisticalTable"
    }
}

/// Defines additional types related to StatisticalTable
pub mod statistical_table {
    #[allow(unused_imports)]
    use super::*;

    /// A quasi-identifier column has a custom_tag, used to know which column
    /// in the data corresponds to which column in the statistical model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QuasiIdentifierField {
        /// Identifies the column.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub field: std::option::Option<crate::model::FieldId>,

        /// A column can be tagged with a custom tag. In this case, the user must
        /// indicate an auxiliary table that contains statistical information on
        /// the possible values of this column (below).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub custom_tag: std::string::String,
    }

    impl QuasiIdentifierField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::statistical_table::QuasiIdentifierField::field].
        pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
            mut self,
            v: T,
        ) -> Self {
            self.field = v.into();
            self
        }

        /// Sets the value of [custom_tag][crate::model::statistical_table::QuasiIdentifierField::custom_tag].
        pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.custom_tag = v.into();
            self
        }
    }

    impl wkt::message::Message for QuasiIdentifierField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.StatisticalTable.QuasiIdentifierField"
        }
    }
}

/// Privacy metric to compute for reidentification risk analysis.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivacyMetric {
    /// Types of analysis.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::privacy_metric::Type>,
}

impl PrivacyMetric {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `r#type`.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::privacy_metric::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `NumericalStatsConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_numerical_stats_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::NumericalStatsConfig>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::NumericalStatsConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `CategoricalStatsConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_categorical_stats_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::CategoricalStatsConfig>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::CategoricalStatsConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `KAnonymityConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_k_anonymity_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::KAnonymityConfig>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::KAnonymityConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `LDiversityConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_l_diversity_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::LDiversityConfig>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::LDiversityConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `KMapEstimationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_k_map_estimation_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privacy_metric::KMapEstimationConfig>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::KMapEstimationConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::PrivacyMetric::r#type]
    /// if it holds a `DeltaPresenceEstimationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_delta_presence_estimation_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::privacy_metric::DeltaPresenceEstimationConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::privacy_metric::Type::DeltaPresenceEstimationConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `NumericalStatsConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_numerical_stats_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::NumericalStatsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::NumericalStatsConfig(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `CategoricalStatsConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_categorical_stats_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::CategoricalStatsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::CategoricalStatsConfig(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `KAnonymityConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_k_anonymity_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::KAnonymityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::KAnonymityConfig(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `LDiversityConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_l_diversity_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::LDiversityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::LDiversityConfig(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `KMapEstimationConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_k_map_estimation_config<
        T: std::convert::Into<std::boxed::Box<crate::model::privacy_metric::KMapEstimationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::KMapEstimationConfig(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::PrivacyMetric::r#type]
    /// to hold a `DeltaPresenceEstimationConfig`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_delta_presence_estimation_config<
        T: std::convert::Into<
            std::boxed::Box<crate::model::privacy_metric::DeltaPresenceEstimationConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::privacy_metric::Type::DeltaPresenceEstimationConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PrivacyMetric {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric"
    }
}

/// Defines additional types related to PrivacyMetric
pub mod privacy_metric {
    #[allow(unused_imports)]
    use super::*;

    /// Compute numerical stats over an individual column, including
    /// min, max, and quantiles.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NumericalStatsConfig {
        /// Field to compute numerical stats on. Supported types are
        /// integer, float, date, datetime, timestamp, time.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub field: std::option::Option<crate::model::FieldId>,
    }

    impl NumericalStatsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::privacy_metric::NumericalStatsConfig::field].
        pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
            mut self,
            v: T,
        ) -> Self {
            self.field = v.into();
            self
        }
    }

    impl wkt::message::Message for NumericalStatsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.NumericalStatsConfig"
        }
    }

    /// Compute numerical stats over an individual column, including
    /// number of distinct values and value count distribution.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CategoricalStatsConfig {
        /// Field to compute categorical stats on. All column types are
        /// supported except for arrays and structs. However, it may be more
        /// informative to use NumericalStats when the field type is supported,
        /// depending on the data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub field: std::option::Option<crate::model::FieldId>,
    }

    impl CategoricalStatsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::privacy_metric::CategoricalStatsConfig::field].
        pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
            mut self,
            v: T,
        ) -> Self {
            self.field = v.into();
            self
        }
    }

    impl wkt::message::Message for CategoricalStatsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.CategoricalStatsConfig"
        }
    }

    /// k-anonymity metric, used for analysis of reidentification risk.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct KAnonymityConfig {
        /// Set of fields to compute k-anonymity over. When multiple fields are
        /// specified, they are considered a single composite key. Structs and
        /// repeated data types are not supported; however, nested fields are
        /// supported so long as they are not structs themselves or nested within
        /// a repeated field.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub quasi_ids: std::vec::Vec<crate::model::FieldId>,

        /// Message indicating that multiple rows might be associated to a
        /// single individual. If the same entity_id is associated to multiple
        /// quasi-identifier tuples over distinct rows, we consider the entire
        /// collection of tuples as the composite quasi-identifier. This collection
        /// is a multiset: the order in which the different tuples appear in the
        /// dataset is ignored, but their frequency is taken into account.
        ///
        /// Important note: a maximum of 1000 rows can be associated to a single
        /// entity ID. If more rows are associated with the same entity ID, some
        /// might be ignored.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub entity_id: std::option::Option<crate::model::EntityId>,
    }

    impl KAnonymityConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_id][crate::model::privacy_metric::KAnonymityConfig::entity_id].
        pub fn set_entity_id<T: std::convert::Into<std::option::Option<crate::model::EntityId>>>(
            mut self,
            v: T,
        ) -> Self {
            self.entity_id = v.into();
            self
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::KAnonymityConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FieldId>,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for KAnonymityConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KAnonymityConfig"
        }
    }

    /// l-diversity metric, used for analysis of reidentification risk.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LDiversityConfig {
        /// Set of quasi-identifiers indicating how equivalence classes are
        /// defined for the l-diversity computation. When multiple fields are
        /// specified, they are considered a single composite key.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub quasi_ids: std::vec::Vec<crate::model::FieldId>,

        /// Sensitive field for computing the l-value.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub sensitive_attribute: std::option::Option<crate::model::FieldId>,
    }

    impl LDiversityConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sensitive_attribute][crate::model::privacy_metric::LDiversityConfig::sensitive_attribute].
        pub fn set_sensitive_attribute<
            T: std::convert::Into<std::option::Option<crate::model::FieldId>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.sensitive_attribute = v.into();
            self
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::LDiversityConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FieldId>,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for LDiversityConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.LDiversityConfig"
        }
    }

    /// Reidentifiability metric. This corresponds to a risk model similar to what
    /// is called "journalist risk" in the literature, except the attack dataset is
    /// statistically modeled instead of being perfectly known. This can be done
    /// using publicly available data (like the US Census), or using a custom
    /// statistical model (indicated as one or several BigQuery tables), or by
    /// extrapolating from the distribution of values in the input dataset.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct KMapEstimationConfig {
        /// Required. Fields considered to be quasi-identifiers. No two columns can
        /// have the same tag.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub quasi_ids:
            std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::TaggedField>,

        /// ISO 3166-1 alpha-2 region code to use in the statistical modeling.
        /// Set if no column is tagged with a region-specific InfoType (like
        /// US_ZIP_5) or a region code.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub region_code: std::string::String,

        /// Several auxiliary tables can be used in the analysis. Each custom_tag
        /// used to tag a quasi-identifiers column must appear in exactly one column
        /// of one auxiliary table.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub auxiliary_tables:
            std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable>,
    }

    impl KMapEstimationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [region_code][crate::model::privacy_metric::KMapEstimationConfig::region_code].
        pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region_code = v.into();
            self
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::KMapEstimationConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::privacy_metric::k_map_estimation_config::TaggedField,
            >,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [auxiliary_tables][crate::model::privacy_metric::KMapEstimationConfig::auxiliary_tables].
        pub fn set_auxiliary_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable,
            >,
        {
            use std::iter::Iterator;
            self.auxiliary_tables = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for KMapEstimationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig"
        }
    }

    /// Defines additional types related to KMapEstimationConfig
    pub mod k_map_estimation_config {
        #[allow(unused_imports)]
        use super::*;

        /// A column with a semantic tag attached.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TaggedField {
            /// Required. Identifies the column.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub field: std::option::Option<crate::model::FieldId>,

            /// Semantic tag that identifies what a column contains, to determine which
            /// statistical model to use to estimate the reidentifiability of each
            /// value. [required]
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub tag: std::option::Option<
                crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag,
            >,
        }

        impl TaggedField {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [field][crate::model::privacy_metric::k_map_estimation_config::TaggedField::field].
            pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
                mut self,
                v: T,
            ) -> Self {
                self.field = v.into();
                self
            }

            /// Sets the value of `tag`.
            pub fn set_tag<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.tag = v.into();
                self
            }

            /// The value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// if it holds a `InfoType`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_info_type(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::InfoType>> {
                #[allow(unreachable_patterns)]
                self.tag.as_ref().and_then(|v| match v {
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::InfoType(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// if it holds a `CustomTag`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_custom_tag(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.tag.as_ref().and_then(|v| match v {
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::CustomTag(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// if it holds a `Inferred`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_inferred(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
                #[allow(unreachable_patterns)]
                self.tag.as_ref().and_then(|v| match v {
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::Inferred(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// to hold a `InfoType`.
            ///
            /// Note that all the setters affecting `tag` are
            /// mutually exclusive.
            pub fn set_info_type<T: std::convert::Into<std::boxed::Box<crate::model::InfoType>>>(
                mut self,
                v: T,
            ) -> Self {
                self.tag = std::option::Option::Some(
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::InfoType(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// to hold a `CustomTag`.
            ///
            /// Note that all the setters affecting `tag` are
            /// mutually exclusive.
            pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.tag = std::option::Option::Some(
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::CustomTag(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [tag][crate::model::privacy_metric::k_map_estimation_config::TaggedField::tag]
            /// to hold a `Inferred`.
            ///
            /// Note that all the setters affecting `tag` are
            /// mutually exclusive.
            pub fn set_inferred<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
                mut self,
                v: T,
            ) -> Self {
                self.tag = std::option::Option::Some(
                    crate::model::privacy_metric::k_map_estimation_config::tagged_field::Tag::Inferred(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for TaggedField {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.TaggedField"
            }
        }

        /// Defines additional types related to TaggedField
        pub mod tagged_field {
            #[allow(unused_imports)]
            use super::*;

            /// Semantic tag that identifies what a column contains, to determine which
            /// statistical model to use to estimate the reidentifiability of each
            /// value. [required]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Tag {
                /// A column can be tagged with a InfoType to use the relevant public
                /// dataset as a statistical model of population, if available. We
                /// currently support US ZIP codes, region codes, ages and genders.
                /// To programmatically obtain the list of supported InfoTypes, use
                /// ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
                InfoType(std::boxed::Box<crate::model::InfoType>),
                /// A column can be tagged with a custom tag. In this case, the user must
                /// indicate an auxiliary table that contains statistical information on
                /// the possible values of this column (below).
                CustomTag(std::string::String),
                /// If no semantic tag is indicated, we infer the statistical model from
                /// the distribution of values in the input data
                Inferred(std::boxed::Box<wkt::Empty>),
            }
        }

        /// An auxiliary table contains statistical information on the relative
        /// frequency of different quasi-identifiers values. It has one or several
        /// quasi-identifiers columns, and one column that indicates the relative
        /// frequency of each quasi-identifier tuple.
        /// If a tuple is present in the data but not in the auxiliary table, the
        /// corresponding relative frequency is assumed to be zero (and thus, the
        /// tuple is highly reidentifiable).
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AuxiliaryTable {

            /// Required. Auxiliary table location.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub table: std::option::Option<crate::model::BigQueryTable>,

            /// Required. Quasi-identifier columns.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub quasi_ids: std::vec::Vec<crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField>,

            /// Required. The relative frequency column must contain a floating-point
            /// number between 0 and 1 (inclusive). Null values are assumed to be zero.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub relative_frequency: std::option::Option<crate::model::FieldId>,
        }

        impl AuxiliaryTable {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [table][crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable::table].
            pub fn set_table<
                T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.table = v.into();
                self
            }

            /// Sets the value of [relative_frequency][crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable::relative_frequency].
            pub fn set_relative_frequency<
                T: std::convert::Into<std::option::Option<crate::model::FieldId>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.relative_frequency = v.into();
                self
            }

            /// Sets the value of [quasi_ids][crate::model::privacy_metric::k_map_estimation_config::AuxiliaryTable::quasi_ids].
            pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField>
            {
                use std::iter::Iterator;
                self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for AuxiliaryTable {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.AuxiliaryTable"
            }
        }

        /// Defines additional types related to AuxiliaryTable
        pub mod auxiliary_table {
            #[allow(unused_imports)]
            use super::*;

            /// A quasi-identifier column has a custom_tag, used to know which column
            /// in the data corresponds to which column in the statistical model.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct QuasiIdField {
                /// Identifies the column.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub field: std::option::Option<crate::model::FieldId>,

                /// A auxiliary field.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub custom_tag: std::string::String,
            }

            impl QuasiIdField {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [field][crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField::field].
                pub fn set_field<
                    T: std::convert::Into<std::option::Option<crate::model::FieldId>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.field = v.into();
                    self
                }

                /// Sets the value of [custom_tag][crate::model::privacy_metric::k_map_estimation_config::auxiliary_table::QuasiIdField::custom_tag].
                pub fn set_custom_tag<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.custom_tag = v.into();
                    self
                }
            }

            impl wkt::message::Message for QuasiIdField {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.KMapEstimationConfig.AuxiliaryTable.QuasiIdField"
                }
            }
        }
    }

    /// -presence metric, used to estimate how likely it is for an attacker to
    /// figure out that one given individual appears in a de-identified dataset.
    /// Similarly to the k-map metric, we cannot compute -presence exactly without
    /// knowing the attack dataset, so we use a statistical model instead.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DeltaPresenceEstimationConfig {
        /// Required. Fields considered to be quasi-identifiers. No two fields can
        /// have the same tag.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub quasi_ids: std::vec::Vec<crate::model::QuasiId>,

        /// ISO 3166-1 alpha-2 region code to use in the statistical modeling.
        /// Set if no column is tagged with a region-specific InfoType (like
        /// US_ZIP_5) or a region code.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub region_code: std::string::String,

        /// Several auxiliary tables can be used in the analysis. Each custom_tag
        /// used to tag a quasi-identifiers field must appear in exactly one
        /// field of one auxiliary table.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub auxiliary_tables: std::vec::Vec<crate::model::StatisticalTable>,
    }

    impl DeltaPresenceEstimationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [region_code][crate::model::privacy_metric::DeltaPresenceEstimationConfig::region_code].
        pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region_code = v.into();
            self
        }

        /// Sets the value of [quasi_ids][crate::model::privacy_metric::DeltaPresenceEstimationConfig::quasi_ids].
        pub fn set_quasi_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::QuasiId>,
        {
            use std::iter::Iterator;
            self.quasi_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [auxiliary_tables][crate::model::privacy_metric::DeltaPresenceEstimationConfig::auxiliary_tables].
        pub fn set_auxiliary_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::StatisticalTable>,
        {
            use std::iter::Iterator;
            self.auxiliary_tables = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DeltaPresenceEstimationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.PrivacyMetric.DeltaPresenceEstimationConfig"
        }
    }

    /// Types of analysis.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// Numerical stats
        NumericalStatsConfig(std::boxed::Box<crate::model::privacy_metric::NumericalStatsConfig>),
        /// Categorical stats
        CategoricalStatsConfig(
            std::boxed::Box<crate::model::privacy_metric::CategoricalStatsConfig>,
        ),
        /// K-anonymity
        KAnonymityConfig(std::boxed::Box<crate::model::privacy_metric::KAnonymityConfig>),
        /// l-diversity
        LDiversityConfig(std::boxed::Box<crate::model::privacy_metric::LDiversityConfig>),
        /// k-map
        KMapEstimationConfig(std::boxed::Box<crate::model::privacy_metric::KMapEstimationConfig>),
        /// delta-presence
        DeltaPresenceEstimationConfig(
            std::boxed::Box<crate::model::privacy_metric::DeltaPresenceEstimationConfig>,
        ),
    }
}

/// Result of a risk analysis operation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalyzeDataSourceRiskDetails {
    /// Privacy metric to compute.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_privacy_metric: std::option::Option<crate::model::PrivacyMetric>,

    /// Input dataset to compute metrics over.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_source_table: std::option::Option<crate::model::BigQueryTable>,

    /// The configuration used for this job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_options: std::option::Option<
        crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions,
    >,

    /// Values associated with this metric.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::analyze_data_source_risk_details::Result>,
}

impl AnalyzeDataSourceRiskDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_privacy_metric][crate::model::AnalyzeDataSourceRiskDetails::requested_privacy_metric].
    pub fn set_requested_privacy_metric<
        T: std::convert::Into<std::option::Option<crate::model::PrivacyMetric>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_privacy_metric = v.into();
        self
    }

    /// Sets the value of [requested_source_table][crate::model::AnalyzeDataSourceRiskDetails::requested_source_table].
    pub fn set_requested_source_table<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_source_table = v.into();
        self
    }

    /// Sets the value of [requested_options][crate::model::AnalyzeDataSourceRiskDetails::requested_options].
    pub fn set_requested_options<
        T: std::convert::Into<
            std::option::Option<
                crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_options = v.into();
        self
    }

    /// Sets the value of `result`.
    pub fn set_result<
        T: std::convert::Into<
            std::option::Option<crate::model::analyze_data_source_risk_details::Result>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `NumericalStatsResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_numerical_stats_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::NumericalStatsResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::NumericalStatsResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `CategoricalStatsResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_categorical_stats_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::CategoricalStatsResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::CategoricalStatsResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `KAnonymityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_k_anonymity_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::KAnonymityResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::KAnonymityResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `LDiversityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_l_diversity_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::LDiversityResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::LDiversityResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `KMapEstimationResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_k_map_estimation_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::analyze_data_source_risk_details::KMapEstimationResult>,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::KMapEstimationResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// if it holds a `DeltaPresenceEstimationResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_delta_presence_estimation_result(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<
            crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult,
        >,
    > {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::analyze_data_source_risk_details::Result::DeltaPresenceEstimationResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `NumericalStatsResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_numerical_stats_result<
        T: std::convert::Into<
            std::boxed::Box<crate::model::analyze_data_source_risk_details::NumericalStatsResult>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::NumericalStatsResult(v.into()),
        );
        self
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `CategoricalStatsResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_categorical_stats_result<
        T: std::convert::Into<
            std::boxed::Box<crate::model::analyze_data_source_risk_details::CategoricalStatsResult>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::CategoricalStatsResult(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `KAnonymityResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_k_anonymity_result<
        T: std::convert::Into<
            std::boxed::Box<crate::model::analyze_data_source_risk_details::KAnonymityResult>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::KAnonymityResult(v.into()),
        );
        self
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `LDiversityResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_l_diversity_result<
        T: std::convert::Into<
            std::boxed::Box<crate::model::analyze_data_source_risk_details::LDiversityResult>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::LDiversityResult(v.into()),
        );
        self
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `KMapEstimationResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_k_map_estimation_result<
        T: std::convert::Into<
            std::boxed::Box<crate::model::analyze_data_source_risk_details::KMapEstimationResult>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::KMapEstimationResult(v.into()),
        );
        self
    }

    /// Sets the value of [result][crate::model::AnalyzeDataSourceRiskDetails::result]
    /// to hold a `DeltaPresenceEstimationResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_delta_presence_estimation_result<
        T: std::convert::Into<
            std::boxed::Box<
                crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::analyze_data_source_risk_details::Result::DeltaPresenceEstimationResult(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for AnalyzeDataSourceRiskDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails"
    }
}

/// Defines additional types related to AnalyzeDataSourceRiskDetails
pub mod analyze_data_source_risk_details {
    #[allow(unused_imports)]
    use super::*;

    /// Result of the numerical stats computation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NumericalStatsResult {
        /// Minimum value appearing in the column.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_value: std::option::Option<crate::model::Value>,

        /// Maximum value appearing in the column.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_value: std::option::Option<crate::model::Value>,

        /// List of 99 values that partition the set of field values into 100 equal
        /// sized buckets.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub quantile_values: std::vec::Vec<crate::model::Value>,
    }

    impl NumericalStatsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_value][crate::model::analyze_data_source_risk_details::NumericalStatsResult::min_value].
        pub fn set_min_value<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_value = v.into();
            self
        }

        /// Sets the value of [max_value][crate::model::analyze_data_source_risk_details::NumericalStatsResult::max_value].
        pub fn set_max_value<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_value = v.into();
            self
        }

        /// Sets the value of [quantile_values][crate::model::analyze_data_source_risk_details::NumericalStatsResult::quantile_values].
        pub fn set_quantile_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Value>,
        {
            use std::iter::Iterator;
            self.quantile_values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NumericalStatsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.NumericalStatsResult"
        }
    }

    /// Result of the categorical stats computation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CategoricalStatsResult {

        /// Histogram of value frequencies in the column.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub value_frequency_histogram_buckets: std::vec::Vec<crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket>,
    }

    impl CategoricalStatsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value_frequency_histogram_buckets][crate::model::analyze_data_source_risk_details::CategoricalStatsResult::value_frequency_histogram_buckets].
        pub fn set_value_frequency_histogram_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket>
        {
            use std::iter::Iterator;
            self.value_frequency_histogram_buckets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CategoricalStatsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.CategoricalStatsResult"
        }
    }

    /// Defines additional types related to CategoricalStatsResult
    pub mod categorical_stats_result {
        #[allow(unused_imports)]
        use super::*;

        /// Histogram of value frequencies in the column.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CategoricalStatsHistogramBucket {
            /// Lower bound on the value frequency of the values in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub value_frequency_lower_bound: i64,

            /// Upper bound on the value frequency of the values in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub value_frequency_upper_bound: i64,

            /// Total number of values in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_size: i64,

            /// Sample of value frequencies in this bucket. The total number of
            /// values returned per bucket is capped at 20.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub bucket_values: std::vec::Vec<crate::model::ValueFrequency>,

            /// Total number of distinct values in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_value_count: i64,
        }

        impl CategoricalStatsHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [value_frequency_lower_bound][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::value_frequency_lower_bound].
            pub fn set_value_frequency_lower_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.value_frequency_lower_bound = v.into();
                self
            }

            /// Sets the value of [value_frequency_upper_bound][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::value_frequency_upper_bound].
            pub fn set_value_frequency_upper_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.value_frequency_upper_bound = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::categorical_stats_result::CategoricalStatsHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::ValueFrequency>,
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for CategoricalStatsHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.CategoricalStatsResult.CategoricalStatsHistogramBucket"
            }
        }
    }

    /// Result of the k-anonymity computation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct KAnonymityResult {

        /// Histogram of k-anonymity equivalence classes.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub equivalence_class_histogram_buckets: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket>,
    }

    impl KAnonymityResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [equivalence_class_histogram_buckets][crate::model::analyze_data_source_risk_details::KAnonymityResult::equivalence_class_histogram_buckets].
        pub fn set_equivalence_class_histogram_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket>
        {
            use std::iter::Iterator;
            self.equivalence_class_histogram_buckets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for KAnonymityResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KAnonymityResult"
        }
    }

    /// Defines additional types related to KAnonymityResult
    pub mod k_anonymity_result {
        #[allow(unused_imports)]
        use super::*;

        /// The set of columns' values that share the same ldiversity value
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct KAnonymityEquivalenceClass {
            /// Set of values defining the equivalence class. One value per
            /// quasi-identifier column in the original KAnonymity metric message.
            /// The order is always the same as the original request.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// Size of the equivalence class, for example number of rows with the
            /// above set of values.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub equivalence_class_size: i64,
        }

        impl KAnonymityEquivalenceClass {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [equivalence_class_size][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass::equivalence_class_size].
            pub fn set_equivalence_class_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.equivalence_class_size = v.into();
                self
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for KAnonymityEquivalenceClass {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityEquivalenceClass"
            }
        }

        /// Histogram of k-anonymity equivalence classes.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct KAnonymityHistogramBucket {

            /// Lower bound on the size of the equivalence classes in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub equivalence_class_size_lower_bound: i64,

            /// Upper bound on the size of the equivalence classes in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub equivalence_class_size_upper_bound: i64,

            /// Total number of equivalence classes in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_size: i64,

            /// Sample of equivalence classes in this bucket. The total number of
            /// classes returned per bucket is capped at 20.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass>,

            /// Total number of distinct equivalence classes in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_value_count: i64,
        }

        impl KAnonymityHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [equivalence_class_size_lower_bound][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::equivalence_class_size_lower_bound].
            pub fn set_equivalence_class_size_lower_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.equivalence_class_size_lower_bound = v.into();
                self
            }

            /// Sets the value of [equivalence_class_size_upper_bound][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::equivalence_class_size_upper_bound].
            pub fn set_equivalence_class_size_upper_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.equivalence_class_size_upper_bound = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_anonymity_result::KAnonymityEquivalenceClass>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for KAnonymityHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityHistogramBucket"
            }
        }
    }

    /// Result of the l-diversity computation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LDiversityResult {

        /// Histogram of l-diversity equivalence class sensitive value frequencies.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub sensitive_value_frequency_histogram_buckets: std::vec::Vec<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket>,
    }

    impl LDiversityResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sensitive_value_frequency_histogram_buckets][crate::model::analyze_data_source_risk_details::LDiversityResult::sensitive_value_frequency_histogram_buckets].
        pub fn set_sensitive_value_frequency_histogram_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket>
        {
            use std::iter::Iterator;
            self.sensitive_value_frequency_histogram_buckets =
                v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for LDiversityResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.LDiversityResult"
        }
    }

    /// Defines additional types related to LDiversityResult
    pub mod l_diversity_result {
        #[allow(unused_imports)]
        use super::*;

        /// The set of columns' values that share the same ldiversity value.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct LDiversityEquivalenceClass {
            /// Quasi-identifier values defining the k-anonymity equivalence
            /// class. The order is always the same as the original request.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// Size of the k-anonymity equivalence class.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub equivalence_class_size: i64,

            /// Number of distinct sensitive values in this equivalence class.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub num_distinct_sensitive_values: i64,

            /// Estimated frequencies of top sensitive values.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub top_sensitive_values: std::vec::Vec<crate::model::ValueFrequency>,
        }

        impl LDiversityEquivalenceClass {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [equivalence_class_size][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::equivalence_class_size].
            pub fn set_equivalence_class_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.equivalence_class_size = v.into();
                self
            }

            /// Sets the value of [num_distinct_sensitive_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::num_distinct_sensitive_values].
            pub fn set_num_distinct_sensitive_values<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.num_distinct_sensitive_values = v.into();
                self
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [top_sensitive_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass::top_sensitive_values].
            pub fn set_top_sensitive_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::ValueFrequency>,
            {
                use std::iter::Iterator;
                self.top_sensitive_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for LDiversityEquivalenceClass {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityEquivalenceClass"
            }
        }

        /// Histogram of l-diversity equivalence class sensitive value frequencies.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct LDiversityHistogramBucket {

            /// Lower bound on the sensitive value frequencies of the equivalence
            /// classes in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub sensitive_value_frequency_lower_bound: i64,

            /// Upper bound on the sensitive value frequencies of the equivalence
            /// classes in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub sensitive_value_frequency_upper_bound: i64,

            /// Total number of equivalence classes in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_size: i64,

            /// Sample of equivalence classes in this bucket. The total number of
            /// classes returned per bucket is capped at 20.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass>,

            /// Total number of distinct equivalence classes in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_value_count: i64,
        }

        impl LDiversityHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [sensitive_value_frequency_lower_bound][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::sensitive_value_frequency_lower_bound].
            pub fn set_sensitive_value_frequency_lower_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.sensitive_value_frequency_lower_bound = v.into();
                self
            }

            /// Sets the value of [sensitive_value_frequency_upper_bound][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::sensitive_value_frequency_upper_bound].
            pub fn set_sensitive_value_frequency_upper_bound<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.sensitive_value_frequency_upper_bound = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::l_diversity_result::LDiversityEquivalenceClass>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for LDiversityHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityHistogramBucket"
            }
        }
    }

    /// Result of the reidentifiability analysis. Note that these results are an
    /// estimation, not exact values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct KMapEstimationResult {

        /// The intervals [min_anonymity, max_anonymity] do not overlap. If a value
        /// doesn't correspond to any such interval, the associated frequency is
        /// zero. For example, the following records:
        /// {min_anonymity: 1, max_anonymity: 1, frequency: 17}
        /// {min_anonymity: 2, max_anonymity: 3, frequency: 42}
        /// {min_anonymity: 5, max_anonymity: 10, frequency: 99}
        /// mean that there are no record with an estimated anonymity of 4, 5, or
        /// larger than 10.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub k_map_estimation_histogram: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket>,
    }

    impl KMapEstimationResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [k_map_estimation_histogram][crate::model::analyze_data_source_risk_details::KMapEstimationResult::k_map_estimation_histogram].
        pub fn set_k_map_estimation_histogram<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket>
        {
            use std::iter::Iterator;
            self.k_map_estimation_histogram = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for KMapEstimationResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KMapEstimationResult"
        }
    }

    /// Defines additional types related to KMapEstimationResult
    pub mod k_map_estimation_result {
        #[allow(unused_imports)]
        use super::*;

        /// A tuple of values for the quasi-identifier columns.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct KMapEstimationQuasiIdValues {
            /// The quasi-identifier values.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// The estimated anonymity for these quasi-identifier values.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub estimated_anonymity: i64,
        }

        impl KMapEstimationQuasiIdValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [estimated_anonymity][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues::estimated_anonymity].
            pub fn set_estimated_anonymity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.estimated_anonymity = v.into();
                self
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for KMapEstimationQuasiIdValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationQuasiIdValues"
            }
        }

        /// A KMapEstimationHistogramBucket message with the following values:
        /// min_anonymity: 3
        /// max_anonymity: 5
        /// frequency: 42
        /// means that there are 42 records whose quasi-identifier values correspond
        /// to 3, 4 or 5 people in the overlying population. An important particular
        /// case is when min_anonymity = max_anonymity = 1: the frequency field then
        /// corresponds to the number of uniquely identifiable records.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct KMapEstimationHistogramBucket {

            /// Always positive.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub min_anonymity: i64,

            /// Always greater than or equal to min_anonymity.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub max_anonymity: i64,

            /// Number of records within these anonymity bounds.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_size: i64,

            /// Sample of quasi-identifier tuple values in this bucket. The total
            /// number of classes returned per bucket is capped at 20.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues>,

            /// Total number of distinct quasi-identifier tuple values in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_value_count: i64,
        }

        impl KMapEstimationHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_anonymity][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::min_anonymity].
            pub fn set_min_anonymity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.min_anonymity = v.into();
                self
            }

            /// Sets the value of [max_anonymity][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::max_anonymity].
            pub fn set_max_anonymity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_anonymity = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::k_map_estimation_result::KMapEstimationQuasiIdValues>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for KMapEstimationHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationHistogramBucket"
            }
        }
    }

    /// Result of the -presence computation. Note that these results are an
    /// estimation, not exact values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DeltaPresenceEstimationResult {

        /// The intervals [min_probability, max_probability) do not overlap. If a
        /// value doesn't correspond to any such interval, the associated frequency
        /// is zero. For example, the following records:
        /// {min_probability: 0, max_probability: 0.1, frequency: 17}
        /// {min_probability: 0.2, max_probability: 0.3, frequency: 42}
        /// {min_probability: 0.3, max_probability: 0.4, frequency: 99}
        /// mean that there are no record with an estimated probability in [0.1, 0.2)
        /// nor larger or equal to 0.4.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub delta_presence_estimation_histogram: std::vec::Vec<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket>,
    }

    impl DeltaPresenceEstimationResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [delta_presence_estimation_histogram][crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult::delta_presence_estimation_histogram].
        pub fn set_delta_presence_estimation_histogram<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket>
        {
            use std::iter::Iterator;
            self.delta_presence_estimation_histogram = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DeltaPresenceEstimationResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult"
        }
    }

    /// Defines additional types related to DeltaPresenceEstimationResult
    pub mod delta_presence_estimation_result {
        #[allow(unused_imports)]
        use super::*;

        /// A tuple of values for the quasi-identifier columns.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DeltaPresenceEstimationQuasiIdValues {
            /// The quasi-identifier values.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub quasi_ids_values: std::vec::Vec<crate::model::Value>,

            /// The estimated probability that a given individual sharing these
            /// quasi-identifier values is in the dataset. This value, typically
            /// called , is the ratio between the number of records in the dataset
            /// with these quasi-identifier values, and the total number of individuals
            /// (inside *and* outside the dataset) with these quasi-identifier values.
            /// For example, if there are 15 individuals in the dataset who share the
            /// same quasi-identifier values, and an estimated 100 people in the entire
            /// population with these values, then  is 0.15.
            pub estimated_probability: f64,
        }

        impl DeltaPresenceEstimationQuasiIdValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [estimated_probability][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues::estimated_probability].
            pub fn set_estimated_probability<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.estimated_probability = v.into();
                self
            }

            /// Sets the value of [quasi_ids_values][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues::quasi_ids_values].
            pub fn set_quasi_ids_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Value>,
            {
                use std::iter::Iterator;
                self.quasi_ids_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for DeltaPresenceEstimationQuasiIdValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationQuasiIdValues"
            }
        }

        /// A DeltaPresenceEstimationHistogramBucket message with the following
        /// values:
        /// min_probability: 0.1
        /// max_probability: 0.2
        /// frequency: 42
        /// means that there are 42 records for which  is in [0.1, 0.2). An
        /// important particular case is when min_probability = max_probability = 1:
        /// then, every individual who shares this quasi-identifier combination is in
        /// the dataset.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DeltaPresenceEstimationHistogramBucket {

            /// Between 0 and 1.
            pub min_probability: f64,

            /// Always greater than or equal to min_probability.
            pub max_probability: f64,

            /// Number of records within these probability bounds.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_size: i64,

            /// Sample of quasi-identifier tuple values in this bucket. The total
            /// number of classes returned per bucket is capped at 20.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub bucket_values: std::vec::Vec<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues>,

            /// Total number of distinct quasi-identifier tuple values in this bucket.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub bucket_value_count: i64,
        }

        impl DeltaPresenceEstimationHistogramBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_probability][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::min_probability].
            pub fn set_min_probability<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.min_probability = v.into();
                self
            }

            /// Sets the value of [max_probability][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::max_probability].
            pub fn set_max_probability<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.max_probability = v.into();
                self
            }

            /// Sets the value of [bucket_size][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::bucket_size].
            pub fn set_bucket_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_size = v.into();
                self
            }

            /// Sets the value of [bucket_value_count][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::bucket_value_count].
            pub fn set_bucket_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.bucket_value_count = v.into();
                self
            }

            /// Sets the value of [bucket_values][crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationHistogramBucket::bucket_values].
            pub fn set_bucket_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::analyze_data_source_risk_details::delta_presence_estimation_result::DeltaPresenceEstimationQuasiIdValues>
            {
                use std::iter::Iterator;
                self.bucket_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for DeltaPresenceEstimationHistogramBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationHistogramBucket"
            }
        }
    }

    /// Risk analysis options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RequestedRiskAnalysisOptions {
        /// The job config for the risk job.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub job_config: std::option::Option<crate::model::RiskAnalysisJobConfig>,
    }

    impl RequestedRiskAnalysisOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [job_config][crate::model::analyze_data_source_risk_details::RequestedRiskAnalysisOptions::job_config].
        pub fn set_job_config<
            T: std::convert::Into<std::option::Option<crate::model::RiskAnalysisJobConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.job_config = v.into();
            self
        }
    }

    impl wkt::message::Message for RequestedRiskAnalysisOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.AnalyzeDataSourceRiskDetails.RequestedRiskAnalysisOptions"
        }
    }

    /// Values associated with this metric.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// Numerical stats result
        NumericalStatsResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::NumericalStatsResult>,
        ),
        /// Categorical stats result
        CategoricalStatsResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::CategoricalStatsResult>,
        ),
        /// K-anonymity result
        KAnonymityResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::KAnonymityResult>,
        ),
        /// L-divesity result
        LDiversityResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::LDiversityResult>,
        ),
        /// K-map result
        KMapEstimationResult(
            std::boxed::Box<crate::model::analyze_data_source_risk_details::KMapEstimationResult>,
        ),
        /// Delta-presence result
        DeltaPresenceEstimationResult(
            std::boxed::Box<
                crate::model::analyze_data_source_risk_details::DeltaPresenceEstimationResult,
            >,
        ),
    }
}

/// A value of a field, including its frequency.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValueFrequency {
    /// A value contained in the field in question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::Value>,

    /// How many times the value is contained in the field.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub count: i64,
}

impl ValueFrequency {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::ValueFrequency::value].
    pub fn set_value<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [count][crate::model::ValueFrequency::count].
    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.count = v.into();
        self
    }
}

impl wkt::message::Message for ValueFrequency {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ValueFrequency"
    }
}

/// Set of primitive values supported by the system.
/// Note that for the purposes of inspection or transformation, the number
/// of bytes considered to comprise a 'Value' is based on its representation
/// as a UTF-8 encoded string. For example, if 'integer_value' is set to
/// 123456789, the number of bytes would be counted as 9, even though an
/// int64 only holds up to 8 bytes of data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Value {
    /// Value types
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::value::Type>,
}

impl Value {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `r#type`.
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::value::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `IntegerValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_integer_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::IntegerValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `FloatValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_float_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::FloatValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `BooleanValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_boolean_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::BooleanValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `TimestampValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_timestamp_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::TimestampValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `TimeValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_time_value(&self) -> std::option::Option<&std::boxed::Box<gtype::model::TimeOfDay>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::TimeValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `DateValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_date_value(&self) -> std::option::Option<&std::boxed::Box<gtype::model::Date>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::DateValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::Value::r#type]
    /// if it holds a `DayOfWeekValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_day_of_week_value(&self) -> std::option::Option<&gtype::model::DayOfWeek> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::value::Type::DayOfWeekValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `IntegerValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_integer_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::IntegerValue(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `FloatValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_float_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::FloatValue(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::StringValue(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `BooleanValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_boolean_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::BooleanValue(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `TimestampValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_timestamp_value<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::value::Type::TimestampValue(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `TimeValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_time_value<T: std::convert::Into<std::boxed::Box<gtype::model::TimeOfDay>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::TimeValue(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `DateValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_date_value<T: std::convert::Into<std::boxed::Box<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(crate::model::value::Type::DateValue(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::Value::r#type]
    /// to hold a `DayOfWeekValue`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_day_of_week_value<T: std::convert::Into<gtype::model::DayOfWeek>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::value::Type::DayOfWeekValue(v.into()));
        self
    }
}

impl wkt::message::Message for Value {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Value"
    }
}

/// Defines additional types related to Value
pub mod value {
    #[allow(unused_imports)]
    use super::*;

    /// Value types
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// integer
        IntegerValue(i64),
        /// float
        FloatValue(f64),
        /// string
        StringValue(std::string::String),
        /// boolean
        BooleanValue(bool),
        /// timestamp
        TimestampValue(std::boxed::Box<wkt::Timestamp>),
        /// time of day
        TimeValue(std::boxed::Box<gtype::model::TimeOfDay>),
        /// date
        DateValue(std::boxed::Box<gtype::model::Date>),
        /// day of week
        DayOfWeekValue(gtype::model::DayOfWeek),
    }
}

/// Message for infoType-dependent details parsed from quote.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuoteInfo {
    /// Object representation of the quote.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub parsed_quote: std::option::Option<crate::model::quote_info::ParsedQuote>,
}

impl QuoteInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `parsed_quote`.
    pub fn set_parsed_quote<
        T: std::convert::Into<std::option::Option<crate::model::quote_info::ParsedQuote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parsed_quote = v.into();
        self
    }

    /// The value of [parsed_quote][crate::model::QuoteInfo::parsed_quote]
    /// if it holds a `DateTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_date_time(&self) -> std::option::Option<&std::boxed::Box<crate::model::DateTime>> {
        #[allow(unreachable_patterns)]
        self.parsed_quote.as_ref().and_then(|v| match v {
            crate::model::quote_info::ParsedQuote::DateTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [parsed_quote][crate::model::QuoteInfo::parsed_quote]
    /// to hold a `DateTime`.
    ///
    /// Note that all the setters affecting `parsed_quote` are
    /// mutually exclusive.
    pub fn set_date_time<T: std::convert::Into<std::boxed::Box<crate::model::DateTime>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parsed_quote =
            std::option::Option::Some(crate::model::quote_info::ParsedQuote::DateTime(v.into()));
        self
    }
}

impl wkt::message::Message for QuoteInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.QuoteInfo"
    }
}

/// Defines additional types related to QuoteInfo
pub mod quote_info {
    #[allow(unused_imports)]
    use super::*;

    /// Object representation of the quote.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ParsedQuote {
        /// The date time indicated by the quote.
        DateTime(std::boxed::Box<crate::model::DateTime>),
    }
}

/// Message for a date time object.
/// e.g. 2018-01-01, 5th August.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DateTime {
    /// One or more of the following must be set.
    /// Must be a valid date or time value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub date: std::option::Option<gtype::model::Date>,

    /// Day of week
    pub day_of_week: gtype::model::DayOfWeek,

    /// Time of day
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time: std::option::Option<gtype::model::TimeOfDay>,

    /// Time zone
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_zone: std::option::Option<crate::model::date_time::TimeZone>,
}

impl DateTime {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [date][crate::model::DateTime::date].
    pub fn set_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.date = v.into();
        self
    }

    /// Sets the value of [day_of_week][crate::model::DateTime::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }

    /// Sets the value of [time][crate::model::DateTime::time].
    pub fn set_time<T: std::convert::Into<std::option::Option<gtype::model::TimeOfDay>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::DateTime::time_zone].
    pub fn set_time_zone<
        T: std::convert::Into<std::option::Option<crate::model::date_time::TimeZone>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_zone = v.into();
        self
    }
}

impl wkt::message::Message for DateTime {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DateTime"
    }
}

/// Defines additional types related to DateTime
pub mod date_time {
    #[allow(unused_imports)]
    use super::*;

    /// Time zone of the date time object.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TimeZone {
        /// Set only if the offset can be determined. Positive for time ahead of UTC.
        /// E.g. For "UTC-9", this value is -540.
        pub offset_minutes: i32,
    }

    impl TimeZone {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [offset_minutes][crate::model::date_time::TimeZone::offset_minutes].
        pub fn set_offset_minutes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.offset_minutes = v.into();
            self
        }
    }

    impl wkt::message::Message for TimeZone {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DateTime.TimeZone"
        }
    }
}

/// The configuration that controls how the data will change.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyConfig {
    /// Mode for handling transformation errors. If left unspecified, the default
    /// mode is `TransformationErrorHandling.ThrowError`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transformation_error_handling:
        std::option::Option<crate::model::TransformationErrorHandling>,

    /// Type of transformation
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub transformation: std::option::Option<crate::model::deidentify_config::Transformation>,
}

impl DeidentifyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformation_error_handling][crate::model::DeidentifyConfig::transformation_error_handling].
    pub fn set_transformation_error_handling<
        T: std::convert::Into<std::option::Option<crate::model::TransformationErrorHandling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation_error_handling = v.into();
        self
    }

    /// Sets the value of `transformation`.
    pub fn set_transformation<
        T: std::convert::Into<std::option::Option<crate::model::deidentify_config::Transformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = v.into();
        self
    }

    /// The value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// if it holds a `InfoTypeTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_info_type_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InfoTypeTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::deidentify_config::Transformation::InfoTypeTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// if it holds a `RecordTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_record_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecordTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::deidentify_config::Transformation::RecordTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// if it holds a `ImageTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_image_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImageTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::deidentify_config::Transformation::ImageTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// to hold a `InfoTypeTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_info_type_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::InfoTypeTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::deidentify_config::Transformation::InfoTypeTransformations(v.into()),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// to hold a `RecordTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_record_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::RecordTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::deidentify_config::Transformation::RecordTransformations(v.into()),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::DeidentifyConfig::transformation]
    /// to hold a `ImageTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_image_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::ImageTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::deidentify_config::Transformation::ImageTransformations(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DeidentifyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyConfig"
    }
}

/// Defines additional types related to DeidentifyConfig
pub mod deidentify_config {
    #[allow(unused_imports)]
    use super::*;

    /// Type of transformation
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Transformation {
        /// Treat the dataset as free-form text and apply the same free text
        /// transformation everywhere.
        InfoTypeTransformations(std::boxed::Box<crate::model::InfoTypeTransformations>),
        /// Treat the dataset as structured. Transformations can be applied to
        /// specific locations within structured datasets, such as transforming
        /// a column within a table.
        RecordTransformations(std::boxed::Box<crate::model::RecordTransformations>),
        /// Treat the dataset as an image and redact.
        ImageTransformations(std::boxed::Box<crate::model::ImageTransformations>),
    }
}

/// A type of transformation that is applied over images.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImageTransformations {
    /// List of transforms to make.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub transforms: std::vec::Vec<crate::model::image_transformations::ImageTransformation>,
}

impl ImageTransformations {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transforms][crate::model::ImageTransformations::transforms].
    pub fn set_transforms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::image_transformations::ImageTransformation>,
    {
        use std::iter::Iterator;
        self.transforms = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImageTransformations {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations"
    }
}

/// Defines additional types related to ImageTransformations
pub mod image_transformations {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for determining how redaction of images should occur.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImageTransformation {
        /// The color to use when redacting content from an image. If not
        /// specified, the default is black.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub redaction_color: std::option::Option<crate::model::Color>,

        /// Part of the image to transform.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub target:
            std::option::Option<crate::model::image_transformations::image_transformation::Target>,
    }

    impl ImageTransformation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [redaction_color][crate::model::image_transformations::ImageTransformation::redaction_color].
        pub fn set_redaction_color<
            T: std::convert::Into<std::option::Option<crate::model::Color>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.redaction_color = v.into();
            self
        }

        /// Sets the value of `target`.
        pub fn set_target<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::image_transformations::image_transformation::Target,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = v.into();
            self
        }

        /// The value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// if it holds a `SelectedInfoTypes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_selected_info_types(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::image_transformations::image_transformation::SelectedInfoTypes,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::image_transformations::image_transformation::Target::SelectedInfoTypes(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// if it holds a `AllInfoTypes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_all_info_types(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::image_transformations::image_transformation::AllInfoTypes,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::image_transformations::image_transformation::Target::AllInfoTypes(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// if it holds a `AllText`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_all_text(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::image_transformations::image_transformation::AllText>,
        > {
            #[allow(unreachable_patterns)]
            self.target.as_ref().and_then(|v| match v {
                crate::model::image_transformations::image_transformation::Target::AllText(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// to hold a `SelectedInfoTypes`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_selected_info_types<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::image_transformations::image_transformation::SelectedInfoTypes,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = std::option::Option::Some(
                crate::model::image_transformations::image_transformation::Target::SelectedInfoTypes(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// to hold a `AllInfoTypes`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_all_info_types<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::image_transformations::image_transformation::AllInfoTypes,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = std::option::Option::Some(
                crate::model::image_transformations::image_transformation::Target::AllInfoTypes(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [target][crate::model::image_transformations::ImageTransformation::target]
        /// to hold a `AllText`.
        ///
        /// Note that all the setters affecting `target` are
        /// mutually exclusive.
        pub fn set_all_text<
            T: std::convert::Into<
                std::boxed::Box<crate::model::image_transformations::image_transformation::AllText>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target = std::option::Option::Some(
                crate::model::image_transformations::image_transformation::Target::AllText(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for ImageTransformation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation"
        }
    }

    /// Defines additional types related to ImageTransformation
    pub mod image_transformation {
        #[allow(unused_imports)]
        use super::*;

        /// Apply transformation to the selected info_types.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SelectedInfoTypes {
            /// Required. InfoTypes to apply the transformation to. Required. Provided
            /// InfoType must be unique within the ImageTransformations message.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub info_types: std::vec::Vec<crate::model::InfoType>,
        }

        impl SelectedInfoTypes {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [info_types][crate::model::image_transformations::image_transformation::SelectedInfoTypes::info_types].
            pub fn set_info_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::InfoType>,
            {
                use std::iter::Iterator;
                self.info_types = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for SelectedInfoTypes {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation.SelectedInfoTypes"
            }
        }

        /// Apply transformation to all findings.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AllInfoTypes {}

        impl AllInfoTypes {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for AllInfoTypes {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation.AllInfoTypes"
            }
        }

        /// Apply to all text.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AllText {}

        impl AllText {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for AllText {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.ImageTransformations.ImageTransformation.AllText"
            }
        }

        /// Part of the image to transform.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Target {
            /// Apply transformation to the selected info_types.
            SelectedInfoTypes(
                std::boxed::Box<
                    crate::model::image_transformations::image_transformation::SelectedInfoTypes,
                >,
            ),
            /// Apply transformation to all findings not specified in other
            /// ImageTransformation's selected_info_types. Only one instance is allowed
            /// within the ImageTransformations message.
            AllInfoTypes(
                std::boxed::Box<
                    crate::model::image_transformations::image_transformation::AllInfoTypes,
                >,
            ),
            /// Apply transformation to all text that doesn't match an infoType. Only
            /// one instance is allowed within the ImageTransformations message.
            AllText(
                std::boxed::Box<crate::model::image_transformations::image_transformation::AllText>,
            ),
        }
    }
}

/// How to handle transformation errors during de-identification. A
/// transformation error occurs when the requested transformation is incompatible
/// with the data. For example, trying to de-identify an IP address using a
/// `DateShift` transformation would result in a transformation error, since date
/// info cannot be extracted from an IP address.
/// Information about any incompatible transformations, and how they were
/// handled, is returned in the response as part of the
/// `TransformationOverviews`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationErrorHandling {
    /// How transformation errors should be handled.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub mode: std::option::Option<crate::model::transformation_error_handling::Mode>,
}

impl TransformationErrorHandling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `mode`.
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::transformation_error_handling::Mode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::TransformationErrorHandling::mode]
    /// if it holds a `ThrowError`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_throw_error(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::transformation_error_handling::ThrowError>,
    > {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::transformation_error_handling::Mode::ThrowError(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [mode][crate::model::TransformationErrorHandling::mode]
    /// if it holds a `LeaveUntransformed`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_leave_untransformed(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::transformation_error_handling::LeaveUntransformed>,
    > {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::transformation_error_handling::Mode::LeaveUntransformed(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::TransformationErrorHandling::mode]
    /// to hold a `ThrowError`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_throw_error<
        T: std::convert::Into<
            std::boxed::Box<crate::model::transformation_error_handling::ThrowError>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::transformation_error_handling::Mode::ThrowError(v.into()),
        );
        self
    }

    /// Sets the value of [mode][crate::model::TransformationErrorHandling::mode]
    /// to hold a `LeaveUntransformed`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_leave_untransformed<
        T: std::convert::Into<
            std::boxed::Box<crate::model::transformation_error_handling::LeaveUntransformed>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::transformation_error_handling::Mode::LeaveUntransformed(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TransformationErrorHandling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationErrorHandling"
    }
}

/// Defines additional types related to TransformationErrorHandling
pub mod transformation_error_handling {
    #[allow(unused_imports)]
    use super::*;

    /// Throw an error and fail the request when a transformation error occurs.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThrowError {}

    impl ThrowError {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for ThrowError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.TransformationErrorHandling.ThrowError"
        }
    }

    /// Skips the data without modifying it if the requested transformation would
    /// cause an error. For example, if a `DateShift` transformation were applied
    /// an an IP address, this mode would leave the IP address unchanged in the
    /// response.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LeaveUntransformed {}

    impl LeaveUntransformed {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for LeaveUntransformed {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.TransformationErrorHandling.LeaveUntransformed"
        }
    }

    /// How transformation errors should be handled.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Mode {
        /// Throw an error
        ThrowError(std::boxed::Box<crate::model::transformation_error_handling::ThrowError>),
        /// Ignore errors
        LeaveUntransformed(
            std::boxed::Box<crate::model::transformation_error_handling::LeaveUntransformed>,
        ),
    }
}

/// A rule for transforming a value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrimitiveTransformation {
    /// Type of transformation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub transformation: std::option::Option<crate::model::primitive_transformation::Transformation>,
}

impl PrimitiveTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `transformation`.
    pub fn set_transformation<
        T: std::convert::Into<
            std::option::Option<crate::model::primitive_transformation::Transformation>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = v.into();
        self
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `ReplaceConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_replace_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplaceValueConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::ReplaceConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `RedactConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_redact_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RedactConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::RedactConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CharacterMaskConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_character_mask_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CharacterMaskConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CharacterMaskConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CryptoReplaceFfxFpeConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_crypto_replace_ffx_fpe_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CryptoReplaceFfxFpeConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CryptoReplaceFfxFpeConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `FixedSizeBucketingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_fixed_size_bucketing_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FixedSizeBucketingConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::FixedSizeBucketingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `BucketingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bucketing_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BucketingConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::BucketingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `ReplaceWithInfoTypeConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_replace_with_info_type_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplaceWithInfoTypeConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::ReplaceWithInfoTypeConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `TimePartConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_time_part_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimePartConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::TimePartConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CryptoHashConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_crypto_hash_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CryptoHashConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CryptoHashConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `DateShiftConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_date_shift_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DateShiftConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::DateShiftConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `CryptoDeterministicConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_crypto_deterministic_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CryptoDeterministicConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::CryptoDeterministicConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// if it holds a `ReplaceDictionaryConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_replace_dictionary_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplaceDictionaryConfig>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::primitive_transformation::Transformation::ReplaceDictionaryConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `ReplaceConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_replace_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplaceValueConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::ReplaceConfig(v.into()),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `RedactConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_redact_config<T: std::convert::Into<std::boxed::Box<crate::model::RedactConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::RedactConfig(v.into()),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CharacterMaskConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_character_mask_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CharacterMaskConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CharacterMaskConfig(v.into()),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CryptoReplaceFfxFpeConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_crypto_replace_ffx_fpe_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CryptoReplaceFfxFpeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CryptoReplaceFfxFpeConfig(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `FixedSizeBucketingConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_fixed_size_bucketing_config<
        T: std::convert::Into<std::boxed::Box<crate::model::FixedSizeBucketingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::FixedSizeBucketingConfig(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `BucketingConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_bucketing_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BucketingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::BucketingConfig(v.into()),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `ReplaceWithInfoTypeConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_replace_with_info_type_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplaceWithInfoTypeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::ReplaceWithInfoTypeConfig(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `TimePartConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_time_part_config<
        T: std::convert::Into<std::boxed::Box<crate::model::TimePartConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::TimePartConfig(v.into()),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CryptoHashConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_crypto_hash_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CryptoHashConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CryptoHashConfig(v.into()),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `DateShiftConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_date_shift_config<
        T: std::convert::Into<std::boxed::Box<crate::model::DateShiftConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::DateShiftConfig(v.into()),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `CryptoDeterministicConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_crypto_deterministic_config<
        T: std::convert::Into<std::boxed::Box<crate::model::CryptoDeterministicConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::CryptoDeterministicConfig(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::PrimitiveTransformation::transformation]
    /// to hold a `ReplaceDictionaryConfig`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_replace_dictionary_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplaceDictionaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::primitive_transformation::Transformation::ReplaceDictionaryConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for PrimitiveTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.PrimitiveTransformation"
    }
}

/// Defines additional types related to PrimitiveTransformation
pub mod primitive_transformation {
    #[allow(unused_imports)]
    use super::*;

    /// Type of transformation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Transformation {
        /// Replace with a specified value.
        ReplaceConfig(std::boxed::Box<crate::model::ReplaceValueConfig>),
        /// Redact
        RedactConfig(std::boxed::Box<crate::model::RedactConfig>),
        /// Mask
        CharacterMaskConfig(std::boxed::Box<crate::model::CharacterMaskConfig>),
        /// Ffx-Fpe. Strongly discouraged, consider using CryptoDeterministicConfig
        /// instead. Fpe is computationally expensive incurring latency costs.
        CryptoReplaceFfxFpeConfig(std::boxed::Box<crate::model::CryptoReplaceFfxFpeConfig>),
        /// Fixed size bucketing
        FixedSizeBucketingConfig(std::boxed::Box<crate::model::FixedSizeBucketingConfig>),
        /// Bucketing
        BucketingConfig(std::boxed::Box<crate::model::BucketingConfig>),
        /// Replace with infotype
        ReplaceWithInfoTypeConfig(std::boxed::Box<crate::model::ReplaceWithInfoTypeConfig>),
        /// Time extraction
        TimePartConfig(std::boxed::Box<crate::model::TimePartConfig>),
        /// Crypto
        CryptoHashConfig(std::boxed::Box<crate::model::CryptoHashConfig>),
        /// Date Shift
        DateShiftConfig(std::boxed::Box<crate::model::DateShiftConfig>),
        /// Deterministic Crypto
        CryptoDeterministicConfig(std::boxed::Box<crate::model::CryptoDeterministicConfig>),
        /// Replace with a value randomly drawn (with replacement) from a dictionary.
        ReplaceDictionaryConfig(std::boxed::Box<crate::model::ReplaceDictionaryConfig>),
    }
}

/// For use with `Date`, `Timestamp`, and `TimeOfDay`, extract or preserve a
/// portion of the value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimePartConfig {
    /// The part of the time to keep.
    pub part_to_extract: crate::model::time_part_config::TimePart,
}

impl TimePartConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [part_to_extract][crate::model::TimePartConfig::part_to_extract].
    pub fn set_part_to_extract<T: std::convert::Into<crate::model::time_part_config::TimePart>>(
        mut self,
        v: T,
    ) -> Self {
        self.part_to_extract = v.into();
        self
    }
}

impl wkt::message::Message for TimePartConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TimePartConfig"
    }
}

/// Defines additional types related to TimePartConfig
pub mod time_part_config {
    #[allow(unused_imports)]
    use super::*;

    /// Components that make up time.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TimePart(i32);

    impl TimePart {
        /// Unused
        pub const TIME_PART_UNSPECIFIED: TimePart = TimePart::new(0);

        /// [0-9999]
        pub const YEAR: TimePart = TimePart::new(1);

        /// [1-12]
        pub const MONTH: TimePart = TimePart::new(2);

        /// [1-31]
        pub const DAY_OF_MONTH: TimePart = TimePart::new(3);

        /// [1-7]
        pub const DAY_OF_WEEK: TimePart = TimePart::new(4);

        /// [1-53]
        pub const WEEK_OF_YEAR: TimePart = TimePart::new(5);

        /// [0-23]
        pub const HOUR_OF_DAY: TimePart = TimePart::new(6);

        /// Creates a new TimePart instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TIME_PART_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("YEAR"),
                2 => std::borrow::Cow::Borrowed("MONTH"),
                3 => std::borrow::Cow::Borrowed("DAY_OF_MONTH"),
                4 => std::borrow::Cow::Borrowed("DAY_OF_WEEK"),
                5 => std::borrow::Cow::Borrowed("WEEK_OF_YEAR"),
                6 => std::borrow::Cow::Borrowed("HOUR_OF_DAY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TIME_PART_UNSPECIFIED" => std::option::Option::Some(Self::TIME_PART_UNSPECIFIED),
                "YEAR" => std::option::Option::Some(Self::YEAR),
                "MONTH" => std::option::Option::Some(Self::MONTH),
                "DAY_OF_MONTH" => std::option::Option::Some(Self::DAY_OF_MONTH),
                "DAY_OF_WEEK" => std::option::Option::Some(Self::DAY_OF_WEEK),
                "WEEK_OF_YEAR" => std::option::Option::Some(Self::WEEK_OF_YEAR),
                "HOUR_OF_DAY" => std::option::Option::Some(Self::HOUR_OF_DAY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TimePart {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TimePart {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Pseudonymization method that generates surrogates via cryptographic hashing.
/// Uses SHA-256.
/// The key size must be either 32 or 64 bytes.
/// Outputs a base64 encoded representation of the hashed output
/// (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
/// Currently, only string and integer values can be hashed.
/// See <https://cloud.google.com/sensitive-data-protection/docs/pseudonymization>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoHashConfig {
    /// The key used by the hash function.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,
}

impl CryptoHashConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key][crate::model::CryptoHashConfig::crypto_key].
    pub fn set_crypto_key<T: std::convert::Into<std::option::Option<crate::model::CryptoKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key = v.into();
        self
    }
}

impl wkt::message::Message for CryptoHashConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoHashConfig"
    }
}

/// Pseudonymization method that generates deterministic encryption for the given
/// input. Outputs a base64 encoded representation of the encrypted output.
/// Uses AES-SIV based on the RFC <https://tools.ietf.org/html/rfc5297>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoDeterministicConfig {
    /// The key used by the encryption function. For deterministic encryption
    /// using AES-SIV, the provided key is internally expanded to 64 bytes prior to
    /// use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    /// The custom info type to annotate the surrogate with.
    /// This annotation will be applied to the surrogate by prefixing it with
    /// the name of the custom info type followed by the number of
    /// characters comprising the surrogate. The following scheme defines the
    /// format: {info type name}({surrogate character count}):{surrogate}
    ///
    /// For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and
    /// the surrogate is 'abc', the full replacement value
    /// will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    ///
    /// This annotation identifies the surrogate when inspecting content using the
    /// custom info type 'Surrogate'. This facilitates reversal of the
    /// surrogate when it occurs in free text.
    ///
    /// Note: For record transformations where the entire cell in a table is being
    /// transformed, surrogates are not mandatory. Surrogates are used to denote
    /// the location of the token and are necessary for re-identification in free
    /// form text.
    ///
    /// In order for inspection to work properly, the name of this info type must
    /// not occur naturally anywhere in your data; otherwise, inspection may either
    ///
    /// - reverse a surrogate that does not correspond to an actual identifier
    /// - be unable to parse the surrogate and result in an error
    ///
    /// Therefore, choose your custom info type name carefully after considering
    /// what your data looks like. One way to select a name that has a high chance
    /// of yielding reliable detection is to include one or more unicode characters
    /// that are highly improbable to exist in your data.
    /// For example, assuming your data is entered from a regular ASCII keyboard,
    /// the symbol with the hex code point 29DD might be used like so:
    /// MY_TOKEN_TYPE.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub surrogate_info_type: std::option::Option<crate::model::InfoType>,

    /// A context may be used for higher security and maintaining
    /// referential integrity such that the same identifier in two different
    /// contexts will be given a distinct surrogate. The context is appended to
    /// plaintext value being encrypted. On decryption the provided context is
    /// validated against the value used during encryption. If a context was
    /// provided during encryption, same context must be provided during decryption
    /// as well.
    ///
    /// If the context is not set, plaintext would be used as is for encryption.
    /// If the context is set but:
    ///
    /// . there is no record present when transforming a given value or
    /// . the field is not present when transforming a given value,
    ///
    /// plaintext would be used as is for encryption.
    ///
    /// Note that case (1) is expected when an `InfoTypeTransformation` is
    /// applied to both structured and unstructured `ContentItem`s.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::FieldId>,
}

impl CryptoDeterministicConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key][crate::model::CryptoDeterministicConfig::crypto_key].
    pub fn set_crypto_key<T: std::convert::Into<std::option::Option<crate::model::CryptoKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key = v.into();
        self
    }

    /// Sets the value of [surrogate_info_type][crate::model::CryptoDeterministicConfig::surrogate_info_type].
    pub fn set_surrogate_info_type<
        T: std::convert::Into<std::option::Option<crate::model::InfoType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.surrogate_info_type = v.into();
        self
    }

    /// Sets the value of [context][crate::model::CryptoDeterministicConfig::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }
}

impl wkt::message::Message for CryptoDeterministicConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoDeterministicConfig"
    }
}

/// Replace each input value with a given `Value`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplaceValueConfig {
    /// Value to replace it with.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub new_value: std::option::Option<crate::model::Value>,
}

impl ReplaceValueConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_value][crate::model::ReplaceValueConfig::new_value].
    pub fn set_new_value<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_value = v.into();
        self
    }
}

impl wkt::message::Message for ReplaceValueConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReplaceValueConfig"
    }
}

/// Replace each input value with a value randomly selected from the dictionary.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplaceDictionaryConfig {
    /// Type of dictionary.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::replace_dictionary_config::Type>,
}

impl ReplaceDictionaryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `r#type`.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::replace_dictionary_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::ReplaceDictionaryConfig::r#type]
    /// if it holds a `WordList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_word_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>>
    {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::replace_dictionary_config::Type::WordList(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::ReplaceDictionaryConfig::r#type]
    /// to hold a `WordList`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_word_list<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::replace_dictionary_config::Type::WordList(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ReplaceDictionaryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReplaceDictionaryConfig"
    }
}

/// Defines additional types related to ReplaceDictionaryConfig
pub mod replace_dictionary_config {
    #[allow(unused_imports)]
    use super::*;

    /// Type of dictionary.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// A list of words to select from for random replacement. The
        /// [limits](https://cloud.google.com/sensitive-data-protection/limits) page
        /// contains details about the size limits of dictionaries.
        WordList(std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>),
    }
}

/// Replace each matching finding with the name of the info_type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplaceWithInfoTypeConfig {}

impl ReplaceWithInfoTypeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ReplaceWithInfoTypeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ReplaceWithInfoTypeConfig"
    }
}

/// Redact a given value. For example, if used with an `InfoTypeTransformation`
/// transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the
/// output would be 'My phone number is '.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RedactConfig {}

impl RedactConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RedactConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RedactConfig"
    }
}

/// Characters to skip when doing deidentification of a value. These will be left
/// alone and skipped.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CharsToIgnore {
    /// Type of characters to skip.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub characters: std::option::Option<crate::model::chars_to_ignore::Characters>,
}

impl CharsToIgnore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `characters`.
    pub fn set_characters<
        T: std::convert::Into<std::option::Option<crate::model::chars_to_ignore::Characters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.characters = v.into();
        self
    }

    /// The value of [characters][crate::model::CharsToIgnore::characters]
    /// if it holds a `CharactersToSkip`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_characters_to_skip(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.characters.as_ref().and_then(|v| match v {
            crate::model::chars_to_ignore::Characters::CharactersToSkip(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [characters][crate::model::CharsToIgnore::characters]
    /// if it holds a `CommonCharactersToIgnore`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_common_characters_to_ignore(
        &self,
    ) -> std::option::Option<&crate::model::chars_to_ignore::CommonCharsToIgnore> {
        #[allow(unreachable_patterns)]
        self.characters.as_ref().and_then(|v| match v {
            crate::model::chars_to_ignore::Characters::CommonCharactersToIgnore(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [characters][crate::model::CharsToIgnore::characters]
    /// to hold a `CharactersToSkip`.
    ///
    /// Note that all the setters affecting `characters` are
    /// mutually exclusive.
    pub fn set_characters_to_skip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.characters = std::option::Option::Some(
            crate::model::chars_to_ignore::Characters::CharactersToSkip(v.into()),
        );
        self
    }

    /// Sets the value of [characters][crate::model::CharsToIgnore::characters]
    /// to hold a `CommonCharactersToIgnore`.
    ///
    /// Note that all the setters affecting `characters` are
    /// mutually exclusive.
    pub fn set_common_characters_to_ignore<
        T: std::convert::Into<crate::model::chars_to_ignore::CommonCharsToIgnore>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.characters = std::option::Option::Some(
            crate::model::chars_to_ignore::Characters::CommonCharactersToIgnore(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CharsToIgnore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CharsToIgnore"
    }
}

/// Defines additional types related to CharsToIgnore
pub mod chars_to_ignore {
    #[allow(unused_imports)]
    use super::*;

    /// Convenience enum for indicating common characters to not transform.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CommonCharsToIgnore(i32);

    impl CommonCharsToIgnore {
        /// Unused.
        pub const COMMON_CHARS_TO_IGNORE_UNSPECIFIED: CommonCharsToIgnore =
            CommonCharsToIgnore::new(0);

        /// 0-9
        pub const NUMERIC: CommonCharsToIgnore = CommonCharsToIgnore::new(1);

        /// A-Z
        pub const ALPHA_UPPER_CASE: CommonCharsToIgnore = CommonCharsToIgnore::new(2);

        /// a-z
        pub const ALPHA_LOWER_CASE: CommonCharsToIgnore = CommonCharsToIgnore::new(3);

        /// US Punctuation, one of !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
        pub const PUNCTUATION: CommonCharsToIgnore = CommonCharsToIgnore::new(4);

        /// Whitespace character, one of [ \t\n\x0B\f\r]
        pub const WHITESPACE: CommonCharsToIgnore = CommonCharsToIgnore::new(5);

        /// Creates a new CommonCharsToIgnore instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COMMON_CHARS_TO_IGNORE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NUMERIC"),
                2 => std::borrow::Cow::Borrowed("ALPHA_UPPER_CASE"),
                3 => std::borrow::Cow::Borrowed("ALPHA_LOWER_CASE"),
                4 => std::borrow::Cow::Borrowed("PUNCTUATION"),
                5 => std::borrow::Cow::Borrowed("WHITESPACE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COMMON_CHARS_TO_IGNORE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::COMMON_CHARS_TO_IGNORE_UNSPECIFIED)
                }
                "NUMERIC" => std::option::Option::Some(Self::NUMERIC),
                "ALPHA_UPPER_CASE" => std::option::Option::Some(Self::ALPHA_UPPER_CASE),
                "ALPHA_LOWER_CASE" => std::option::Option::Some(Self::ALPHA_LOWER_CASE),
                "PUNCTUATION" => std::option::Option::Some(Self::PUNCTUATION),
                "WHITESPACE" => std::option::Option::Some(Self::WHITESPACE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for CommonCharsToIgnore {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for CommonCharsToIgnore {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of characters to skip.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Characters {
        /// Characters to not transform when masking.
        CharactersToSkip(std::string::String),
        /// Common characters to not transform when masking. Useful to avoid removing
        /// punctuation.
        CommonCharactersToIgnore(crate::model::chars_to_ignore::CommonCharsToIgnore),
    }
}

/// Partially mask a string by replacing a given number of characters with a
/// fixed character. Masking can start from the beginning or end of the string.
/// This can be used on data of any type (numbers, longs, and so on) and when
/// de-identifying structured data we'll attempt to preserve the original data's
/// type. (This allows you to take a long like 123 and modify it to a string like
/// **3.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CharacterMaskConfig {
    /// Character to use to mask the sensitive values&mdash;for example, `*` for an
    /// alphabetic string such as a name, or `0` for a numeric string such as ZIP
    /// code or credit card number. This string must have a length of 1. If not
    /// supplied, this value defaults to `*` for strings, and `0` for digits.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub masking_character: std::string::String,

    /// Number of characters to mask. If not set, all matching chars will be
    /// masked. Skipped characters do not count towards this tally.
    ///
    /// If `number_to_mask` is negative, this denotes inverse masking. Cloud DLP
    /// masks all but a number of characters.
    /// For example, suppose you have the following values:
    ///
    /// - `masking_character` is `*`
    /// - `number_to_mask` is `-4`
    /// - `reverse_order` is `false`
    /// - `CharsToIgnore` includes `-`
    /// - Input string is `1234-5678-9012-3456`
    ///
    /// The resulting de-identified string is
    /// `****-****-****-3456`. Cloud DLP masks all but the last four characters.
    /// If `reverse_order` is `true`, all but the first four characters are masked
    /// as `1234-****-****-****`.
    pub number_to_mask: i32,

    /// Mask characters in reverse order. For example, if `masking_character` is
    /// `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the
    /// input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
    /// If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order`
    /// is `true`, then the string `12345` is masked as `12***`.
    pub reverse_order: bool,

    /// When masking a string, items in this list will be skipped when replacing
    /// characters. For example, if the input string is `555-555-5555` and you
    /// instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP
    /// returns `***-**5-5555`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub characters_to_ignore: std::vec::Vec<crate::model::CharsToIgnore>,
}

impl CharacterMaskConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [masking_character][crate::model::CharacterMaskConfig::masking_character].
    pub fn set_masking_character<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.masking_character = v.into();
        self
    }

    /// Sets the value of [number_to_mask][crate::model::CharacterMaskConfig::number_to_mask].
    pub fn set_number_to_mask<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.number_to_mask = v.into();
        self
    }

    /// Sets the value of [reverse_order][crate::model::CharacterMaskConfig::reverse_order].
    pub fn set_reverse_order<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reverse_order = v.into();
        self
    }

    /// Sets the value of [characters_to_ignore][crate::model::CharacterMaskConfig::characters_to_ignore].
    pub fn set_characters_to_ignore<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CharsToIgnore>,
    {
        use std::iter::Iterator;
        self.characters_to_ignore = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CharacterMaskConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CharacterMaskConfig"
    }
}

/// Buckets values based on fixed size ranges. The
/// Bucketing transformation can provide all of this functionality,
/// but requires more configuration. This message is provided as a convenience to
/// the user for simple bucketing strategies.
///
/// The transformed value will be a hyphenated string of
/// {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound
/// = 20, all values that are within this bucket will be replaced with "10-20".
///
/// This can be used on data of type: double, long.
///
/// If the bound Value type differs from the type of data
/// being transformed, we will first attempt converting the type of the data to
/// be transformed to match the type of the bound before comparing.
///
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-bucketing> to
/// learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FixedSizeBucketingConfig {
    /// Required. Lower bound value of buckets. All values less than `lower_bound`
    /// are grouped together into a single bucket; for example if `lower_bound` =
    /// 10, then all values less than 10 are replaced with the value "-10".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lower_bound: std::option::Option<crate::model::Value>,

    /// Required. Upper bound value of buckets. All values greater than upper_bound
    /// are grouped together into a single bucket; for example if `upper_bound` =
    /// 89, then all values greater than 89 are replaced with the value "89+".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upper_bound: std::option::Option<crate::model::Value>,

    /// Required. Size of each bucket (except for minimum and maximum buckets). So
    /// if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the
    /// following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60,
    /// 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
    pub bucket_size: f64,
}

impl FixedSizeBucketingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lower_bound][crate::model::FixedSizeBucketingConfig::lower_bound].
    pub fn set_lower_bound<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.lower_bound = v.into();
        self
    }

    /// Sets the value of [upper_bound][crate::model::FixedSizeBucketingConfig::upper_bound].
    pub fn set_upper_bound<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.upper_bound = v.into();
        self
    }

    /// Sets the value of [bucket_size][crate::model::FixedSizeBucketingConfig::bucket_size].
    pub fn set_bucket_size<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.bucket_size = v.into();
        self
    }
}

impl wkt::message::Message for FixedSizeBucketingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FixedSizeBucketingConfig"
    }
}

/// Generalization function that buckets values based on ranges. The ranges and
/// replacement values are dynamically provided by the user for custom behavior,
/// such as 1-30 -> LOW, 31-65 -> MEDIUM, 66-100 -> HIGH.
///
/// This can be used on data of type: number, long, string, timestamp.
///
/// If the bound `Value` type differs from the type of data being transformed, we
/// will first attempt converting the type of the data to be transformed to match
/// the type of the bound before comparing.
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-bucketing> to
/// learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BucketingConfig {
    /// Set of buckets. Ranges must be non-overlapping.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub buckets: std::vec::Vec<crate::model::bucketing_config::Bucket>,
}

impl BucketingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [buckets][crate::model::BucketingConfig::buckets].
    pub fn set_buckets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::bucketing_config::Bucket>,
    {
        use std::iter::Iterator;
        self.buckets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BucketingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BucketingConfig"
    }
}

/// Defines additional types related to BucketingConfig
pub mod bucketing_config {
    #[allow(unused_imports)]
    use super::*;

    /// Bucket is represented as a range, along with replacement values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Bucket {
        /// Lower bound of the range, inclusive. Type should be the same as max if
        /// used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min: std::option::Option<crate::model::Value>,

        /// Upper bound of the range, exclusive; type must match min.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max: std::option::Option<crate::model::Value>,

        /// Required. Replacement value for this bucket.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub replacement_value: std::option::Option<crate::model::Value>,
    }

    impl Bucket {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min][crate::model::bucketing_config::Bucket::min].
        pub fn set_min<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min = v.into();
            self
        }

        /// Sets the value of [max][crate::model::bucketing_config::Bucket::max].
        pub fn set_max<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max = v.into();
            self
        }

        /// Sets the value of [replacement_value][crate::model::bucketing_config::Bucket::replacement_value].
        pub fn set_replacement_value<
            T: std::convert::Into<std::option::Option<crate::model::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.replacement_value = v.into();
            self
        }
    }

    impl wkt::message::Message for Bucket {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.BucketingConfig.Bucket"
        }
    }
}

/// Replaces an identifier with a surrogate using Format Preserving Encryption
/// (FPE) with the FFX mode of operation; however when used in the
/// `ReidentifyContent` API method, it serves the opposite function by reversing
/// the surrogate back into the original identifier. The identifier must be
/// encoded as ASCII. For a given crypto key and context, the same identifier
/// will be replaced with the same surrogate. Identifiers must be at least two
/// characters long. In the case that the identifier is the empty string, it will
/// be skipped. See
/// <https://cloud.google.com/sensitive-data-protection/docs/pseudonymization> to
/// learn more.
///
/// Note: We recommend using  CryptoDeterministicConfig for all use cases which
/// do not require preserving the input alphabet space and size, plus warrant
/// referential integrity. FPE incurs significant latency costs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoReplaceFfxFpeConfig {
    /// Required. The key used by the encryption algorithm.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    /// The 'tweak', a context may be used for higher security since the same
    /// identifier in two different contexts won't be given the same surrogate. If
    /// the context is not set, a default tweak will be used.
    ///
    /// If the context is set but:
    ///
    /// . there is no record present when transforming a given value or
    /// . the field is not present when transforming a given value,
    ///
    /// a default tweak will be used.
    ///
    /// Note that case (1) is expected when an `InfoTypeTransformation` is
    /// applied to both structured and unstructured `ContentItem`s.
    /// Currently, the referenced field may be of value type integer or string.
    ///
    /// The tweak is constructed as a sequence of bytes in big endian byte order
    /// such that:
    ///
    /// - a 64 bit integer is encoded followed by a single byte of value 1
    /// - a string is encoded in UTF-8 format followed by a single byte of value 2
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::FieldId>,

    /// The custom infoType to annotate the surrogate with.
    /// This annotation will be applied to the surrogate by prefixing it with
    /// the name of the custom infoType followed by the number of
    /// characters comprising the surrogate. The following scheme defines the
    /// format: info_type_name(surrogate_character_count):surrogate
    ///
    /// For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and
    /// the surrogate is 'abc', the full replacement value
    /// will be: 'MY_TOKEN_INFO_TYPE(3):abc'
    ///
    /// This annotation identifies the surrogate when inspecting content using the
    /// custom infoType
    /// [`SurrogateType`](https://cloud.google.com/sensitive-data-protection/docs/reference/rest/v2/InspectConfig#surrogatetype).
    /// This facilitates reversal of the surrogate when it occurs in free text.
    ///
    /// In order for inspection to work properly, the name of this infoType must
    /// not occur naturally anywhere in your data; otherwise, inspection may
    /// find a surrogate that does not correspond to an actual identifier.
    /// Therefore, choose your custom infoType name carefully after considering
    /// what your data looks like. One way to select a name that has a high chance
    /// of yielding reliable detection is to include one or more unicode characters
    /// that are highly improbable to exist in your data.
    /// For example, assuming your data is entered from a regular ASCII keyboard,
    /// the symbol with the hex code point 29DD might be used like so:
    /// MY_TOKEN_TYPE
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub surrogate_info_type: std::option::Option<crate::model::InfoType>,

    /// Choose an alphabet which the data being transformed will be made up of.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub alphabet: std::option::Option<crate::model::crypto_replace_ffx_fpe_config::Alphabet>,
}

impl CryptoReplaceFfxFpeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key][crate::model::CryptoReplaceFfxFpeConfig::crypto_key].
    pub fn set_crypto_key<T: std::convert::Into<std::option::Option<crate::model::CryptoKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key = v.into();
        self
    }

    /// Sets the value of [context][crate::model::CryptoReplaceFfxFpeConfig::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [surrogate_info_type][crate::model::CryptoReplaceFfxFpeConfig::surrogate_info_type].
    pub fn set_surrogate_info_type<
        T: std::convert::Into<std::option::Option<crate::model::InfoType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.surrogate_info_type = v.into();
        self
    }

    /// Sets the value of `alphabet`.
    pub fn set_alphabet<
        T: std::convert::Into<
            std::option::Option<crate::model::crypto_replace_ffx_fpe_config::Alphabet>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alphabet = v.into();
        self
    }

    /// The value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// if it holds a `CommonAlphabet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_common_alphabet(
        &self,
    ) -> std::option::Option<&crate::model::crypto_replace_ffx_fpe_config::FfxCommonNativeAlphabet>
    {
        #[allow(unreachable_patterns)]
        self.alphabet.as_ref().and_then(|v| match v {
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CommonAlphabet(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// if it holds a `CustomAlphabet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_custom_alphabet(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.alphabet.as_ref().and_then(|v| match v {
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CustomAlphabet(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// if it holds a `Radix`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_radix(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.alphabet.as_ref().and_then(|v| match v {
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::Radix(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// to hold a `CommonAlphabet`.
    ///
    /// Note that all the setters affecting `alphabet` are
    /// mutually exclusive.
    pub fn set_common_alphabet<
        T: std::convert::Into<crate::model::crypto_replace_ffx_fpe_config::FfxCommonNativeAlphabet>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alphabet = std::option::Option::Some(
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CommonAlphabet(v.into()),
        );
        self
    }

    /// Sets the value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// to hold a `CustomAlphabet`.
    ///
    /// Note that all the setters affecting `alphabet` are
    /// mutually exclusive.
    pub fn set_custom_alphabet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.alphabet = std::option::Option::Some(
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::CustomAlphabet(v.into()),
        );
        self
    }

    /// Sets the value of [alphabet][crate::model::CryptoReplaceFfxFpeConfig::alphabet]
    /// to hold a `Radix`.
    ///
    /// Note that all the setters affecting `alphabet` are
    /// mutually exclusive.
    pub fn set_radix<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.alphabet = std::option::Option::Some(
            crate::model::crypto_replace_ffx_fpe_config::Alphabet::Radix(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CryptoReplaceFfxFpeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoReplaceFfxFpeConfig"
    }
}

/// Defines additional types related to CryptoReplaceFfxFpeConfig
pub mod crypto_replace_ffx_fpe_config {
    #[allow(unused_imports)]
    use super::*;

    /// These are commonly used subsets of the alphabet that the FFX mode
    /// natively supports. In the algorithm, the alphabet is selected using
    /// the "radix". Therefore each corresponds to a particular radix.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct FfxCommonNativeAlphabet(i32);

    impl FfxCommonNativeAlphabet {
        /// Unused.
        pub const FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED: FfxCommonNativeAlphabet =
            FfxCommonNativeAlphabet::new(0);

        /// `[0-9]` (radix of 10)
        pub const NUMERIC: FfxCommonNativeAlphabet = FfxCommonNativeAlphabet::new(1);

        /// `[0-9A-F]` (radix of 16)
        pub const HEXADECIMAL: FfxCommonNativeAlphabet = FfxCommonNativeAlphabet::new(2);

        /// `[0-9A-Z]` (radix of 36)
        pub const UPPER_CASE_ALPHA_NUMERIC: FfxCommonNativeAlphabet =
            FfxCommonNativeAlphabet::new(3);

        /// `[0-9A-Za-z]` (radix of 62)
        pub const ALPHA_NUMERIC: FfxCommonNativeAlphabet = FfxCommonNativeAlphabet::new(4);

        /// Creates a new FfxCommonNativeAlphabet instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NUMERIC"),
                2 => std::borrow::Cow::Borrowed("HEXADECIMAL"),
                3 => std::borrow::Cow::Borrowed("UPPER_CASE_ALPHA_NUMERIC"),
                4 => std::borrow::Cow::Borrowed("ALPHA_NUMERIC"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED" => {
                    std::option::Option::Some(Self::FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED)
                }
                "NUMERIC" => std::option::Option::Some(Self::NUMERIC),
                "HEXADECIMAL" => std::option::Option::Some(Self::HEXADECIMAL),
                "UPPER_CASE_ALPHA_NUMERIC" => {
                    std::option::Option::Some(Self::UPPER_CASE_ALPHA_NUMERIC)
                }
                "ALPHA_NUMERIC" => std::option::Option::Some(Self::ALPHA_NUMERIC),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for FfxCommonNativeAlphabet {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for FfxCommonNativeAlphabet {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Choose an alphabet which the data being transformed will be made up of.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Alphabet {
        /// Common alphabets.
        CommonAlphabet(crate::model::crypto_replace_ffx_fpe_config::FfxCommonNativeAlphabet),
        /// This is supported by mapping these to the alphanumeric characters
        /// that the FFX mode natively supports. This happens before/after
        /// encryption/decryption.
        /// Each character listed must appear only once.
        /// Number of characters must be in the range [2, 95].
        /// This must be encoded as ASCII.
        /// The order of characters does not matter.
        /// The full list of allowed characters is:
        /// ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz~`!@#$%^&*()_-+={[}]|\:;"'<,>.?/``
        CustomAlphabet(std::string::String),
        /// The native way to select the alphabet. Must be in the range [2, 95].
        Radix(i32),
    }
}

/// This is a data encryption key (DEK) (as opposed to
/// a key encryption key (KEK) stored by Cloud Key Management Service
/// (Cloud KMS).
/// When using Cloud KMS to wrap or unwrap a DEK, be sure to set an appropriate
/// IAM policy on the KEK to ensure an attacker cannot
/// unwrap the DEK.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoKey {
    /// Sources of crypto keys.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::crypto_key::Source>,
}

impl CryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::crypto_key::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::CryptoKey::source]
    /// if it holds a `Transient`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_transient(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TransientCryptoKey>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::crypto_key::Source::Transient(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::CryptoKey::source]
    /// if it holds a `Unwrapped`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_unwrapped(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UnwrappedCryptoKey>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::crypto_key::Source::Unwrapped(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::CryptoKey::source]
    /// if it holds a `KmsWrapped`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_kms_wrapped(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::KmsWrappedCryptoKey>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::crypto_key::Source::KmsWrapped(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::CryptoKey::source]
    /// to hold a `Transient`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_transient<
        T: std::convert::Into<std::boxed::Box<crate::model::TransientCryptoKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::crypto_key::Source::Transient(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::CryptoKey::source]
    /// to hold a `Unwrapped`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_unwrapped<
        T: std::convert::Into<std::boxed::Box<crate::model::UnwrappedCryptoKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::crypto_key::Source::Unwrapped(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::CryptoKey::source]
    /// to hold a `KmsWrapped`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_kms_wrapped<
        T: std::convert::Into<std::boxed::Box<crate::model::KmsWrappedCryptoKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::crypto_key::Source::KmsWrapped(v.into()));
        self
    }
}

impl wkt::message::Message for CryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CryptoKey"
    }
}

/// Defines additional types related to CryptoKey
pub mod crypto_key {
    #[allow(unused_imports)]
    use super::*;

    /// Sources of crypto keys.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Transient crypto key
        Transient(std::boxed::Box<crate::model::TransientCryptoKey>),
        /// Unwrapped crypto key
        Unwrapped(std::boxed::Box<crate::model::UnwrappedCryptoKey>),
        /// Key wrapped using Cloud KMS
        KmsWrapped(std::boxed::Box<crate::model::KmsWrappedCryptoKey>),
    }
}

/// Use this to have a random data crypto key generated.
/// It will be discarded after the request finishes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransientCryptoKey {
    /// Required. Name of the key.
    /// This is an arbitrary string used to differentiate different keys.
    /// A unique key is generated per name: two separate `TransientCryptoKey`
    /// protos share the same generated key if their names are the same.
    /// When the data crypto key is generated, this name is not used in any way
    /// (repeating the api call will result in a different key being generated).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl TransientCryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransientCryptoKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for TransientCryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransientCryptoKey"
    }
}

/// Using raw keys is prone to security risks due to accidentally
/// leaking the key. Choose another type of key if possible.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UnwrappedCryptoKey {
    /// Required. A 128/192/256 bit key.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub key: ::bytes::Bytes,
}

impl UnwrappedCryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::UnwrappedCryptoKey::key].
    pub fn set_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for UnwrappedCryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UnwrappedCryptoKey"
    }
}

/// Include to use an existing data crypto key wrapped by KMS.
/// The wrapped key must be a 128-, 192-, or 256-bit key.
/// Authorization requires the following IAM permissions when sending a request
/// to perform a crypto transformation using a KMS-wrapped crypto key:
/// dlp.kms.encrypt
///
/// For more information, see [Creating a wrapped key]
/// (<https://cloud.google.com/sensitive-data-protection/docs/create-wrapped-key>).
///
/// Note: When you use Cloud KMS for cryptographic operations,
/// [charges apply](https://cloud.google.com/kms/pricing).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KmsWrappedCryptoKey {
    /// Required. The wrapped data crypto key.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub wrapped_key: ::bytes::Bytes,

    /// Required. The resource name of the KMS CryptoKey to use for unwrapping.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_name: std::string::String,
}

impl KmsWrappedCryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [wrapped_key][crate::model::KmsWrappedCryptoKey::wrapped_key].
    pub fn set_wrapped_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.wrapped_key = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::KmsWrappedCryptoKey::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }
}

impl wkt::message::Message for KmsWrappedCryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.KmsWrappedCryptoKey"
    }
}

/// Shifts dates by random number of days, with option to be consistent for the
/// same context. See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-date-shifting>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DateShiftConfig {
    /// Required. Range of shift in days. Actual shift will be selected at random
    /// within this range (inclusive ends). Negative means shift to earlier in
    /// time. Must not be more than 365250 days (1000 years) each direction.
    ///
    /// For example, 3 means shift date to at most 3 days into the future.
    pub upper_bound_days: i32,

    /// Required. For example, -5 means shift date to at most 5 days back in the
    /// past.
    pub lower_bound_days: i32,

    /// Points to the field that contains the context, for example, an entity id.
    /// If set, must also set cryptoKey. If set, shift will be consistent for the
    /// given context.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::FieldId>,

    /// Method for calculating shift that takes context into consideration. If
    /// set, must also set context. Can only be applied to table items.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub method: std::option::Option<crate::model::date_shift_config::Method>,
}

impl DateShiftConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upper_bound_days][crate::model::DateShiftConfig::upper_bound_days].
    pub fn set_upper_bound_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.upper_bound_days = v.into();
        self
    }

    /// Sets the value of [lower_bound_days][crate::model::DateShiftConfig::lower_bound_days].
    pub fn set_lower_bound_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.lower_bound_days = v.into();
        self
    }

    /// Sets the value of [context][crate::model::DateShiftConfig::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of `method`.
    pub fn set_method<
        T: std::convert::Into<std::option::Option<crate::model::date_shift_config::Method>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }

    /// The value of [method][crate::model::DateShiftConfig::method]
    /// if it holds a `CryptoKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_crypto_key(&self) -> std::option::Option<&std::boxed::Box<crate::model::CryptoKey>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::date_shift_config::Method::CryptoKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::DateShiftConfig::method]
    /// to hold a `CryptoKey`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_crypto_key<T: std::convert::Into<std::boxed::Box<crate::model::CryptoKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.method =
            std::option::Option::Some(crate::model::date_shift_config::Method::CryptoKey(v.into()));
        self
    }
}

impl wkt::message::Message for DateShiftConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DateShiftConfig"
    }
}

/// Defines additional types related to DateShiftConfig
pub mod date_shift_config {
    #[allow(unused_imports)]
    use super::*;

    /// Method for calculating shift that takes context into consideration. If
    /// set, must also set context. Can only be applied to table items.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Method {
        /// Causes the shift to be computed based on this key and the context. This
        /// results in the same shift for the same context and crypto_key. If
        /// set, must also set context. Can only be applied to table items.
        CryptoKey(std::boxed::Box<crate::model::CryptoKey>),
    }
}

/// A type of transformation that will scan unstructured text and
/// apply various `PrimitiveTransformation`s to each finding, where the
/// transformation is applied to only values that were identified as a specific
/// info_type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoTypeTransformations {
    /// Required. Transformation for each infoType. Cannot specify more than one
    /// for a given infoType.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub transformations:
        std::vec::Vec<crate::model::info_type_transformations::InfoTypeTransformation>,
}

impl InfoTypeTransformations {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformations][crate::model::InfoTypeTransformations::transformations].
    pub fn set_transformations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::info_type_transformations::InfoTypeTransformation>,
    {
        use std::iter::Iterator;
        self.transformations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InfoTypeTransformations {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeTransformations"
    }
}

/// Defines additional types related to InfoTypeTransformations
pub mod info_type_transformations {
    #[allow(unused_imports)]
    use super::*;

    /// A transformation to apply to text that is identified as a specific
    /// info_type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InfoTypeTransformation {
        /// InfoTypes to apply the transformation to. An empty list will cause
        /// this transformation to apply to all findings that correspond to
        /// infoTypes that were requested in `InspectConfig`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub info_types: std::vec::Vec<crate::model::InfoType>,

        /// Required. Primitive transformation to apply to the infoType.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub primitive_transformation: std::option::Option<crate::model::PrimitiveTransformation>,
    }

    impl InfoTypeTransformation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [primitive_transformation][crate::model::info_type_transformations::InfoTypeTransformation::primitive_transformation].
        pub fn set_primitive_transformation<
            T: std::convert::Into<std::option::Option<crate::model::PrimitiveTransformation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.primitive_transformation = v.into();
            self
        }

        /// Sets the value of [info_types][crate::model::info_type_transformations::InfoTypeTransformation::info_types].
        pub fn set_info_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::InfoType>,
        {
            use std::iter::Iterator;
            self.info_types = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InfoTypeTransformation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.InfoTypeTransformations.InfoTypeTransformation"
        }
    }
}

/// The transformation to apply to the field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FieldTransformation {
    /// Required. Input field(s) to apply the transformation to.
    /// When you have columns that reference their position within a list,
    /// omit the index from the FieldId. FieldId name matching ignores the index.
    /// For example, instead of "contact.nums[0].type", use "contact.nums.type".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<crate::model::FieldId>,

    /// Only apply the transformation if the condition evaluates to true for the
    /// given `RecordCondition`. The conditions are allowed to reference fields
    /// that are not used in the actual transformation.
    ///
    /// Example Use Cases:
    ///
    /// - Apply a different bucket transformation to an age column if the zip code
    ///   column for the same record is within a specific range.
    /// - Redact a field if the date of birth field is greater than 85.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<crate::model::RecordCondition>,

    /// Transformation to apply. [required]
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub transformation: std::option::Option<crate::model::field_transformation::Transformation>,
}

impl FieldTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [condition][crate::model::FieldTransformation::condition].
    pub fn set_condition<
        T: std::convert::Into<std::option::Option<crate::model::RecordCondition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::FieldTransformation::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `transformation`.
    pub fn set_transformation<
        T: std::convert::Into<std::option::Option<crate::model::field_transformation::Transformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = v.into();
        self
    }

    /// The value of [transformation][crate::model::FieldTransformation::transformation]
    /// if it holds a `PrimitiveTransformation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_primitive_transformation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrimitiveTransformation>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::field_transformation::Transformation::PrimitiveTransformation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [transformation][crate::model::FieldTransformation::transformation]
    /// if it holds a `InfoTypeTransformations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_info_type_transformations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InfoTypeTransformations>> {
        #[allow(unreachable_patterns)]
        self.transformation.as_ref().and_then(|v| match v {
            crate::model::field_transformation::Transformation::InfoTypeTransformations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transformation][crate::model::FieldTransformation::transformation]
    /// to hold a `PrimitiveTransformation`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_primitive_transformation<
        T: std::convert::Into<std::boxed::Box<crate::model::PrimitiveTransformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::field_transformation::Transformation::PrimitiveTransformation(v.into()),
        );
        self
    }

    /// Sets the value of [transformation][crate::model::FieldTransformation::transformation]
    /// to hold a `InfoTypeTransformations`.
    ///
    /// Note that all the setters affecting `transformation` are
    /// mutually exclusive.
    pub fn set_info_type_transformations<
        T: std::convert::Into<std::boxed::Box<crate::model::InfoTypeTransformations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = std::option::Option::Some(
            crate::model::field_transformation::Transformation::InfoTypeTransformations(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FieldTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FieldTransformation"
    }
}

/// Defines additional types related to FieldTransformation
pub mod field_transformation {
    #[allow(unused_imports)]
    use super::*;

    /// Transformation to apply. [required]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Transformation {
        /// Apply the transformation to the entire field.
        PrimitiveTransformation(std::boxed::Box<crate::model::PrimitiveTransformation>),
        /// Treat the contents of the field as free text, and selectively
        /// transform content that matches an `InfoType`.
        InfoTypeTransformations(std::boxed::Box<crate::model::InfoTypeTransformations>),
    }
}

/// A type of transformation that is applied over structured data such as a
/// table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordTransformations {
    /// Transform the record by applying various field transformations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub field_transformations: std::vec::Vec<crate::model::FieldTransformation>,

    /// Configuration defining which records get suppressed entirely. Records that
    /// match any suppression rule are omitted from the output.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub record_suppressions: std::vec::Vec<crate::model::RecordSuppression>,
}

impl RecordTransformations {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field_transformations][crate::model::RecordTransformations::field_transformations].
    pub fn set_field_transformations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldTransformation>,
    {
        use std::iter::Iterator;
        self.field_transformations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [record_suppressions][crate::model::RecordTransformations::record_suppressions].
    pub fn set_record_suppressions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RecordSuppression>,
    {
        use std::iter::Iterator;
        self.record_suppressions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RecordTransformations {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordTransformations"
    }
}

/// Configuration to suppress records whose suppression conditions evaluate to
/// true.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordSuppression {
    /// A condition that when it evaluates to true will result in the record being
    /// evaluated to be suppressed from the transformed content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<crate::model::RecordCondition>,
}

impl RecordSuppression {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [condition][crate::model::RecordSuppression::condition].
    pub fn set_condition<
        T: std::convert::Into<std::option::Option<crate::model::RecordCondition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition = v.into();
        self
    }
}

impl wkt::message::Message for RecordSuppression {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordSuppression"
    }
}

/// A condition for determining whether a transformation should be applied to
/// a field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordCondition {
    /// An expression.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expressions: std::option::Option<crate::model::record_condition::Expressions>,
}

impl RecordCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expressions][crate::model::RecordCondition::expressions].
    pub fn set_expressions<
        T: std::convert::Into<std::option::Option<crate::model::record_condition::Expressions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expressions = v.into();
        self
    }
}

impl wkt::message::Message for RecordCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordCondition"
    }
}

/// Defines additional types related to RecordCondition
pub mod record_condition {
    #[allow(unused_imports)]
    use super::*;

    /// The field type of `value` and `field` do not need to match to be
    /// considered equal, but not all comparisons are possible.
    /// EQUAL_TO and NOT_EQUAL_TO attempt to compare even with incompatible types,
    /// but all other comparisons are invalid with incompatible types.
    /// A `value` of type:
    ///
    /// - `string` can be compared against all other types
    /// - `boolean` can only be compared against other booleans
    /// - `integer` can be compared against doubles or a string if the string value
    ///   can be parsed as an integer.
    /// - `double` can be compared against integers or a string if the string can
    ///   be parsed as a double.
    /// - `Timestamp` can be compared against strings in RFC 3339 date string
    ///   format.
    /// - `TimeOfDay` can be compared against timestamps and strings in the format
    ///   of 'HH:mm:ss'.
    ///
    /// If we fail to compare do to type mismatch, a warning will be given and
    /// the condition will evaluate to false.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Condition {
        /// Required. Field within the record this condition is evaluated against.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub field: std::option::Option<crate::model::FieldId>,

        /// Required. Operator used to compare the field or infoType to the value.
        pub operator: crate::model::RelationalOperator,

        /// Value to compare against. [Mandatory, except for `EXISTS` tests.]
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::Value>,
    }

    impl Condition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::record_condition::Condition::field].
        pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
            mut self,
            v: T,
        ) -> Self {
            self.field = v.into();
            self
        }

        /// Sets the value of [operator][crate::model::record_condition::Condition::operator].
        pub fn set_operator<T: std::convert::Into<crate::model::RelationalOperator>>(
            mut self,
            v: T,
        ) -> Self {
            self.operator = v.into();
            self
        }

        /// Sets the value of [value][crate::model::record_condition::Condition::value].
        pub fn set_value<T: std::convert::Into<std::option::Option<crate::model::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Condition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RecordCondition.Condition"
        }
    }

    /// A collection of conditions.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Conditions {
        /// A collection of conditions.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub conditions: std::vec::Vec<crate::model::record_condition::Condition>,
    }

    impl Conditions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [conditions][crate::model::record_condition::Conditions::conditions].
        pub fn set_conditions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::record_condition::Condition>,
        {
            use std::iter::Iterator;
            self.conditions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Conditions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RecordCondition.Conditions"
        }
    }

    /// An expression, consisting of an operator and conditions.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Expressions {
        /// The operator to apply to the result of conditions. Default and currently
        /// only supported value is `AND`.
        pub logical_operator: crate::model::record_condition::expressions::LogicalOperator,

        /// Expression types.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub r#type: std::option::Option<crate::model::record_condition::expressions::Type>,
    }

    impl Expressions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [logical_operator][crate::model::record_condition::Expressions::logical_operator].
        pub fn set_logical_operator<
            T: std::convert::Into<crate::model::record_condition::expressions::LogicalOperator>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.logical_operator = v.into();
            self
        }

        /// Sets the value of `r#type`.
        pub fn set_type<
            T: std::convert::Into<
                std::option::Option<crate::model::record_condition::expressions::Type>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// The value of [r#type][crate::model::record_condition::Expressions::r#type]
        /// if it holds a `Conditions`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_conditions(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::record_condition::Conditions>>
        {
            #[allow(unreachable_patterns)]
            self.r#type.as_ref().and_then(|v| match v {
                crate::model::record_condition::expressions::Type::Conditions(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#type][crate::model::record_condition::Expressions::r#type]
        /// to hold a `Conditions`.
        ///
        /// Note that all the setters affecting `r#type` are
        /// mutually exclusive.
        pub fn set_conditions<
            T: std::convert::Into<std::boxed::Box<crate::model::record_condition::Conditions>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = std::option::Option::Some(
                crate::model::record_condition::expressions::Type::Conditions(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Expressions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.RecordCondition.Expressions"
        }
    }

    /// Defines additional types related to Expressions
    pub mod expressions {
        #[allow(unused_imports)]
        use super::*;

        /// Logical operators for conditional checks.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct LogicalOperator(i32);

        impl LogicalOperator {
            /// Unused
            pub const LOGICAL_OPERATOR_UNSPECIFIED: LogicalOperator = LogicalOperator::new(0);

            /// Conditional AND
            pub const AND: LogicalOperator = LogicalOperator::new(1);

            /// Creates a new LogicalOperator instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("LOGICAL_OPERATOR_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("AND"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "LOGICAL_OPERATOR_UNSPECIFIED" => {
                        std::option::Option::Some(Self::LOGICAL_OPERATOR_UNSPECIFIED)
                    }
                    "AND" => std::option::Option::Some(Self::AND),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for LogicalOperator {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for LogicalOperator {
            fn default() -> Self {
                Self::new(0)
            }
        }

        /// Expression types.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Type {
            /// Conditions to apply to the expression.
            Conditions(std::boxed::Box<crate::model::record_condition::Conditions>),
        }
    }
}

/// Overview of the modifications that occurred.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationOverview {
    /// Total size in bytes that were transformed in some way.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformed_bytes: i64,

    /// Transformations applied to the dataset.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub transformation_summaries: std::vec::Vec<crate::model::TransformationSummary>,
}

impl TransformationOverview {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transformed_bytes][crate::model::TransformationOverview::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [transformation_summaries][crate::model::TransformationOverview::transformation_summaries].
    pub fn set_transformation_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransformationSummary>,
    {
        use std::iter::Iterator;
        self.transformation_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TransformationOverview {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationOverview"
    }
}

/// Summary of a single transformation.
/// Only one of 'transformation', 'field_transformation', or 'record_suppress'
/// will be set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationSummary {
    /// Set if the transformation was limited to a specific InfoType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Set if the transformation was limited to a specific FieldId.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<crate::model::FieldId>,

    /// The specific transformation these stats apply to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transformation: std::option::Option<crate::model::PrimitiveTransformation>,

    /// The field transformation that was applied.
    /// If multiple field transformations are requested for a single field,
    /// this list will contain all of them; otherwise, only one is supplied.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub field_transformations: std::vec::Vec<crate::model::FieldTransformation>,

    /// The specific suppression option these stats apply to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub record_suppress: std::option::Option<crate::model::RecordSuppression>,

    /// Collection of all transformations that took place or had an error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub results: std::vec::Vec<crate::model::transformation_summary::SummaryResult>,

    /// Total size in bytes that were transformed in some way.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformed_bytes: i64,
}

impl TransformationSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::TransformationSummary::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [field][crate::model::TransformationSummary::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [transformation][crate::model::TransformationSummary::transformation].
    pub fn set_transformation<
        T: std::convert::Into<std::option::Option<crate::model::PrimitiveTransformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation = v.into();
        self
    }

    /// Sets the value of [record_suppress][crate::model::TransformationSummary::record_suppress].
    pub fn set_record_suppress<
        T: std::convert::Into<std::option::Option<crate::model::RecordSuppression>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.record_suppress = v.into();
        self
    }

    /// Sets the value of [transformed_bytes][crate::model::TransformationSummary::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [field_transformations][crate::model::TransformationSummary::field_transformations].
    pub fn set_field_transformations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldTransformation>,
    {
        use std::iter::Iterator;
        self.field_transformations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [results][crate::model::TransformationSummary::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transformation_summary::SummaryResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TransformationSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationSummary"
    }
}

/// Defines additional types related to TransformationSummary
pub mod transformation_summary {
    #[allow(unused_imports)]
    use super::*;

    /// A collection that informs the user the number of times a particular
    /// `TransformationResultCode` and error details occurred.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SummaryResult {
        /// Number of transformations counted by this result.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub count: i64,

        /// Outcome of the transformation.
        pub code: crate::model::transformation_summary::TransformationResultCode,

        /// A place for warnings or errors to show up if a transformation didn't
        /// work as expected.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub details: std::string::String,
    }

    impl SummaryResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [count][crate::model::transformation_summary::SummaryResult::count].
        pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }

        /// Sets the value of [code][crate::model::transformation_summary::SummaryResult::code].
        pub fn set_code<
            T: std::convert::Into<crate::model::transformation_summary::TransformationResultCode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.code = v.into();
            self
        }

        /// Sets the value of [details][crate::model::transformation_summary::SummaryResult::details].
        pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.details = v.into();
            self
        }
    }

    impl wkt::message::Message for SummaryResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.TransformationSummary.SummaryResult"
        }
    }

    /// Possible outcomes of transformations.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TransformationResultCode(i32);

    impl TransformationResultCode {
        /// Unused
        pub const TRANSFORMATION_RESULT_CODE_UNSPECIFIED: TransformationResultCode =
            TransformationResultCode::new(0);

        /// Transformation completed without an error.
        pub const SUCCESS: TransformationResultCode = TransformationResultCode::new(1);

        /// Transformation had an error.
        pub const ERROR: TransformationResultCode = TransformationResultCode::new(2);

        /// Creates a new TransformationResultCode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TRANSFORMATION_RESULT_CODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SUCCESS"),
                2 => std::borrow::Cow::Borrowed("ERROR"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TRANSFORMATION_RESULT_CODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::TRANSFORMATION_RESULT_CODE_UNSPECIFIED)
                }
                "SUCCESS" => std::option::Option::Some(Self::SUCCESS),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TransformationResultCode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TransformationResultCode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A flattened description of a `PrimitiveTransformation` or
/// `RecordSuppression`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationDescription {
    /// The transformation type.
    #[serde(rename = "type")]
    pub r#type: crate::model::TransformationType,

    /// A description of the transformation. This is empty for a
    /// RECORD_SUPPRESSION, or is the output of calling toString() on the
    /// `PrimitiveTransformation` protocol buffer message for any other type of
    /// transformation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// A human-readable string representation of the `RecordCondition`
    /// corresponding to this transformation. Set if a `RecordCondition` was used
    /// to determine whether or not to apply this transformation.
    ///
    /// Examples:
    /// * (age_field > 85)
    /// * (age_field <= 18)
    /// * (zip_field exists)
    /// * (zip_field == 01234) && (city_field != "Springville")
    /// * (zip_field == 01234) && (age_field <= 18) && (city_field exists)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub condition: std::string::String,

    /// Set if the transformation was limited to a specific `InfoType`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,
}

impl TransformationDescription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TransformationDescription::type].
    pub fn set_type<T: std::convert::Into<crate::model::TransformationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TransformationDescription::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::TransformationDescription::condition].
    pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [info_type][crate::model::TransformationDescription::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }
}

impl wkt::message::Message for TransformationDescription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationDescription"
    }
}

/// Details about a single transformation. This object contains a description of
/// the transformation, information about whether the transformation was
/// successfully applied, and the precise location where the transformation
/// occurred. These details are stored in a user-specified BigQuery table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationDetails {
    /// The name of the job that completed the transformation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_name: std::string::String,

    /// The top level name of the container where the transformation is located
    /// (this will be the source file name or table name).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_name: std::string::String,

    /// Description of transformation. This would only contain more than one
    /// element if there were multiple matching transformations and which one to
    /// apply was ambiguous. Not set for states that contain no transformation,
    /// currently only state that contains no transformation is
    /// TransformationResultStateType.METADATA_UNRETRIEVABLE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub transformation: std::vec::Vec<crate::model::TransformationDescription>,

    /// Status of the transformation, if transformation was not successful, this
    /// will specify what caused it to fail, otherwise it will show that the
    /// transformation was successful.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status_details: std::option::Option<crate::model::TransformationResultStatus>,

    /// The number of bytes that were transformed. If transformation was
    /// unsuccessful or did not take place because there was no content to
    /// transform, this will be zero.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub transformed_bytes: i64,

    /// The precise location of the transformed content in the original container.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transformation_location: std::option::Option<crate::model::TransformationLocation>,
}

impl TransformationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_name][crate::model::TransformationDetails::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [container_name][crate::model::TransformationDetails::container_name].
    pub fn set_container_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_name = v.into();
        self
    }

    /// Sets the value of [status_details][crate::model::TransformationDetails::status_details].
    pub fn set_status_details<
        T: std::convert::Into<std::option::Option<crate::model::TransformationResultStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status_details = v.into();
        self
    }

    /// Sets the value of [transformed_bytes][crate::model::TransformationDetails::transformed_bytes].
    pub fn set_transformed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.transformed_bytes = v.into();
        self
    }

    /// Sets the value of [transformation_location][crate::model::TransformationDetails::transformation_location].
    pub fn set_transformation_location<
        T: std::convert::Into<std::option::Option<crate::model::TransformationLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transformation_location = v.into();
        self
    }

    /// Sets the value of [transformation][crate::model::TransformationDetails::transformation].
    pub fn set_transformation<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransformationDescription>,
    {
        use std::iter::Iterator;
        self.transformation = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TransformationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationDetails"
    }
}

/// Specifies the location of a transformation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationLocation {
    /// Information about the functionality of the container where this finding
    /// occurred, if available.
    pub container_type: crate::model::TransformationContainerType,

    /// Location type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location_type: std::option::Option<crate::model::transformation_location::LocationType>,
}

impl TransformationLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_type][crate::model::TransformationLocation::container_type].
    pub fn set_container_type<T: std::convert::Into<crate::model::TransformationContainerType>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_type = v.into();
        self
    }

    /// Sets the value of `location_type`.
    pub fn set_location_type<
        T: std::convert::Into<
            std::option::Option<crate::model::transformation_location::LocationType>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_type = v.into();
        self
    }

    /// The value of [location_type][crate::model::TransformationLocation::location_type]
    /// if it holds a `FindingId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_finding_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.location_type.as_ref().and_then(|v| match v {
            crate::model::transformation_location::LocationType::FindingId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [location_type][crate::model::TransformationLocation::location_type]
    /// if it holds a `RecordTransformation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_record_transformation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecordTransformation>> {
        #[allow(unreachable_patterns)]
        self.location_type.as_ref().and_then(|v| match v {
            crate::model::transformation_location::LocationType::RecordTransformation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location_type][crate::model::TransformationLocation::location_type]
    /// to hold a `FindingId`.
    ///
    /// Note that all the setters affecting `location_type` are
    /// mutually exclusive.
    pub fn set_finding_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_type = std::option::Option::Some(
            crate::model::transformation_location::LocationType::FindingId(v.into()),
        );
        self
    }

    /// Sets the value of [location_type][crate::model::TransformationLocation::location_type]
    /// to hold a `RecordTransformation`.
    ///
    /// Note that all the setters affecting `location_type` are
    /// mutually exclusive.
    pub fn set_record_transformation<
        T: std::convert::Into<std::boxed::Box<crate::model::RecordTransformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_type = std::option::Option::Some(
            crate::model::transformation_location::LocationType::RecordTransformation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TransformationLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationLocation"
    }
}

/// Defines additional types related to TransformationLocation
pub mod transformation_location {
    #[allow(unused_imports)]
    use super::*;

    /// Location type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum LocationType {
        /// For infotype transformations, link to the corresponding findings ID so
        /// that location information does not need to be duplicated. Each findings
        /// ID correlates to an entry in the findings output table, this table only
        /// gets created when users specify to save findings (add the save findings
        /// action to the request).
        FindingId(std::string::String),
        /// For record transformations, provide a field and container information.
        RecordTransformation(std::boxed::Box<crate::model::RecordTransformation>),
    }
}

/// The field in a record to transform.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordTransformation {
    /// For record transformations, provide a field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field_id: std::option::Option<crate::model::FieldId>,

    /// Findings container modification timestamp, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container_timestamp: std::option::Option<wkt::Timestamp>,

    /// Container version, if available ("generation" for Cloud Storage).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_version: std::string::String,
}

impl RecordTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field_id][crate::model::RecordTransformation::field_id].
    pub fn set_field_id<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field_id = v.into();
        self
    }

    /// Sets the value of [container_timestamp][crate::model::RecordTransformation::container_timestamp].
    pub fn set_container_timestamp<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_timestamp = v.into();
        self
    }

    /// Sets the value of [container_version][crate::model::RecordTransformation::container_version].
    pub fn set_container_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_version = v.into();
        self
    }
}

impl wkt::message::Message for RecordTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordTransformation"
    }
}

/// The outcome of a transformation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationResultStatus {
    /// Transformation result status type, this will be either SUCCESS, or it will
    /// be the reason for why the transformation was not completely successful.
    pub result_status_type: crate::model::TransformationResultStatusType,

    /// Detailed error codes and messages
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<rpc::model::Status>,
}

impl TransformationResultStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result_status_type][crate::model::TransformationResultStatus::result_status_type].
    pub fn set_result_status_type<
        T: std::convert::Into<crate::model::TransformationResultStatusType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result_status_type = v.into();
        self
    }

    /// Sets the value of [details][crate::model::TransformationResultStatus::details].
    pub fn set_details<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }
}

impl wkt::message::Message for TransformationResultStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationResultStatus"
    }
}

/// Config for storing transformation details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationDetailsStorageConfig {
    /// Location to store the transformation summary.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::transformation_details_storage_config::Type>,
}

impl TransformationDetailsStorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `r#type`.
    pub fn set_type<
        T: std::convert::Into<
            std::option::Option<crate::model::transformation_details_storage_config::Type>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::TransformationDetailsStorageConfig::r#type]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_table(&self) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTable>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::transformation_details_storage_config::Type::Table(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::TransformationDetailsStorageConfig::r#type]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTable>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::transformation_details_storage_config::Type::Table(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TransformationDetailsStorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationDetailsStorageConfig"
    }
}

/// Defines additional types related to TransformationDetailsStorageConfig
pub mod transformation_details_storage_config {
    #[allow(unused_imports)]
    use super::*;

    /// Location to store the transformation summary.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// The BigQuery table in which to store the output. This may be an existing
        /// table or in a new table in an existing dataset.
        /// If table_id is not set a new one will be generated for you with the
        /// following format:
        /// dlp_googleapis_transformation_details_yyyy_mm_dd_[dlp_job_id]. Pacific
        /// time zone will be used for generating the date details.
        Table(std::boxed::Box<crate::model::BigQueryTable>),
    }
}

/// Schedule for inspect job triggers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Schedule {
    /// Type of schedule.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub option: std::option::Option<crate::model::schedule::Option>,
}

impl Schedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `option`.
    pub fn set_option<
        T: std::convert::Into<std::option::Option<crate::model::schedule::Option>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.option = v.into();
        self
    }

    /// The value of [option][crate::model::Schedule::option]
    /// if it holds a `RecurrencePeriodDuration`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_recurrence_period_duration(
        &self,
    ) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.option.as_ref().and_then(|v| match v {
            crate::model::schedule::Option::RecurrencePeriodDuration(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [option][crate::model::Schedule::option]
    /// to hold a `RecurrencePeriodDuration`.
    ///
    /// Note that all the setters affecting `option` are
    /// mutually exclusive.
    pub fn set_recurrence_period_duration<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.option = std::option::Option::Some(
            crate::model::schedule::Option::RecurrencePeriodDuration(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Schedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Schedule"
    }
}

/// Defines additional types related to Schedule
pub mod schedule {
    #[allow(unused_imports)]
    use super::*;

    /// Type of schedule.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Option {
        /// With this option a job is started on a regular periodic basis. For
        /// example: every day (86400 seconds).
        ///
        /// A scheduled start time will be skipped if the previous
        /// execution has not ended when its scheduled time occurs.
        ///
        /// This value must be set to a time duration greater than or equal
        /// to 1 day and can be no longer than 60 days.
        RecurrencePeriodDuration(std::boxed::Box<wkt::Duration>),
    }
}

/// Job trigger option for hybrid jobs. Jobs must be manually created
/// and finished.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Manual {}

impl Manual {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for Manual {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Manual"
    }
}

/// The inspectTemplate contains a configuration (set of types of sensitive data
/// to be detected) to be used anywhere you otherwise would normally specify
/// InspectConfig. See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-templates> to
/// learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectTemplate {
    /// Output only. The template name.
    ///
    /// The template will have one of the following formats:
    /// `projects/PROJECT_ID/inspectTemplates/TEMPLATE_ID` OR
    /// `organizations/ORGANIZATION_ID/inspectTemplates/TEMPLATE_ID`;
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Display name (max 256 chars).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Short description (max 256 chars).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation timestamp of an inspectTemplate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of an inspectTemplate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The core content of the template. Configuration of the scanning process.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,
}

impl InspectTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InspectTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::InspectTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::InspectTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::InspectTemplate::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::InspectTemplate::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::InspectTemplate::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }
}

impl wkt::message::Message for InspectTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectTemplate"
    }
}

/// DeidentifyTemplates contains instructions on how to de-identify content.
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-templates> to
/// learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeidentifyTemplate {
    /// Output only. The template name.
    ///
    /// The template will have one of the following formats:
    /// `projects/PROJECT_ID/deidentifyTemplates/TEMPLATE_ID` OR
    /// `organizations/ORGANIZATION_ID/deidentifyTemplates/TEMPLATE_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Display name (max 256 chars).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Short description (max 256 chars).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation timestamp of an inspectTemplate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of an inspectTemplate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The core content of the template.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deidentify_config: std::option::Option<crate::model::DeidentifyConfig>,
}

impl DeidentifyTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeidentifyTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DeidentifyTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DeidentifyTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeidentifyTemplate::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DeidentifyTemplate::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [deidentify_config][crate::model::DeidentifyTemplate::deidentify_config].
    pub fn set_deidentify_config<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_config = v.into();
        self
    }
}

impl wkt::message::Message for DeidentifyTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeidentifyTemplate"
    }
}

/// Details information about an error encountered during job execution or
/// the results of an unsuccessful activation of the JobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Error {
    /// Detailed error codes and messages.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<rpc::model::Status>,

    /// The times the error occurred. List includes the oldest timestamp and the
    /// last 9 timestamps.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub timestamps: std::vec::Vec<wkt::Timestamp>,

    /// Additional information about the error.
    pub extra_info: crate::model::error::ErrorExtraInfo,
}

impl Error {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::Error::details].
    pub fn set_details<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// Sets the value of [extra_info][crate::model::Error::extra_info].
    pub fn set_extra_info<T: std::convert::Into<crate::model::error::ErrorExtraInfo>>(
        mut self,
        v: T,
    ) -> Self {
        self.extra_info = v.into();
        self
    }

    /// Sets the value of [timestamps][crate::model::Error::timestamps].
    pub fn set_timestamps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Timestamp>,
    {
        use std::iter::Iterator;
        self.timestamps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Error {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Error"
    }
}

/// Defines additional types related to Error
pub mod error {
    #[allow(unused_imports)]
    use super::*;

    /// Additional information about the error.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ErrorExtraInfo(i32);

    impl ErrorExtraInfo {
        /// Unused.
        pub const ERROR_INFO_UNSPECIFIED: ErrorExtraInfo = ErrorExtraInfo::new(0);

        /// Image scan is not available in the region.
        pub const IMAGE_SCAN_UNAVAILABLE_IN_REGION: ErrorExtraInfo = ErrorExtraInfo::new(1);

        /// File store cluster is not supported for profile generation.
        pub const FILE_STORE_CLUSTER_UNSUPPORTED: ErrorExtraInfo = ErrorExtraInfo::new(2);

        /// Creates a new ErrorExtraInfo instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ERROR_INFO_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("IMAGE_SCAN_UNAVAILABLE_IN_REGION"),
                2 => std::borrow::Cow::Borrowed("FILE_STORE_CLUSTER_UNSUPPORTED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ERROR_INFO_UNSPECIFIED" => std::option::Option::Some(Self::ERROR_INFO_UNSPECIFIED),
                "IMAGE_SCAN_UNAVAILABLE_IN_REGION" => {
                    std::option::Option::Some(Self::IMAGE_SCAN_UNAVAILABLE_IN_REGION)
                }
                "FILE_STORE_CLUSTER_UNSUPPORTED" => {
                    std::option::Option::Some(Self::FILE_STORE_CLUSTER_UNSUPPORTED)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ErrorExtraInfo {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ErrorExtraInfo {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Contains a configuration to make API calls on a repeating basis.
/// See
/// <https://cloud.google.com/sensitive-data-protection/docs/concepts-job-triggers>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobTrigger {
    /// Unique resource name for the triggeredJob, assigned by the service when the
    /// triggeredJob is created, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Display name (max 100 chars)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// User provided description (max 256 chars)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// A list of triggers which will be OR'ed together. Only one in the list
    /// needs to trigger for a job to be started. The list may contain only
    /// a single Schedule trigger and must have at least one object.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub triggers: std::vec::Vec<crate::model::job_trigger::Trigger>,

    /// Output only. A stream of errors encountered when the trigger was activated.
    /// Repeated errors may result in the JobTrigger automatically being paused.
    /// Will return the last 100 errors. Whenever the JobTrigger is modified
    /// this list will be cleared.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Output only. The creation timestamp of a triggeredJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of a triggeredJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the last time this trigger executed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_run_time: std::option::Option<wkt::Timestamp>,

    /// Required. A status for this trigger.
    pub status: crate::model::job_trigger::Status,

    /// The configuration details for the specific type of job to run.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::job_trigger::Job>,
}

impl JobTrigger {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::JobTrigger::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::JobTrigger::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::JobTrigger::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::JobTrigger::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::JobTrigger::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [last_run_time][crate::model::JobTrigger::last_run_time].
    pub fn set_last_run_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_run_time = v.into();
        self
    }

    /// Sets the value of [status][crate::model::JobTrigger::status].
    pub fn set_status<T: std::convert::Into<crate::model::job_trigger::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [triggers][crate::model::JobTrigger::triggers].
    pub fn set_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::job_trigger::Trigger>,
    {
        use std::iter::Iterator;
        self.triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors][crate::model::JobTrigger::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `job`.
    pub fn set_job<T: std::convert::Into<std::option::Option<crate::model::job_trigger::Job>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }

    /// The value of [job][crate::model::JobTrigger::job]
    /// if it holds a `InspectJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_inspect_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InspectJobConfig>> {
        #[allow(unreachable_patterns)]
        self.job.as_ref().and_then(|v| match v {
            crate::model::job_trigger::Job::InspectJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job][crate::model::JobTrigger::job]
    /// to hold a `InspectJob`.
    ///
    /// Note that all the setters affecting `job` are
    /// mutually exclusive.
    pub fn set_inspect_job<
        T: std::convert::Into<std::boxed::Box<crate::model::InspectJobConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job = std::option::Option::Some(crate::model::job_trigger::Job::InspectJob(v.into()));
        self
    }
}

impl wkt::message::Message for JobTrigger {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.JobTrigger"
    }
}

/// Defines additional types related to JobTrigger
pub mod job_trigger {
    #[allow(unused_imports)]
    use super::*;

    /// What event needs to occur for a new job to be started.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Trigger {
        /// What event needs to occur for a new job to be started.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub trigger: std::option::Option<crate::model::job_trigger::trigger::Trigger>,
    }

    impl Trigger {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `trigger`.
        pub fn set_trigger<
            T: std::convert::Into<std::option::Option<crate::model::job_trigger::trigger::Trigger>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = v.into();
            self
        }

        /// The value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// if it holds a `Schedule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_schedule(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::Schedule>> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::job_trigger::trigger::Trigger::Schedule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// if it holds a `Manual`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_manual(&self) -> std::option::Option<&std::boxed::Box<crate::model::Manual>> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::job_trigger::trigger::Trigger::Manual(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// to hold a `Schedule`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_schedule<T: std::convert::Into<std::boxed::Box<crate::model::Schedule>>>(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::job_trigger::trigger::Trigger::Schedule(v.into()),
            );
            self
        }

        /// Sets the value of [trigger][crate::model::job_trigger::Trigger::trigger]
        /// to hold a `Manual`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_manual<T: std::convert::Into<std::boxed::Box<crate::model::Manual>>>(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::job_trigger::trigger::Trigger::Manual(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Trigger {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.JobTrigger.Trigger"
        }
    }

    /// Defines additional types related to Trigger
    pub mod trigger {
        #[allow(unused_imports)]
        use super::*;

        /// What event needs to occur for a new job to be started.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Trigger {
            /// Create a job on a repeating basis based on the elapse of time.
            Schedule(std::boxed::Box<crate::model::Schedule>),
            /// For use with hybrid jobs. Jobs must be manually created and finished.
            Manual(std::boxed::Box<crate::model::Manual>),
        }
    }

    /// Whether the trigger is currently active. If PAUSED or CANCELLED, no jobs
    /// will be created with this configuration. The service may automatically
    /// pause triggers experiencing frequent errors. To restart a job, set the
    /// status to HEALTHY after correcting user errors.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Status(i32);

    impl Status {
        /// Unused.
        pub const STATUS_UNSPECIFIED: Status = Status::new(0);

        /// Trigger is healthy.
        pub const HEALTHY: Status = Status::new(1);

        /// Trigger is temporarily paused.
        pub const PAUSED: Status = Status::new(2);

        /// Trigger is cancelled and can not be resumed.
        pub const CANCELLED: Status = Status::new(3);

        /// Creates a new Status instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATUS_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("HEALTHY"),
                2 => std::borrow::Cow::Borrowed("PAUSED"),
                3 => std::borrow::Cow::Borrowed("CANCELLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATUS_UNSPECIFIED" => std::option::Option::Some(Self::STATUS_UNSPECIFIED),
                "HEALTHY" => std::option::Option::Some(Self::HEALTHY),
                "PAUSED" => std::option::Option::Some(Self::PAUSED),
                "CANCELLED" => std::option::Option::Some(Self::CANCELLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The configuration details for the specific type of job to run.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Job {
        /// For inspect jobs, a snapshot of the configuration.
        InspectJob(std::boxed::Box<crate::model::InspectJobConfig>),
    }
}

/// A task to execute on the completion of a job.
/// See <https://cloud.google.com/sensitive-data-protection/docs/concepts-actions>
/// to learn more.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Action {
    /// Extra events to execute after the job has finished.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub action: std::option::Option<crate::model::action::Action>,
}

impl Action {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `action`.
    pub fn set_action<T: std::convert::Into<std::option::Option<crate::model::action::Action>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `SaveFindings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_save_findings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::SaveFindings>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::SaveFindings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PubSub`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pub_sub(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::PublishToPubSub>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PubSub(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PublishSummaryToCscc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_publish_summary_to_cscc(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::PublishSummaryToCscc>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PublishSummaryToCscc(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PublishFindingsToCloudDataCatalog`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_publish_findings_to_cloud_data_catalog(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::action::PublishFindingsToCloudDataCatalog>,
    > {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PublishFindingsToCloudDataCatalog(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `Deidentify`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_deidentify(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::Deidentify>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::Deidentify(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `JobNotificationEmails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_job_notification_emails(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::JobNotificationEmails>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::JobNotificationEmails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::Action::action]
    /// if it holds a `PublishToStackdriver`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_publish_to_stackdriver(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::PublishToStackdriver>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::action::Action::PublishToStackdriver(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `SaveFindings`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_save_findings<
        T: std::convert::Into<std::boxed::Box<crate::model::action::SaveFindings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::action::Action::SaveFindings(v.into()));
        self
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PubSub`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_pub_sub<
        T: std::convert::Into<std::boxed::Box<crate::model::action::PublishToPubSub>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(crate::model::action::Action::PubSub(v.into()));
        self
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PublishSummaryToCscc`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_summary_to_cscc<
        T: std::convert::Into<std::boxed::Box<crate::model::action::PublishSummaryToCscc>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::action::Action::PublishSummaryToCscc(v.into()));
        self
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PublishFindingsToCloudDataCatalog`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_findings_to_cloud_data_catalog<
        T: std::convert::Into<
            std::boxed::Box<crate::model::action::PublishFindingsToCloudDataCatalog>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::action::Action::PublishFindingsToCloudDataCatalog(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `Deidentify`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_deidentify<
        T: std::convert::Into<std::boxed::Box<crate::model::action::Deidentify>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(crate::model::action::Action::Deidentify(v.into()));
        self
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `JobNotificationEmails`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_job_notification_emails<
        T: std::convert::Into<std::boxed::Box<crate::model::action::JobNotificationEmails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::action::Action::JobNotificationEmails(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::Action::action]
    /// to hold a `PublishToStackdriver`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_to_stackdriver<
        T: std::convert::Into<std::boxed::Box<crate::model::action::PublishToStackdriver>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::action::Action::PublishToStackdriver(v.into()));
        self
    }
}

impl wkt::message::Message for Action {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Action"
    }
}

/// Defines additional types related to Action
pub mod action {
    #[allow(unused_imports)]
    use super::*;

    /// If set, the detailed findings will be persisted to the specified
    /// OutputStorageConfig. Only a single instance of this action can be
    /// specified.
    /// Compatible with: Inspect, Risk
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SaveFindings {
        /// Location to store findings outside of DLP.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub output_config: std::option::Option<crate::model::OutputStorageConfig>,
    }

    impl SaveFindings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [output_config][crate::model::action::SaveFindings::output_config].
        pub fn set_output_config<
            T: std::convert::Into<std::option::Option<crate::model::OutputStorageConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.output_config = v.into();
            self
        }
    }

    impl wkt::message::Message for SaveFindings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.SaveFindings"
        }
    }

    /// Publish a message into a given Pub/Sub topic when DlpJob has completed. The
    /// message contains a single field, `DlpJobName`, which is equal to the
    /// finished job's
    /// [`DlpJob.name`](https://cloud.google.com/sensitive-data-protection/docs/reference/rest/v2/projects.dlpJobs#DlpJob).
    /// Compatible with: Inspect, Risk
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishToPubSub {
        /// Cloud Pub/Sub topic to send notifications to. The topic must have given
        /// publishing access rights to the DLP API service account executing
        /// the long running DlpJob sending the notifications.
        /// Format is projects/{project}/topics/{topic}.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub topic: std::string::String,
    }

    impl PublishToPubSub {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [topic][crate::model::action::PublishToPubSub::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }
    }

    impl wkt::message::Message for PublishToPubSub {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishToPubSub"
        }
    }

    /// Publish the result summary of a DlpJob to [Security Command
    /// Center](https://cloud.google.com/security-command-center). This action is
    /// available for only projects that belong to an organization. This action
    /// publishes the count of finding instances and their infoTypes. The summary
    /// of findings are persisted in Security Command Center and are governed by
    /// [service-specific policies for Security Command
    /// Center](https://cloud.google.com/terms/service-terms). Only a single
    /// instance of this action can be specified. Compatible with: Inspect
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishSummaryToCscc {}

    impl PublishSummaryToCscc {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishSummaryToCscc {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishSummaryToCscc"
        }
    }

    /// Publish findings of a DlpJob to Data Catalog. In Data Catalog, tag
    /// templates are applied to the resource that Cloud DLP scanned. Data
    /// Catalog tag templates are stored in the same project and region where the
    /// BigQuery table exists. For Cloud DLP to create and apply the tag template,
    /// the Cloud DLP service agent must have the
    /// `roles/datacatalog.tagTemplateOwner` permission on the project. The tag
    /// template contains fields summarizing the results of the DlpJob. Any field
    /// values previously written by another DlpJob are deleted. [InfoType naming
    /// patterns][google.privacy.dlp.v2.InfoType] are strictly enforced when using
    /// this feature.
    ///
    /// Findings are persisted in Data Catalog storage and are governed by
    /// service-specific policies for Data Catalog. For more information, see
    /// [Service Specific Terms](https://cloud.google.com/terms/service-terms).
    ///
    /// Only a single instance of this action can be specified. This action is
    /// allowed only if all resources being scanned are BigQuery tables.
    /// Compatible with: Inspect
    ///
    /// [google.privacy.dlp.v2.InfoType]: crate::model::InfoType
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishFindingsToCloudDataCatalog {}

    impl PublishFindingsToCloudDataCatalog {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishFindingsToCloudDataCatalog {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishFindingsToCloudDataCatalog"
        }
    }

    /// Create a de-identified copy of the requested table or files.
    ///
    /// A TransformationDetail will be created for each transformation.
    ///
    /// If any rows in BigQuery are skipped during de-identification
    /// (transformation errors or row size exceeds BigQuery insert API limits) they
    /// are placed in the failure output table. If the original row exceeds
    /// the BigQuery insert API limit it will be truncated when written to the
    /// failure output table. The failure output table can be set in the
    /// action.deidentify.output.big_query_output.deidentified_failure_output_table
    /// field, if no table is set, a table will be automatically created in the
    /// same project and dataset as the original table.
    ///
    /// Compatible with: Inspect
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Deidentify {
        /// User specified deidentify templates and configs for structured,
        /// unstructured, and image files.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub transformation_config: std::option::Option<crate::model::TransformationConfig>,

        /// Config for storing transformation details. This is separate from the
        /// de-identified content, and contains metadata about the successful
        /// transformations and/or failures that occurred while de-identifying. This
        /// needs to be set in order for users to access information about the status
        /// of each transformation (see
        /// [TransformationDetails][google.privacy.dlp.v2.TransformationDetails]
        /// message for more information about what is noted).
        ///
        /// [google.privacy.dlp.v2.TransformationDetails]: crate::model::TransformationDetails
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub transformation_details_storage_config:
            std::option::Option<crate::model::TransformationDetailsStorageConfig>,

        /// List of user-specified file type groups to transform. If specified, only
        /// the files with these file types will be transformed. If empty, all
        /// supported files will be transformed. Supported types may be automatically
        /// added over time. If a file type is set in this field that isn't supported
        /// by the Deidentify action then the job will fail and will not be
        /// successfully created/started. Currently the only file types supported
        /// are: IMAGES, TEXT_FILES, CSV, TSV.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub file_types_to_transform: std::vec::Vec<crate::model::FileType>,

        /// Where to store the output.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub output: std::option::Option<crate::model::action::deidentify::Output>,
    }

    impl Deidentify {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [transformation_config][crate::model::action::Deidentify::transformation_config].
        pub fn set_transformation_config<
            T: std::convert::Into<std::option::Option<crate::model::TransformationConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.transformation_config = v.into();
            self
        }

        /// Sets the value of [transformation_details_storage_config][crate::model::action::Deidentify::transformation_details_storage_config].
        pub fn set_transformation_details_storage_config<
            T: std::convert::Into<
                std::option::Option<crate::model::TransformationDetailsStorageConfig>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.transformation_details_storage_config = v.into();
            self
        }

        /// Sets the value of [file_types_to_transform][crate::model::action::Deidentify::file_types_to_transform].
        pub fn set_file_types_to_transform<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FileType>,
        {
            use std::iter::Iterator;
            self.file_types_to_transform = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of `output`.
        pub fn set_output<
            T: std::convert::Into<std::option::Option<crate::model::action::deidentify::Output>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.output = v.into();
            self
        }

        /// The value of [output][crate::model::action::Deidentify::output]
        /// if it holds a `CloudStorageOutput`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_cloud_storage_output(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.output.as_ref().and_then(|v| match v {
                crate::model::action::deidentify::Output::CloudStorageOutput(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [output][crate::model::action::Deidentify::output]
        /// to hold a `CloudStorageOutput`.
        ///
        /// Note that all the setters affecting `output` are
        /// mutually exclusive.
        pub fn set_cloud_storage_output<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.output = std::option::Option::Some(
                crate::model::action::deidentify::Output::CloudStorageOutput(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Deidentify {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.Deidentify"
        }
    }

    /// Defines additional types related to Deidentify
    pub mod deidentify {
        #[allow(unused_imports)]
        use super::*;

        /// Where to store the output.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Output {
            /// Required. User settable Cloud Storage bucket and folders to store
            /// de-identified files. This field must be set for Cloud Storage
            /// deidentification. The output Cloud Storage bucket must be different
            /// from the input bucket. De-identified files will overwrite files in the
            /// output path.
            ///
            /// Form of: gs://bucket/folder/ or gs://bucket
            CloudStorageOutput(std::string::String),
        }
    }

    /// Sends an email when the job completes. The email goes to IAM project owners
    /// and technical [Essential
    /// Contacts](https://cloud.google.com/resource-manager/docs/managing-notification-contacts).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct JobNotificationEmails {}

    impl JobNotificationEmails {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for JobNotificationEmails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.JobNotificationEmails"
        }
    }

    /// Enable Stackdriver metric dlp.googleapis.com/finding_count. This
    /// will publish a metric to stack driver on each infotype requested and
    /// how many findings were found for it. CustomDetectors will be bucketed
    /// as 'Custom' under the Stackdriver label 'info_type'.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishToStackdriver {}

    impl PublishToStackdriver {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishToStackdriver {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Action.PublishToStackdriver"
        }
    }

    /// Extra events to execute after the job has finished.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Action {
        /// Save resulting findings in a provided location.
        SaveFindings(std::boxed::Box<crate::model::action::SaveFindings>),
        /// Publish a notification to a Pub/Sub topic.
        PubSub(std::boxed::Box<crate::model::action::PublishToPubSub>),
        /// Publish summary to Cloud Security Command Center (Alpha).
        PublishSummaryToCscc(std::boxed::Box<crate::model::action::PublishSummaryToCscc>),
        /// Publish findings to Cloud Datahub.
        PublishFindingsToCloudDataCatalog(
            std::boxed::Box<crate::model::action::PublishFindingsToCloudDataCatalog>,
        ),
        /// Create a de-identified copy of the input data.
        Deidentify(std::boxed::Box<crate::model::action::Deidentify>),
        /// Sends an email when the job completes. The email goes to IAM project
        /// owners and technical [Essential
        /// Contacts](https://cloud.google.com/resource-manager/docs/managing-notification-contacts).
        JobNotificationEmails(std::boxed::Box<crate::model::action::JobNotificationEmails>),
        /// Enable Stackdriver metric dlp.googleapis.com/finding_count.
        PublishToStackdriver(std::boxed::Box<crate::model::action::PublishToStackdriver>),
    }
}

/// User specified templates and configs for how to deidentify structured,
/// unstructures, and image files. User must provide either a unstructured
/// deidentify template or at least one redact image config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformationConfig {
    /// De-identify template.
    /// If this template is specified, it will serve as the default de-identify
    /// template. This template cannot contain `record_transformations` since it
    /// can be used for unstructured content such as free-form text files. If this
    /// template is not set, a default `ReplaceWithInfoTypeConfig` will be used to
    /// de-identify unstructured content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deidentify_template: std::string::String,

    /// Structured de-identify template.
    /// If this template is specified, it will serve as the de-identify template
    /// for structured content such as delimited files and tables. If this template
    /// is not set but the `deidentify_template` is set, then `deidentify_template`
    /// will also apply to the structured content. If neither template is set, a
    /// default `ReplaceWithInfoTypeConfig` will be used to de-identify structured
    /// content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub structured_deidentify_template: std::string::String,

    /// Image redact template.
    /// If this template is specified, it will serve as the de-identify template
    /// for images. If this template is not set, all findings in the image will be
    /// redacted with a black box.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_redact_template: std::string::String,
}

impl TransformationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deidentify_template][crate::model::TransformationConfig::deidentify_template].
    pub fn set_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }

    /// Sets the value of [structured_deidentify_template][crate::model::TransformationConfig::structured_deidentify_template].
    pub fn set_structured_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.structured_deidentify_template = v.into();
        self
    }

    /// Sets the value of [image_redact_template][crate::model::TransformationConfig::image_redact_template].
    pub fn set_image_redact_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.image_redact_template = v.into();
        self
    }
}

impl wkt::message::Message for TransformationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TransformationConfig"
    }
}

/// Request message for CreateInspectTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInspectTemplateRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The InspectTemplate to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template: std::option::Option<crate::model::InspectTemplate>,

    /// The template id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template_id: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl CreateInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInspectTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [inspect_template][crate::model::CreateInspectTemplateRequest::inspect_template].
    pub fn set_inspect_template<
        T: std::convert::Into<std::option::Option<crate::model::InspectTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template = v.into();
        self
    }

    /// Sets the value of [template_id][crate::model::CreateInspectTemplateRequest::template_id].
    pub fn set_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateInspectTemplateRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateInspectTemplateRequest"
    }
}

/// Request message for UpdateInspectTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInspectTemplateRequest {
    /// Required. Resource name of organization and inspectTemplate to be updated,
    /// for example `organizations/433245324/inspectTemplates/432452342` or
    /// projects/project-id/inspectTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// New InspectTemplate value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template: std::option::Option<crate::model::InspectTemplate>,

    /// Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateInspectTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [inspect_template][crate::model::UpdateInspectTemplateRequest::inspect_template].
    pub fn set_inspect_template<
        T: std::convert::Into<std::option::Option<crate::model::InspectTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInspectTemplateRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateInspectTemplateRequest"
    }
}

/// Request message for GetInspectTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInspectTemplateRequest {
    /// Required. Resource name of the organization and inspectTemplate to be read,
    /// for example `organizations/433245324/inspectTemplates/432452342` or
    /// projects/project-id/inspectTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInspectTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetInspectTemplateRequest"
    }
}

/// Request message for ListInspectTemplates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInspectTemplatesRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to `ListInspectTemplates`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the template was created.
    /// - `update_time`: corresponds to the time the template was last updated.
    /// - `name`: corresponds to the template's name.
    /// - `display_name`: corresponds to the template's display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl ListInspectTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInspectTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInspectTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInspectTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInspectTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListInspectTemplatesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListInspectTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInspectTemplatesRequest"
    }
}

/// Response message for ListInspectTemplates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInspectTemplatesResponse {
    /// List of inspectTemplates, up to page_size in ListInspectTemplatesRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inspect_templates: std::vec::Vec<crate::model::InspectTemplate>,

    /// If the next page is available then the next page token to be used in the
    /// following ListInspectTemplates request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListInspectTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInspectTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [inspect_templates][crate::model::ListInspectTemplatesResponse::inspect_templates].
    pub fn set_inspect_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InspectTemplate>,
    {
        use std::iter::Iterator;
        self.inspect_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInspectTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListInspectTemplatesResponse"
    }
}

impl gax::paginator::PageableResponse for ListInspectTemplatesResponse {
    type PageItem = crate::model::InspectTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.inspect_templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteInspectTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInspectTemplateRequest {
    /// Required. Resource name of the organization and inspectTemplate to be
    /// deleted, for example `organizations/433245324/inspectTemplates/432452342`
    /// or projects/project-id/inspectTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteInspectTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInspectTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInspectTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteInspectTemplateRequest"
    }
}

/// Request message for CreateJobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateJobTriggerRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The JobTrigger to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_trigger: std::option::Option<crate::model::JobTrigger>,

    /// The trigger id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_id: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl CreateJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateJobTriggerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job_trigger][crate::model::CreateJobTriggerRequest::job_trigger].
    pub fn set_job_trigger<T: std::convert::Into<std::option::Option<crate::model::JobTrigger>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_trigger = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::CreateJobTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateJobTriggerRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateJobTriggerRequest"
    }
}

/// Request message for ActivateJobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ActivateJobTriggerRequest {
    /// Required. Resource name of the trigger to activate, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ActivateJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ActivateJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ActivateJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ActivateJobTriggerRequest"
    }
}

/// Request message for UpdateJobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateJobTriggerRequest {
    /// Required. Resource name of the project and the triggeredJob, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// New JobTrigger value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_trigger: std::option::Option<crate::model::JobTrigger>,

    /// Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [job_trigger][crate::model::UpdateJobTriggerRequest::job_trigger].
    pub fn set_job_trigger<T: std::convert::Into<std::option::Option<crate::model::JobTrigger>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_trigger = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateJobTriggerRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateJobTriggerRequest"
    }
}

/// Request message for GetJobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetJobTriggerRequest {
    /// Required. Resource name of the project and the triggeredJob, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetJobTriggerRequest"
    }
}

/// Request message for CreateDiscoveryConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDiscoveryConfigRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization):
    ///
    /// + Projects scope:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Organizations scope:
    ///   `organizations/{org_id}/locations/{location_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The DiscoveryConfig to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub discovery_config: std::option::Option<crate::model::DiscoveryConfig>,

    /// The config ID can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub config_id: std::string::String,
}

impl CreateDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDiscoveryConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [discovery_config][crate::model::CreateDiscoveryConfigRequest::discovery_config].
    pub fn set_discovery_config<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_config = v.into();
        self
    }

    /// Sets the value of [config_id][crate::model::CreateDiscoveryConfigRequest::config_id].
    pub fn set_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateDiscoveryConfigRequest"
    }
}

/// Request message for UpdateDiscoveryConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDiscoveryConfigRequest {
    /// Required. Resource name of the project and the configuration, for example
    /// `projects/dlp-test-project/discoveryConfigs/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. New DiscoveryConfig value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub discovery_config: std::option::Option<crate::model::DiscoveryConfig>,

    /// Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateDiscoveryConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [discovery_config][crate::model::UpdateDiscoveryConfigRequest::discovery_config].
    pub fn set_discovery_config<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDiscoveryConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateDiscoveryConfigRequest"
    }
}

/// Request message for GetDiscoveryConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDiscoveryConfigRequest {
    /// Required. Resource name of the project and the configuration, for example
    /// `projects/dlp-test-project/discoveryConfigs/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDiscoveryConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetDiscoveryConfigRequest"
    }
}

/// Request message for ListDiscoveryConfigs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDiscoveryConfigsRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value is as follows:
    /// `projects/{project_id}/locations/{location_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to ListDiscoveryConfigs. `order_by` field must not
    /// change for subsequent calls.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by a server.
    pub page_size: i32,

    /// Comma-separated list of config fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `last_run_time`: corresponds to the last time the DiscoveryConfig ran.
    /// - `name`: corresponds to the DiscoveryConfig's name.
    /// - `status`: corresponds to DiscoveryConfig's status.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListDiscoveryConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDiscoveryConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDiscoveryConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDiscoveryConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDiscoveryConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDiscoveryConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDiscoveryConfigsRequest"
    }
}

/// Response message for ListDiscoveryConfigs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDiscoveryConfigsResponse {
    /// List of configs, up to page_size in ListDiscoveryConfigsRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub discovery_configs: std::vec::Vec<crate::model::DiscoveryConfig>,

    /// If the next page is available then this value is the next page token to be
    /// used in the following ListDiscoveryConfigs request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDiscoveryConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDiscoveryConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [discovery_configs][crate::model::ListDiscoveryConfigsResponse::discovery_configs].
    pub fn set_discovery_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveryConfig>,
    {
        use std::iter::Iterator;
        self.discovery_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDiscoveryConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDiscoveryConfigsResponse"
    }
}

impl gax::paginator::PageableResponse for ListDiscoveryConfigsResponse {
    type PageItem = crate::model::DiscoveryConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.discovery_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteDiscoveryConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDiscoveryConfigRequest {
    /// Required. Resource name of the project and the config, for example
    /// `projects/dlp-test-project/discoveryConfigs/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteDiscoveryConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDiscoveryConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDiscoveryConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteDiscoveryConfigRequest"
    }
}

/// Request message for CreateDlpJobRequest. Used to initiate long running
/// jobs such as calculating risk metrics or inspecting Google Cloud
/// Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDlpJobRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The job id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    /// The configuration details for the specific type of job to run.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::create_dlp_job_request::Job>,
}

impl CreateDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDlpJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::CreateDlpJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateDlpJobRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of `job`.
    pub fn set_job<
        T: std::convert::Into<std::option::Option<crate::model::create_dlp_job_request::Job>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }

    /// The value of [job][crate::model::CreateDlpJobRequest::job]
    /// if it holds a `InspectJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_inspect_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InspectJobConfig>> {
        #[allow(unreachable_patterns)]
        self.job.as_ref().and_then(|v| match v {
            crate::model::create_dlp_job_request::Job::InspectJob(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [job][crate::model::CreateDlpJobRequest::job]
    /// if it holds a `RiskJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_risk_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RiskAnalysisJobConfig>> {
        #[allow(unreachable_patterns)]
        self.job.as_ref().and_then(|v| match v {
            crate::model::create_dlp_job_request::Job::RiskJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job][crate::model::CreateDlpJobRequest::job]
    /// to hold a `InspectJob`.
    ///
    /// Note that all the setters affecting `job` are
    /// mutually exclusive.
    pub fn set_inspect_job<
        T: std::convert::Into<std::boxed::Box<crate::model::InspectJobConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job = std::option::Option::Some(
            crate::model::create_dlp_job_request::Job::InspectJob(v.into()),
        );
        self
    }

    /// Sets the value of [job][crate::model::CreateDlpJobRequest::job]
    /// to hold a `RiskJob`.
    ///
    /// Note that all the setters affecting `job` are
    /// mutually exclusive.
    pub fn set_risk_job<
        T: std::convert::Into<std::boxed::Box<crate::model::RiskAnalysisJobConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job =
            std::option::Option::Some(crate::model::create_dlp_job_request::Job::RiskJob(v.into()));
        self
    }
}

impl wkt::message::Message for CreateDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateDlpJobRequest"
    }
}

/// Defines additional types related to CreateDlpJobRequest
pub mod create_dlp_job_request {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration details for the specific type of job to run.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Job {
        /// An inspection job scans a storage repository for InfoTypes.
        InspectJob(std::boxed::Box<crate::model::InspectJobConfig>),
        /// A risk analysis job calculates re-identification risk metrics for a
        /// BigQuery table.
        RiskJob(std::boxed::Box<crate::model::RiskAnalysisJobConfig>),
    }
}

/// Request message for ListJobTriggers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobTriggersRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to ListJobTriggers. `order_by` field must not
    /// change for subsequent calls.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by a server.
    pub page_size: i32,

    /// Comma-separated list of triggeredJob fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the JobTrigger was created.
    /// - `update_time`: corresponds to the time the JobTrigger was last updated.
    /// - `last_run_time`: corresponds to the last time the JobTrigger ran.
    /// - `name`: corresponds to the JobTrigger's name.
    /// - `display_name`: corresponds to the JobTrigger's display name.
    /// - `status`: corresponds to JobTrigger's status.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values for inspect triggers:
    ///   - `status` - HEALTHY|PAUSED|CANCELLED
    ///   - `inspected_storage` - DATASTORE|CLOUD_STORAGE|BIGQUERY
    ///   - 'last_run_time` - RFC 3339 formatted timestamp, surrounded by
    ///     quotation marks. Nanoseconds are ignored.
    ///   - 'error_count' - Number of errors that have occurred while running.
    /// * The operator must be `=` or `!=` for status and inspected_storage.
    ///
    /// Examples:
    ///
    /// * inspected_storage = cloud_storage AND status = HEALTHY
    /// * inspected_storage = cloud_storage OR inspected_storage = bigquery
    /// * inspected_storage = cloud_storage AND (state = PAUSED OR state = HEALTHY)
    /// * last_run_time > \"2017-12-12T00:00:00+00:00\"
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The type of jobs. Will use `DlpJobType.INSPECT` if not set.
    #[serde(rename = "type")]
    pub r#type: crate::model::DlpJobType,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl ListJobTriggersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListJobTriggersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobTriggersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobTriggersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListJobTriggersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListJobTriggersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ListJobTriggersRequest::type].
    pub fn set_type<T: std::convert::Into<crate::model::DlpJobType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListJobTriggersRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListJobTriggersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListJobTriggersRequest"
    }
}

/// Response message for ListJobTriggers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobTriggersResponse {
    /// List of triggeredJobs, up to page_size in ListJobTriggersRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub job_triggers: std::vec::Vec<crate::model::JobTrigger>,

    /// If the next page is available then this value is the next page token to be
    /// used in the following ListJobTriggers request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListJobTriggersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListJobTriggersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [job_triggers][crate::model::ListJobTriggersResponse::job_triggers].
    pub fn set_job_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobTrigger>,
    {
        use std::iter::Iterator;
        self.job_triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListJobTriggersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListJobTriggersResponse"
    }
}

impl gax::paginator::PageableResponse for ListJobTriggersResponse {
    type PageItem = crate::model::JobTrigger;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.job_triggers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteJobTrigger.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteJobTriggerRequest {
    /// Required. Resource name of the project and the triggeredJob, for example
    /// `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteJobTriggerRequest"
    }
}

/// Controls what and how to inspect for findings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InspectJobConfig {
    /// The data to scan.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub storage_config: std::option::Option<crate::model::StorageConfig>,

    /// How and what to scan for.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// If provided, will be used as the default for all values in InspectConfig.
    /// `inspect_config` will be merged into the values persisted as part of the
    /// template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template_name: std::string::String,

    /// Actions to execute at the completion of the job.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub actions: std::vec::Vec<crate::model::Action>,
}

impl InspectJobConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_config][crate::model::InspectJobConfig::storage_config].
    pub fn set_storage_config<
        T: std::convert::Into<std::option::Option<crate::model::StorageConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_config = v.into();
        self
    }

    /// Sets the value of [inspect_config][crate::model::InspectJobConfig::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::InspectJobConfig::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [actions][crate::model::InspectJobConfig::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Action>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InspectJobConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InspectJobConfig"
    }
}

/// A task to execute when a data profile has been generated.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileAction {
    /// Type of action to execute when a profile is generated.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub action: std::option::Option<crate::model::data_profile_action::Action>,
}

impl DataProfileAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `action`.
    pub fn set_action<
        T: std::convert::Into<std::option::Option<crate::model::data_profile_action::Action>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `ExportData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_export_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::Export>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::ExportData(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `PubSubNotification`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pub_sub_notification(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::PubSubNotification>>
    {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::PubSubNotification(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `PublishToChronicle`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_publish_to_chronicle(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::PublishToChronicle>>
    {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::PublishToChronicle(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `PublishToScc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_publish_to_scc(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_profile_action::PublishToSecurityCommandCenter>,
    > {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::PublishToScc(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::DataProfileAction::action]
    /// if it holds a `TagResources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tag_resources(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_action::TagResources>>
    {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::data_profile_action::Action::TagResources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `ExportData`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_export_data<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::Export>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::ExportData(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `PubSubNotification`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_pub_sub_notification<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::PubSubNotification>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::PubSubNotification(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `PublishToChronicle`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_to_chronicle<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::PublishToChronicle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::PublishToChronicle(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `PublishToScc`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_publish_to_scc<
        T: std::convert::Into<
            std::boxed::Box<crate::model::data_profile_action::PublishToSecurityCommandCenter>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::PublishToScc(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::DataProfileAction::action]
    /// to hold a `TagResources`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_tag_resources<
        T: std::convert::Into<std::boxed::Box<crate::model::data_profile_action::TagResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::data_profile_action::Action::TagResources(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataProfileAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction"
    }
}

/// Defines additional types related to DataProfileAction
pub mod data_profile_action {
    #[allow(unused_imports)]
    use super::*;

    /// If set, the detailed data profiles will be persisted to the location
    /// of your choice whenever updated.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Export {
        /// Store all profiles to BigQuery.
        ///
        /// * The system will create a new dataset and table for you if none are
        ///   are provided. The dataset will be named
        ///   `sensitive_data_protection_discovery` and table will be named
        ///   `discovery_profiles`. This table will be placed in the same project as
        ///   the container project running the scan. After the first profile is
        ///   generated and the dataset and table are created, the discovery scan
        ///   configuration will be updated with the dataset and table names.
        /// * See [Analyze data profiles stored in
        ///   BigQuery](https://cloud.google.com/sensitive-data-protection/docs/analyze-data-profiles).
        /// * See [Sample queries for your BigQuery
        ///   table](https://cloud.google.com/sensitive-data-protection/docs/analyze-data-profiles#sample_sql_queries).
        /// * Data is inserted using [streaming
        ///   insert](https://cloud.google.com/blog/products/bigquery/life-of-a-bigquery-streaming-insert)
        ///   and so data may be in the buffer for a period of time after the
        ///   profile has finished.
        /// * The Pub/Sub notification is sent before the streaming buffer is
        ///   guaranteed to be written, so data may not be instantly
        ///   visible to queries by the time your topic receives the Pub/Sub
        ///   notification.
        /// * The best practice is to use the same table for an entire organization
        ///   so that you can take advantage of the [provided Looker
        ///   reports](https://cloud.google.com/sensitive-data-protection/docs/analyze-data-profiles#use_a_premade_report).
        ///   If you use VPC Service Controls to define security perimeters, then
        ///   you must use a separate table for each boundary.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub profile_table: std::option::Option<crate::model::BigQueryTable>,
    }

    impl Export {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [profile_table][crate::model::data_profile_action::Export::profile_table].
        pub fn set_profile_table<
            T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.profile_table = v.into();
            self
        }
    }

    impl wkt::message::Message for Export {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.Export"
        }
    }

    /// Send a Pub/Sub message into the given Pub/Sub topic to connect other
    /// systems to data profile generation. The message payload data will
    /// be the byte serialization of `DataProfilePubSubMessage`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PubSubNotification {
        /// Cloud Pub/Sub topic to send notifications to.
        /// Format is projects/{project}/topics/{topic}.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub topic: std::string::String,

        /// The type of event that triggers a Pub/Sub. At most one
        /// `PubSubNotification` per EventType is permitted.
        pub event: crate::model::data_profile_action::EventType,

        /// Conditions (e.g., data risk or sensitivity level) for triggering a
        /// Pub/Sub.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub pubsub_condition: std::option::Option<crate::model::DataProfilePubSubCondition>,

        /// How much data to include in the Pub/Sub message. If the user wishes to
        /// limit the size of the message, they can use resource_name and fetch the
        /// profile fields they wish to. Per table profile (not per column).
        pub detail_of_message: crate::model::data_profile_action::pub_sub_notification::DetailLevel,
    }

    impl PubSubNotification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [topic][crate::model::data_profile_action::PubSubNotification::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }

        /// Sets the value of [event][crate::model::data_profile_action::PubSubNotification::event].
        pub fn set_event<T: std::convert::Into<crate::model::data_profile_action::EventType>>(
            mut self,
            v: T,
        ) -> Self {
            self.event = v.into();
            self
        }

        /// Sets the value of [pubsub_condition][crate::model::data_profile_action::PubSubNotification::pubsub_condition].
        pub fn set_pubsub_condition<
            T: std::convert::Into<std::option::Option<crate::model::DataProfilePubSubCondition>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.pubsub_condition = v.into();
            self
        }

        /// Sets the value of [detail_of_message][crate::model::data_profile_action::PubSubNotification::detail_of_message].
        pub fn set_detail_of_message<
            T: std::convert::Into<
                crate::model::data_profile_action::pub_sub_notification::DetailLevel,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.detail_of_message = v.into();
            self
        }
    }

    impl wkt::message::Message for PubSubNotification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.PubSubNotification"
        }
    }

    /// Defines additional types related to PubSubNotification
    pub mod pub_sub_notification {
        #[allow(unused_imports)]
        use super::*;

        /// The levels of detail that can be included in the Pub/Sub message.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct DetailLevel(i32);

        impl DetailLevel {
            /// Unused.
            pub const DETAIL_LEVEL_UNSPECIFIED: DetailLevel = DetailLevel::new(0);

            /// The full table data profile.
            pub const TABLE_PROFILE: DetailLevel = DetailLevel::new(1);

            /// The name of the profiled resource.
            pub const RESOURCE_NAME: DetailLevel = DetailLevel::new(2);

            /// The full file store data profile.
            pub const FILE_STORE_PROFILE: DetailLevel = DetailLevel::new(3);

            /// Creates a new DetailLevel instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("DETAIL_LEVEL_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("TABLE_PROFILE"),
                    2 => std::borrow::Cow::Borrowed("RESOURCE_NAME"),
                    3 => std::borrow::Cow::Borrowed("FILE_STORE_PROFILE"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "DETAIL_LEVEL_UNSPECIFIED" => {
                        std::option::Option::Some(Self::DETAIL_LEVEL_UNSPECIFIED)
                    }
                    "TABLE_PROFILE" => std::option::Option::Some(Self::TABLE_PROFILE),
                    "RESOURCE_NAME" => std::option::Option::Some(Self::RESOURCE_NAME),
                    "FILE_STORE_PROFILE" => std::option::Option::Some(Self::FILE_STORE_PROFILE),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for DetailLevel {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for DetailLevel {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Message expressing intention to publish to Google Security Operations.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishToChronicle {}

    impl PublishToChronicle {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishToChronicle {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.PublishToChronicle"
        }
    }

    /// If set, a summary finding will be created or updated in Security Command
    /// Center for each profile.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PublishToSecurityCommandCenter {}

    impl PublishToSecurityCommandCenter {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PublishToSecurityCommandCenter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.PublishToSecurityCommandCenter"
        }
    }

    /// If set, attaches the [tags]
    /// (<https://cloud.google.com/resource-manager/docs/tags/tags-overview>)
    /// provided to profiled resources. Tags support [access
    /// control](https://cloud.google.com/iam/docs/tags-access-control). You can
    /// conditionally grant or deny access to a resource based on whether the
    /// resource has a specific tag.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TagResources {
        /// The tags to associate with different conditions.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub tag_conditions:
            std::vec::Vec<crate::model::data_profile_action::tag_resources::TagCondition>,

        /// The profile generations for which the tag should be attached to
        /// resources. If you attach a tag to only new profiles, then if the
        /// sensitivity score of a profile subsequently changes, its tag doesn't
        /// change. By default, this field includes only new profiles. To include
        /// both new and updated profiles for tagging, this field should explicitly
        /// include both `PROFILE_GENERATION_NEW` and `PROFILE_GENERATION_UPDATE`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub profile_generations_to_tag: std::vec::Vec<crate::model::ProfileGeneration>,

        /// Whether applying a tag to a resource should lower the risk of the profile
        /// for that resource. For example, in conjunction with an [IAM deny
        /// policy](https://cloud.google.com/iam/docs/deny-overview), you can deny
        /// all principals a permission if a tag value is present, mitigating the
        /// risk of the resource. This also lowers the data risk of resources at the
        /// lower levels of the resource hierarchy. For example, reducing the data
        /// risk of a table data profile also reduces the data risk of the
        /// constituent column data profiles.
        pub lower_data_risk_to_low: bool,
    }

    impl TagResources {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [lower_data_risk_to_low][crate::model::data_profile_action::TagResources::lower_data_risk_to_low].
        pub fn set_lower_data_risk_to_low<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.lower_data_risk_to_low = v.into();
            self
        }

        /// Sets the value of [tag_conditions][crate::model::data_profile_action::TagResources::tag_conditions].
        pub fn set_tag_conditions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::data_profile_action::tag_resources::TagCondition>,
        {
            use std::iter::Iterator;
            self.tag_conditions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [profile_generations_to_tag][crate::model::data_profile_action::TagResources::profile_generations_to_tag].
        pub fn set_profile_generations_to_tag<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ProfileGeneration>,
        {
            use std::iter::Iterator;
            self.profile_generations_to_tag = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TagResources {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.TagResources"
        }
    }

    /// Defines additional types related to TagResources
    pub mod tag_resources {
        #[allow(unused_imports)]
        use super::*;

        /// The tag to attach to profiles matching the condition. At most one
        /// `TagCondition` can be specified per sensitivity level.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TagCondition {
            /// The tag value to attach to resources.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub tag:
                std::option::Option<crate::model::data_profile_action::tag_resources::TagValue>,

            /// The type of condition on which attaching the tag will be predicated.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub r#type: std::option::Option<
                crate::model::data_profile_action::tag_resources::tag_condition::Type,
            >,
        }

        impl TagCondition {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [tag][crate::model::data_profile_action::tag_resources::TagCondition::tag].
            pub fn set_tag<
                T: std::convert::Into<
                    std::option::Option<crate::model::data_profile_action::tag_resources::TagValue>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.tag = v.into();
                self
            }

            /// Sets the value of `r#type`.
            pub fn set_type<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::data_profile_action::tag_resources::tag_condition::Type,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// The value of [r#type][crate::model::data_profile_action::tag_resources::TagCondition::r#type]
            /// if it holds a `SensitivityScore`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_sensitivity_score(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::SensitivityScore>> {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::data_profile_action::tag_resources::tag_condition::Type::SensitivityScore(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::data_profile_action::tag_resources::TagCondition::r#type]
            /// to hold a `SensitivityScore`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_sensitivity_score<
                T: std::convert::Into<std::boxed::Box<crate::model::SensitivityScore>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::data_profile_action::tag_resources::tag_condition::Type::SensitivityScore(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for TagCondition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.TagResources.TagCondition"
            }
        }

        /// Defines additional types related to TagCondition
        pub mod tag_condition {
            #[allow(unused_imports)]
            use super::*;

            /// The type of condition on which attaching the tag will be predicated.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Type {
                /// Conditions attaching the tag to a resource on its profile having this
                /// sensitivity score.
                SensitivityScore(std::boxed::Box<crate::model::SensitivityScore>),
            }
        }

        /// A value of a tag.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TagValue {
            /// The format of the tag value.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub format: std::option::Option<
                crate::model::data_profile_action::tag_resources::tag_value::Format,
            >,
        }

        impl TagValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of `format`.
            pub fn set_format<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::data_profile_action::tag_resources::tag_value::Format,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.format = v.into();
                self
            }

            /// The value of [format][crate::model::data_profile_action::tag_resources::TagValue::format]
            /// if it holds a `NamespacedValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_namespaced_value(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.format.as_ref().and_then(|v| match v {
                    crate::model::data_profile_action::tag_resources::tag_value::Format::NamespacedValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [format][crate::model::data_profile_action::tag_resources::TagValue::format]
            /// to hold a `NamespacedValue`.
            ///
            /// Note that all the setters affecting `format` are
            /// mutually exclusive.
            pub fn set_namespaced_value<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.format = std::option::Option::Some(
                    crate::model::data_profile_action::tag_resources::tag_value::Format::NamespacedValue(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for TagValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.DataProfileAction.TagResources.TagValue"
            }
        }

        /// Defines additional types related to TagValue
        pub mod tag_value {
            #[allow(unused_imports)]
            use super::*;

            /// The format of the tag value.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Format {
                /// The namespaced name for the tag value to attach to resources. Must be
                /// in the format `{parent_id}/{tag_key_short_name}/{short_name}`, for
                /// example, "123456/environment/prod".
                NamespacedValue(std::string::String),
            }
        }
    }

    /// Types of event that can trigger an action.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct EventType(i32);

    impl EventType {
        /// Unused.
        pub const EVENT_TYPE_UNSPECIFIED: EventType = EventType::new(0);

        /// New profile (not a re-profile).
        pub const NEW_PROFILE: EventType = EventType::new(1);

        /// One of the following profile metrics changed: Data risk score,
        /// Sensitivity score, Resource visibility, Encryption type, Predicted
        /// infoTypes, Other infoTypes
        pub const CHANGED_PROFILE: EventType = EventType::new(2);

        /// Table data risk score or sensitivity score increased.
        pub const SCORE_INCREASED: EventType = EventType::new(3);

        /// A user (non-internal) error occurred.
        pub const ERROR_CHANGED: EventType = EventType::new(4);

        /// Creates a new EventType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EVENT_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NEW_PROFILE"),
                2 => std::borrow::Cow::Borrowed("CHANGED_PROFILE"),
                3 => std::borrow::Cow::Borrowed("SCORE_INCREASED"),
                4 => std::borrow::Cow::Borrowed("ERROR_CHANGED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EVENT_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::EVENT_TYPE_UNSPECIFIED),
                "NEW_PROFILE" => std::option::Option::Some(Self::NEW_PROFILE),
                "CHANGED_PROFILE" => std::option::Option::Some(Self::CHANGED_PROFILE),
                "SCORE_INCREASED" => std::option::Option::Some(Self::SCORE_INCREASED),
                "ERROR_CHANGED" => std::option::Option::Some(Self::ERROR_CHANGED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of action to execute when a profile is generated.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Action {
        /// Export data profiles into a provided location.
        ExportData(std::boxed::Box<crate::model::data_profile_action::Export>),
        /// Publish a message into the Pub/Sub topic.
        PubSubNotification(std::boxed::Box<crate::model::data_profile_action::PubSubNotification>),
        /// Publishes generated data profiles to Google Security Operations.
        /// For more information, see [Use Sensitive Data Protection data in
        /// context-aware
        /// analytics](https://cloud.google.com/chronicle/docs/detection/usecase-dlp-high-risk-user-download).
        PublishToChronicle(std::boxed::Box<crate::model::data_profile_action::PublishToChronicle>),
        /// Publishes findings to Security Command Center for each data profile.
        PublishToScc(
            std::boxed::Box<crate::model::data_profile_action::PublishToSecurityCommandCenter>,
        ),
        /// Tags the profiled resources with the specified tag values.
        TagResources(std::boxed::Box<crate::model::data_profile_action::TagResources>),
    }
}

/// Configuration for setting up a job to scan resources for profile generation.
/// Only one data profile configuration may exist per organization, folder,
/// or project.
///
/// The generated data profiles are retained according to the
/// [data retention policy]
/// (<https://cloud.google.com/sensitive-data-protection/docs/data-profiles#retention>).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileJobConfig {
    /// The data to scan.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::DataProfileLocation>,

    /// The project that will run the scan. The DLP service
    /// account that exists within this project must have access to all resources
    /// that are profiled, and the DLP API must be enabled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Must be set only when scanning other clouds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub other_cloud_starting_location:
        std::option::Option<crate::model::OtherCloudDiscoveryStartingLocation>,

    /// Detection logic for profile generation.
    ///
    /// Not all template features are used by profiles. FindingLimits,
    /// include_quote and exclude_info_types have no impact on
    /// data profiling.
    ///
    /// Multiple templates may be provided if there is data in multiple regions.
    /// At most one template must be specified per-region (including "global").
    /// Each region is scanned using the applicable template. If no region-specific
    /// template is specified, but a "global" template is specified, it will be
    /// copied to that region and used instead. If no global or region-specific
    /// template is provided for a region with data, that region's data will not be
    /// scanned.
    ///
    /// For more information, see
    /// <https://cloud.google.com/sensitive-data-protection/docs/data-profiles#data-residency>.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inspect_templates: std::vec::Vec<std::string::String>,

    /// Actions to execute at the completion of the job.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_profile_actions: std::vec::Vec<crate::model::DataProfileAction>,
}

impl DataProfileJobConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::DataProfileJobConfig::location].
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::DataProfileLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DataProfileJobConfig::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [other_cloud_starting_location][crate::model::DataProfileJobConfig::other_cloud_starting_location].
    pub fn set_other_cloud_starting_location<
        T: std::convert::Into<std::option::Option<crate::model::OtherCloudDiscoveryStartingLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.other_cloud_starting_location = v.into();
        self
    }

    /// Sets the value of [inspect_templates][crate::model::DataProfileJobConfig::inspect_templates].
    pub fn set_inspect_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.inspect_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_profile_actions][crate::model::DataProfileJobConfig::data_profile_actions].
    pub fn set_data_profile_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataProfileAction>,
    {
        use std::iter::Iterator;
        self.data_profile_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DataProfileJobConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileJobConfig"
    }
}

/// A pattern to match against one or more tables, datasets, or projects that
/// contain BigQuery tables. At least one pattern must be specified.
/// Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryRegex {
    /// For organizations, if unset, will match all projects. Has no effect
    /// for data profile configurations created within a project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id_regex: std::string::String,

    /// If unset, this property matches all datasets.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id_regex: std::string::String,

    /// If unset, this property matches all tables.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id_regex: std::string::String,
}

impl BigQueryRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::BigQueryRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }

    /// Sets the value of [dataset_id_regex][crate::model::BigQueryRegex::dataset_id_regex].
    pub fn set_dataset_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_id_regex = v.into();
        self
    }

    /// Sets the value of [table_id_regex][crate::model::BigQueryRegex::table_id_regex].
    pub fn set_table_id_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id_regex = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryRegex"
    }
}

/// A collection of regular expressions to determine what tables to match
/// against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryRegexes {
    /// A single BigQuery regular expression pattern to match against one or more
    /// tables, datasets, or projects that contain BigQuery tables.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patterns: std::vec::Vec<crate::model::BigQueryRegex>,
}

impl BigQueryRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::BigQueryRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQueryRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryRegexes"
    }
}

/// The types of BigQuery tables supported by Cloud DLP.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryTableTypes {
    /// A set of BigQuery table types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub types: std::vec::Vec<crate::model::BigQueryTableType>,
}

impl BigQueryTableTypes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [types][crate::model::BigQueryTableTypes::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQueryTableType>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryTableTypes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryTableTypes"
    }
}

/// Do not profile the tables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Disabled {}

impl Disabled {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for Disabled {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Disabled"
    }
}

/// The data that will be profiled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileLocation {
    /// The location to be scanned.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::data_profile_location::Location>,
}

impl DataProfileLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `location`.
    pub fn set_location<
        T: std::convert::Into<std::option::Option<crate::model::data_profile_location::Location>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::DataProfileLocation::location]
    /// if it holds a `OrganizationId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_organization_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::data_profile_location::Location::OrganizationId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [location][crate::model::DataProfileLocation::location]
    /// if it holds a `FolderId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_folder_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::data_profile_location::Location::FolderId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::DataProfileLocation::location]
    /// to hold a `OrganizationId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_organization_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::data_profile_location::Location::OrganizationId(v.into()),
        );
        self
    }

    /// Sets the value of [location][crate::model::DataProfileLocation::location]
    /// to hold a `FolderId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::data_profile_location::Location::FolderId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataProfileLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileLocation"
    }
}

/// Defines additional types related to DataProfileLocation
pub mod data_profile_location {
    #[allow(unused_imports)]
    use super::*;

    /// The location to be scanned.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Location {
        /// The ID of an organization to scan.
        OrganizationId(i64),
        /// The ID of the folder within an organization to scan.
        FolderId(i64),
    }
}

/// Configuration for discovery to scan resources for profile generation.
/// Only one discovery configuration may exist per organization, folder,
/// or project.
///
/// The generated data profiles are retained according to the
/// [data retention policy]
/// (<https://cloud.google.com/sensitive-data-protection/docs/data-profiles#retention>).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryConfig {
    /// Unique resource name for the DiscoveryConfig, assigned by the service when
    /// the DiscoveryConfig is created, for example
    /// `projects/dlp-test-project/locations/global/discoveryConfigs/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Display name (max 100 chars)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Only set when the parent is an org.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub org_config: std::option::Option<crate::model::discovery_config::OrgConfig>,

    /// Must be set only when scanning other clouds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub other_cloud_starting_location:
        std::option::Option<crate::model::OtherCloudDiscoveryStartingLocation>,

    /// Detection logic for profile generation.
    ///
    /// Not all template features are used by Discovery. FindingLimits,
    /// include_quote and exclude_info_types have no impact on
    /// Discovery.
    ///
    /// Multiple templates may be provided if there is data in multiple regions.
    /// At most one template must be specified per-region (including "global").
    /// Each region is scanned using the applicable template. If no region-specific
    /// template is specified, but a "global" template is specified, it will be
    /// copied to that region and used instead. If no global or region-specific
    /// template is provided for a region with data, that region's data will not be
    /// scanned.
    ///
    /// For more information, see
    /// <https://cloud.google.com/sensitive-data-protection/docs/data-profiles#data-residency>.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inspect_templates: std::vec::Vec<std::string::String>,

    /// Actions to execute at the completion of scanning.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub actions: std::vec::Vec<crate::model::DataProfileAction>,

    /// Target to match against for determining what to scan and how frequently.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub targets: std::vec::Vec<crate::model::DiscoveryTarget>,

    /// Output only. A stream of errors encountered when the config was activated.
    /// Repeated errors may result in the config automatically being paused. Output
    /// only field. Will return the last 100 errors. Whenever the config is
    /// modified this list will be cleared.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Output only. The creation timestamp of a DiscoveryConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of a DiscoveryConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the last time this config was executed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_run_time: std::option::Option<wkt::Timestamp>,

    /// Required. A status for this configuration.
    pub status: crate::model::discovery_config::Status,

    /// Optional. Processing location configuration. Vertex AI dataset scanning
    /// will set processing_location.image_fallback_type to MultiRegionProcessing
    /// by default.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub processing_location: std::option::Option<crate::model::ProcessingLocation>,
}

impl DiscoveryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiscoveryConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DiscoveryConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [org_config][crate::model::DiscoveryConfig::org_config].
    pub fn set_org_config<
        T: std::convert::Into<std::option::Option<crate::model::discovery_config::OrgConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.org_config = v.into();
        self
    }

    /// Sets the value of [other_cloud_starting_location][crate::model::DiscoveryConfig::other_cloud_starting_location].
    pub fn set_other_cloud_starting_location<
        T: std::convert::Into<std::option::Option<crate::model::OtherCloudDiscoveryStartingLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.other_cloud_starting_location = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DiscoveryConfig::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DiscoveryConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [last_run_time][crate::model::DiscoveryConfig::last_run_time].
    pub fn set_last_run_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_run_time = v.into();
        self
    }

    /// Sets the value of [status][crate::model::DiscoveryConfig::status].
    pub fn set_status<T: std::convert::Into<crate::model::discovery_config::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [processing_location][crate::model::DiscoveryConfig::processing_location].
    pub fn set_processing_location<
        T: std::convert::Into<std::option::Option<crate::model::ProcessingLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.processing_location = v.into();
        self
    }

    /// Sets the value of [inspect_templates][crate::model::DiscoveryConfig::inspect_templates].
    pub fn set_inspect_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.inspect_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [actions][crate::model::DiscoveryConfig::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataProfileAction>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [targets][crate::model::DiscoveryConfig::targets].
    pub fn set_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveryTarget>,
    {
        use std::iter::Iterator;
        self.targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors][crate::model::DiscoveryConfig::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiscoveryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryConfig"
    }
}

/// Defines additional types related to DiscoveryConfig
pub mod discovery_config {
    #[allow(unused_imports)]
    use super::*;

    /// Project and scan location information. Only set when the parent is an org.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OrgConfig {
        /// The data to scan: folder, org, or project
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub location: std::option::Option<crate::model::DiscoveryStartingLocation>,

        /// The project that will run the scan. The DLP service
        /// account that exists within this project must have access to all resources
        /// that are profiled, and the DLP API must be enabled.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub project_id: std::string::String,
    }

    impl OrgConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [location][crate::model::discovery_config::OrgConfig::location].
        pub fn set_location<
            T: std::convert::Into<std::option::Option<crate::model::DiscoveryStartingLocation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [project_id][crate::model::discovery_config::OrgConfig::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }
    }

    impl wkt::message::Message for OrgConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryConfig.OrgConfig"
        }
    }

    /// Whether the discovery config is currently active. New options may be added
    /// at a later time.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Status(i32);

    impl Status {
        /// Unused
        pub const STATUS_UNSPECIFIED: Status = Status::new(0);

        /// The discovery config is currently active.
        pub const RUNNING: Status = Status::new(1);

        /// The discovery config is paused temporarily.
        pub const PAUSED: Status = Status::new(2);

        /// Creates a new Status instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATUS_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RUNNING"),
                2 => std::borrow::Cow::Borrowed("PAUSED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATUS_UNSPECIFIED" => std::option::Option::Some(Self::STATUS_UNSPECIFIED),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "PAUSED" => std::option::Option::Some(Self::PAUSED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Target used to match against for Discovery.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryTarget {
    /// A target to match against for Discovery.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::discovery_target::Target>,
}

impl DiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `target`.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::discovery_target::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `BigQueryTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_big_query_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::BigQueryTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `CloudSqlTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_sql_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::CloudSqlTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `SecretsTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_secrets_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SecretsDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::SecretsTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `CloudStorageTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_storage_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::CloudStorageTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `OtherCloudTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_other_cloud_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::OtherCloudTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [target][crate::model::DiscoveryTarget::target]
    /// if it holds a `VertexDatasetTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_dataset_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetDiscoveryTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::discovery_target::Target::VertexDatasetTarget(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `BigQueryTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_big_query_target<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::BigQueryTarget(v.into()),
        );
        self
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `CloudSqlTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_cloud_sql_target<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::CloudSqlTarget(v.into()),
        );
        self
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `SecretsTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_secrets_target<
        T: std::convert::Into<std::boxed::Box<crate::model::SecretsDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::SecretsTarget(v.into()),
        );
        self
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `CloudStorageTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_cloud_storage_target<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::CloudStorageTarget(v.into()),
        );
        self
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `OtherCloudTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_other_cloud_target<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::OtherCloudTarget(v.into()),
        );
        self
    }

    /// Sets the value of [target][crate::model::DiscoveryTarget::target]
    /// to hold a `VertexDatasetTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_target<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetDiscoveryTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::discovery_target::Target::VertexDatasetTarget(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryTarget"
    }
}

/// Defines additional types related to DiscoveryTarget
pub mod discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// A target to match against for Discovery.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Target {
        /// BigQuery target for Discovery. The first target to match a table will be
        /// the one applied.
        BigQueryTarget(std::boxed::Box<crate::model::BigQueryDiscoveryTarget>),
        /// Cloud SQL target for Discovery. The first target to match a table will be
        /// the one applied.
        CloudSqlTarget(std::boxed::Box<crate::model::CloudSqlDiscoveryTarget>),
        /// Discovery target that looks for credentials and secrets stored in cloud
        /// resource metadata and reports them as vulnerabilities to Security Command
        /// Center. Only one target of this type is allowed.
        SecretsTarget(std::boxed::Box<crate::model::SecretsDiscoveryTarget>),
        /// Cloud Storage target for Discovery. The first target to match a table
        /// will be the one applied.
        CloudStorageTarget(std::boxed::Box<crate::model::CloudStorageDiscoveryTarget>),
        /// Other clouds target for discovery. The first target to match a resource
        /// will be the one applied.
        OtherCloudTarget(std::boxed::Box<crate::model::OtherCloudDiscoveryTarget>),
        /// Vertex AI dataset target for Discovery. The first target to match a
        /// dataset will be the one applied. Note that discovery for Vertex AI can
        /// incur Cloud Storage Class B operation charges for storage.objects.get
        /// operations and retrieval fees. For more information, see [Cloud Storage
        /// pricing](https://cloud.google.com/storage/pricing#price-tables).
        /// Note that discovery for Vertex AI dataset will not be able to scan images
        /// unless DiscoveryConfig.processing_location.image_fallback_location has
        /// multi_region_processing or global_processing configured.
        VertexDatasetTarget(std::boxed::Box<crate::model::VertexDatasetDiscoveryTarget>),
    }
}

/// Target used to match against for discovery with BigQuery tables
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryDiscoveryTarget {
    /// Required. The tables the discovery cadence applies to. The first target
    /// with a matching filter will be the one to apply to a table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::DiscoveryBigQueryFilter>,

    /// In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::DiscoveryBigQueryConditions>,

    /// The generation rule includes the logic on how frequently
    /// to update the data profiles. If not specified, discovery will re-run and
    /// update no more than once a month if new columns appear in the table.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub frequency: std::option::Option<crate::model::big_query_discovery_target::Frequency>,
}

impl BigQueryDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::BigQueryDiscoveryTarget::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryBigQueryFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::BigQueryDiscoveryTarget::conditions].
    pub fn set_conditions<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryBigQueryConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// Sets the value of `frequency`.
    pub fn set_frequency<
        T: std::convert::Into<
            std::option::Option<crate::model::big_query_discovery_target::Frequency>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }

    /// The value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// if it holds a `Cadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryGenerationCadence>> {
        #[allow(unreachable_patterns)]
        self.frequency.as_ref().and_then(|v| match v {
            crate::model::big_query_discovery_target::Frequency::Cadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.frequency.as_ref().and_then(|v| match v {
            crate::model::big_query_discovery_target::Frequency::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// to hold a `Cadence`.
    ///
    /// Note that all the setters affecting `frequency` are
    /// mutually exclusive.
    pub fn set_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = std::option::Option::Some(
            crate::model::big_query_discovery_target::Frequency::Cadence(v.into()),
        );
        self
    }

    /// Sets the value of [frequency][crate::model::BigQueryDiscoveryTarget::frequency]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `frequency` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = std::option::Option::Some(
            crate::model::big_query_discovery_target::Frequency::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryDiscoveryTarget"
    }
}

/// Defines additional types related to BigQueryDiscoveryTarget
pub mod big_query_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// The generation rule includes the logic on how frequently
    /// to update the data profiles. If not specified, discovery will re-run and
    /// update no more than once a month if new columns appear in the table.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Frequency {
        /// How often and when to update profiles. New tables that match both the
        /// filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        Cadence(std::boxed::Box<crate::model::DiscoveryGenerationCadence>),
        /// Tables that match this filter will not have profiles created.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines what tables will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID, dataset ID, and table ID.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryBigQueryFilter {
    /// Whether the filter applies to a specific set of tables or all other tables
    /// within the location being profiled. The first filter to match will be
    /// applied, regardless of the condition. If none is set, will default to
    /// `other_tables`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::discovery_big_query_filter::Filter>,
}

impl DiscoveryBigQueryFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `filter`.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::discovery_big_query_filter::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// if it holds a `Tables`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tables(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTableCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_filter::Filter::Tables(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// if it holds a `OtherTables`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_other_tables(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::discovery_big_query_filter::AllOtherBigQueryTables>,
    > {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_filter::Filter::OtherTables(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// if it holds a `TableReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_table_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TableReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_filter::Filter::TableReference(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// to hold a `Tables`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_tables<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTableCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_big_query_filter::Filter::Tables(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// to hold a `OtherTables`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_other_tables<
        T: std::convert::Into<
            std::boxed::Box<crate::model::discovery_big_query_filter::AllOtherBigQueryTables>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_big_query_filter::Filter::OtherTables(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::DiscoveryBigQueryFilter::filter]
    /// to hold a `TableReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_table_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_big_query_filter::Filter::TableReference(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryBigQueryFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryFilter"
    }
}

/// Defines additional types related to DiscoveryBigQueryFilter
pub mod discovery_big_query_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Catch-all for all other tables not specified by other filters. Should
    /// always be last, except for single-table configurations, which will only
    /// have a TableReference target.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AllOtherBigQueryTables {}

    impl AllOtherBigQueryTables {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for AllOtherBigQueryTables {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryFilter.AllOtherBigQueryTables"
        }
    }

    /// Whether the filter applies to a specific set of tables or all other tables
    /// within the location being profiled. The first filter to match will be
    /// applied, regardless of the condition. If none is set, will default to
    /// `other_tables`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// A specific set of tables for this filter to apply to. A table collection
        /// must be specified in only one filter per config.
        /// If a table id or dataset is empty, Cloud DLP assumes all tables in that
        /// collection must be profiled. Must specify a project ID.
        Tables(std::boxed::Box<crate::model::BigQueryTableCollection>),
        /// Catch-all. This should always be the last filter in the list because
        /// anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        OtherTables(
            std::boxed::Box<crate::model::discovery_big_query_filter::AllOtherBigQueryTables>,
        ),
        /// The table to scan. Discovery configurations including this can only
        /// include one DiscoveryTarget (the DiscoveryTarget with this
        /// TableReference).
        TableReference(std::boxed::Box<crate::model::TableReference>),
    }
}

/// Specifies a collection of BigQuery tables. Used for Discovery.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryTableCollection {
    /// Maximum of 100 entries.
    /// The first filter containing a pattern that matches a table will be used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub pattern: std::option::Option<crate::model::big_query_table_collection::Pattern>,
}

impl BigQueryTableCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `pattern`.
    pub fn set_pattern<
        T: std::convert::Into<std::option::Option<crate::model::big_query_table_collection::Pattern>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::BigQueryTableCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::big_query_table_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::BigQueryTableCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::big_query_table_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQueryTableCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryTableCollection"
    }
}

/// Defines additional types related to BigQueryTableCollection
pub mod big_query_table_collection {
    #[allow(unused_imports)]
    use super::*;

    /// Maximum of 100 entries.
    /// The first filter containing a pattern that matches a table will be used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Pattern {
        /// A collection of regular expressions to match a BigQuery table against.
        IncludeRegexes(std::boxed::Box<crate::model::BigQueryRegexes>),
    }
}

/// Requirements that must be true before a table is scanned in discovery for the
/// first time. There is an AND relationship between the top-level attributes.
/// Additionally, minimum conditions with an OR relationship that must be met
/// before Cloud DLP scans a table can be set (like a minimum row count or a
/// minimum table age).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryBigQueryConditions {
    /// BigQuery table must have been created after this date. Used to avoid
    /// backfilling.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_after: std::option::Option<wkt::Timestamp>,

    /// At least one of the conditions must be true for a table to be scanned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub or_conditions:
        std::option::Option<crate::model::discovery_big_query_conditions::OrConditions>,

    /// The type of BigQuery tables to scan. If nothing is set the default
    /// behavior is to scan only tables of type TABLE and to give errors
    /// for all unsupported tables.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub included_types:
        std::option::Option<crate::model::discovery_big_query_conditions::IncludedTypes>,
}

impl DiscoveryBigQueryConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_after][crate::model::DiscoveryBigQueryConditions::created_after].
    pub fn set_created_after<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.created_after = v.into();
        self
    }

    /// Sets the value of [or_conditions][crate::model::DiscoveryBigQueryConditions::or_conditions].
    pub fn set_or_conditions<
        T: std::convert::Into<
            std::option::Option<crate::model::discovery_big_query_conditions::OrConditions>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.or_conditions = v.into();
        self
    }

    /// Sets the value of `included_types`.
    pub fn set_included_types<
        T: std::convert::Into<
            std::option::Option<crate::model::discovery_big_query_conditions::IncludedTypes>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.included_types = v.into();
        self
    }

    /// The value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// if it holds a `Types`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_types(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryTableTypes>> {
        #[allow(unreachable_patterns)]
        self.included_types.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_conditions::IncludedTypes::Types(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// if it holds a `TypeCollection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_type_collection(
        &self,
    ) -> std::option::Option<&crate::model::BigQueryTableTypeCollection> {
        #[allow(unreachable_patterns)]
        self.included_types.as_ref().and_then(|v| match v {
            crate::model::discovery_big_query_conditions::IncludedTypes::TypeCollection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// to hold a `Types`.
    ///
    /// Note that all the setters affecting `included_types` are
    /// mutually exclusive.
    pub fn set_types<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryTableTypes>>>(
        mut self,
        v: T,
    ) -> Self {
        self.included_types = std::option::Option::Some(
            crate::model::discovery_big_query_conditions::IncludedTypes::Types(v.into()),
        );
        self
    }

    /// Sets the value of [included_types][crate::model::DiscoveryBigQueryConditions::included_types]
    /// to hold a `TypeCollection`.
    ///
    /// Note that all the setters affecting `included_types` are
    /// mutually exclusive.
    pub fn set_type_collection<T: std::convert::Into<crate::model::BigQueryTableTypeCollection>>(
        mut self,
        v: T,
    ) -> Self {
        self.included_types = std::option::Option::Some(
            crate::model::discovery_big_query_conditions::IncludedTypes::TypeCollection(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryBigQueryConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryConditions"
    }
}

/// Defines additional types related to DiscoveryBigQueryConditions
pub mod discovery_big_query_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// There is an OR relationship between these attributes. They are used to
    /// determine if a table should be scanned or not in Discovery.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OrConditions {
        /// Minimum number of rows that should be present before Cloud DLP
        /// profiles a table
        pub min_row_count: i32,

        /// Minimum age a table must have before Cloud DLP can profile it. Value must
        /// be 1 hour or greater.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_age: std::option::Option<wkt::Duration>,
    }

    impl OrConditions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_row_count][crate::model::discovery_big_query_conditions::OrConditions::min_row_count].
        pub fn set_min_row_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_row_count = v.into();
            self
        }

        /// Sets the value of [min_age][crate::model::discovery_big_query_conditions::OrConditions::min_age].
        pub fn set_min_age<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_age = v.into();
            self
        }
    }

    impl wkt::message::Message for OrConditions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryBigQueryConditions.OrConditions"
        }
    }

    /// The type of BigQuery tables to scan. If nothing is set the default
    /// behavior is to scan only tables of type TABLE and to give errors
    /// for all unsupported tables.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum IncludedTypes {
        /// Restrict discovery to specific table types.
        Types(std::boxed::Box<crate::model::BigQueryTableTypes>),
        /// Restrict discovery to categories of table types.
        TypeCollection(crate::model::BigQueryTableTypeCollection),
    }
}

/// What must take place for a profile to be updated and how
/// frequently it should occur.
/// New tables are scanned as quickly as possible depending on system
/// capacity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryGenerationCadence {
    /// Governs when to update data profiles when a schema is modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema_modified_cadence: std::option::Option<crate::model::DiscoverySchemaModifiedCadence>,

    /// Governs when to update data profiles when a table is modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_modified_cadence: std::option::Option<crate::model::DiscoveryTableModifiedCadence>,

    /// Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,

    /// Frequency at which profiles should be updated, regardless of whether the
    /// underlying resource has changed. Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,
}

impl DiscoveryGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_modified_cadence][crate::model::DiscoveryGenerationCadence::schema_modified_cadence].
    pub fn set_schema_modified_cadence<
        T: std::convert::Into<std::option::Option<crate::model::DiscoverySchemaModifiedCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema_modified_cadence = v.into();
        self
    }

    /// Sets the value of [table_modified_cadence][crate::model::DiscoveryGenerationCadence::table_modified_cadence].
    pub fn set_table_modified_cadence<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryTableModifiedCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_modified_cadence = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<
        T: std::convert::Into<
            std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_cadence = v.into();
        self
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryGenerationCadence"
    }
}

/// The cadence at which to update data profiles when a table is modified.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryTableModifiedCadence {
    /// The type of events to consider when deciding if the table has been
    /// modified and should have the profile updated. Defaults to
    /// MODIFIED_TIMESTAMP.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub types: std::vec::Vec<crate::model::BigQueryTableModification>,

    /// How frequently data profiles can be updated when tables are modified.
    /// Defaults to never.
    pub frequency: crate::model::DataProfileUpdateFrequency,
}

impl DiscoveryTableModifiedCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [frequency][crate::model::DiscoveryTableModifiedCadence::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }

    /// Sets the value of [types][crate::model::DiscoveryTableModifiedCadence::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQueryTableModification>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiscoveryTableModifiedCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryTableModifiedCadence"
    }
}

/// The cadence at which to update data profiles when a schema is modified.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoverySchemaModifiedCadence {
    /// The type of events to consider when deciding if the table's schema
    /// has been modified and should have the profile updated. Defaults to
    /// NEW_COLUMNS.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub types: std::vec::Vec<crate::model::BigQuerySchemaModification>,

    /// How frequently profiles may be updated when schemas are
    /// modified. Defaults to monthly.
    pub frequency: crate::model::DataProfileUpdateFrequency,
}

impl DiscoverySchemaModifiedCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [frequency][crate::model::DiscoverySchemaModifiedCadence::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }

    /// Sets the value of [types][crate::model::DiscoverySchemaModifiedCadence::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQuerySchemaModification>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiscoverySchemaModifiedCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoverySchemaModifiedCadence"
    }
}

/// The cadence at which to update data profiles when the inspection rules
/// defined by the `InspectTemplate` change.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryInspectTemplateModifiedCadence {
    /// How frequently data profiles can be updated when the template is modified.
    /// Defaults to never.
    pub frequency: crate::model::DataProfileUpdateFrequency,
}

impl DiscoveryInspectTemplateModifiedCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [frequency][crate::model::DiscoveryInspectTemplateModifiedCadence::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryInspectTemplateModifiedCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryInspectTemplateModifiedCadence"
    }
}

/// Target used to match against for discovery with Cloud SQL tables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlDiscoveryTarget {
    /// Required. The tables the discovery cadence applies to. The first target
    /// with a matching filter will be the one to apply to a table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::DiscoveryCloudSqlFilter>,

    /// In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::DiscoveryCloudSqlConditions>,

    /// Type of schedule.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cadence: std::option::Option<crate::model::cloud_sql_discovery_target::Cadence>,
}

impl CloudSqlDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::CloudSqlDiscoveryTarget::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryCloudSqlFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::CloudSqlDiscoveryTarget::conditions].
    pub fn set_conditions<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryCloudSqlConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// Sets the value of `cadence`.
    pub fn set_cadence<
        T: std::convert::Into<std::option::Option<crate::model::cloud_sql_discovery_target::Cadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryCloudSqlGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryCloudSqlGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_sql_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// Sets the value of [cadence][crate::model::CloudSqlDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_sql_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudSqlDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudSqlDiscoveryTarget"
    }
}

/// Defines additional types related to CloudSqlDiscoveryTarget
pub mod cloud_sql_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// Type of schedule.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Cadence {
        /// How often and when to update profiles. New tables that match both the
        /// filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryCloudSqlGenerationCadence>),
        /// Disable profiling for database resources that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines what tables will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID, location, instance, database, and database resource name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudSqlFilter {
    /// Whether the filter applies to a specific set of database resources or all
    /// other database resources within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::discovery_cloud_sql_filter::Filter>,
}

impl DiscoveryCloudSqlFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `filter`.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::discovery_cloud_sql_filter::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseResourceCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_sql_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_others(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherDatabaseResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_sql_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// if it holds a `DatabaseResourceReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_database_resource_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseResourceReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_sql_filter::Filter::DatabaseResourceReference(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseResourceCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_sql_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<
        T: std::convert::Into<std::boxed::Box<crate::model::AllOtherDatabaseResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_sql_filter::Filter::Others(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudSqlFilter::filter]
    /// to hold a `DatabaseResourceReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_database_resource_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_sql_filter::Filter::DatabaseResourceReference(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryCloudSqlFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlFilter"
    }
}

/// Defines additional types related to DiscoveryCloudSqlFilter
pub mod discovery_cloud_sql_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of database resources or all
    /// other database resources within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// A specific set of database resources for this filter to apply to.
        Collection(std::boxed::Box<crate::model::DatabaseResourceCollection>),
        /// Catch-all. This should always be the last target in the list because
        /// anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherDatabaseResources>),
        /// The database resource to scan. Targets including this can only include
        /// one target (the target with this database resource reference).
        DatabaseResourceReference(std::boxed::Box<crate::model::DatabaseResourceReference>),
    }
}

/// Match database resources using regex filters. Examples of database
/// resources are tables, views, and stored procedures.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseResourceCollection {
    /// The first filter containing a pattern that matches a database resource will
    /// be used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub pattern: std::option::Option<crate::model::database_resource_collection::Pattern>,
}

impl DatabaseResourceCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `pattern`.
    pub fn set_pattern<
        T: std::convert::Into<
            std::option::Option<crate::model::database_resource_collection::Pattern>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::DatabaseResourceCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseResourceRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::database_resource_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::DatabaseResourceCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseResourceRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::database_resource_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DatabaseResourceCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceCollection"
    }
}

/// Defines additional types related to DatabaseResourceCollection
pub mod database_resource_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The first filter containing a pattern that matches a database resource will
    /// be used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Pattern {
        /// A collection of regular expressions to match a database resource against.
        IncludeRegexes(std::boxed::Box<crate::model::DatabaseResourceRegexes>),
    }
}

/// A collection of regular expressions to determine what database resources to
/// match against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseResourceRegexes {
    /// A group of regular expression patterns to match against one or more
    /// database resources.
    /// Maximum of 100 entries. The sum of all regular expression's length can't
    /// exceed 10 KiB.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patterns: std::vec::Vec<crate::model::DatabaseResourceRegex>,
}

impl DatabaseResourceRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::DatabaseResourceRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseResourceRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatabaseResourceRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceRegexes"
    }
}

/// A pattern to match against one or more database resources. At least one
/// pattern must be specified. Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseResourceRegex {
    /// For organizations, if unset, will match all projects. Has no effect
    /// for configurations created within a project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id_regex: std::string::String,

    /// Regex to test the instance name against. If empty, all instances match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_regex: std::string::String,

    /// Regex to test the database name against. If empty, all databases match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_regex: std::string::String,

    /// Regex to test the database resource's name against. An example of a
    /// database resource name is a table's name. Other database resource names
    /// like view names could be included in the future. If empty, all database
    /// resources match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_resource_name_regex: std::string::String,
}

impl DatabaseResourceRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::DatabaseResourceRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }

    /// Sets the value of [instance_regex][crate::model::DatabaseResourceRegex::instance_regex].
    pub fn set_instance_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_regex = v.into();
        self
    }

    /// Sets the value of [database_regex][crate::model::DatabaseResourceRegex::database_regex].
    pub fn set_database_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_regex = v.into();
        self
    }

    /// Sets the value of [database_resource_name_regex][crate::model::DatabaseResourceRegex::database_resource_name_regex].
    pub fn set_database_resource_name_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_resource_name_regex = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseResourceRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceRegex"
    }
}

/// Match database resources not covered by any other filter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AllOtherDatabaseResources {}

impl AllOtherDatabaseResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AllOtherDatabaseResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AllOtherDatabaseResources"
    }
}

/// Identifies a single database resource, like a table within a database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseResourceReference {
    /// Required. If within a project-level config, then this must match the
    /// config's project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The instance where this resource is located. For example: Cloud
    /// SQL instance ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Required. Name of a database within the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Required. Name of a database resource, for example, a table within the
    /// database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_resource: std::string::String,
}

impl DatabaseResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DatabaseResourceReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::DatabaseResourceReference::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [database][crate::model::DatabaseResourceReference::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [database_resource][crate::model::DatabaseResourceReference::database_resource].
    pub fn set_database_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_resource = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatabaseResourceReference"
    }
}

/// Requirements that must be true before a table is profiled for the
/// first time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudSqlConditions {
    /// Optional. Database engines that should be profiled.
    /// Optional. Defaults to ALL_SUPPORTED_DATABASE_ENGINES if unspecified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub database_engines:
        std::vec::Vec<crate::model::discovery_cloud_sql_conditions::DatabaseEngine>,

    /// Data profiles will only be generated for the database resource types
    /// specified in this field.
    /// If not specified, defaults to [DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES].
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub types: std::vec::Vec<crate::model::discovery_cloud_sql_conditions::DatabaseResourceType>,
}

impl DiscoveryCloudSqlConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_engines][crate::model::DiscoveryCloudSqlConditions::database_engines].
    pub fn set_database_engines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::discovery_cloud_sql_conditions::DatabaseEngine>,
    {
        use std::iter::Iterator;
        self.database_engines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [types][crate::model::DiscoveryCloudSqlConditions::types].
    pub fn set_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::discovery_cloud_sql_conditions::DatabaseResourceType>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiscoveryCloudSqlConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlConditions"
    }
}

/// Defines additional types related to DiscoveryCloudSqlConditions
pub mod discovery_cloud_sql_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// The database engines that should be profiled.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DatabaseEngine(i32);

    impl DatabaseEngine {
        /// Unused.
        pub const DATABASE_ENGINE_UNSPECIFIED: DatabaseEngine = DatabaseEngine::new(0);

        /// Include all supported database engines.
        pub const ALL_SUPPORTED_DATABASE_ENGINES: DatabaseEngine = DatabaseEngine::new(1);

        /// MySQL database.
        pub const MYSQL: DatabaseEngine = DatabaseEngine::new(2);

        /// PostgreSQL database.
        pub const POSTGRES: DatabaseEngine = DatabaseEngine::new(3);

        /// Creates a new DatabaseEngine instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DATABASE_ENGINE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ALL_SUPPORTED_DATABASE_ENGINES"),
                2 => std::borrow::Cow::Borrowed("MYSQL"),
                3 => std::borrow::Cow::Borrowed("POSTGRES"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DATABASE_ENGINE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DATABASE_ENGINE_UNSPECIFIED)
                }
                "ALL_SUPPORTED_DATABASE_ENGINES" => {
                    std::option::Option::Some(Self::ALL_SUPPORTED_DATABASE_ENGINES)
                }
                "MYSQL" => std::option::Option::Some(Self::MYSQL),
                "POSTGRES" => std::option::Option::Some(Self::POSTGRES),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DatabaseEngine {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DatabaseEngine {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Cloud SQL database resource types. New values can be added at a later time.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DatabaseResourceType(i32);

    impl DatabaseResourceType {
        /// Unused.
        pub const DATABASE_RESOURCE_TYPE_UNSPECIFIED: DatabaseResourceType =
            DatabaseResourceType::new(0);

        /// Includes database resource types that become supported at a later time.
        pub const DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES: DatabaseResourceType =
            DatabaseResourceType::new(1);

        /// Tables.
        pub const DATABASE_RESOURCE_TYPE_TABLE: DatabaseResourceType = DatabaseResourceType::new(2);

        /// Creates a new DatabaseResourceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DATABASE_RESOURCE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES"),
                2 => std::borrow::Cow::Borrowed("DATABASE_RESOURCE_TYPE_TABLE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DATABASE_RESOURCE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DATABASE_RESOURCE_TYPE_UNSPECIFIED)
                }
                "DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES" => {
                    std::option::Option::Some(Self::DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES)
                }
                "DATABASE_RESOURCE_TYPE_TABLE" => {
                    std::option::Option::Some(Self::DATABASE_RESOURCE_TYPE_TABLE)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DatabaseResourceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DatabaseResourceType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// How often existing tables should have their profiles refreshed.
/// New tables are scanned as quickly as possible depending on system
/// capacity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudSqlGenerationCadence {
    /// When to reprofile if the schema has changed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema_modified_cadence: std::option::Option<
        crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence,
    >,

    /// Data changes (non-schema changes) in Cloud SQL tables can't trigger
    /// reprofiling. If you set this field, profiles are refreshed at this
    /// frequency regardless of whether the underlying tables have changed.
    /// Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
}

impl DiscoveryCloudSqlGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_modified_cadence][crate::model::DiscoveryCloudSqlGenerationCadence::schema_modified_cadence].
    pub fn set_schema_modified_cadence<
        T: std::convert::Into<
            std::option::Option<
                crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema_modified_cadence = v.into();
        self
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryCloudSqlGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryCloudSqlGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<
        T: std::convert::Into<
            std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_cadence = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryCloudSqlGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlGenerationCadence"
    }
}

/// Defines additional types related to DiscoveryCloudSqlGenerationCadence
pub mod discovery_cloud_sql_generation_cadence {
    #[allow(unused_imports)]
    use super::*;

    /// How frequently to modify the profile when the table's schema is modified.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SchemaModifiedCadence {

        /// The types of schema modifications to consider.
        /// Defaults to NEW_COLUMNS.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub types: std::vec::Vec<crate::model::discovery_cloud_sql_generation_cadence::schema_modified_cadence::CloudSqlSchemaModification>,

        /// Frequency to regenerate data profiles when the schema is modified.
        /// Defaults to monthly.
        pub frequency: crate::model::DataProfileUpdateFrequency,
    }

    impl SchemaModifiedCadence {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [frequency][crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence::frequency].
        pub fn set_frequency<T: std::convert::Into<crate::model::DataProfileUpdateFrequency>>(
            mut self,
            v: T,
        ) -> Self {
            self.frequency = v.into();
            self
        }

        /// Sets the value of [types][crate::model::discovery_cloud_sql_generation_cadence::SchemaModifiedCadence::types].
        pub fn set_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::discovery_cloud_sql_generation_cadence::schema_modified_cadence::CloudSqlSchemaModification>
        {
            use std::iter::Iterator;
            self.types = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SchemaModifiedCadence {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudSqlGenerationCadence.SchemaModifiedCadence"
        }
    }

    /// Defines additional types related to SchemaModifiedCadence
    pub mod schema_modified_cadence {
        #[allow(unused_imports)]
        use super::*;

        /// The type of modification that causes a profile update.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct CloudSqlSchemaModification(i32);

        impl CloudSqlSchemaModification {
            /// Unused.
            pub const SQL_SCHEMA_MODIFICATION_UNSPECIFIED: CloudSqlSchemaModification =
                CloudSqlSchemaModification::new(0);

            /// New columns have appeared.
            pub const NEW_COLUMNS: CloudSqlSchemaModification = CloudSqlSchemaModification::new(1);

            /// Columns have been removed from the table.
            pub const REMOVED_COLUMNS: CloudSqlSchemaModification =
                CloudSqlSchemaModification::new(2);

            /// Creates a new CloudSqlSchemaModification instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("SQL_SCHEMA_MODIFICATION_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("NEW_COLUMNS"),
                    2 => std::borrow::Cow::Borrowed("REMOVED_COLUMNS"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "SQL_SCHEMA_MODIFICATION_UNSPECIFIED" => {
                        std::option::Option::Some(Self::SQL_SCHEMA_MODIFICATION_UNSPECIFIED)
                    }
                    "NEW_COLUMNS" => std::option::Option::Some(Self::NEW_COLUMNS),
                    "REMOVED_COLUMNS" => std::option::Option::Some(Self::REMOVED_COLUMNS),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for CloudSqlSchemaModification {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for CloudSqlSchemaModification {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }
}

/// Discovery target for credentials and secrets in cloud resource metadata.
///
/// This target does not include any filtering or frequency controls. Cloud
/// DLP will scan cloud resource metadata for secrets daily.
///
/// No inspect template should be included in the discovery config for a
/// security benchmarks scan. Instead, the built-in list of secrets and
/// credentials infoTypes will be used (see
/// <https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference#credentials_and_secrets>).
///
/// Credentials and secrets discovered will be reported as vulnerabilities to
/// Security Command Center.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretsDiscoveryTarget {}

impl SecretsDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SecretsDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SecretsDiscoveryTarget"
    }
}

/// Target used to match against for discovery with Cloud Storage buckets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageDiscoveryTarget {
    /// Required. The buckets the generation_cadence applies to. The first target
    /// with a matching filter will be the one to apply to a bucket.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::DiscoveryCloudStorageFilter>,

    /// Optional. In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::DiscoveryFileStoreConditions>,

    /// How often and when to update profiles.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cadence: std::option::Option<crate::model::cloud_storage_discovery_target::Cadence>,
}

impl CloudStorageDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::CloudStorageDiscoveryTarget::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryCloudStorageFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::CloudStorageDiscoveryTarget::conditions].
    pub fn set_conditions<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryFileStoreConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// Sets the value of `cadence`.
    pub fn set_cadence<
        T: std::convert::Into<
            std::option::Option<crate::model::cloud_storage_discovery_target::Cadence>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryCloudStorageGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_storage_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::cloud_storage_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryCloudStorageGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_storage_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// Sets the value of [cadence][crate::model::CloudStorageDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::cloud_storage_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudStorageDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageDiscoveryTarget"
    }
}

/// Defines additional types related to CloudStorageDiscoveryTarget
pub mod cloud_storage_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// How often and when to update profiles.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Cadence {
        /// Optional. How often and when to update profiles. New buckets that match
        /// both the filter and conditions are scanned as quickly as possible
        /// depending on system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryCloudStorageGenerationCadence>),
        /// Optional. Disable profiling for buckets that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines which buckets will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID and bucket name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudStorageFilter {
    /// Whether the filter applies to a specific set of buckets or all
    /// other buckets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::discovery_cloud_storage_filter::Filter>,
}

impl DiscoveryCloudStorageFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `filter`.
    pub fn set_filter<
        T: std::convert::Into<
            std::option::Option<crate::model::discovery_cloud_storage_filter::Filter>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileStoreCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_storage_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// if it holds a `CloudStorageResourceReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_storage_resource_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageResourceReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_storage_filter::Filter::CloudStorageResourceReference(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_others(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_cloud_storage_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::FileStoreCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_storage_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// to hold a `CloudStorageResourceReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_cloud_storage_resource_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_storage_filter::Filter::CloudStorageResourceReference(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [filter][crate::model::DiscoveryCloudStorageFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<T: std::convert::Into<std::boxed::Box<crate::model::AllOtherResources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_cloud_storage_filter::Filter::Others(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryCloudStorageFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudStorageFilter"
    }
}

/// Defines additional types related to DiscoveryCloudStorageFilter
pub mod discovery_cloud_storage_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of buckets or all
    /// other buckets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, will default to `others`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// Optional. A specific set of buckets for this filter to apply to.
        Collection(std::boxed::Box<crate::model::FileStoreCollection>),
        /// Optional. The bucket to scan. Targets including this can only include one
        /// target (the target with this bucket). This enables profiling the contents
        /// of a single bucket, while the other options allow for easy profiling of
        /// many bucets within a project or an organization.
        CloudStorageResourceReference(std::boxed::Box<crate::model::CloudStorageResourceReference>),
        /// Optional. Catch-all. This should always be the last target in the list
        /// because anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherResources>),
    }
}

/// Match file stores (e.g. buckets) using regex filters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStoreCollection {
    /// The first filter containing a pattern that matches a file store will
    /// be used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub pattern: std::option::Option<crate::model::file_store_collection::Pattern>,
}

impl FileStoreCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `pattern`.
    pub fn set_pattern<
        T: std::convert::Into<std::option::Option<crate::model::file_store_collection::Pattern>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::FileStoreCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileStoreRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::file_store_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::FileStoreCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::FileStoreRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::file_store_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileStoreCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreCollection"
    }
}

/// Defines additional types related to FileStoreCollection
pub mod file_store_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The first filter containing a pattern that matches a file store will
    /// be used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Pattern {
        /// Optional. A collection of regular expressions to match a file store
        /// against.
        IncludeRegexes(std::boxed::Box<crate::model::FileStoreRegexes>),
    }
}

/// A collection of regular expressions to determine what file store to match
/// against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStoreRegexes {
    /// Required. The group of regular expression patterns to match against one or
    /// more file stores. Maximum of 100 entries. The sum of all regular
    /// expression's length can't exceed 10 KiB.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patterns: std::vec::Vec<crate::model::FileStoreRegex>,
}

impl FileStoreRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::FileStoreRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileStoreRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreRegexes"
    }
}

/// A pattern to match against one or more file stores.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStoreRegex {
    /// The type of resource regex to use.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub resource_regex: std::option::Option<crate::model::file_store_regex::ResourceRegex>,
}

impl FileStoreRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `resource_regex`.
    pub fn set_resource_regex<
        T: std::convert::Into<std::option::Option<crate::model::file_store_regex::ResourceRegex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = v.into();
        self
    }

    /// The value of [resource_regex][crate::model::FileStoreRegex::resource_regex]
    /// if it holds a `CloudStorageRegex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_storage_regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageRegex>> {
        #[allow(unreachable_patterns)]
        self.resource_regex.as_ref().and_then(|v| match v {
            crate::model::file_store_regex::ResourceRegex::CloudStorageRegex(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_regex][crate::model::FileStoreRegex::resource_regex]
    /// to hold a `CloudStorageRegex`.
    ///
    /// Note that all the setters affecting `resource_regex` are
    /// mutually exclusive.
    pub fn set_cloud_storage_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageRegex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = std::option::Option::Some(
            crate::model::file_store_regex::ResourceRegex::CloudStorageRegex(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileStoreRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreRegex"
    }
}

/// Defines additional types related to FileStoreRegex
pub mod file_store_regex {
    #[allow(unused_imports)]
    use super::*;

    /// The type of resource regex to use.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ResourceRegex {
        /// Optional. Regex for Cloud Storage.
        CloudStorageRegex(std::boxed::Box<crate::model::CloudStorageRegex>),
    }
}

/// A pattern to match against one or more file stores. At least one
/// pattern must be specified. Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageRegex {
    /// Optional. For organizations, if unset, will match all projects.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id_regex: std::string::String,

    /// Optional. Regex to test the bucket name against. If empty, all buckets
    /// match. Example: "marketing2021" or "(marketing)\d{4}" will both match the
    /// bucket gs://marketing2021
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name_regex: std::string::String,
}

impl CloudStorageRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::CloudStorageRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }

    /// Sets the value of [bucket_name_regex][crate::model::CloudStorageRegex::bucket_name_regex].
    pub fn set_bucket_name_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_name_regex = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageRegex"
    }
}

/// Identifies a single Cloud Storage bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageResourceReference {
    /// Required. The bucket to scan.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name: std::string::String,

    /// Required. If within a project-level config, then this must match the
    /// config's project id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,
}

impl CloudStorageResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::CloudStorageResourceReference::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CloudStorageResourceReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageResourceReference"
    }
}

/// How often existing buckets should have their profiles refreshed.
/// New buckets are scanned as quickly as possible depending on system
/// capacity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudStorageGenerationCadence {
    /// Optional. Data changes in Cloud Storage can't trigger reprofiling. If you
    /// set this field, profiles are refreshed at this frequency regardless of
    /// whether the underlying buckets have changed. Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Optional. Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
}

impl DiscoveryCloudStorageGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryCloudStorageGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryCloudStorageGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<
        T: std::convert::Into<
            std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_cadence = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryCloudStorageGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudStorageGenerationCadence"
    }
}

/// Requirements that must be true before a Cloud Storage bucket or object is
/// scanned in discovery for the first time. There is an AND relationship between
/// the top-level attributes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryCloudStorageConditions {
    /// Required. Only objects with the specified attributes will be scanned. If an
    /// object has one of the specified attributes but is inside an excluded
    /// bucket, it will not be scanned. Defaults to [ALL_SUPPORTED_OBJECTS]. A
    /// profile will be created even if no objects match the
    /// included_object_attributes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub included_object_attributes: std::vec::Vec<
        crate::model::discovery_cloud_storage_conditions::CloudStorageObjectAttribute,
    >,

    /// Required. Only objects with the specified attributes will be scanned.
    /// Defaults to [ALL_SUPPORTED_BUCKETS] if unset.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub included_bucket_attributes: std::vec::Vec<
        crate::model::discovery_cloud_storage_conditions::CloudStorageBucketAttribute,
    >,
}

impl DiscoveryCloudStorageConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [included_object_attributes][crate::model::DiscoveryCloudStorageConditions::included_object_attributes].
    pub fn set_included_object_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
            crate::model::discovery_cloud_storage_conditions::CloudStorageObjectAttribute,
        >,
    {
        use std::iter::Iterator;
        self.included_object_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [included_bucket_attributes][crate::model::DiscoveryCloudStorageConditions::included_bucket_attributes].
    pub fn set_included_bucket_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
            crate::model::discovery_cloud_storage_conditions::CloudStorageBucketAttribute,
        >,
    {
        use std::iter::Iterator;
        self.included_bucket_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiscoveryCloudStorageConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryCloudStorageConditions"
    }
}

/// Defines additional types related to DiscoveryCloudStorageConditions
pub mod discovery_cloud_storage_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// The attribute of an object. See
    /// <https://cloud.google.com/storage/docs/storage-classes> for more information
    /// on storage classes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CloudStorageObjectAttribute(i32);

    impl CloudStorageObjectAttribute {
        /// Unused.
        pub const CLOUD_STORAGE_OBJECT_ATTRIBUTE_UNSPECIFIED: CloudStorageObjectAttribute =
            CloudStorageObjectAttribute::new(0);

        /// Scan objects regardless of the attribute.
        pub const ALL_SUPPORTED_OBJECTS: CloudStorageObjectAttribute =
            CloudStorageObjectAttribute::new(1);

        /// Scan objects with the standard storage class.
        pub const STANDARD: CloudStorageObjectAttribute = CloudStorageObjectAttribute::new(2);

        /// Scan objects with the nearline storage class. This will incur retrieval
        /// fees.
        pub const NEARLINE: CloudStorageObjectAttribute = CloudStorageObjectAttribute::new(3);

        /// Scan objects with the coldline storage class. This will incur retrieval
        /// fees.
        pub const COLDLINE: CloudStorageObjectAttribute = CloudStorageObjectAttribute::new(4);

        /// Scan objects with the archive storage class. This will incur retrieval
        /// fees.
        pub const ARCHIVE: CloudStorageObjectAttribute = CloudStorageObjectAttribute::new(5);

        /// Scan objects with the regional storage class.
        pub const REGIONAL: CloudStorageObjectAttribute = CloudStorageObjectAttribute::new(6);

        /// Scan objects with the multi-regional storage class.
        pub const MULTI_REGIONAL: CloudStorageObjectAttribute = CloudStorageObjectAttribute::new(7);

        /// Scan objects with the dual-regional storage class. This will incur
        /// retrieval fees.
        pub const DURABLE_REDUCED_AVAILABILITY: CloudStorageObjectAttribute =
            CloudStorageObjectAttribute::new(8);

        /// Creates a new CloudStorageObjectAttribute instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CLOUD_STORAGE_OBJECT_ATTRIBUTE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ALL_SUPPORTED_OBJECTS"),
                2 => std::borrow::Cow::Borrowed("STANDARD"),
                3 => std::borrow::Cow::Borrowed("NEARLINE"),
                4 => std::borrow::Cow::Borrowed("COLDLINE"),
                5 => std::borrow::Cow::Borrowed("ARCHIVE"),
                6 => std::borrow::Cow::Borrowed("REGIONAL"),
                7 => std::borrow::Cow::Borrowed("MULTI_REGIONAL"),
                8 => std::borrow::Cow::Borrowed("DURABLE_REDUCED_AVAILABILITY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CLOUD_STORAGE_OBJECT_ATTRIBUTE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CLOUD_STORAGE_OBJECT_ATTRIBUTE_UNSPECIFIED)
                }
                "ALL_SUPPORTED_OBJECTS" => std::option::Option::Some(Self::ALL_SUPPORTED_OBJECTS),
                "STANDARD" => std::option::Option::Some(Self::STANDARD),
                "NEARLINE" => std::option::Option::Some(Self::NEARLINE),
                "COLDLINE" => std::option::Option::Some(Self::COLDLINE),
                "ARCHIVE" => std::option::Option::Some(Self::ARCHIVE),
                "REGIONAL" => std::option::Option::Some(Self::REGIONAL),
                "MULTI_REGIONAL" => std::option::Option::Some(Self::MULTI_REGIONAL),
                "DURABLE_REDUCED_AVAILABILITY" => {
                    std::option::Option::Some(Self::DURABLE_REDUCED_AVAILABILITY)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for CloudStorageObjectAttribute {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for CloudStorageObjectAttribute {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The attribute of a bucket.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CloudStorageBucketAttribute(i32);

    impl CloudStorageBucketAttribute {
        /// Unused.
        pub const CLOUD_STORAGE_BUCKET_ATTRIBUTE_UNSPECIFIED: CloudStorageBucketAttribute =
            CloudStorageBucketAttribute::new(0);

        /// Scan buckets regardless of the attribute.
        pub const ALL_SUPPORTED_BUCKETS: CloudStorageBucketAttribute =
            CloudStorageBucketAttribute::new(1);

        /// Buckets with [Autoclass](https://cloud.google.com/storage/docs/autoclass)
        /// disabled. Only one of
        /// AUTOCLASS_DISABLED or AUTOCLASS_ENABLED should be set.
        pub const AUTOCLASS_DISABLED: CloudStorageBucketAttribute =
            CloudStorageBucketAttribute::new(2);

        /// Buckets with [Autoclass](https://cloud.google.com/storage/docs/autoclass)
        /// enabled. Only one of
        /// AUTOCLASS_DISABLED or AUTOCLASS_ENABLED should be set. Scanning
        /// Autoclass-enabled buckets can affect object storage classes.
        pub const AUTOCLASS_ENABLED: CloudStorageBucketAttribute =
            CloudStorageBucketAttribute::new(3);

        /// Creates a new CloudStorageBucketAttribute instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CLOUD_STORAGE_BUCKET_ATTRIBUTE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ALL_SUPPORTED_BUCKETS"),
                2 => std::borrow::Cow::Borrowed("AUTOCLASS_DISABLED"),
                3 => std::borrow::Cow::Borrowed("AUTOCLASS_ENABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CLOUD_STORAGE_BUCKET_ATTRIBUTE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CLOUD_STORAGE_BUCKET_ATTRIBUTE_UNSPECIFIED)
                }
                "ALL_SUPPORTED_BUCKETS" => std::option::Option::Some(Self::ALL_SUPPORTED_BUCKETS),
                "AUTOCLASS_DISABLED" => std::option::Option::Some(Self::AUTOCLASS_DISABLED),
                "AUTOCLASS_ENABLED" => std::option::Option::Some(Self::AUTOCLASS_ENABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for CloudStorageBucketAttribute {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for CloudStorageBucketAttribute {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Requirements that must be true before a file store is scanned in discovery
/// for the first time. There is an AND relationship between the top-level
/// attributes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryFileStoreConditions {
    /// Optional. File store must have been created after this date. Used to avoid
    /// backfilling.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_after: std::option::Option<wkt::Timestamp>,

    /// Optional. Minimum age a file store must have. If set, the value must be 1
    /// hour or greater.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_age: std::option::Option<wkt::Duration>,

    /// File store specific conditions.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::discovery_file_store_conditions::Conditions>,
}

impl DiscoveryFileStoreConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_after][crate::model::DiscoveryFileStoreConditions::created_after].
    pub fn set_created_after<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.created_after = v.into();
        self
    }

    /// Sets the value of [min_age][crate::model::DiscoveryFileStoreConditions::min_age].
    pub fn set_min_age<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_age = v.into();
        self
    }

    /// Sets the value of `conditions`.
    pub fn set_conditions<
        T: std::convert::Into<
            std::option::Option<crate::model::discovery_file_store_conditions::Conditions>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// The value of [conditions][crate::model::DiscoveryFileStoreConditions::conditions]
    /// if it holds a `CloudStorageConditions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_storage_conditions(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryCloudStorageConditions>> {
        #[allow(unreachable_patterns)]
        self.conditions.as_ref().and_then(|v| match v {
            crate::model::discovery_file_store_conditions::Conditions::CloudStorageConditions(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [conditions][crate::model::DiscoveryFileStoreConditions::conditions]
    /// to hold a `CloudStorageConditions`.
    ///
    /// Note that all the setters affecting `conditions` are
    /// mutually exclusive.
    pub fn set_cloud_storage_conditions<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryCloudStorageConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = std::option::Option::Some(
            crate::model::discovery_file_store_conditions::Conditions::CloudStorageConditions(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryFileStoreConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryFileStoreConditions"
    }
}

/// Defines additional types related to DiscoveryFileStoreConditions
pub mod discovery_file_store_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// File store specific conditions.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Conditions {
        /// Optional. Cloud Storage conditions.
        CloudStorageConditions(std::boxed::Box<crate::model::DiscoveryCloudStorageConditions>),
    }
}

/// Target used to match against for discovery of resources from other clouds.
/// An [AWS connector in Security Command Center
/// (Enterprise](https://cloud.google.com/security-command-center/docs/connect-scc-to-aws)
/// is required to use this feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudDiscoveryTarget {
    /// Required. The type of data profiles generated by this discovery target.
    /// Supported values are:
    ///
    /// * aws/s3/bucket
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_source_type: std::option::Option<crate::model::DataSourceType>,

    /// Required. The resources that the discovery cadence applies to. The
    /// first target with a matching filter will be the one to apply to a resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::DiscoveryOtherCloudFilter>,

    /// Optional. In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::DiscoveryOtherCloudConditions>,

    /// Type of cadence.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cadence: std::option::Option<crate::model::other_cloud_discovery_target::Cadence>,
}

impl OtherCloudDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_source_type][crate::model::OtherCloudDiscoveryTarget::data_source_type].
    pub fn set_data_source_type<
        T: std::convert::Into<std::option::Option<crate::model::DataSourceType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source_type = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::OtherCloudDiscoveryTarget::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryOtherCloudFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::OtherCloudDiscoveryTarget::conditions].
    pub fn set_conditions<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryOtherCloudConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// Sets the value of `cadence`.
    pub fn set_cadence<
        T: std::convert::Into<
            std::option::Option<crate::model::other_cloud_discovery_target::Cadence>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryOtherCloudGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::other_cloud_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::other_cloud_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryOtherCloudGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::other_cloud_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// Sets the value of [cadence][crate::model::OtherCloudDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::other_cloud_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudDiscoveryTarget"
    }
}

/// Defines additional types related to OtherCloudDiscoveryTarget
pub mod other_cloud_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// Type of cadence.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Cadence {
        /// How often and when to update data profiles. New resources that match both
        /// the filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryOtherCloudGenerationCadence>),
        /// Disable profiling for resources that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines which resources from the other cloud will have profiles generated.
/// Includes the ability to filter by resource names.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryOtherCloudFilter {
    /// Whether the filter applies to a specific set of resources or all
    /// other resources. The first filter to match will be applied, regardless of
    /// the condition. Defaults to `others` if none is set.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::discovery_other_cloud_filter::Filter>,
}

impl DiscoveryOtherCloudFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `filter`.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::discovery_other_cloud_filter::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudResourceCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// if it holds a `SingleResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_single_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudSingleResourceReference>>
    {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_filter::Filter::SingleResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_others(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudResourceCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_other_cloud_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// to hold a `SingleResource`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_single_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudSingleResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_other_cloud_filter::Filter::SingleResource(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::DiscoveryOtherCloudFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<T: std::convert::Into<std::boxed::Box<crate::model::AllOtherResources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_other_cloud_filter::Filter::Others(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryOtherCloudFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryOtherCloudFilter"
    }
}

/// Defines additional types related to DiscoveryOtherCloudFilter
pub mod discovery_other_cloud_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of resources or all
    /// other resources. The first filter to match will be applied, regardless of
    /// the condition. Defaults to `others` if none is set.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// A collection of resources for this filter to apply to.
        Collection(std::boxed::Box<crate::model::OtherCloudResourceCollection>),
        /// The resource to scan. Configs using this filter can only have one target
        /// (the target with this single resource reference).
        SingleResource(std::boxed::Box<crate::model::OtherCloudSingleResourceReference>),
        /// Optional. Catch-all. This should always be the last target in the list
        /// because anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherResources>),
    }
}

/// Match resources using regex filters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudResourceCollection {
    /// The first filter containing a pattern that matches a resource will be used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub pattern: std::option::Option<crate::model::other_cloud_resource_collection::Pattern>,
}

impl OtherCloudResourceCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `pattern`.
    pub fn set_pattern<
        T: std::convert::Into<
            std::option::Option<crate::model::other_cloud_resource_collection::Pattern>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::OtherCloudResourceCollection::pattern]
    /// if it holds a `IncludeRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_include_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OtherCloudResourceRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::other_cloud_resource_collection::Pattern::IncludeRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::OtherCloudResourceCollection::pattern]
    /// to hold a `IncludeRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_include_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::OtherCloudResourceRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::other_cloud_resource_collection::Pattern::IncludeRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudResourceCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudResourceCollection"
    }
}

/// Defines additional types related to OtherCloudResourceCollection
pub mod other_cloud_resource_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The first filter containing a pattern that matches a resource will be used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Pattern {
        /// A collection of regular expressions to match a resource against.
        IncludeRegexes(std::boxed::Box<crate::model::OtherCloudResourceRegexes>),
    }
}

/// A collection of regular expressions to determine what resources to match
/// against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudResourceRegexes {
    /// A group of regular expression patterns to match against one or more
    /// resources.
    /// Maximum of 100 entries. The sum of all regular expression's length can't
    /// exceed 10 KiB.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patterns: std::vec::Vec<crate::model::OtherCloudResourceRegex>,
}

impl OtherCloudResourceRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::OtherCloudResourceRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OtherCloudResourceRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OtherCloudResourceRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudResourceRegexes"
    }
}

/// A pattern to match against one or more resources. At least one pattern must
/// be specified. Regular expressions use RE2
/// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
/// under the google/re2 repository on GitHub.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudResourceRegex {
    /// The type of resource regex to use.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub resource_regex:
        std::option::Option<crate::model::other_cloud_resource_regex::ResourceRegex>,
}

impl OtherCloudResourceRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `resource_regex`.
    pub fn set_resource_regex<
        T: std::convert::Into<
            std::option::Option<crate::model::other_cloud_resource_regex::ResourceRegex>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = v.into();
        self
    }

    /// The value of [resource_regex][crate::model::OtherCloudResourceRegex::resource_regex]
    /// if it holds a `AmazonS3BucketRegex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_amazon_s3_bucket_regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AmazonS3BucketRegex>> {
        #[allow(unreachable_patterns)]
        self.resource_regex.as_ref().and_then(|v| match v {
            crate::model::other_cloud_resource_regex::ResourceRegex::AmazonS3BucketRegex(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_regex][crate::model::OtherCloudResourceRegex::resource_regex]
    /// to hold a `AmazonS3BucketRegex`.
    ///
    /// Note that all the setters affecting `resource_regex` are
    /// mutually exclusive.
    pub fn set_amazon_s3_bucket_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::AmazonS3BucketRegex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_regex = std::option::Option::Some(
            crate::model::other_cloud_resource_regex::ResourceRegex::AmazonS3BucketRegex(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudResourceRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudResourceRegex"
    }
}

/// Defines additional types related to OtherCloudResourceRegex
pub mod other_cloud_resource_regex {
    #[allow(unused_imports)]
    use super::*;

    /// The type of resource regex to use.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ResourceRegex {
        /// Regex for Amazon S3 buckets.
        AmazonS3BucketRegex(std::boxed::Box<crate::model::AmazonS3BucketRegex>),
    }
}

/// AWS account regex.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsAccountRegex {
    /// Optional. Regex to test the AWS account ID against.
    /// If empty, all accounts match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub account_id_regex: std::string::String,
}

impl AwsAccountRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [account_id_regex][crate::model::AwsAccountRegex::account_id_regex].
    pub fn set_account_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.account_id_regex = v.into();
        self
    }
}

impl wkt::message::Message for AwsAccountRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AwsAccountRegex"
    }
}

/// Amazon S3 bucket regex.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AmazonS3BucketRegex {
    /// The AWS account regex.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aws_account_regex: std::option::Option<crate::model::AwsAccountRegex>,

    /// Optional. Regex to test the bucket name against.
    /// If empty, all buckets match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name_regex: std::string::String,
}

impl AmazonS3BucketRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_account_regex][crate::model::AmazonS3BucketRegex::aws_account_regex].
    pub fn set_aws_account_regex<
        T: std::convert::Into<std::option::Option<crate::model::AwsAccountRegex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aws_account_regex = v.into();
        self
    }

    /// Sets the value of [bucket_name_regex][crate::model::AmazonS3BucketRegex::bucket_name_regex].
    pub fn set_bucket_name_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_name_regex = v.into();
        self
    }
}

impl wkt::message::Message for AmazonS3BucketRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AmazonS3BucketRegex"
    }
}

/// Identifies a single resource, like a single Amazon S3 bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudSingleResourceReference {
    /// The resource to scan.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub resource:
        std::option::Option<crate::model::other_cloud_single_resource_reference::Resource>,
}

impl OtherCloudSingleResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `resource`.
    pub fn set_resource<
        T: std::convert::Into<
            std::option::Option<crate::model::other_cloud_single_resource_reference::Resource>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// The value of [resource][crate::model::OtherCloudSingleResourceReference::resource]
    /// if it holds a `AmazonS3Bucket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_amazon_s3_bucket(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AmazonS3Bucket>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::other_cloud_single_resource_reference::Resource::AmazonS3Bucket(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::OtherCloudSingleResourceReference::resource]
    /// to hold a `AmazonS3Bucket`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_amazon_s3_bucket<
        T: std::convert::Into<std::boxed::Box<crate::model::AmazonS3Bucket>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::other_cloud_single_resource_reference::Resource::AmazonS3Bucket(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudSingleResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudSingleResourceReference"
    }
}

/// Defines additional types related to OtherCloudSingleResourceReference
pub mod other_cloud_single_resource_reference {
    #[allow(unused_imports)]
    use super::*;

    /// The resource to scan.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Resource {
        /// Amazon S3 bucket.
        AmazonS3Bucket(std::boxed::Box<crate::model::AmazonS3Bucket>),
    }
}

/// AWS account.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsAccount {
    /// Required. AWS account ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub account_id: std::string::String,
}

impl AwsAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [account_id][crate::model::AwsAccount::account_id].
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }
}

impl wkt::message::Message for AwsAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AwsAccount"
    }
}

/// Amazon S3 bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AmazonS3Bucket {
    /// The AWS account.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aws_account: std::option::Option<crate::model::AwsAccount>,

    /// Required. The bucket name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name: std::string::String,
}

impl AmazonS3Bucket {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_account][crate::model::AmazonS3Bucket::aws_account].
    pub fn set_aws_account<T: std::convert::Into<std::option::Option<crate::model::AwsAccount>>>(
        mut self,
        v: T,
    ) -> Self {
        self.aws_account = v.into();
        self
    }

    /// Sets the value of [bucket_name][crate::model::AmazonS3Bucket::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }
}

impl wkt::message::Message for AmazonS3Bucket {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AmazonS3Bucket"
    }
}

/// Requirements that must be true before a resource is profiled for the first
/// time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryOtherCloudConditions {
    /// Minimum age a resource must be before Cloud DLP can profile it. Value must
    /// be 1 hour or greater.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_age: std::option::Option<wkt::Duration>,

    /// The conditions to apply.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::discovery_other_cloud_conditions::Conditions>,
}

impl DiscoveryOtherCloudConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_age][crate::model::DiscoveryOtherCloudConditions::min_age].
    pub fn set_min_age<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_age = v.into();
        self
    }

    /// Sets the value of `conditions`.
    pub fn set_conditions<
        T: std::convert::Into<
            std::option::Option<crate::model::discovery_other_cloud_conditions::Conditions>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// The value of [conditions][crate::model::DiscoveryOtherCloudConditions::conditions]
    /// if it holds a `AmazonS3BucketConditions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_amazon_s3_bucket_conditions(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AmazonS3BucketConditions>> {
        #[allow(unreachable_patterns)]
        self.conditions.as_ref().and_then(|v| match v {
            crate::model::discovery_other_cloud_conditions::Conditions::AmazonS3BucketConditions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [conditions][crate::model::DiscoveryOtherCloudConditions::conditions]
    /// to hold a `AmazonS3BucketConditions`.
    ///
    /// Note that all the setters affecting `conditions` are
    /// mutually exclusive.
    pub fn set_amazon_s3_bucket_conditions<
        T: std::convert::Into<std::boxed::Box<crate::model::AmazonS3BucketConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = std::option::Option::Some(
            crate::model::discovery_other_cloud_conditions::Conditions::AmazonS3BucketConditions(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryOtherCloudConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryOtherCloudConditions"
    }
}

/// Defines additional types related to DiscoveryOtherCloudConditions
pub mod discovery_other_cloud_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// The conditions to apply.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Conditions {
        /// Amazon S3 bucket conditions.
        AmazonS3BucketConditions(std::boxed::Box<crate::model::AmazonS3BucketConditions>),
    }
}

/// Amazon S3 bucket conditions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AmazonS3BucketConditions {
    /// Optional. Bucket types that should be profiled.
    /// Optional. Defaults to TYPE_ALL_SUPPORTED if unspecified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bucket_types: std::vec::Vec<crate::model::amazon_s_3_bucket_conditions::BucketType>,

    /// Optional. Object classes that should be profiled.
    /// Optional. Defaults to ALL_SUPPORTED_CLASSES if unspecified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub object_storage_classes:
        std::vec::Vec<crate::model::amazon_s_3_bucket_conditions::ObjectStorageClass>,
}

impl AmazonS3BucketConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_types][crate::model::AmazonS3BucketConditions::bucket_types].
    pub fn set_bucket_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::amazon_s_3_bucket_conditions::BucketType>,
    {
        use std::iter::Iterator;
        self.bucket_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [object_storage_classes][crate::model::AmazonS3BucketConditions::object_storage_classes].
    pub fn set_object_storage_classes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::amazon_s_3_bucket_conditions::ObjectStorageClass>,
    {
        use std::iter::Iterator;
        self.object_storage_classes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AmazonS3BucketConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AmazonS3BucketConditions"
    }
}

/// Defines additional types related to AmazonS3BucketConditions
pub mod amazon_s_3_bucket_conditions {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Amazon S3 bucket types.
    /// Defaults to TYPE_ALL_SUPPORTED.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct BucketType(i32);

    impl BucketType {
        /// Unused.
        pub const TYPE_UNSPECIFIED: BucketType = BucketType::new(0);

        /// All supported classes.
        pub const TYPE_ALL_SUPPORTED: BucketType = BucketType::new(1);

        /// A general purpose Amazon S3 bucket.
        pub const TYPE_GENERAL_PURPOSE: BucketType = BucketType::new(2);

        /// Creates a new BucketType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("TYPE_ALL_SUPPORTED"),
                2 => std::borrow::Cow::Borrowed("TYPE_GENERAL_PURPOSE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "TYPE_ALL_SUPPORTED" => std::option::Option::Some(Self::TYPE_ALL_SUPPORTED),
                "TYPE_GENERAL_PURPOSE" => std::option::Option::Some(Self::TYPE_GENERAL_PURPOSE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for BucketType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for BucketType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Supported Amazon S3 object storage classes.
    /// Defaults to ALL_SUPPORTED_CLASSES.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ObjectStorageClass(i32);

    impl ObjectStorageClass {
        /// Unused.
        pub const UNSPECIFIED: ObjectStorageClass = ObjectStorageClass::new(0);

        /// All supported classes.
        pub const ALL_SUPPORTED_CLASSES: ObjectStorageClass = ObjectStorageClass::new(1);

        /// Standard object class.
        pub const STANDARD: ObjectStorageClass = ObjectStorageClass::new(2);

        /// Standard - infrequent access object class.
        pub const STANDARD_INFREQUENT_ACCESS: ObjectStorageClass = ObjectStorageClass::new(4);

        /// Glacier - instant retrieval object class.
        pub const GLACIER_INSTANT_RETRIEVAL: ObjectStorageClass = ObjectStorageClass::new(6);

        /// Objects in the S3 Intelligent-Tiering access tiers.
        pub const INTELLIGENT_TIERING: ObjectStorageClass = ObjectStorageClass::new(7);

        /// Creates a new ObjectStorageClass instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ALL_SUPPORTED_CLASSES"),
                2 => std::borrow::Cow::Borrowed("STANDARD"),
                4 => std::borrow::Cow::Borrowed("STANDARD_INFREQUENT_ACCESS"),
                6 => std::borrow::Cow::Borrowed("GLACIER_INSTANT_RETRIEVAL"),
                7 => std::borrow::Cow::Borrowed("INTELLIGENT_TIERING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "UNSPECIFIED" => std::option::Option::Some(Self::UNSPECIFIED),
                "ALL_SUPPORTED_CLASSES" => std::option::Option::Some(Self::ALL_SUPPORTED_CLASSES),
                "STANDARD" => std::option::Option::Some(Self::STANDARD),
                "STANDARD_INFREQUENT_ACCESS" => {
                    std::option::Option::Some(Self::STANDARD_INFREQUENT_ACCESS)
                }
                "GLACIER_INSTANT_RETRIEVAL" => {
                    std::option::Option::Some(Self::GLACIER_INSTANT_RETRIEVAL)
                }
                "INTELLIGENT_TIERING" => std::option::Option::Some(Self::INTELLIGENT_TIERING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ObjectStorageClass {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ObjectStorageClass {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// How often existing resources should have their profiles refreshed.
/// New resources are scanned as quickly as possible depending on system
/// capacity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryOtherCloudGenerationCadence {
    /// Optional. Frequency to update profiles regardless of whether the underlying
    /// resource has changes. Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Optional. Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
}

impl DiscoveryOtherCloudGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryOtherCloudGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryOtherCloudGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<
        T: std::convert::Into<
            std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_cadence = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryOtherCloudGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryOtherCloudGenerationCadence"
    }
}

/// The location to begin a discovery scan. Denotes an organization ID or folder
/// ID within an organization.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryStartingLocation {
    /// The location to be scanned.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::discovery_starting_location::Location>,
}

impl DiscoveryStartingLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `location`.
    pub fn set_location<
        T: std::convert::Into<
            std::option::Option<crate::model::discovery_starting_location::Location>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::DiscoveryStartingLocation::location]
    /// if it holds a `OrganizationId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_organization_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::discovery_starting_location::Location::OrganizationId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [location][crate::model::DiscoveryStartingLocation::location]
    /// if it holds a `FolderId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_folder_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::discovery_starting_location::Location::FolderId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::DiscoveryStartingLocation::location]
    /// to hold a `OrganizationId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_organization_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::discovery_starting_location::Location::OrganizationId(v.into()),
        );
        self
    }

    /// Sets the value of [location][crate::model::DiscoveryStartingLocation::location]
    /// to hold a `FolderId`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::discovery_starting_location::Location::FolderId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryStartingLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryStartingLocation"
    }
}

/// Defines additional types related to DiscoveryStartingLocation
pub mod discovery_starting_location {
    #[allow(unused_imports)]
    use super::*;

    /// The location to be scanned.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Location {
        /// The ID of an organization to scan.
        OrganizationId(i64),
        /// The ID of the folder within an organization to be scanned.
        FolderId(i64),
    }
}

/// The other cloud starting location for discovery.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherCloudDiscoveryStartingLocation {
    /// The other cloud starting location for discovery.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub location:
        std::option::Option<crate::model::other_cloud_discovery_starting_location::Location>,
}

impl OtherCloudDiscoveryStartingLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `location`.
    pub fn set_location<
        T: std::convert::Into<
            std::option::Option<crate::model::other_cloud_discovery_starting_location::Location>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::OtherCloudDiscoveryStartingLocation::location]
    /// if it holds a `AwsLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_aws_location(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<
            crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation,
        >,
    > {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::other_cloud_discovery_starting_location::Location::AwsLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::OtherCloudDiscoveryStartingLocation::location]
    /// to hold a `AwsLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_aws_location<
        T: std::convert::Into<
            std::boxed::Box<
                crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = std::option::Option::Some(
            crate::model::other_cloud_discovery_starting_location::Location::AwsLocation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OtherCloudDiscoveryStartingLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherCloudDiscoveryStartingLocation"
    }
}

/// Defines additional types related to OtherCloudDiscoveryStartingLocation
pub mod other_cloud_discovery_starting_location {
    #[allow(unused_imports)]
    use super::*;

    /// The AWS starting location for discovery.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AwsDiscoveryStartingLocation {

        /// The scope of this starting location.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub scope: std::option::Option<crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope>,
    }

    impl AwsDiscoveryStartingLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `scope`.
        pub fn set_scope<T: std::convert::Into<std::option::Option<crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope>>>(mut self, v: T) -> Self
        {
            self.scope = v.into();
            self
        }

        /// The value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// if it holds a `AccountId`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_account_id(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.scope.as_ref().and_then(|v| match v {
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AccountId(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// if it holds a `AllAssetInventoryAssets`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_all_asset_inventory_assets(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.scope.as_ref().and_then(|v| match v {
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AllAssetInventoryAssets(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// to hold a `AccountId`.
        ///
        /// Note that all the setters affecting `scope` are
        /// mutually exclusive.
        pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.scope = std::option::Option::Some(
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AccountId(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [scope][crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation::scope]
        /// to hold a `AllAssetInventoryAssets`.
        ///
        /// Note that all the setters affecting `scope` are
        /// mutually exclusive.
        pub fn set_all_asset_inventory_assets<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.scope = std::option::Option::Some(
                crate::model::other_cloud_discovery_starting_location::aws_discovery_starting_location::Scope::AllAssetInventoryAssets(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for AwsDiscoveryStartingLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.OtherCloudDiscoveryStartingLocation.AwsDiscoveryStartingLocation"
        }
    }

    /// Defines additional types related to AwsDiscoveryStartingLocation
    pub mod aws_discovery_starting_location {
        #[allow(unused_imports)]
        use super::*;

        /// The scope of this starting location.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Scope {
            /// The AWS account ID that this discovery config applies to.
            /// Within an AWS organization, you can find the AWS account ID inside an
            /// AWS account ARN. Example:
            /// arn:{partition}:organizations::{management_account_id}:account/{org_id}/{account_id}
            AccountId(std::string::String),
            /// All AWS assets stored in Asset Inventory that didn't match other AWS
            /// discovery configs.
            AllAssetInventoryAssets(bool),
        }
    }

    /// The other cloud starting location for discovery.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Location {
        /// The AWS starting location for discovery.
        AwsLocation(
            std::boxed::Box<
                crate::model::other_cloud_discovery_starting_location::AwsDiscoveryStartingLocation,
            >,
        ),
    }
}

/// Match discovery resources not covered by any other filter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AllOtherResources {}

impl AllOtherResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AllOtherResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.AllOtherResources"
    }
}

/// Target used to match against for discovery with Vertex AI datasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexDatasetDiscoveryTarget {
    /// Required. The datasets the discovery cadence applies to. The first target
    /// with a matching filter will be the one to apply to a dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::DiscoveryVertexDatasetFilter>,

    /// In addition to matching the filter, these conditions must be true
    /// before a profile is generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conditions: std::option::Option<crate::model::DiscoveryVertexDatasetConditions>,

    /// Type of schedule.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cadence: std::option::Option<crate::model::vertex_dataset_discovery_target::Cadence>,
}

impl VertexDatasetDiscoveryTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::VertexDatasetDiscoveryTarget::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryVertexDatasetFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::VertexDatasetDiscoveryTarget::conditions].
    pub fn set_conditions<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryVertexDatasetConditions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conditions = v.into();
        self
    }

    /// Sets the value of `cadence`.
    pub fn set_cadence<
        T: std::convert::Into<
            std::option::Option<crate::model::vertex_dataset_discovery_target::Cadence>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = v.into();
        self
    }

    /// The value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// if it holds a `GenerationCadence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_generation_cadence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryVertexDatasetGenerationCadence>>
    {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::vertex_dataset_discovery_target::Cadence::GenerationCadence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// if it holds a `Disabled`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_disabled(&self) -> std::option::Option<&std::boxed::Box<crate::model::Disabled>> {
        #[allow(unreachable_patterns)]
        self.cadence.as_ref().and_then(|v| match v {
            crate::model::vertex_dataset_discovery_target::Cadence::Disabled(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// to hold a `GenerationCadence`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_generation_cadence<
        T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryVertexDatasetGenerationCadence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::vertex_dataset_discovery_target::Cadence::GenerationCadence(v.into()),
        );
        self
    }

    /// Sets the value of [cadence][crate::model::VertexDatasetDiscoveryTarget::cadence]
    /// to hold a `Disabled`.
    ///
    /// Note that all the setters affecting `cadence` are
    /// mutually exclusive.
    pub fn set_disabled<T: std::convert::Into<std::boxed::Box<crate::model::Disabled>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cadence = std::option::Option::Some(
            crate::model::vertex_dataset_discovery_target::Cadence::Disabled(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VertexDatasetDiscoveryTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetDiscoveryTarget"
    }
}

/// Defines additional types related to VertexDatasetDiscoveryTarget
pub mod vertex_dataset_discovery_target {
    #[allow(unused_imports)]
    use super::*;

    /// Type of schedule.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Cadence {
        /// How often and when to update profiles. New datasets that match both the
        /// filter and conditions are scanned as quickly as possible depending on
        /// system capacity.
        GenerationCadence(std::boxed::Box<crate::model::DiscoveryVertexDatasetGenerationCadence>),
        /// Disable profiling for datasets that match this filter.
        Disabled(std::boxed::Box<crate::model::Disabled>),
    }
}

/// Determines what datasets will have profiles generated within an organization
/// or project. Includes the ability to filter by regular expression patterns
/// on project ID or dataset regex.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryVertexDatasetFilter {
    /// Whether the filter applies to a specific set of datasets or all
    /// other datasets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, this field defaults to `others`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::discovery_vertex_dataset_filter::Filter>,
}

impl DiscoveryVertexDatasetFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `filter`.
    pub fn set_filter<
        T: std::convert::Into<
            std::option::Option<crate::model::discovery_vertex_dataset_filter::Filter>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// if it holds a `Collection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_collection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetCollection>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_vertex_dataset_filter::Filter::Collection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// if it holds a `VertexDatasetResourceReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_dataset_resource_reference(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetResourceReference>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_vertex_dataset_filter::Filter::VertexDatasetResourceReference(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// if it holds a `Others`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_others(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AllOtherResources>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::discovery_vertex_dataset_filter::Filter::Others(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// to hold a `Collection`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_collection<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_vertex_dataset_filter::Filter::Collection(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// to hold a `VertexDatasetResourceReference`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_resource_reference<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetResourceReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_vertex_dataset_filter::Filter::VertexDatasetResourceReference(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [filter][crate::model::DiscoveryVertexDatasetFilter::filter]
    /// to hold a `Others`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_others<T: std::convert::Into<std::boxed::Box<crate::model::AllOtherResources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::discovery_vertex_dataset_filter::Filter::Others(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiscoveryVertexDatasetFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryVertexDatasetFilter"
    }
}

/// Defines additional types related to DiscoveryVertexDatasetFilter
pub mod discovery_vertex_dataset_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the filter applies to a specific set of datasets or all
    /// other datasets within the location being profiled. The first
    /// filter to match will be applied, regardless of the condition. If none is
    /// set, this field defaults to `others`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// A specific set of Vertex AI datasets for this filter to apply to.
        Collection(std::boxed::Box<crate::model::VertexDatasetCollection>),
        /// The dataset resource to scan. Targets including this can only include
        /// one target (the target with this dataset resource reference).
        VertexDatasetResourceReference(
            std::boxed::Box<crate::model::VertexDatasetResourceReference>,
        ),
        /// Catch-all. This should always be the last target in the list because
        /// anything above it will apply first. Should only appear once in a
        /// configuration. If none is specified, a default one will be added
        /// automatically.
        Others(std::boxed::Box<crate::model::AllOtherResources>),
    }
}

/// Match dataset resources using regex filters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexDatasetCollection {
    /// The pattern used to filter dataset resources.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub pattern: std::option::Option<crate::model::vertex_dataset_collection::Pattern>,
}

impl VertexDatasetCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `pattern`.
    pub fn set_pattern<
        T: std::convert::Into<std::option::Option<crate::model::vertex_dataset_collection::Pattern>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = v.into();
        self
    }

    /// The value of [pattern][crate::model::VertexDatasetCollection::pattern]
    /// if it holds a `VertexDatasetRegexes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_dataset_regexes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexDatasetRegexes>> {
        #[allow(unreachable_patterns)]
        self.pattern.as_ref().and_then(|v| match v {
            crate::model::vertex_dataset_collection::Pattern::VertexDatasetRegexes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pattern][crate::model::VertexDatasetCollection::pattern]
    /// to hold a `VertexDatasetRegexes`.
    ///
    /// Note that all the setters affecting `pattern` are
    /// mutually exclusive.
    pub fn set_vertex_dataset_regexes<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexDatasetRegexes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pattern = std::option::Option::Some(
            crate::model::vertex_dataset_collection::Pattern::VertexDatasetRegexes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VertexDatasetCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetCollection"
    }
}

/// Defines additional types related to VertexDatasetCollection
pub mod vertex_dataset_collection {
    #[allow(unused_imports)]
    use super::*;

    /// The pattern used to filter dataset resources.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Pattern {
        /// The regex used to filter dataset resources.
        VertexDatasetRegexes(std::boxed::Box<crate::model::VertexDatasetRegexes>),
    }
}

/// A collection of regular expressions to determine what datasets to match
/// against.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexDatasetRegexes {
    /// Required. The group of regular expression patterns to match against one or
    /// more datasets. Maximum of 100 entries. The sum of the lengths of all
    /// regular expressions can't exceed 10 KiB.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patterns: std::vec::Vec<crate::model::VertexDatasetRegex>,
}

impl VertexDatasetRegexes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patterns][crate::model::VertexDatasetRegexes::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VertexDatasetRegex>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VertexDatasetRegexes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetRegexes"
    }
}

/// A pattern to match against one or more dataset resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexDatasetRegex {
    /// For organizations, if unset, will match all projects. Has no effect
    /// for configurations created within a project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id_regex: std::string::String,
}

impl VertexDatasetRegex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id_regex][crate::model::VertexDatasetRegex::project_id_regex].
    pub fn set_project_id_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_id_regex = v.into();
        self
    }
}

impl wkt::message::Message for VertexDatasetRegex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetRegex"
    }
}

/// Identifies a single Vertex AI dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexDatasetResourceReference {
    /// Required. The name of the dataset resource. If set within a project-level
    /// configuration, the specified resource must be within the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_resource_name: std::string::String,
}

impl VertexDatasetResourceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_resource_name][crate::model::VertexDatasetResourceReference::dataset_resource_name].
    pub fn set_dataset_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_resource_name = v.into();
        self
    }
}

impl wkt::message::Message for VertexDatasetResourceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.VertexDatasetResourceReference"
    }
}

/// Requirements that must be true before a dataset is profiled for the
/// first time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryVertexDatasetConditions {
    /// Vertex AI dataset must have been created after this date. Used to avoid
    /// backfilling.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_after: std::option::Option<wkt::Timestamp>,

    /// Minimum age a Vertex AI dataset must have. If set, the value must be 1 hour
    /// or greater.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_age: std::option::Option<wkt::Duration>,
}

impl DiscoveryVertexDatasetConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_after][crate::model::DiscoveryVertexDatasetConditions::created_after].
    pub fn set_created_after<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.created_after = v.into();
        self
    }

    /// Sets the value of [min_age][crate::model::DiscoveryVertexDatasetConditions::min_age].
    pub fn set_min_age<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_age = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryVertexDatasetConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryVertexDatasetConditions"
    }
}

/// How often existing datasets should have their profiles refreshed.
/// New datasets are scanned as quickly as possible depending on system
/// capacity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryVertexDatasetGenerationCadence {
    /// If you set this field, profiles are refreshed at this
    /// frequency regardless of whether the underlying datasets have changed.
    /// Defaults to never.
    pub refresh_frequency: crate::model::DataProfileUpdateFrequency,

    /// Governs when to update data profiles when the inspection rules
    /// defined by the `InspectTemplate` change.
    /// If not set, changing the template will not cause a data profile to be
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_cadence:
        std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
}

impl DiscoveryVertexDatasetGenerationCadence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [refresh_frequency][crate::model::DiscoveryVertexDatasetGenerationCadence::refresh_frequency].
    pub fn set_refresh_frequency<
        T: std::convert::Into<crate::model::DataProfileUpdateFrequency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_frequency = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_cadence][crate::model::DiscoveryVertexDatasetGenerationCadence::inspect_template_modified_cadence].
    pub fn set_inspect_template_modified_cadence<
        T: std::convert::Into<
            std::option::Option<crate::model::DiscoveryInspectTemplateModifiedCadence>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_cadence = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryVertexDatasetGenerationCadence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DiscoveryVertexDatasetGenerationCadence"
    }
}

/// Combines all of the information about a DLP job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DlpJob {
    /// The server-assigned name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The type of job.
    #[serde(rename = "type")]
    pub r#type: crate::model::DlpJobType,

    /// State of a job.
    pub state: crate::model::dlp_job::JobState,

    /// Time when the job was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time when the job started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Time when the job finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Time when the job was last modified by the system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_modified: std::option::Option<wkt::Timestamp>,

    /// If created by a job trigger, the resource name of the trigger that
    /// instantiated the job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_trigger_name: std::string::String,

    /// A stream of errors encountered running the job.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Events that should occur after the job has completed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub action_details: std::vec::Vec<crate::model::ActionDetails>,

    /// Job details.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::dlp_job::Details>,
}

impl DlpJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DlpJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DlpJob::type].
    pub fn set_type<T: std::convert::Into<crate::model::DlpJobType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DlpJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::dlp_job::JobState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DlpJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::DlpJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::DlpJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [last_modified][crate::model::DlpJob::last_modified].
    pub fn set_last_modified<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_modified = v.into();
        self
    }

    /// Sets the value of [job_trigger_name][crate::model::DlpJob::job_trigger_name].
    pub fn set_job_trigger_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_trigger_name = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::DlpJob::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [action_details][crate::model::DlpJob::action_details].
    pub fn set_action_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ActionDetails>,
    {
        use std::iter::Iterator;
        self.action_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `details`.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::dlp_job::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::DlpJob::details]
    /// if it holds a `RiskDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_risk_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AnalyzeDataSourceRiskDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::dlp_job::Details::RiskDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::DlpJob::details]
    /// if it holds a `InspectDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_inspect_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InspectDataSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::dlp_job::Details::InspectDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DlpJob::details]
    /// to hold a `RiskDetails`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_risk_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AnalyzeDataSourceRiskDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::dlp_job::Details::RiskDetails(v.into()));
        self
    }

    /// Sets the value of [details][crate::model::DlpJob::details]
    /// to hold a `InspectDetails`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_inspect_details<
        T: std::convert::Into<std::boxed::Box<crate::model::InspectDataSourceDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::dlp_job::Details::InspectDetails(v.into()));
        self
    }
}

impl wkt::message::Message for DlpJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DlpJob"
    }
}

/// Defines additional types related to DlpJob
pub mod dlp_job {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a job. New items may be added.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct JobState(i32);

    impl JobState {
        /// Unused.
        pub const JOB_STATE_UNSPECIFIED: JobState = JobState::new(0);

        /// The job has not yet started.
        pub const PENDING: JobState = JobState::new(1);

        /// The job is currently running. Once a job has finished it will transition
        /// to FAILED or DONE.
        pub const RUNNING: JobState = JobState::new(2);

        /// The job is no longer running.
        pub const DONE: JobState = JobState::new(3);

        /// The job was canceled before it could be completed.
        pub const CANCELED: JobState = JobState::new(4);

        /// The job had an error and did not complete.
        pub const FAILED: JobState = JobState::new(5);

        /// The job is currently accepting findings via hybridInspect.
        /// A hybrid job in ACTIVE state may continue to have findings added to it
        /// through the calling of hybridInspect. After the job has finished no more
        /// calls to hybridInspect may be made. ACTIVE jobs can transition to DONE.
        pub const ACTIVE: JobState = JobState::new(6);

        /// Creates a new JobState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("JOB_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PENDING"),
                2 => std::borrow::Cow::Borrowed("RUNNING"),
                3 => std::borrow::Cow::Borrowed("DONE"),
                4 => std::borrow::Cow::Borrowed("CANCELED"),
                5 => std::borrow::Cow::Borrowed("FAILED"),
                6 => std::borrow::Cow::Borrowed("ACTIVE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "JOB_STATE_UNSPECIFIED" => std::option::Option::Some(Self::JOB_STATE_UNSPECIFIED),
                "PENDING" => std::option::Option::Some(Self::PENDING),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "DONE" => std::option::Option::Some(Self::DONE),
                "CANCELED" => std::option::Option::Some(Self::CANCELED),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for JobState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for JobState {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Job details.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Results from analyzing risk of a data source.
        RiskDetails(std::boxed::Box<crate::model::AnalyzeDataSourceRiskDetails>),
        /// Results from inspecting a data source.
        InspectDetails(std::boxed::Box<crate::model::InspectDataSourceDetails>),
    }
}

/// The request message for
/// [GetDlpJob][google.privacy.dlp.v2.DlpService.GetDlpJob].
///
/// [google.privacy.dlp.v2.DlpService.GetDlpJob]: crate::client::DlpService::get_dlp_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDlpJobRequest {
    /// Required. The name of the DlpJob resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetDlpJobRequest"
    }
}

/// The request message for listing DLP jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDlpJobsRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on whether you have [specified a
    /// processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values for inspect jobs:
    ///   - `state` - PENDING|RUNNING|CANCELED|FINISHED|FAILED
    ///   - `inspected_storage` - DATASTORE|CLOUD_STORAGE|BIGQUERY
    ///   - `trigger_name` - The name of the trigger that created the job.
    ///   - 'end_time` - Corresponds to the time the job finished.
    ///   - 'start_time` - Corresponds to the time the job finished.
    /// * Supported fields for risk analysis jobs:
    ///   - `state` - RUNNING|CANCELED|FINISHED|FAILED
    ///   - 'end_time` - Corresponds to the time the job finished.
    ///   - 'start_time` - Corresponds to the time the job finished.
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * inspected_storage = cloud_storage AND state = done
    /// * inspected_storage = cloud_storage OR inspected_storage = bigquery
    /// * inspected_storage = cloud_storage AND (state = done OR state = canceled)
    /// * end_time > \"2017-12-12T00:00:00+00:00\"
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The type of job. Defaults to `DlpJobType.INSPECT`
    #[serde(rename = "type")]
    pub r#type: crate::model::DlpJobType,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc, end_time asc, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the job was created.
    /// - `end_time`: corresponds to the time the job ended.
    /// - `name`: corresponds to the job's name.
    /// - `state`: corresponds to `state`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl ListDlpJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDlpJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDlpJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDlpJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDlpJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ListDlpJobsRequest::type].
    pub fn set_type<T: std::convert::Into<crate::model::DlpJobType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDlpJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListDlpJobsRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListDlpJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDlpJobsRequest"
    }
}

/// The response message for listing DLP jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDlpJobsResponse {
    /// A list of DlpJobs that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jobs: std::vec::Vec<crate::model::DlpJob>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDlpJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDlpJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [jobs][crate::model::ListDlpJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DlpJob>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDlpJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDlpJobsResponse"
    }
}

impl gax::paginator::PageableResponse for ListDlpJobsResponse {
    type PageItem = crate::model::DlpJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for canceling a DLP job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelDlpJobRequest {
    /// Required. The name of the DlpJob resource to be cancelled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl CancelDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CancelDlpJobRequest"
    }
}

/// The request message for finishing a DLP hybrid job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FinishDlpJobRequest {
    /// Required. The name of the DlpJob resource to be finished.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl FinishDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FinishDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for FinishDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FinishDlpJobRequest"
    }
}

/// The request message for deleting a DLP job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDlpJobRequest {
    /// Required. The name of the DlpJob resource to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteDlpJobRequest"
    }
}

/// Request message for CreateDeidentifyTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDeidentifyTemplateRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The DeidentifyTemplate to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deidentify_template: std::option::Option<crate::model::DeidentifyTemplate>,

    /// The template id can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template_id: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl CreateDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeidentifyTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deidentify_template][crate::model::CreateDeidentifyTemplateRequest::deidentify_template].
    pub fn set_deidentify_template<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }

    /// Sets the value of [template_id][crate::model::CreateDeidentifyTemplateRequest::template_id].
    pub fn set_template_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateDeidentifyTemplateRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateDeidentifyTemplateRequest"
    }
}

/// Request message for UpdateDeidentifyTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDeidentifyTemplateRequest {
    /// Required. Resource name of organization and deidentify template to be
    /// updated, for example
    /// `organizations/433245324/deidentifyTemplates/432452342` or
    /// projects/project-id/deidentifyTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// New DeidentifyTemplate value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deidentify_template: std::option::Option<crate::model::DeidentifyTemplate>,

    /// Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateDeidentifyTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [deidentify_template][crate::model::UpdateDeidentifyTemplateRequest::deidentify_template].
    pub fn set_deidentify_template<
        T: std::convert::Into<std::option::Option<crate::model::DeidentifyTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeidentifyTemplateRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest"
    }
}

/// Request message for GetDeidentifyTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDeidentifyTemplateRequest {
    /// Required. Resource name of the organization and deidentify template to be
    /// read, for example `organizations/433245324/deidentifyTemplates/432452342`
    /// or projects/project-id/deidentifyTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeidentifyTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetDeidentifyTemplateRequest"
    }
}

/// Request message for ListDeidentifyTemplates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeidentifyTemplatesRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to `ListDeidentifyTemplates`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc,update_time, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the template was created.
    /// - `update_time`: corresponds to the time the template was last updated.
    /// - `name`: corresponds to the template's name.
    /// - `display_name`: corresponds to the template's display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl ListDeidentifyTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeidentifyTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeidentifyTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeidentifyTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDeidentifyTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListDeidentifyTemplatesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListDeidentifyTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDeidentifyTemplatesRequest"
    }
}

/// Response message for ListDeidentifyTemplates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeidentifyTemplatesResponse {
    /// List of deidentify templates, up to page_size in
    /// ListDeidentifyTemplatesRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deidentify_templates: std::vec::Vec<crate::model::DeidentifyTemplate>,

    /// If the next page is available then the next page token to be used in the
    /// following ListDeidentifyTemplates request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDeidentifyTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDeidentifyTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [deidentify_templates][crate::model::ListDeidentifyTemplatesResponse::deidentify_templates].
    pub fn set_deidentify_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeidentifyTemplate>,
    {
        use std::iter::Iterator;
        self.deidentify_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDeidentifyTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListDeidentifyTemplatesResponse"
    }
}

impl gax::paginator::PageableResponse for ListDeidentifyTemplatesResponse {
    type PageItem = crate::model::DeidentifyTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deidentify_templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteDeidentifyTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDeidentifyTemplateRequest {
    /// Required. Resource name of the organization and deidentify template to be
    /// deleted, for example
    /// `organizations/433245324/deidentifyTemplates/432452342` or
    /// projects/project-id/deidentifyTemplates/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteDeidentifyTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDeidentifyTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDeidentifyTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest"
    }
}

/// Configuration for a custom dictionary created from a data source of any size
/// up to the maximum size defined in the
/// [limits](https://cloud.google.com/sensitive-data-protection/limits) page. The
/// artifacts of dictionary creation are stored in the specified Cloud Storage
/// location. Consider using `CustomInfoType.Dictionary` for smaller dictionaries
/// that satisfy the size requirements.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LargeCustomDictionaryConfig {
    /// Location to store dictionary artifacts in Cloud Storage. These files
    /// will only be accessible by project owners and the DLP API. If any of these
    /// artifacts are modified, the dictionary is considered invalid and can no
    /// longer be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_path: std::option::Option<crate::model::CloudStoragePath>,

    /// Source of the dictionary.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::large_custom_dictionary_config::Source>,
}

impl LargeCustomDictionaryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_path][crate::model::LargeCustomDictionaryConfig::output_path].
    pub fn set_output_path<
        T: std::convert::Into<std::option::Option<crate::model::CloudStoragePath>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_path = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<
            std::option::Option<crate::model::large_custom_dictionary_config::Source>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// if it holds a `CloudStorageFileSet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_storage_file_set(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageFileSet>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::large_custom_dictionary_config::Source::CloudStorageFileSet(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// if it holds a `BigQueryField`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_big_query_field(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryField>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::large_custom_dictionary_config::Source::BigQueryField(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// to hold a `CloudStorageFileSet`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cloud_storage_file_set<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageFileSet>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::large_custom_dictionary_config::Source::CloudStorageFileSet(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::LargeCustomDictionaryConfig::source]
    /// to hold a `BigQueryField`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_big_query_field<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryField>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::large_custom_dictionary_config::Source::BigQueryField(v.into()),
        );
        self
    }
}

impl wkt::message::Message for LargeCustomDictionaryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.LargeCustomDictionaryConfig"
    }
}

/// Defines additional types related to LargeCustomDictionaryConfig
pub mod large_custom_dictionary_config {
    #[allow(unused_imports)]
    use super::*;

    /// Source of the dictionary.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Set of files containing newline-delimited lists of dictionary phrases.
        CloudStorageFileSet(std::boxed::Box<crate::model::CloudStorageFileSet>),
        /// Field in a BigQuery table where each cell represents a dictionary phrase.
        BigQueryField(std::boxed::Box<crate::model::BigQueryField>),
    }
}

/// Summary statistics of a custom dictionary.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LargeCustomDictionaryStats {
    /// Approximate number of distinct phrases in the dictionary.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub approx_num_phrases: i64,
}

impl LargeCustomDictionaryStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approx_num_phrases][crate::model::LargeCustomDictionaryStats::approx_num_phrases].
    pub fn set_approx_num_phrases<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.approx_num_phrases = v.into();
        self
    }
}

impl wkt::message::Message for LargeCustomDictionaryStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.LargeCustomDictionaryStats"
    }
}

/// Configuration for stored infoTypes. All fields and subfield are provided
/// by the user. For more information, see
/// <https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredInfoTypeConfig {
    /// Display name of the StoredInfoType (max 256 characters).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of the StoredInfoType (max 256 characters).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Stored infotype types.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::stored_info_type_config::Type>,
}

impl StoredInfoTypeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::StoredInfoTypeConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::StoredInfoTypeConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of `r#type`.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::stored_info_type_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// if it holds a `LargeCustomDictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_large_custom_dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LargeCustomDictionaryConfig>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_config::Type::LargeCustomDictionary(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// if it holds a `Dictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Dictionary>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_config::Type::Dictionary(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// if it holds a `Regex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Regex>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_config::Type::Regex(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// to hold a `LargeCustomDictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_large_custom_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::LargeCustomDictionaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::stored_info_type_config::Type::LargeCustomDictionary(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// to hold a `Dictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Dictionary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::stored_info_type_config::Type::Dictionary(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeConfig::r#type]
    /// to hold a `Regex`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Regex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::stored_info_type_config::Type::Regex(v.into()));
        self
    }
}

impl wkt::message::Message for StoredInfoTypeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoTypeConfig"
    }
}

/// Defines additional types related to StoredInfoTypeConfig
pub mod stored_info_type_config {
    #[allow(unused_imports)]
    use super::*;

    /// Stored infotype types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// StoredInfoType where findings are defined by a dictionary of phrases.
        LargeCustomDictionary(std::boxed::Box<crate::model::LargeCustomDictionaryConfig>),
        /// Store dictionary-based CustomInfoType.
        Dictionary(std::boxed::Box<crate::model::custom_info_type::Dictionary>),
        /// Store regular expression-based StoredInfoType.
        Regex(std::boxed::Box<crate::model::custom_info_type::Regex>),
    }
}

/// Statistics for a StoredInfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredInfoTypeStats {
    /// Stat types
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::stored_info_type_stats::Type>,
}

impl StoredInfoTypeStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `r#type`.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::stored_info_type_stats::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::StoredInfoTypeStats::r#type]
    /// if it holds a `LargeCustomDictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_large_custom_dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LargeCustomDictionaryStats>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::stored_info_type_stats::Type::LargeCustomDictionary(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StoredInfoTypeStats::r#type]
    /// to hold a `LargeCustomDictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_large_custom_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::LargeCustomDictionaryStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::stored_info_type_stats::Type::LargeCustomDictionary(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StoredInfoTypeStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoTypeStats"
    }
}

/// Defines additional types related to StoredInfoTypeStats
pub mod stored_info_type_stats {
    #[allow(unused_imports)]
    use super::*;

    /// Stat types
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// StoredInfoType where findings are defined by a dictionary of phrases.
        LargeCustomDictionary(std::boxed::Box<crate::model::LargeCustomDictionaryStats>),
    }
}

/// Version of a StoredInfoType, including the configuration used to build it,
/// create timestamp, and current state.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredInfoTypeVersion {
    /// StoredInfoType configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::StoredInfoTypeConfig>,

    /// Create timestamp of the version. Read-only, determined by the system
    /// when the version is created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Stored info type version state. Read-only, updated by the system
    /// during dictionary creation.
    pub state: crate::model::StoredInfoTypeState,

    /// Errors that occurred when creating this storedInfoType version, or
    /// anomalies detected in the storedInfoType data that render it unusable. Only
    /// the five most recent errors will be displayed, with the most recent error
    /// appearing first.
    ///
    /// For example, some of the data for stored custom dictionaries is put in
    /// the user's Cloud Storage bucket, and if this data is modified or
    /// deleted by the user or another system, the dictionary becomes invalid.
    ///
    /// If any errors occur, fix the problem indicated by the error message and
    /// use the UpdateStoredInfoType API method to create another version of the
    /// storedInfoType to continue using it, reusing the same `config` if it was
    /// not the source of the error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Statistics about this storedInfoType version.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stats: std::option::Option<crate::model::StoredInfoTypeStats>,
}

impl StoredInfoTypeVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::StoredInfoTypeVersion::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::StoredInfoTypeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::StoredInfoTypeVersion::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::StoredInfoTypeVersion::state].
    pub fn set_state<T: std::convert::Into<crate::model::StoredInfoTypeState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [stats][crate::model::StoredInfoTypeVersion::stats].
    pub fn set_stats<
        T: std::convert::Into<std::option::Option<crate::model::StoredInfoTypeStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.stats = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::StoredInfoTypeVersion::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StoredInfoTypeVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoTypeVersion"
    }
}

/// StoredInfoType resource message that contains information about the current
/// version and any pending updates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredInfoType {
    /// Resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Current version of the stored info type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub current_version: std::option::Option<crate::model::StoredInfoTypeVersion>,

    /// Pending versions of the stored info type. Empty if no versions are
    /// pending.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pending_versions: std::vec::Vec<crate::model::StoredInfoTypeVersion>,
}

impl StoredInfoType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StoredInfoType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [current_version][crate::model::StoredInfoType::current_version].
    pub fn set_current_version<
        T: std::convert::Into<std::option::Option<crate::model::StoredInfoTypeVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.current_version = v.into();
        self
    }

    /// Sets the value of [pending_versions][crate::model::StoredInfoType::pending_versions].
    pub fn set_pending_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StoredInfoTypeVersion>,
    {
        use std::iter::Iterator;
        self.pending_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StoredInfoType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredInfoType"
    }
}

/// Request message for CreateStoredInfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateStoredInfoTypeRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    /// + Organizations scope, location specified:
    ///   `organizations/{org_id}/locations/{location_id}`
    /// + Organizations scope, no location specified (defaults to global):
    ///   `organizations/{org_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Configuration of the storedInfoType to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::StoredInfoTypeConfig>,

    /// The storedInfoType ID can contain uppercase and lowercase letters,
    /// numbers, and hyphens; that is, it must match the regular
    /// expression: `[a-zA-Z\d-_]+`. The maximum length is 100
    /// characters. Can be empty to allow the system to generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub stored_info_type_id: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl CreateStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateStoredInfoTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [config][crate::model::CreateStoredInfoTypeRequest::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::StoredInfoTypeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [stored_info_type_id][crate::model::CreateStoredInfoTypeRequest::stored_info_type_id].
    pub fn set_stored_info_type_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.stored_info_type_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::CreateStoredInfoTypeRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateStoredInfoTypeRequest"
    }
}

/// Request message for UpdateStoredInfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateStoredInfoTypeRequest {
    /// Required. Resource name of organization and storedInfoType to be updated,
    /// for example `organizations/433245324/storedInfoTypes/432452342` or
    /// projects/project-id/storedInfoTypes/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Updated configuration for the storedInfoType. If not provided, a new
    /// version of the storedInfoType will be created with the existing
    /// configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::StoredInfoTypeConfig>,

    /// Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateStoredInfoTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::UpdateStoredInfoTypeRequest::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::StoredInfoTypeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateStoredInfoTypeRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateStoredInfoTypeRequest"
    }
}

/// Request message for GetStoredInfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetStoredInfoTypeRequest {
    /// Required. Resource name of the organization and storedInfoType to be read,
    /// for example `organizations/433245324/storedInfoTypes/432452342` or
    /// projects/project-id/storedInfoTypes/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStoredInfoTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetStoredInfoTypeRequest"
    }
}

/// Request message for ListStoredInfoTypes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStoredInfoTypesRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization) and whether you have [specified a processing
    /// location](https://cloud.google.com/sensitive-data-protection/docs/specifying-location):
    ///
    /// + Projects scope, location specified:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Projects scope, no location specified (defaults to global):
    ///   `projects/{project_id}`
    ///
    /// The following example `parent` string specifies a parent project with the
    /// identifier `example-project`, and specifies the `europe-west3` location
    /// for processing data:
    ///
    /// ```norust
    /// parent=projects/example-project/locations/europe-west3
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval. Comes from the previous call
    /// to `ListStoredInfoTypes`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by,
    /// followed by `asc` or `desc` postfix. This list is case insensitive. The
    /// default sorting order is ascending. Redundant space characters are
    /// insignificant.
    ///
    /// Example: `name asc, display_name, create_time desc`
    ///
    /// Supported fields are:
    ///
    /// - `create_time`: corresponds to the time the most recent version of the
    ///   resource was created.
    /// - `state`: corresponds to the state of the resource.
    /// - `name`: corresponds to resource name.
    /// - `display_name`: corresponds to info type's display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Deprecated. This field has no effect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,
}

impl ListStoredInfoTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListStoredInfoTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListStoredInfoTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListStoredInfoTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListStoredInfoTypesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::ListStoredInfoTypesRequest::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }
}

impl wkt::message::Message for ListStoredInfoTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListStoredInfoTypesRequest"
    }
}

/// Response message for ListStoredInfoTypes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStoredInfoTypesResponse {
    /// List of storedInfoTypes, up to page_size in ListStoredInfoTypesRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stored_info_types: std::vec::Vec<crate::model::StoredInfoType>,

    /// If the next page is available then the next page token to be used
    /// in the following ListStoredInfoTypes request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListStoredInfoTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListStoredInfoTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [stored_info_types][crate::model::ListStoredInfoTypesResponse::stored_info_types].
    pub fn set_stored_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StoredInfoType>,
    {
        use std::iter::Iterator;
        self.stored_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListStoredInfoTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListStoredInfoTypesResponse"
    }
}

impl gax::paginator::PageableResponse for ListStoredInfoTypesResponse {
    type PageItem = crate::model::StoredInfoType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.stored_info_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteStoredInfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteStoredInfoTypeRequest {
    /// Required. Resource name of the organization and storedInfoType to be
    /// deleted, for example `organizations/433245324/storedInfoTypes/432452342` or
    /// projects/project-id/storedInfoTypes/432452342.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteStoredInfoTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteStoredInfoTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteStoredInfoTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteStoredInfoTypeRequest"
    }
}

/// Request to search for potentially sensitive info in a custom location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridInspectJobTriggerRequest {
    /// Required. Resource name of the trigger to execute a hybrid inspect on, for
    /// example `projects/dlp-test-project/jobTriggers/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The item to inspect.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hybrid_item: std::option::Option<crate::model::HybridContentItem>,
}

impl HybridInspectJobTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HybridInspectJobTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [hybrid_item][crate::model::HybridInspectJobTriggerRequest::hybrid_item].
    pub fn set_hybrid_item<
        T: std::convert::Into<std::option::Option<crate::model::HybridContentItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hybrid_item = v.into();
        self
    }
}

impl wkt::message::Message for HybridInspectJobTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectJobTriggerRequest"
    }
}

/// Request to search for potentially sensitive info in a custom location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridInspectDlpJobRequest {
    /// Required. Resource name of the job to execute a hybrid inspect on, for
    /// example `projects/dlp-test-project/dlpJob/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The item to inspect.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hybrid_item: std::option::Option<crate::model::HybridContentItem>,
}

impl HybridInspectDlpJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HybridInspectDlpJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [hybrid_item][crate::model::HybridInspectDlpJobRequest::hybrid_item].
    pub fn set_hybrid_item<
        T: std::convert::Into<std::option::Option<crate::model::HybridContentItem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hybrid_item = v.into();
        self
    }
}

impl wkt::message::Message for HybridInspectDlpJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectDlpJobRequest"
    }
}

/// An individual hybrid item to inspect. Will be stored temporarily during
/// processing.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridContentItem {
    /// The item to inspect.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub item: std::option::Option<crate::model::ContentItem>,

    /// Supplementary information that will be added to each finding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finding_details: std::option::Option<crate::model::HybridFindingDetails>,
}

impl HybridContentItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [item][crate::model::HybridContentItem::item].
    pub fn set_item<T: std::convert::Into<std::option::Option<crate::model::ContentItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.item = v.into();
        self
    }

    /// Sets the value of [finding_details][crate::model::HybridContentItem::finding_details].
    pub fn set_finding_details<
        T: std::convert::Into<std::option::Option<crate::model::HybridFindingDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.finding_details = v.into();
        self
    }
}

impl wkt::message::Message for HybridContentItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridContentItem"
    }
}

/// Populate to associate additional data with each finding.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridFindingDetails {
    /// Details about the container where the content being inspected is from.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container_details: std::option::Option<crate::model::Container>,

    /// Offset in bytes of the line, from the beginning of the file, where the
    /// finding  is located. Populate if the item being scanned is only part of a
    /// bigger item, such as a shard of a file and you want to track the absolute
    /// position of the finding.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub file_offset: i64,

    /// Offset of the row for tables. Populate if the row(s) being scanned are
    /// part of a bigger dataset and you want to keep track of their absolute
    /// position.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub row_offset: i64,

    /// If the container is a table, additional information to make findings
    /// meaningful such as the columns that are primary keys. If not known ahead
    /// of time, can also be set within each inspect hybrid call and the two
    /// will be merged. Note that identifying_fields will only be stored to
    /// BigQuery, and only if the BigQuery action has been included.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_options: std::option::Option<crate::model::TableOptions>,

    /// Labels to represent user provided metadata about the data being inspected.
    /// If configured by the job, some key values may be required.
    /// The labels associated with `Finding`'s produced by hybrid
    /// inspection.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// Label values must be between 0 and 63 characters long and must conform
    /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
    ///
    /// No more than 10 labels can be associated with a given finding.
    ///
    /// Examples:
    ///
    /// * `"environment" : "production"`
    /// * `"pipeline" : "etl"`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,
}

impl HybridFindingDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_details][crate::model::HybridFindingDetails::container_details].
    pub fn set_container_details<
        T: std::convert::Into<std::option::Option<crate::model::Container>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.container_details = v.into();
        self
    }

    /// Sets the value of [file_offset][crate::model::HybridFindingDetails::file_offset].
    pub fn set_file_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.file_offset = v.into();
        self
    }

    /// Sets the value of [row_offset][crate::model::HybridFindingDetails::row_offset].
    pub fn set_row_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_offset = v.into();
        self
    }

    /// Sets the value of [table_options][crate::model::HybridFindingDetails::table_options].
    pub fn set_table_options<
        T: std::convert::Into<std::option::Option<crate::model::TableOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_options = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::HybridFindingDetails::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for HybridFindingDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridFindingDetails"
    }
}

/// Quota exceeded errors will be thrown once quota has been met.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridInspectResponse {}

impl HybridInspectResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for HybridInspectResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridInspectResponse"
    }
}

/// Request to list the profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProjectDataProfilesRequest {
    /// Required. organizations/{org_id}/locations/{loc_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero, server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by, followed by `asc` or `desc`
    /// postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: Google Cloud project ID
    /// - `sensitivity_level`: How sensitive the data in a project is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `sensitivity_level` - HIGH|MODERATE|LOW
    ///   - `data_risk_level` - HIGH|MODERATE|LOW
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * `project_id = 12345 AND status_code = 1`
    /// * `project_id = 12345 AND sensitivity_level = HIGH`
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListProjectDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProjectDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProjectDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProjectDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListProjectDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListProjectDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListProjectDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListProjectDataProfilesRequest"
    }
}

/// List of profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProjectDataProfilesResponse {
    /// List of data profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub project_data_profiles: std::vec::Vec<crate::model::ProjectDataProfile>,

    /// The next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListProjectDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListProjectDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [project_data_profiles][crate::model::ListProjectDataProfilesResponse::project_data_profiles].
    pub fn set_project_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProjectDataProfile>,
    {
        use std::iter::Iterator;
        self.project_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListProjectDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListProjectDataProfilesResponse"
    }
}

impl gax::paginator::PageableResponse for ListProjectDataProfilesResponse {
    type PageItem = crate::model::ProjectDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.project_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to list the profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTableDataProfilesRequest {
    /// Required. Resource name of the organization or project, for
    /// example `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero, server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by, followed by `asc` or `desc`
    /// postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id asc`
    /// * `table_id`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: The Google Cloud project ID.
    /// - `dataset_id`: The ID of a BigQuery dataset.
    /// - `table_id`: The ID of a BigQuery table.
    /// - `sensitivity_level`: How sensitive the data in a table is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    /// - `last_modified`: The last time the resource was modified.
    /// - `resource_visibility`: Visibility restriction for this resource.
    /// - `row_count`: Number of rows in this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `project_id` - The Google Cloud project ID.
    ///   - `dataset_id` - The BigQuery dataset ID.
    ///   - `table_id` - The ID of the BigQuery table.
    ///   - `sensitivity_level` - HIGH|MODERATE|LOW
    ///   - `data_risk_level` - HIGH|MODERATE|LOW
    ///   - `resource_visibility`: PUBLIC|RESTRICTED
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * `project_id = 12345 AND status_code = 1`
    /// * `project_id = 12345 AND sensitivity_level = HIGH`
    /// * `project_id = 12345 AND resource_visibility = PUBLIC`
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListTableDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTableDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTableDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTableDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTableDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTableDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListTableDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListTableDataProfilesRequest"
    }
}

/// List of profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTableDataProfilesResponse {
    /// List of data profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub table_data_profiles: std::vec::Vec<crate::model::TableDataProfile>,

    /// The next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTableDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTableDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [table_data_profiles][crate::model::ListTableDataProfilesResponse::table_data_profiles].
    pub fn set_table_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableDataProfile>,
    {
        use std::iter::Iterator;
        self.table_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTableDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListTableDataProfilesResponse"
    }
}

impl gax::paginator::PageableResponse for ListTableDataProfilesResponse {
    type PageItem = crate::model::TableDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.table_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to list the profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListColumnDataProfilesRequest {
    /// Required. Resource name of the organization or project, for
    /// example `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Page token to continue retrieval.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Size of the page. This value can be limited by the server. If zero, server
    /// returns a page of max size 100.
    pub page_size: i32,

    /// Comma-separated list of fields to order by, followed by `asc` or `desc`
    /// postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id asc`
    /// * `table_id`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: The Google Cloud project ID.
    /// - `dataset_id`: The ID of a BigQuery dataset.
    /// - `table_id`: The ID of a BigQuery table.
    /// - `sensitivity_level`: How sensitive the data in a column is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `table_data_profile_name` - The name of the related table data
    ///     profile.
    ///   - `project_id` - The Google Cloud project ID. (REQUIRED)
    ///   - `dataset_id` - The BigQuery dataset ID. (REQUIRED)
    ///   - `table_id` - The BigQuery table ID. (REQUIRED)
    ///   - `field_id` - The ID of the BigQuery field.
    ///   - `info_type` - The infotype detected in the resource.
    ///   - `sensitivity_level` - HIGH|MEDIUM|LOW
    ///   - `data_risk_level`: How much risk is associated with this data.
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` for project_id, dataset_id, and table_id. Other
    ///   filters also support `!=`.
    ///
    /// Examples:
    ///
    /// * project_id = 12345 AND status_code = 1
    /// * project_id = 12345 AND sensitivity_level = HIGH
    /// * project_id = 12345 AND info_type = STREET_ADDRESS
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListColumnDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListColumnDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListColumnDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListColumnDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListColumnDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListColumnDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListColumnDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListColumnDataProfilesRequest"
    }
}

/// List of profiles generated for a given organization or project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListColumnDataProfilesResponse {
    /// List of data profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub column_data_profiles: std::vec::Vec<crate::model::ColumnDataProfile>,

    /// The next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListColumnDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListColumnDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [column_data_profiles][crate::model::ListColumnDataProfilesResponse::column_data_profiles].
    pub fn set_column_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnDataProfile>,
    {
        use std::iter::Iterator;
        self.column_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListColumnDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListColumnDataProfilesResponse"
    }
}

impl gax::paginator::PageableResponse for ListColumnDataProfilesResponse {
    type PageItem = crate::model::ColumnDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.column_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Score is a summary of all elements in the data profile.
/// A higher number means more risk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataRiskLevel {
    /// The score applied to the resource.
    pub score: crate::model::data_risk_level::DataRiskLevelScore,
}

impl DataRiskLevel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::DataRiskLevel::score].
    pub fn set_score<T: std::convert::Into<crate::model::data_risk_level::DataRiskLevelScore>>(
        mut self,
        v: T,
    ) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for DataRiskLevel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataRiskLevel"
    }
}

/// Defines additional types related to DataRiskLevel
pub mod data_risk_level {
    #[allow(unused_imports)]
    use super::*;

    /// Various score levels for resources.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DataRiskLevelScore(i32);

    impl DataRiskLevelScore {
        /// Unused.
        pub const RISK_SCORE_UNSPECIFIED: DataRiskLevelScore = DataRiskLevelScore::new(0);

        /// Low risk - Lower indication of sensitive data that appears to have
        /// additional access restrictions in place or no indication of sensitive
        /// data found.
        pub const RISK_LOW: DataRiskLevelScore = DataRiskLevelScore::new(10);

        /// Unable to determine risk.
        pub const RISK_UNKNOWN: DataRiskLevelScore = DataRiskLevelScore::new(12);

        /// Medium risk - Sensitive data may be present but additional access or fine
        /// grain access restrictions appear to be present.  Consider limiting
        /// access even further or transform data to mask.
        pub const RISK_MODERATE: DataRiskLevelScore = DataRiskLevelScore::new(20);

        /// High risk  SPII may be present. Access controls may include public
        /// ACLs. Exfiltration of data may lead to user data loss. Re-identification
        /// of users may be possible. Consider limiting usage and or removing SPII.
        pub const RISK_HIGH: DataRiskLevelScore = DataRiskLevelScore::new(30);

        /// Creates a new DataRiskLevelScore instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RISK_SCORE_UNSPECIFIED"),
                10 => std::borrow::Cow::Borrowed("RISK_LOW"),
                12 => std::borrow::Cow::Borrowed("RISK_UNKNOWN"),
                20 => std::borrow::Cow::Borrowed("RISK_MODERATE"),
                30 => std::borrow::Cow::Borrowed("RISK_HIGH"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RISK_SCORE_UNSPECIFIED" => std::option::Option::Some(Self::RISK_SCORE_UNSPECIFIED),
                "RISK_LOW" => std::option::Option::Some(Self::RISK_LOW),
                "RISK_UNKNOWN" => std::option::Option::Some(Self::RISK_UNKNOWN),
                "RISK_MODERATE" => std::option::Option::Some(Self::RISK_MODERATE),
                "RISK_HIGH" => std::option::Option::Some(Self::RISK_HIGH),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DataRiskLevelScore {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DataRiskLevelScore {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// An aggregated profile for this project, based on the resources profiled
/// within it.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProjectDataProfile {
    /// The resource name of the profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Project ID or account that was profiled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The last time the profile was generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// The sensitivity score of this project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// Success or error status of the last attempt to profile the project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// The number of table data profiles generated for this project.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub table_data_profile_count: i64,

    /// The number of file store data profiles generated for this project.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub file_store_data_profile_count: i64,
}

impl ProjectDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProjectDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::ProjectDataProfile::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::ProjectDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_last_generated = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::ProjectDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [data_risk_level][crate::model::ProjectDataProfile::data_risk_level].
    pub fn set_data_risk_level<
        T: std::convert::Into<std::option::Option<crate::model::DataRiskLevel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_risk_level = v.into();
        self
    }

    /// Sets the value of [profile_status][crate::model::ProjectDataProfile::profile_status].
    pub fn set_profile_status<
        T: std::convert::Into<std::option::Option<crate::model::ProfileStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_status = v.into();
        self
    }

    /// Sets the value of [table_data_profile_count][crate::model::ProjectDataProfile::table_data_profile_count].
    pub fn set_table_data_profile_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.table_data_profile_count = v.into();
        self
    }

    /// Sets the value of [file_store_data_profile_count][crate::model::ProjectDataProfile::file_store_data_profile_count].
    pub fn set_file_store_data_profile_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.file_store_data_profile_count = v.into();
        self
    }
}

impl wkt::message::Message for ProjectDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ProjectDataProfile"
    }
}

/// Snapshot of the configurations used to generate the profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileConfigSnapshot {
    /// A copy of the inspection config used to generate this profile. This
    /// is a copy of the inspect_template specified in `DataProfileJobConfig`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_config: std::option::Option<crate::model::InspectConfig>,

    /// A copy of the configuration used to generate this profile. This is
    /// deprecated, and the DiscoveryConfig field is preferred moving forward.
    /// DataProfileJobConfig will still be written here for Discovery in BigQuery
    /// for backwards compatibility, but will not be updated with new fields, while
    /// DiscoveryConfig will.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_profile_job: std::option::Option<crate::model::DataProfileJobConfig>,

    /// A copy of the configuration used to generate this profile.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub discovery_config: std::option::Option<crate::model::DiscoveryConfig>,

    /// Name of the inspection template used to generate this profile
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template_name: std::string::String,

    /// Timestamp when the template was modified
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inspect_template_modified_time: std::option::Option<wkt::Timestamp>,
}

impl DataProfileConfigSnapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inspect_config][crate::model::DataProfileConfigSnapshot::inspect_config].
    pub fn set_inspect_config<
        T: std::convert::Into<std::option::Option<crate::model::InspectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_config = v.into();
        self
    }

    /// Sets the value of [data_profile_job][crate::model::DataProfileConfigSnapshot::data_profile_job].
    pub fn set_data_profile_job<
        T: std::convert::Into<std::option::Option<crate::model::DataProfileJobConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_profile_job = v.into();
        self
    }

    /// Sets the value of [discovery_config][crate::model::DataProfileConfigSnapshot::discovery_config].
    pub fn set_discovery_config<
        T: std::convert::Into<std::option::Option<crate::model::DiscoveryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_config = v.into();
        self
    }

    /// Sets the value of [inspect_template_name][crate::model::DataProfileConfigSnapshot::inspect_template_name].
    pub fn set_inspect_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_name = v.into();
        self
    }

    /// Sets the value of [inspect_template_modified_time][crate::model::DataProfileConfigSnapshot::inspect_template_modified_time].
    pub fn set_inspect_template_modified_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template_modified_time = v.into();
        self
    }
}

impl wkt::message::Message for DataProfileConfigSnapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfileConfigSnapshot"
    }
}

/// The profile for a scanned table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableDataProfile {
    /// The name of the profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The resource type that was profiled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_source_type: std::option::Option<crate::model::DataSourceType>,

    /// The resource name of the project data profile for this table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_data_profile: std::string::String,

    /// The Google Cloud project ID that owns the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_project_id: std::string::String,

    /// If supported, the location where the dataset's data is stored.
    /// See <https://cloud.google.com/bigquery/docs/locations> for supported
    /// locations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_location: std::string::String,

    /// If the resource is BigQuery, the dataset ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// The table ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// The Cloud Asset Inventory resource that was profiled in order to generate
    /// this TableDataProfile.
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_resource: std::string::String,

    /// Success or error status from the most recent profile generation attempt.
    /// May be empty if the profile is still being generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// State of a profile.
    pub state: crate::model::table_data_profile::State,

    /// The sensitivity score of this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// The infoTypes predicted from this table's data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub predicted_info_types: std::vec::Vec<crate::model::InfoTypeSummary>,

    /// Other infoTypes found in this table's data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub other_info_types: std::vec::Vec<crate::model::OtherInfoTypeSummary>,

    /// The snapshot of the configurations used to generate the profile.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_snapshot: std::option::Option<crate::model::DataProfileConfigSnapshot>,

    /// The time when this table was last modified
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_modified_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The time when this table expires.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// The number of columns profiled in the table.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub scanned_column_count: i64,

    /// The number of columns skipped in the table because of an error.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_column_count: i64,

    /// The size of the table when the profile was generated.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub table_size_bytes: i64,

    /// Number of rows in the table when the profile was generated.
    /// This will not be populated for BigLake tables.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub row_count: i64,

    /// How the table is encrypted.
    pub encryption_status: crate::model::EncryptionStatus,

    /// How broadly a resource has been shared.
    pub resource_visibility: crate::model::ResourceVisibility,

    /// The last time the profile was generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// The labels applied to the resource at the time the profile was generated.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The time at which the table was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resources related to this profile.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_resources: std::vec::Vec<crate::model::RelatedResource>,
}

impl TableDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TableDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_source_type][crate::model::TableDataProfile::data_source_type].
    pub fn set_data_source_type<
        T: std::convert::Into<std::option::Option<crate::model::DataSourceType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source_type = v.into();
        self
    }

    /// Sets the value of [project_data_profile][crate::model::TableDataProfile::project_data_profile].
    pub fn set_project_data_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_data_profile = v.into();
        self
    }

    /// Sets the value of [dataset_project_id][crate::model::TableDataProfile::dataset_project_id].
    pub fn set_dataset_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_project_id = v.into();
        self
    }

    /// Sets the value of [dataset_location][crate::model::TableDataProfile::dataset_location].
    pub fn set_dataset_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_location = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::TableDataProfile::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::TableDataProfile::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [full_resource][crate::model::TableDataProfile::full_resource].
    pub fn set_full_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_resource = v.into();
        self
    }

    /// Sets the value of [profile_status][crate::model::TableDataProfile::profile_status].
    pub fn set_profile_status<
        T: std::convert::Into<std::option::Option<crate::model::ProfileStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_status = v.into();
        self
    }

    /// Sets the value of [state][crate::model::TableDataProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::table_data_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::TableDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [data_risk_level][crate::model::TableDataProfile::data_risk_level].
    pub fn set_data_risk_level<
        T: std::convert::Into<std::option::Option<crate::model::DataRiskLevel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_risk_level = v.into();
        self
    }

    /// Sets the value of [config_snapshot][crate::model::TableDataProfile::config_snapshot].
    pub fn set_config_snapshot<
        T: std::convert::Into<std::option::Option<crate::model::DataProfileConfigSnapshot>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config_snapshot = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::TableDataProfile::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::TableDataProfile::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [scanned_column_count][crate::model::TableDataProfile::scanned_column_count].
    pub fn set_scanned_column_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.scanned_column_count = v.into();
        self
    }

    /// Sets the value of [failed_column_count][crate::model::TableDataProfile::failed_column_count].
    pub fn set_failed_column_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_column_count = v.into();
        self
    }

    /// Sets the value of [table_size_bytes][crate::model::TableDataProfile::table_size_bytes].
    pub fn set_table_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.table_size_bytes = v.into();
        self
    }

    /// Sets the value of [row_count][crate::model::TableDataProfile::row_count].
    pub fn set_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_count = v.into();
        self
    }

    /// Sets the value of [encryption_status][crate::model::TableDataProfile::encryption_status].
    pub fn set_encryption_status<T: std::convert::Into<crate::model::EncryptionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_status = v.into();
        self
    }

    /// Sets the value of [resource_visibility][crate::model::TableDataProfile::resource_visibility].
    pub fn set_resource_visibility<T: std::convert::Into<crate::model::ResourceVisibility>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_visibility = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::TableDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_last_generated = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TableDataProfile::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [predicted_info_types][crate::model::TableDataProfile::predicted_info_types].
    pub fn set_predicted_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.predicted_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [other_info_types][crate::model::TableDataProfile::other_info_types].
    pub fn set_other_info_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OtherInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.other_info_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [related_resources][crate::model::TableDataProfile::related_resources].
    pub fn set_related_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedResource>,
    {
        use std::iter::Iterator;
        self.related_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_labels][crate::model::TableDataProfile::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TableDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableDataProfile"
    }
}

/// Defines additional types related to TableDataProfile
pub mod table_data_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a profile. New items may be added.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Unused.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The profile is currently running. Once a profile has finished it will
        /// transition to DONE.
        pub const RUNNING: State = State::new(1);

        /// The profile is no longer generating.
        /// If profile_status.status.code is 0, the profile succeeded, otherwise, it
        /// failed.
        pub const DONE: State = State::new(2);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RUNNING"),
                2 => std::borrow::Cow::Borrowed("DONE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "DONE" => std::option::Option::Some(Self::DONE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Success or errors for the profile generation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProfileStatus {
    /// Profiling status code and optional message. The `status.code` value is 0
    /// (default value) for OK.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,

    /// Time when the profile generation status was updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timestamp: std::option::Option<wkt::Timestamp>,
}

impl ProfileStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::ProfileStatus::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [timestamp][crate::model::ProfileStatus::timestamp].
    pub fn set_timestamp<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timestamp = v.into();
        self
    }
}

impl wkt::message::Message for ProfileStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ProfileStatus"
    }
}

/// The infoType details for this column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoTypeSummary {
    /// The infoType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Not populated for predicted infotypes.
    pub estimated_prevalence: i32,
}

impl InfoTypeSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::InfoTypeSummary::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [estimated_prevalence][crate::model::InfoTypeSummary::estimated_prevalence].
    pub fn set_estimated_prevalence<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.estimated_prevalence = v.into();
        self
    }
}

impl wkt::message::Message for InfoTypeSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoTypeSummary"
    }
}

/// Infotype details for other infoTypes found within a column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OtherInfoTypeSummary {
    /// The other infoType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Approximate percentage of non-null rows that contained data detected by
    /// this infotype.
    pub estimated_prevalence: i32,

    /// Whether this infoType was excluded from sensitivity and risk analysis due
    /// to factors such as low prevalence (subject to change).
    pub excluded_from_analysis: bool,
}

impl OtherInfoTypeSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::OtherInfoTypeSummary::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [estimated_prevalence][crate::model::OtherInfoTypeSummary::estimated_prevalence].
    pub fn set_estimated_prevalence<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.estimated_prevalence = v.into();
        self
    }

    /// Sets the value of [excluded_from_analysis][crate::model::OtherInfoTypeSummary::excluded_from_analysis].
    pub fn set_excluded_from_analysis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.excluded_from_analysis = v.into();
        self
    }
}

impl wkt::message::Message for OtherInfoTypeSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.OtherInfoTypeSummary"
    }
}

/// The profile for a scanned column within a table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ColumnDataProfile {
    /// The name of the profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Success or error status from the most recent profile generation attempt.
    /// May be empty if the profile is still being generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// State of a profile.
    pub state: crate::model::column_data_profile::State,

    /// The last time the profile was generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// The resource name of the table data profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_data_profile: std::string::String,

    /// The resource name of the resource this column is within.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_full_resource: std::string::String,

    /// The Google Cloud project ID that owns the profiled resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_project_id: std::string::String,

    /// If supported, the location where the dataset's data is stored.
    /// See <https://cloud.google.com/bigquery/docs/locations> for supported
    /// BigQuery locations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_location: std::string::String,

    /// The BigQuery dataset ID, if the resource profiled is a BigQuery table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// The table ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// The name of the column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub column: std::string::String,

    /// The sensitivity of this column.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level for this column.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// If it's been determined this column can be identified as a single type,
    /// this will be set. Otherwise the column either has unidentifiable content
    /// or mixed types.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub column_info_type: std::option::Option<crate::model::InfoTypeSummary>,

    /// Other types found within this column. List will be unordered.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub other_matches: std::vec::Vec<crate::model::OtherInfoTypeSummary>,

    /// Approximate percentage of entries being null in the column.
    pub estimated_null_percentage: crate::model::NullPercentageLevel,

    /// Approximate uniqueness of the column.
    pub estimated_uniqueness_score: crate::model::UniquenessScoreLevel,

    /// The likelihood that this column contains free-form text.
    /// A value close to 1 may indicate the column is likely to contain
    /// free-form or natural language text.
    /// Range in 0-1.
    pub free_text_score: f64,

    /// The data type of a given column.
    pub column_type: crate::model::column_data_profile::ColumnDataType,

    /// Indicates if a policy tag has been applied to the column.
    pub policy_state: crate::model::column_data_profile::ColumnPolicyState,
}

impl ColumnDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ColumnDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [profile_status][crate::model::ColumnDataProfile::profile_status].
    pub fn set_profile_status<
        T: std::convert::Into<std::option::Option<crate::model::ProfileStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_status = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ColumnDataProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::column_data_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::ColumnDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_last_generated = v.into();
        self
    }

    /// Sets the value of [table_data_profile][crate::model::ColumnDataProfile::table_data_profile].
    pub fn set_table_data_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.table_data_profile = v.into();
        self
    }

    /// Sets the value of [table_full_resource][crate::model::ColumnDataProfile::table_full_resource].
    pub fn set_table_full_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.table_full_resource = v.into();
        self
    }

    /// Sets the value of [dataset_project_id][crate::model::ColumnDataProfile::dataset_project_id].
    pub fn set_dataset_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_project_id = v.into();
        self
    }

    /// Sets the value of [dataset_location][crate::model::ColumnDataProfile::dataset_location].
    pub fn set_dataset_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_location = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ColumnDataProfile::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::ColumnDataProfile::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [column][crate::model::ColumnDataProfile::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::ColumnDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [data_risk_level][crate::model::ColumnDataProfile::data_risk_level].
    pub fn set_data_risk_level<
        T: std::convert::Into<std::option::Option<crate::model::DataRiskLevel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_risk_level = v.into();
        self
    }

    /// Sets the value of [column_info_type][crate::model::ColumnDataProfile::column_info_type].
    pub fn set_column_info_type<
        T: std::convert::Into<std::option::Option<crate::model::InfoTypeSummary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.column_info_type = v.into();
        self
    }

    /// Sets the value of [estimated_null_percentage][crate::model::ColumnDataProfile::estimated_null_percentage].
    pub fn set_estimated_null_percentage<
        T: std::convert::Into<crate::model::NullPercentageLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.estimated_null_percentage = v.into();
        self
    }

    /// Sets the value of [estimated_uniqueness_score][crate::model::ColumnDataProfile::estimated_uniqueness_score].
    pub fn set_estimated_uniqueness_score<
        T: std::convert::Into<crate::model::UniquenessScoreLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.estimated_uniqueness_score = v.into();
        self
    }

    /// Sets the value of [free_text_score][crate::model::ColumnDataProfile::free_text_score].
    pub fn set_free_text_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.free_text_score = v.into();
        self
    }

    /// Sets the value of [column_type][crate::model::ColumnDataProfile::column_type].
    pub fn set_column_type<
        T: std::convert::Into<crate::model::column_data_profile::ColumnDataType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.column_type = v.into();
        self
    }

    /// Sets the value of [policy_state][crate::model::ColumnDataProfile::policy_state].
    pub fn set_policy_state<
        T: std::convert::Into<crate::model::column_data_profile::ColumnPolicyState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy_state = v.into();
        self
    }

    /// Sets the value of [other_matches][crate::model::ColumnDataProfile::other_matches].
    pub fn set_other_matches<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OtherInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.other_matches = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ColumnDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ColumnDataProfile"
    }
}

/// Defines additional types related to ColumnDataProfile
pub mod column_data_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a profile. New items may be added.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Unused.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The profile is currently running. Once a profile has finished it will
        /// transition to DONE.
        pub const RUNNING: State = State::new(1);

        /// The profile is no longer generating.
        /// If profile_status.status.code is 0, the profile succeeded, otherwise, it
        /// failed.
        pub const DONE: State = State::new(2);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RUNNING"),
                2 => std::borrow::Cow::Borrowed("DONE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "DONE" => std::option::Option::Some(Self::DONE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Data types of the data in a column. Types may be added over time.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ColumnDataType(i32);

    impl ColumnDataType {
        /// Invalid type.
        pub const COLUMN_DATA_TYPE_UNSPECIFIED: ColumnDataType = ColumnDataType::new(0);

        /// Encoded as a string in decimal format.
        pub const TYPE_INT64: ColumnDataType = ColumnDataType::new(1);

        /// Encoded as a boolean "false" or "true".
        pub const TYPE_BOOL: ColumnDataType = ColumnDataType::new(2);

        /// Encoded as a number, or string "NaN", "Infinity" or "-Infinity".
        pub const TYPE_FLOAT64: ColumnDataType = ColumnDataType::new(3);

        /// Encoded as a string value.
        pub const TYPE_STRING: ColumnDataType = ColumnDataType::new(4);

        /// Encoded as a base64 string per RFC 4648, section 4.
        pub const TYPE_BYTES: ColumnDataType = ColumnDataType::new(5);

        /// Encoded as an RFC 3339 timestamp with mandatory "Z" time zone string:
        /// 1985-04-12T23:20:50.52Z
        pub const TYPE_TIMESTAMP: ColumnDataType = ColumnDataType::new(6);

        /// Encoded as RFC 3339 full-date format string: 1985-04-12
        pub const TYPE_DATE: ColumnDataType = ColumnDataType::new(7);

        /// Encoded as RFC 3339 partial-time format string: 23:20:50.52
        pub const TYPE_TIME: ColumnDataType = ColumnDataType::new(8);

        /// Encoded as RFC 3339 full-date "T" partial-time: 1985-04-12T23:20:50.52
        pub const TYPE_DATETIME: ColumnDataType = ColumnDataType::new(9);

        /// Encoded as WKT
        pub const TYPE_GEOGRAPHY: ColumnDataType = ColumnDataType::new(10);

        /// Encoded as a decimal string.
        pub const TYPE_NUMERIC: ColumnDataType = ColumnDataType::new(11);

        /// Container of ordered fields, each with a type and field name.
        pub const TYPE_RECORD: ColumnDataType = ColumnDataType::new(12);

        /// Decimal type.
        pub const TYPE_BIGNUMERIC: ColumnDataType = ColumnDataType::new(13);

        /// Json type.
        pub const TYPE_JSON: ColumnDataType = ColumnDataType::new(14);

        /// Interval type.
        pub const TYPE_INTERVAL: ColumnDataType = ColumnDataType::new(15);

        /// `Range<Date>` type.
        pub const TYPE_RANGE_DATE: ColumnDataType = ColumnDataType::new(16);

        /// `Range<Datetime>` type.
        pub const TYPE_RANGE_DATETIME: ColumnDataType = ColumnDataType::new(17);

        /// `Range<Timestamp>` type.
        pub const TYPE_RANGE_TIMESTAMP: ColumnDataType = ColumnDataType::new(18);

        /// Creates a new ColumnDataType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COLUMN_DATA_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("TYPE_INT64"),
                2 => std::borrow::Cow::Borrowed("TYPE_BOOL"),
                3 => std::borrow::Cow::Borrowed("TYPE_FLOAT64"),
                4 => std::borrow::Cow::Borrowed("TYPE_STRING"),
                5 => std::borrow::Cow::Borrowed("TYPE_BYTES"),
                6 => std::borrow::Cow::Borrowed("TYPE_TIMESTAMP"),
                7 => std::borrow::Cow::Borrowed("TYPE_DATE"),
                8 => std::borrow::Cow::Borrowed("TYPE_TIME"),
                9 => std::borrow::Cow::Borrowed("TYPE_DATETIME"),
                10 => std::borrow::Cow::Borrowed("TYPE_GEOGRAPHY"),
                11 => std::borrow::Cow::Borrowed("TYPE_NUMERIC"),
                12 => std::borrow::Cow::Borrowed("TYPE_RECORD"),
                13 => std::borrow::Cow::Borrowed("TYPE_BIGNUMERIC"),
                14 => std::borrow::Cow::Borrowed("TYPE_JSON"),
                15 => std::borrow::Cow::Borrowed("TYPE_INTERVAL"),
                16 => std::borrow::Cow::Borrowed("TYPE_RANGE_DATE"),
                17 => std::borrow::Cow::Borrowed("TYPE_RANGE_DATETIME"),
                18 => std::borrow::Cow::Borrowed("TYPE_RANGE_TIMESTAMP"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COLUMN_DATA_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::COLUMN_DATA_TYPE_UNSPECIFIED)
                }
                "TYPE_INT64" => std::option::Option::Some(Self::TYPE_INT64),
                "TYPE_BOOL" => std::option::Option::Some(Self::TYPE_BOOL),
                "TYPE_FLOAT64" => std::option::Option::Some(Self::TYPE_FLOAT64),
                "TYPE_STRING" => std::option::Option::Some(Self::TYPE_STRING),
                "TYPE_BYTES" => std::option::Option::Some(Self::TYPE_BYTES),
                "TYPE_TIMESTAMP" => std::option::Option::Some(Self::TYPE_TIMESTAMP),
                "TYPE_DATE" => std::option::Option::Some(Self::TYPE_DATE),
                "TYPE_TIME" => std::option::Option::Some(Self::TYPE_TIME),
                "TYPE_DATETIME" => std::option::Option::Some(Self::TYPE_DATETIME),
                "TYPE_GEOGRAPHY" => std::option::Option::Some(Self::TYPE_GEOGRAPHY),
                "TYPE_NUMERIC" => std::option::Option::Some(Self::TYPE_NUMERIC),
                "TYPE_RECORD" => std::option::Option::Some(Self::TYPE_RECORD),
                "TYPE_BIGNUMERIC" => std::option::Option::Some(Self::TYPE_BIGNUMERIC),
                "TYPE_JSON" => std::option::Option::Some(Self::TYPE_JSON),
                "TYPE_INTERVAL" => std::option::Option::Some(Self::TYPE_INTERVAL),
                "TYPE_RANGE_DATE" => std::option::Option::Some(Self::TYPE_RANGE_DATE),
                "TYPE_RANGE_DATETIME" => std::option::Option::Some(Self::TYPE_RANGE_DATETIME),
                "TYPE_RANGE_TIMESTAMP" => std::option::Option::Some(Self::TYPE_RANGE_TIMESTAMP),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ColumnDataType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ColumnDataType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The possible policy states for a column.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ColumnPolicyState(i32);

    impl ColumnPolicyState {
        /// No policy tags.
        pub const COLUMN_POLICY_STATE_UNSPECIFIED: ColumnPolicyState = ColumnPolicyState::new(0);

        /// Column has policy tag applied.
        pub const COLUMN_POLICY_TAGGED: ColumnPolicyState = ColumnPolicyState::new(1);

        /// Creates a new ColumnPolicyState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COLUMN_POLICY_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("COLUMN_POLICY_TAGGED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COLUMN_POLICY_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::COLUMN_POLICY_STATE_UNSPECIFIED)
                }
                "COLUMN_POLICY_TAGGED" => std::option::Option::Some(Self::COLUMN_POLICY_TAGGED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ColumnPolicyState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ColumnPolicyState {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The profile for a file store.
///
/// * Cloud Storage: maps 1:1 with a bucket.
/// * Amazon S3: maps 1:1 with a bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStoreDataProfile {
    /// The name of the profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The resource type that was profiled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_source_type: std::option::Option<crate::model::DataSourceType>,

    /// The resource name of the project data profile for this file store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_data_profile: std::string::String,

    /// The Google Cloud project ID that owns the resource.
    /// For Amazon S3 buckets, this is the AWS Account Id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The location of the file store.
    ///
    /// * Cloud Storage:
    ///   <https://cloud.google.com/storage/docs/locations#available-locations>
    /// * Amazon S3:
    ///   <https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_store_location: std::string::String,

    /// For resources that have multiple storage locations, these are those
    /// regions. For Cloud Storage this is the list of regions chosen for
    /// dual-region storage. `file_store_location` will normally be the
    /// corresponding multi-region for the list of individual locations. The first
    /// region is always picked as the processing and storage location for the data
    /// profile.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_storage_locations: std::vec::Vec<std::string::String>,

    /// The location type of the file store (region, dual-region, multi-region,
    /// etc). If dual-region, expect data_storage_locations to be populated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_type: std::string::String,

    /// The file store path.
    ///
    /// * Cloud Storage: `gs://{bucket}`
    /// * Amazon S3: `s3://{bucket}`
    /// * Vertex AI dataset:
    ///   `projects/{project_number}/locations/{location}/datasets/{dataset_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_store_path: std::string::String,

    /// The resource name of the resource profiled.
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    ///
    /// Example format of an S3 bucket full resource name:
    /// `//cloudasset.googleapis.com/organizations/{org_id}/otherCloudConnections/aws/arn:aws:s3:::{bucket_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_resource: std::string::String,

    /// The snapshot of the configurations used to generate the profile.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_snapshot: std::option::Option<crate::model::DataProfileConfigSnapshot>,

    /// Success or error status from the most recent profile generation attempt.
    /// May be empty if the profile is still being generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_status: std::option::Option<crate::model::ProfileStatus>,

    /// State of a profile.
    pub state: crate::model::file_store_data_profile::State,

    /// The last time the profile was generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile_last_generated: std::option::Option<wkt::Timestamp>,

    /// How broadly a resource has been shared.
    pub resource_visibility: crate::model::ResourceVisibility,

    /// The sensitivity score of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// The time the file store was first created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the file store was last modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_modified_time: std::option::Option<wkt::Timestamp>,

    /// FileClusterSummary per each cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_cluster_summaries: std::vec::Vec<crate::model::FileClusterSummary>,

    /// Attributes of the resource being profiled.
    /// Currently used attributes:
    ///
    /// * customer_managed_encryption: boolean
    ///   - true: the resource is encrypted with a customer-managed key.
    ///   - false: the resource is encrypted with a provider-managed key.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_attributes: std::collections::HashMap<std::string::String, crate::model::Value>,

    /// The labels applied to the resource at the time the profile was generated.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// InfoTypes detected in this file store.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_store_info_type_summaries: std::vec::Vec<crate::model::FileStoreInfoTypeSummary>,

    /// The file store does not have any files.
    pub file_store_is_empty: bool,

    /// Resources related to this profile.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_resources: std::vec::Vec<crate::model::RelatedResource>,
}

impl FileStoreDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FileStoreDataProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_source_type][crate::model::FileStoreDataProfile::data_source_type].
    pub fn set_data_source_type<
        T: std::convert::Into<std::option::Option<crate::model::DataSourceType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source_type = v.into();
        self
    }

    /// Sets the value of [project_data_profile][crate::model::FileStoreDataProfile::project_data_profile].
    pub fn set_project_data_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_data_profile = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::FileStoreDataProfile::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [file_store_location][crate::model::FileStoreDataProfile::file_store_location].
    pub fn set_file_store_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_store_location = v.into();
        self
    }

    /// Sets the value of [location_type][crate::model::FileStoreDataProfile::location_type].
    pub fn set_location_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_type = v.into();
        self
    }

    /// Sets the value of [file_store_path][crate::model::FileStoreDataProfile::file_store_path].
    pub fn set_file_store_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_store_path = v.into();
        self
    }

    /// Sets the value of [full_resource][crate::model::FileStoreDataProfile::full_resource].
    pub fn set_full_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_resource = v.into();
        self
    }

    /// Sets the value of [config_snapshot][crate::model::FileStoreDataProfile::config_snapshot].
    pub fn set_config_snapshot<
        T: std::convert::Into<std::option::Option<crate::model::DataProfileConfigSnapshot>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config_snapshot = v.into();
        self
    }

    /// Sets the value of [profile_status][crate::model::FileStoreDataProfile::profile_status].
    pub fn set_profile_status<
        T: std::convert::Into<std::option::Option<crate::model::ProfileStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_status = v.into();
        self
    }

    /// Sets the value of [state][crate::model::FileStoreDataProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::file_store_data_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [profile_last_generated][crate::model::FileStoreDataProfile::profile_last_generated].
    pub fn set_profile_last_generated<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile_last_generated = v.into();
        self
    }

    /// Sets the value of [resource_visibility][crate::model::FileStoreDataProfile::resource_visibility].
    pub fn set_resource_visibility<T: std::convert::Into<crate::model::ResourceVisibility>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_visibility = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::FileStoreDataProfile::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [data_risk_level][crate::model::FileStoreDataProfile::data_risk_level].
    pub fn set_data_risk_level<
        T: std::convert::Into<std::option::Option<crate::model::DataRiskLevel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_risk_level = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FileStoreDataProfile::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::FileStoreDataProfile::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [file_store_is_empty][crate::model::FileStoreDataProfile::file_store_is_empty].
    pub fn set_file_store_is_empty<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.file_store_is_empty = v.into();
        self
    }

    /// Sets the value of [data_storage_locations][crate::model::FileStoreDataProfile::data_storage_locations].
    pub fn set_data_storage_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_storage_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_cluster_summaries][crate::model::FileStoreDataProfile::file_cluster_summaries].
    pub fn set_file_cluster_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileClusterSummary>,
    {
        use std::iter::Iterator;
        self.file_cluster_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_store_info_type_summaries][crate::model::FileStoreDataProfile::file_store_info_type_summaries].
    pub fn set_file_store_info_type_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.file_store_info_type_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [related_resources][crate::model::FileStoreDataProfile::related_resources].
    pub fn set_related_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedResource>,
    {
        use std::iter::Iterator;
        self.related_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_attributes][crate::model::FileStoreDataProfile::resource_attributes].
    pub fn set_resource_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Value>,
    {
        use std::iter::Iterator;
        self.resource_attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [resource_labels][crate::model::FileStoreDataProfile::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for FileStoreDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreDataProfile"
    }
}

/// Defines additional types related to FileStoreDataProfile
pub mod file_store_data_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a profile. New items may be added.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Unused.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The profile is currently running. Once a profile has finished it will
        /// transition to DONE.
        pub const RUNNING: State = State::new(1);

        /// The profile is no longer generating.
        /// If profile_status.status.code is 0, the profile succeeded, otherwise, it
        /// failed.
        pub const DONE: State = State::new(2);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RUNNING"),
                2 => std::borrow::Cow::Borrowed("DONE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "DONE" => std::option::Option::Some(Self::DONE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A related resource.
/// Examples:
///
/// * The source BigQuery table for a Vertex AI dataset.
/// * The source Cloud Storage bucket for a Vertex AI dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RelatedResource {
    /// The full resource name of the related resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_resource: std::string::String,
}

impl RelatedResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [full_resource][crate::model::RelatedResource::full_resource].
    pub fn set_full_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_resource = v.into();
        self
    }
}

impl wkt::message::Message for RelatedResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RelatedResource"
    }
}

/// Information regarding the discovered InfoType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStoreInfoTypeSummary {
    /// The InfoType seen.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,
}

impl FileStoreInfoTypeSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::FileStoreInfoTypeSummary::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }
}

impl wkt::message::Message for FileStoreInfoTypeSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileStoreInfoTypeSummary"
    }
}

/// Information regarding the discovered file extension.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileExtensionInfo {
    /// The file extension if set. (aka .pdf, .jpg, .txt)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_extension: std::string::String,
}

impl FileExtensionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_extension][crate::model::FileExtensionInfo::file_extension].
    pub fn set_file_extension<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_extension = v.into();
        self
    }
}

impl wkt::message::Message for FileExtensionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileExtensionInfo"
    }
}

/// The file cluster summary.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileClusterSummary {
    /// The file cluster type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_cluster_type: std::option::Option<crate::model::FileClusterType>,

    /// InfoTypes detected in this cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_store_info_type_summaries: std::vec::Vec<crate::model::FileStoreInfoTypeSummary>,

    /// The sensitivity score of this cluster. The score will be SENSITIVITY_LOW
    /// if nothing has been scanned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// The data risk level of this cluster. RISK_LOW if nothing has been
    /// scanned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_risk_level: std::option::Option<crate::model::DataRiskLevel>,

    /// A list of errors detected while scanning this cluster. The list is
    /// truncated to 10 per cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// A sample of file types scanned in this cluster. Empty if no files were
    /// scanned. File extensions can be derived from the file name or the file
    /// content.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_extensions_scanned: std::vec::Vec<crate::model::FileExtensionInfo>,

    /// A sample of file types seen in this cluster. Empty if no files were seen.
    /// File extensions can be derived from the file name or the file content.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_extensions_seen: std::vec::Vec<crate::model::FileExtensionInfo>,

    /// True if no files exist in this cluster. If the file store had more files
    /// than could be listed, this will be false even if no files for this cluster
    /// were seen and file_extensions_seen is empty.
    pub no_files_exist: bool,
}

impl FileClusterSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_cluster_type][crate::model::FileClusterSummary::file_cluster_type].
    pub fn set_file_cluster_type<
        T: std::convert::Into<std::option::Option<crate::model::FileClusterType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_cluster_type = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::FileClusterSummary::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [data_risk_level][crate::model::FileClusterSummary::data_risk_level].
    pub fn set_data_risk_level<
        T: std::convert::Into<std::option::Option<crate::model::DataRiskLevel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_risk_level = v.into();
        self
    }

    /// Sets the value of [no_files_exist][crate::model::FileClusterSummary::no_files_exist].
    pub fn set_no_files_exist<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.no_files_exist = v.into();
        self
    }

    /// Sets the value of [file_store_info_type_summaries][crate::model::FileClusterSummary::file_store_info_type_summaries].
    pub fn set_file_store_info_type_summaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreInfoTypeSummary>,
    {
        use std::iter::Iterator;
        self.file_store_info_type_summaries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors][crate::model::FileClusterSummary::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_extensions_scanned][crate::model::FileClusterSummary::file_extensions_scanned].
    pub fn set_file_extensions_scanned<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileExtensionInfo>,
    {
        use std::iter::Iterator;
        self.file_extensions_scanned = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_extensions_seen][crate::model::FileClusterSummary::file_extensions_seen].
    pub fn set_file_extensions_seen<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileExtensionInfo>,
    {
        use std::iter::Iterator;
        self.file_extensions_seen = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileClusterSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileClusterSummary"
    }
}

/// Request to get a project data profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetProjectDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/projectDataProfiles/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetProjectDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProjectDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProjectDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetProjectDataProfileRequest"
    }
}

/// Request to get a file store data profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFileStoreDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/fileStoreDataProfiles/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetFileStoreDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFileStoreDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFileStoreDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetFileStoreDataProfileRequest"
    }
}

/// Request to list the file store profiles generated for a given organization or
/// project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFileStoreDataProfilesRequest {
    /// Required. Resource name of the organization or project, for
    /// example `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Page token to continue retrieval.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Size of the page. This value can be limited by the server. If
    /// zero, server returns a page of max size 100.
    pub page_size: i32,

    /// Optional. Comma-separated list of fields to order by, followed by `asc` or
    /// `desc` postfix. This list is case insensitive. The default sorting order is
    /// ascending. Redundant space characters are insignificant. Only one order
    /// field at a time is allowed.
    ///
    /// Examples:
    ///
    /// * `project_id asc`
    /// * `name`
    /// * `sensitivity_level desc`
    ///
    /// Supported fields are:
    ///
    /// - `project_id`: The Google Cloud project ID.
    /// - `sensitivity_level`: How sensitive the data in a table is, at most.
    /// - `data_risk_level`: How much risk is associated with this data.
    /// - `profile_last_generated`: When the profile was last updated in epoch
    ///   seconds.
    /// - `last_modified`: The last time the resource was modified.
    /// - `resource_visibility`: Visibility restriction for this resource.
    /// - `name`: The name of the profile.
    /// - `create_time`: The time the file store was first created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. Allows filtering.
    ///
    /// Supported syntax:
    ///
    /// * Filter expressions are made up of one or more restrictions.
    /// * Restrictions can be combined by `AND` or `OR` logical operators. A
    ///   sequence of restrictions implicitly uses `AND`.
    /// * A restriction has the form of `{field} {operator} {value}`.
    /// * Supported fields/values:
    ///   - `project_id` - The Google Cloud project ID.
    ///   - `account_id` - The AWS account ID.
    ///   - `file_store_path` - The path like "gs://bucket".
    ///   - `data_source_type` - The profile's data source type, like
    ///     "google/storage/bucket".
    ///   - `data_storage_location` - The location where the file store's data is
    ///     stored, like "us-central1".
    ///   - `sensitivity_level` - HIGH|MODERATE|LOW
    ///   - `data_risk_level` - HIGH|MODERATE|LOW
    ///   - `resource_visibility`: PUBLIC|RESTRICTED
    ///   - `status_code` - an RPC status code as defined in
    ///     <https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto>
    /// * The operator must be `=` or `!=`.
    ///
    /// Examples:
    ///
    /// * `project_id = 12345 AND status_code = 1`
    /// * `project_id = 12345 AND sensitivity_level = HIGH`
    /// * `project_id = 12345 AND resource_visibility = PUBLIC`
    /// * `file_store_path = "gs://mybucket"`
    ///
    /// The length of this field should be no more than 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListFileStoreDataProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFileStoreDataProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFileStoreDataProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFileStoreDataProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFileStoreDataProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFileStoreDataProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListFileStoreDataProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListFileStoreDataProfilesRequest"
    }
}

/// List of file store data profiles generated for a given organization or
/// project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFileStoreDataProfilesResponse {
    /// List of data profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_store_data_profiles: std::vec::Vec<crate::model::FileStoreDataProfile>,

    /// The next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListFileStoreDataProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFileStoreDataProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [file_store_data_profiles][crate::model::ListFileStoreDataProfilesResponse::file_store_data_profiles].
    pub fn set_file_store_data_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileStoreDataProfile>,
    {
        use std::iter::Iterator;
        self.file_store_data_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFileStoreDataProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListFileStoreDataProfilesResponse"
    }
}

impl gax::paginator::PageableResponse for ListFileStoreDataProfilesResponse {
    type PageItem = crate::model::FileStoreDataProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.file_store_data_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for DeleteFileStoreProfile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFileStoreDataProfileRequest {
    /// Required. Resource name of the file store data profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteFileStoreDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFileStoreDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFileStoreDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteFileStoreDataProfileRequest"
    }
}

/// Request to get a table data profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTableDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/tableDataProfiles/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetTableDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTableDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTableDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetTableDataProfileRequest"
    }
}

/// Request to get a column data profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetColumnDataProfileRequest {
    /// Required. Resource name, for example
    /// `organizations/12345/locations/us/columnDataProfiles/53234423`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetColumnDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetColumnDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetColumnDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetColumnDataProfileRequest"
    }
}

/// A condition for determining whether a Pub/Sub should be triggered.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfilePubSubCondition {
    /// An expression.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expressions:
        std::option::Option<crate::model::data_profile_pub_sub_condition::PubSubExpressions>,
}

impl DataProfilePubSubCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expressions][crate::model::DataProfilePubSubCondition::expressions].
    pub fn set_expressions<
        T: std::convert::Into<
            std::option::Option<crate::model::data_profile_pub_sub_condition::PubSubExpressions>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expressions = v.into();
        self
    }
}

impl wkt::message::Message for DataProfilePubSubCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubCondition"
    }
}

/// Defines additional types related to DataProfilePubSubCondition
pub mod data_profile_pub_sub_condition {
    #[allow(unused_imports)]
    use super::*;

    /// A condition consisting of a value.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PubSubCondition {
        /// The value for the condition to trigger.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<
            crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value,
        >,
    }

    impl PubSubCondition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `value`.
        pub fn set_value<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// if it holds a `MinimumRiskScore`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_minimum_risk_score(
            &self,
        ) -> std::option::Option<&crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>
        {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumRiskScore(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// if it holds a `MinimumSensitivityScore`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_minimum_sensitivity_score(
            &self,
        ) -> std::option::Option<&crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>
        {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumSensitivityScore(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// to hold a `MinimumRiskScore`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_minimum_risk_score<
            T: std::convert::Into<crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumRiskScore(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [value][crate::model::data_profile_pub_sub_condition::PubSubCondition::value]
        /// to hold a `MinimumSensitivityScore`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_minimum_sensitivity_score<
            T: std::convert::Into<crate::model::data_profile_pub_sub_condition::ProfileScoreBucket>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::data_profile_pub_sub_condition::pub_sub_condition::Value::MinimumSensitivityScore(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for PubSubCondition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubCondition.PubSubCondition"
        }
    }

    /// Defines additional types related to PubSubCondition
    pub mod pub_sub_condition {
        #[allow(unused_imports)]
        use super::*;

        /// The value for the condition to trigger.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// The minimum data risk score that triggers the condition.
            MinimumRiskScore(crate::model::data_profile_pub_sub_condition::ProfileScoreBucket),
            /// The minimum sensitivity level that triggers the condition.
            MinimumSensitivityScore(
                crate::model::data_profile_pub_sub_condition::ProfileScoreBucket,
            ),
        }
    }

    /// An expression, consisting of an operator and conditions.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PubSubExpressions {

        /// The operator to apply to the collection of conditions.
        pub logical_operator: crate::model::data_profile_pub_sub_condition::pub_sub_expressions::PubSubLogicalOperator,

        /// Conditions to apply to the expression.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub conditions: std::vec::Vec<crate::model::data_profile_pub_sub_condition::PubSubCondition>,
    }

    impl PubSubExpressions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [logical_operator][crate::model::data_profile_pub_sub_condition::PubSubExpressions::logical_operator].
        pub fn set_logical_operator<T: std::convert::Into<crate::model::data_profile_pub_sub_condition::pub_sub_expressions::PubSubLogicalOperator>>(mut self, v: T) -> Self{
            self.logical_operator = v.into();
            self
        }

        /// Sets the value of [conditions][crate::model::data_profile_pub_sub_condition::PubSubExpressions::conditions].
        pub fn set_conditions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::data_profile_pub_sub_condition::PubSubCondition>,
        {
            use std::iter::Iterator;
            self.conditions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PubSubExpressions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubCondition.PubSubExpressions"
        }
    }

    /// Defines additional types related to PubSubExpressions
    pub mod pub_sub_expressions {
        #[allow(unused_imports)]
        use super::*;

        /// Logical operators for conditional checks.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct PubSubLogicalOperator(i32);

        impl PubSubLogicalOperator {
            /// Unused.
            pub const LOGICAL_OPERATOR_UNSPECIFIED: PubSubLogicalOperator =
                PubSubLogicalOperator::new(0);

            /// Conditional OR.
            pub const OR: PubSubLogicalOperator = PubSubLogicalOperator::new(1);

            /// Conditional AND.
            pub const AND: PubSubLogicalOperator = PubSubLogicalOperator::new(2);

            /// Creates a new PubSubLogicalOperator instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("LOGICAL_OPERATOR_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("OR"),
                    2 => std::borrow::Cow::Borrowed("AND"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "LOGICAL_OPERATOR_UNSPECIFIED" => {
                        std::option::Option::Some(Self::LOGICAL_OPERATOR_UNSPECIFIED)
                    }
                    "OR" => std::option::Option::Some(Self::OR),
                    "AND" => std::option::Option::Some(Self::AND),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for PubSubLogicalOperator {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for PubSubLogicalOperator {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Various score levels for resources.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ProfileScoreBucket(i32);

    impl ProfileScoreBucket {
        /// Unused.
        pub const PROFILE_SCORE_BUCKET_UNSPECIFIED: ProfileScoreBucket = ProfileScoreBucket::new(0);

        /// High risk/sensitivity detected.
        pub const HIGH: ProfileScoreBucket = ProfileScoreBucket::new(1);

        /// Medium or high risk/sensitivity detected.
        pub const MEDIUM_OR_HIGH: ProfileScoreBucket = ProfileScoreBucket::new(2);

        /// Creates a new ProfileScoreBucket instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PROFILE_SCORE_BUCKET_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("HIGH"),
                2 => std::borrow::Cow::Borrowed("MEDIUM_OR_HIGH"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PROFILE_SCORE_BUCKET_UNSPECIFIED" => {
                    std::option::Option::Some(Self::PROFILE_SCORE_BUCKET_UNSPECIFIED)
                }
                "HIGH" => std::option::Option::Some(Self::HIGH),
                "MEDIUM_OR_HIGH" => std::option::Option::Some(Self::MEDIUM_OR_HIGH),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ProfileScoreBucket {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ProfileScoreBucket {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Pub/Sub topic message for a DataProfileAction.PubSubNotification event.
/// To receive a message of protocol buffer schema type, convert the message data
/// to an object of this proto class.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfilePubSubMessage {
    /// If `DetailLevel` is `TABLE_PROFILE` this will be fully populated.
    /// Otherwise, if `DetailLevel` is `RESOURCE_NAME`, then only `name` and
    /// `full_resource` will be populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile: std::option::Option<crate::model::TableDataProfile>,

    /// If `DetailLevel` is `FILE_STORE_PROFILE` this will be fully populated.
    /// Otherwise, if `DetailLevel` is `RESOURCE_NAME`, then only `name` and
    /// `file_store_path` will be populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_store_profile: std::option::Option<crate::model::FileStoreDataProfile>,

    /// The event that caused the Pub/Sub message to be sent.
    pub event: crate::model::data_profile_action::EventType,
}

impl DataProfilePubSubMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [profile][crate::model::DataProfilePubSubMessage::profile].
    pub fn set_profile<
        T: std::convert::Into<std::option::Option<crate::model::TableDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = v.into();
        self
    }

    /// Sets the value of [file_store_profile][crate::model::DataProfilePubSubMessage::file_store_profile].
    pub fn set_file_store_profile<
        T: std::convert::Into<std::option::Option<crate::model::FileStoreDataProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_store_profile = v.into();
        self
    }

    /// Sets the value of [event][crate::model::DataProfilePubSubMessage::event].
    pub fn set_event<T: std::convert::Into<crate::model::data_profile_action::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.event = v.into();
        self
    }
}

impl wkt::message::Message for DataProfilePubSubMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataProfilePubSubMessage"
    }
}

/// Request message for CreateConnection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectionRequest {
    /// Required. Parent resource name.
    ///
    /// The format of this value varies depending on the scope of the request
    /// (project or organization):
    ///
    /// + Projects scope:
    ///   `projects/{project_id}/locations/{location_id}`
    /// + Organizations scope:
    ///   `organizations/{org_id}/locations/{location_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The connection resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,
}

impl CreateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::option::Option<crate::model::Connection>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CreateConnectionRequest"
    }
}

/// Request message for GetConnection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectionRequest {
    /// Required. Resource name in the format:
    /// `projects/{project}/locations/{location}/connections/{connection}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.GetConnectionRequest"
    }
}

/// Request message for ListConnections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Resource name of the organization or project, for
    /// example, `organizations/433245324/locations/europe` or
    /// `projects/project-id/locations/asia`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Number of results per page, max 1000.
    pub page_size: i32,

    /// Optional. Page token from a previous page to return the next set of
    /// results. If set, all other request fields must match the original request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Supported field/value: `state` - MISSING|AVAILABLE|ERROR
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListConnectionsRequest"
    }
}

/// Request message for SearchConnections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchConnectionsRequest {
    /// Required. Resource name of the organization or project with a wildcard
    /// location, for example, `organizations/433245324/locations/-` or
    /// `projects/project-id/locations/-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Number of results per page, max 1000.
    pub page_size: i32,

    /// Optional. Page token from a previous page to return the next set of
    /// results. If set, all other request fields must match the original request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Supported field/value: - `state` - MISSING|AVAILABLE|ERROR
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl SearchConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for SearchConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SearchConnectionsRequest"
    }
}

/// Response message for ListConnections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// List of connections.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// Token to retrieve the next page of results. An empty value means there are
    /// no more results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ListConnectionsResponse"
    }
}

impl gax::paginator::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Response message for SearchConnections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchConnectionsResponse {
    /// List of connections that match the search query. Note that only a subset
    /// of the fields will be populated, and only "name" is guaranteed to be set.
    /// For full details of a Connection, call GetConnection with the name.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// Token to retrieve the next page of results. An empty value means there are
    /// no more results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl SearchConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [connections][crate::model::SearchConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SearchConnectionsResponse"
    }
}

impl gax::paginator::PageableResponse for SearchConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for UpdateConnection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectionRequest {
    /// Required. Resource name in the format:
    /// `projects/{project}/locations/{location}/connections/{connection}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The connection with new values for the relevant fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,

    /// Optional. Mask to control which fields get updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::option::Option<crate::model::Connection>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.UpdateConnectionRequest"
    }
}

/// Request message for DeleteConnection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectionRequest {
    /// Required. Resource name of the Connection to be deleted, in the format:
    /// `projects/{project}/locations/{location}/connections/{connection}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteConnectionRequest"
    }
}

/// A data connection to allow the DLP API to profile data in locations that
/// require additional configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Connection {
    /// Output only. Name of the connection:
    /// `projects/{project}/locations/{location}/connections/{name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The connection's state in its lifecycle.
    pub state: crate::model::ConnectionState,

    /// Output only. Set if status == ERROR, to provide additional details. Will
    /// store the last 10 errors sorted with the most recent first.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::Error>,

    /// Type of connection.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::connection::Properties>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Connection::state].
    pub fn set_state<T: std::convert::Into<crate::model::ConnectionState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::Connection::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Error>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `properties`.
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::connection::Properties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `CloudSql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_sql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::CloudSql(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `CloudSql`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_cloud_sql<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::CloudSql(v.into()));
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Connection"
    }
}

/// Defines additional types related to Connection
pub mod connection {
    #[allow(unused_imports)]
    use super::*;

    /// Type of connection.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Properties {
        /// Connect to a Cloud SQL instance.
        CloudSql(std::boxed::Box<crate::model::CloudSqlProperties>),
    }
}

/// A credential consisting of a username and password, where the password is
/// stored in a Secret Manager resource.
/// Note: Secret Manager [charges
/// apply](https://cloud.google.com/secret-manager/pricing).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretManagerCredential {
    /// Required. The username.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Required. The name of the Secret Manager resource that stores the password,
    /// in the form `projects/project-id/secrets/secret-name/versions/version`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password_secret_version_name: std::string::String,
}

impl SecretManagerCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::SecretManagerCredential::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password_secret_version_name][crate::model::SecretManagerCredential::password_secret_version_name].
    pub fn set_password_secret_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.password_secret_version_name = v.into();
        self
    }
}

impl wkt::message::Message for SecretManagerCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SecretManagerCredential"
    }
}

/// Use IAM authentication to connect. This requires the Cloud SQL IAM feature
/// to be enabled on the instance, which is not the default for Cloud SQL.
/// See <https://cloud.google.com/sql/docs/postgres/authentication> and
/// <https://cloud.google.com/sql/docs/mysql/authentication>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlIamCredential {}

impl CloudSqlIamCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CloudSqlIamCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudSqlIamCredential"
    }
}

/// Cloud SQL connection properties.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlProperties {
    /// Optional. Immutable. The Cloud SQL instance for which the connection is
    /// defined. Only one connection per instance is allowed. This can only be set
    /// at creation time, and cannot be updated.
    ///
    /// It is an error to use a connection_name from different project or region
    /// than the one that holds the connection.
    /// For example, a Connection resource for Cloud SQL connection_name
    /// `project-id:us-central1:sql-instance`
    /// must be created under the parent
    /// `projects/project-id/locations/us-central1`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_name: std::string::String,

    /// Required. The DLP API will limit its connections to max_connections.
    /// Must be 2 or greater.
    pub max_connections: i32,

    /// Required. The database engine used by the Cloud SQL instance that this
    /// connection configures.
    pub database_engine: crate::model::cloud_sql_properties::DatabaseEngine,

    /// How to authenticate to the instance.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub credential: std::option::Option<crate::model::cloud_sql_properties::Credential>,
}

impl CloudSqlProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_name][crate::model::CloudSqlProperties::connection_name].
    pub fn set_connection_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_name = v.into();
        self
    }

    /// Sets the value of [max_connections][crate::model::CloudSqlProperties::max_connections].
    pub fn set_max_connections<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_connections = v.into();
        self
    }

    /// Sets the value of [database_engine][crate::model::CloudSqlProperties::database_engine].
    pub fn set_database_engine<
        T: std::convert::Into<crate::model::cloud_sql_properties::DatabaseEngine>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_engine = v.into();
        self
    }

    /// Sets the value of `credential`.
    pub fn set_credential<
        T: std::convert::Into<std::option::Option<crate::model::cloud_sql_properties::Credential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credential = v.into();
        self
    }

    /// The value of [credential][crate::model::CloudSqlProperties::credential]
    /// if it holds a `UsernamePassword`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_username_password(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SecretManagerCredential>> {
        #[allow(unreachable_patterns)]
        self.credential.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_properties::Credential::UsernamePassword(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [credential][crate::model::CloudSqlProperties::credential]
    /// if it holds a `CloudSqlIam`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_sql_iam(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlIamCredential>> {
        #[allow(unreachable_patterns)]
        self.credential.as_ref().and_then(|v| match v {
            crate::model::cloud_sql_properties::Credential::CloudSqlIam(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credential][crate::model::CloudSqlProperties::credential]
    /// to hold a `UsernamePassword`.
    ///
    /// Note that all the setters affecting `credential` are
    /// mutually exclusive.
    pub fn set_username_password<
        T: std::convert::Into<std::boxed::Box<crate::model::SecretManagerCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credential = std::option::Option::Some(
            crate::model::cloud_sql_properties::Credential::UsernamePassword(v.into()),
        );
        self
    }

    /// Sets the value of [credential][crate::model::CloudSqlProperties::credential]
    /// to hold a `CloudSqlIam`.
    ///
    /// Note that all the setters affecting `credential` are
    /// mutually exclusive.
    pub fn set_cloud_sql_iam<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlIamCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credential = std::option::Option::Some(
            crate::model::cloud_sql_properties::Credential::CloudSqlIam(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudSqlProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudSqlProperties"
    }
}

/// Defines additional types related to CloudSqlProperties
pub mod cloud_sql_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Database engine of a Cloud SQL instance.
    /// New values may be added over time.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DatabaseEngine(i32);

    impl DatabaseEngine {
        /// An engine that is not currently supported by Sensitive Data Protection.
        pub const DATABASE_ENGINE_UNKNOWN: DatabaseEngine = DatabaseEngine::new(0);

        /// Cloud SQL for MySQL instance.
        pub const DATABASE_ENGINE_MYSQL: DatabaseEngine = DatabaseEngine::new(1);

        /// Cloud SQL for PostgreSQL instance.
        pub const DATABASE_ENGINE_POSTGRES: DatabaseEngine = DatabaseEngine::new(2);

        /// Creates a new DatabaseEngine instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DATABASE_ENGINE_UNKNOWN"),
                1 => std::borrow::Cow::Borrowed("DATABASE_ENGINE_MYSQL"),
                2 => std::borrow::Cow::Borrowed("DATABASE_ENGINE_POSTGRES"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DATABASE_ENGINE_UNKNOWN" => {
                    std::option::Option::Some(Self::DATABASE_ENGINE_UNKNOWN)
                }
                "DATABASE_ENGINE_MYSQL" => std::option::Option::Some(Self::DATABASE_ENGINE_MYSQL),
                "DATABASE_ENGINE_POSTGRES" => {
                    std::option::Option::Some(Self::DATABASE_ENGINE_POSTGRES)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DatabaseEngine {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DatabaseEngine {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// How to authenticate to the instance.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Credential {
        /// A username and password stored in Secret Manager.
        UsernamePassword(std::boxed::Box<crate::model::SecretManagerCredential>),
        /// Built-in IAM authentication (must be configured in Cloud SQL).
        CloudSqlIam(std::boxed::Box<crate::model::CloudSqlIamCredential>),
    }
}

/// Request message for DeleteTableProfile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTableDataProfileRequest {
    /// Required. Resource name of the table data profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTableDataProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTableDataProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTableDataProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DeleteTableDataProfileRequest"
    }
}

/// Message used to identify the type of resource being profiled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataSourceType {
    /// Output only. An identifying string to the type of resource being profiled.
    /// Current values:
    ///
    /// * google/bigquery/table
    /// * google/project
    /// * google/sql/table
    /// * google/gcs/bucket
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_source: std::string::String,
}

impl DataSourceType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_source][crate::model::DataSourceType::data_source].
    pub fn set_data_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source = v.into();
        self
    }
}

impl wkt::message::Message for DataSourceType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DataSourceType"
    }
}

/// Message used to identify file cluster type being profiled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileClusterType {
    /// File cluster type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub file_cluster_type: std::option::Option<crate::model::file_cluster_type::FileClusterType>,
}

impl FileClusterType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `file_cluster_type`.
    pub fn set_file_cluster_type<
        T: std::convert::Into<std::option::Option<crate::model::file_cluster_type::FileClusterType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_cluster_type = v.into();
        self
    }

    /// The value of [file_cluster_type][crate::model::FileClusterType::file_cluster_type]
    /// if it holds a `Cluster`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cluster(&self) -> std::option::Option<&crate::model::file_cluster_type::Cluster> {
        #[allow(unreachable_patterns)]
        self.file_cluster_type.as_ref().and_then(|v| match v {
            crate::model::file_cluster_type::FileClusterType::Cluster(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [file_cluster_type][crate::model::FileClusterType::file_cluster_type]
    /// to hold a `Cluster`.
    ///
    /// Note that all the setters affecting `file_cluster_type` are
    /// mutually exclusive.
    pub fn set_cluster<T: std::convert::Into<crate::model::file_cluster_type::Cluster>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_cluster_type = std::option::Option::Some(
            crate::model::file_cluster_type::FileClusterType::Cluster(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FileClusterType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FileClusterType"
    }
}

/// Defines additional types related to FileClusterType
pub mod file_cluster_type {
    #[allow(unused_imports)]
    use super::*;

    /// Cluster type. Each cluster corresponds to a set of file types.
    /// Over time, new types may be added and files may move between clusters.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Cluster(i32);

    impl Cluster {
        /// Unused.
        pub const CLUSTER_UNSPECIFIED: Cluster = Cluster::new(0);

        /// Unsupported files.
        pub const CLUSTER_UNKNOWN: Cluster = Cluster::new(1);

        /// Plain text.
        pub const CLUSTER_TEXT: Cluster = Cluster::new(2);

        /// Structured data like CSV, TSV etc.
        pub const CLUSTER_STRUCTURED_DATA: Cluster = Cluster::new(3);

        /// Source code.
        pub const CLUSTER_SOURCE_CODE: Cluster = Cluster::new(4);

        /// Rich document like docx, xlsx etc.
        pub const CLUSTER_RICH_DOCUMENT: Cluster = Cluster::new(5);

        /// Images like jpeg, bmp.
        pub const CLUSTER_IMAGE: Cluster = Cluster::new(6);

        /// Archives and containers like .zip, .tar etc.
        pub const CLUSTER_ARCHIVE: Cluster = Cluster::new(7);

        /// Multimedia like .mp4, .avi etc.
        pub const CLUSTER_MULTIMEDIA: Cluster = Cluster::new(8);

        /// Executable files like .exe, .class, .apk etc.
        pub const CLUSTER_EXECUTABLE: Cluster = Cluster::new(9);

        /// AI models like .tflite etc.
        pub const CLUSTER_AI_MODEL: Cluster = Cluster::new(10);

        /// Creates a new Cluster instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CLUSTER_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CLUSTER_UNKNOWN"),
                2 => std::borrow::Cow::Borrowed("CLUSTER_TEXT"),
                3 => std::borrow::Cow::Borrowed("CLUSTER_STRUCTURED_DATA"),
                4 => std::borrow::Cow::Borrowed("CLUSTER_SOURCE_CODE"),
                5 => std::borrow::Cow::Borrowed("CLUSTER_RICH_DOCUMENT"),
                6 => std::borrow::Cow::Borrowed("CLUSTER_IMAGE"),
                7 => std::borrow::Cow::Borrowed("CLUSTER_ARCHIVE"),
                8 => std::borrow::Cow::Borrowed("CLUSTER_MULTIMEDIA"),
                9 => std::borrow::Cow::Borrowed("CLUSTER_EXECUTABLE"),
                10 => std::borrow::Cow::Borrowed("CLUSTER_AI_MODEL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CLUSTER_UNSPECIFIED" => std::option::Option::Some(Self::CLUSTER_UNSPECIFIED),
                "CLUSTER_UNKNOWN" => std::option::Option::Some(Self::CLUSTER_UNKNOWN),
                "CLUSTER_TEXT" => std::option::Option::Some(Self::CLUSTER_TEXT),
                "CLUSTER_STRUCTURED_DATA" => {
                    std::option::Option::Some(Self::CLUSTER_STRUCTURED_DATA)
                }
                "CLUSTER_SOURCE_CODE" => std::option::Option::Some(Self::CLUSTER_SOURCE_CODE),
                "CLUSTER_RICH_DOCUMENT" => std::option::Option::Some(Self::CLUSTER_RICH_DOCUMENT),
                "CLUSTER_IMAGE" => std::option::Option::Some(Self::CLUSTER_IMAGE),
                "CLUSTER_ARCHIVE" => std::option::Option::Some(Self::CLUSTER_ARCHIVE),
                "CLUSTER_MULTIMEDIA" => std::option::Option::Some(Self::CLUSTER_MULTIMEDIA),
                "CLUSTER_EXECUTABLE" => std::option::Option::Some(Self::CLUSTER_EXECUTABLE),
                "CLUSTER_AI_MODEL" => std::option::Option::Some(Self::CLUSTER_AI_MODEL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Cluster {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Cluster {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// File cluster type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FileClusterType {
        /// Cluster type.
        Cluster(crate::model::file_cluster_type::Cluster),
    }
}

/// Configure processing location for discovery and inspection. For example,
/// image OCR is only provided in limited regions but configuring
/// ProcessingLocation will redirect OCR to a location where OCR is provided.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProcessingLocation {
    /// Image processing will fall back using this configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub image_fallback_location:
        std::option::Option<crate::model::processing_location::ImageFallbackLocation>,
}

impl ProcessingLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_fallback_location][crate::model::ProcessingLocation::image_fallback_location].
    pub fn set_image_fallback_location<
        T: std::convert::Into<
            std::option::Option<crate::model::processing_location::ImageFallbackLocation>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.image_fallback_location = v.into();
        self
    }
}

impl wkt::message::Message for ProcessingLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation"
    }
}

/// Defines additional types related to ProcessingLocation
pub mod processing_location {
    #[allow(unused_imports)]
    use super::*;

    /// Processing will happen in a multi-region that contains the current region
    /// if available.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MultiRegionProcessing {}

    impl MultiRegionProcessing {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for MultiRegionProcessing {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation.MultiRegionProcessing"
        }
    }

    /// Processing will happen in the global region.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GlobalProcessing {}

    impl GlobalProcessing {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for GlobalProcessing {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation.GlobalProcessing"
        }
    }

    /// Configure image processing to fall back to the configured processing option
    /// below if unavailable in the request location.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImageFallbackLocation {
        /// Processing will happen in a multi-region that contains the current region
        /// if available.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub multi_region_processing:
            std::option::Option<crate::model::processing_location::MultiRegionProcessing>,

        /// Processing will happen in the global region.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub global_processing:
            std::option::Option<crate::model::processing_location::GlobalProcessing>,
    }

    impl ImageFallbackLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [multi_region_processing][crate::model::processing_location::ImageFallbackLocation::multi_region_processing].
        pub fn set_multi_region_processing<
            T: std::convert::Into<
                std::option::Option<crate::model::processing_location::MultiRegionProcessing>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.multi_region_processing = v.into();
            self
        }

        /// Sets the value of [global_processing][crate::model::processing_location::ImageFallbackLocation::global_processing].
        pub fn set_global_processing<
            T: std::convert::Into<
                std::option::Option<crate::model::processing_location::GlobalProcessing>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.global_processing = v.into();
            self
        }
    }

    impl wkt::message::Message for ImageFallbackLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.ProcessingLocation.ImageFallbackLocation"
        }
    }
}

/// Type of information detected by the API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InfoType {
    /// Name of the information type. Either a name of your choosing when
    /// creating a CustomInfoType, or one of the names listed
    /// at
    /// <https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference>
    /// when specifying a built-in type.  When sending Cloud DLP results to Data
    /// Catalog, infoType names should conform to the pattern
    /// `[A-Za-z0-9$_-]{1,64}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional version name for this InfoType.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Optional custom sensitivity for this InfoType.
    /// This only applies to data profiling.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,
}

impl InfoType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InfoType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::InfoType::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::InfoType::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }
}

impl wkt::message::Message for InfoType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.InfoType"
    }
}

/// Score is calculated from of all elements in the data profile.
/// A higher level means the data is more sensitive.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SensitivityScore {
    /// The sensitivity score applied to the resource.
    pub score: crate::model::sensitivity_score::SensitivityScoreLevel,
}

impl SensitivityScore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SensitivityScore::score].
    pub fn set_score<
        T: std::convert::Into<crate::model::sensitivity_score::SensitivityScoreLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for SensitivityScore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.SensitivityScore"
    }
}

/// Defines additional types related to SensitivityScore
pub mod sensitivity_score {
    #[allow(unused_imports)]
    use super::*;

    /// Various sensitivity score levels for resources.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SensitivityScoreLevel(i32);

    impl SensitivityScoreLevel {
        /// Unused.
        pub const SENSITIVITY_SCORE_UNSPECIFIED: SensitivityScoreLevel =
            SensitivityScoreLevel::new(0);

        /// No sensitive information detected. The resource isn't publicly
        /// accessible.
        pub const SENSITIVITY_LOW: SensitivityScoreLevel = SensitivityScoreLevel::new(10);

        /// Unable to determine sensitivity.
        pub const SENSITIVITY_UNKNOWN: SensitivityScoreLevel = SensitivityScoreLevel::new(12);

        /// Medium risk. Contains personally identifiable information (PII),
        /// potentially sensitive data, or fields with free-text data that are at a
        /// higher risk of having intermittent sensitive data. Consider limiting
        /// access.
        pub const SENSITIVITY_MODERATE: SensitivityScoreLevel = SensitivityScoreLevel::new(20);

        /// High risk. Sensitive personally identifiable information (SPII) can be
        /// present. Exfiltration of data can lead to user data loss.
        /// Re-identification of users might be possible. Consider limiting usage and
        /// or removing SPII.
        pub const SENSITIVITY_HIGH: SensitivityScoreLevel = SensitivityScoreLevel::new(30);

        /// Creates a new SensitivityScoreLevel instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SENSITIVITY_SCORE_UNSPECIFIED"),
                10 => std::borrow::Cow::Borrowed("SENSITIVITY_LOW"),
                12 => std::borrow::Cow::Borrowed("SENSITIVITY_UNKNOWN"),
                20 => std::borrow::Cow::Borrowed("SENSITIVITY_MODERATE"),
                30 => std::borrow::Cow::Borrowed("SENSITIVITY_HIGH"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SENSITIVITY_SCORE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SENSITIVITY_SCORE_UNSPECIFIED)
                }
                "SENSITIVITY_LOW" => std::option::Option::Some(Self::SENSITIVITY_LOW),
                "SENSITIVITY_UNKNOWN" => std::option::Option::Some(Self::SENSITIVITY_UNKNOWN),
                "SENSITIVITY_MODERATE" => std::option::Option::Some(Self::SENSITIVITY_MODERATE),
                "SENSITIVITY_HIGH" => std::option::Option::Some(Self::SENSITIVITY_HIGH),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SensitivityScoreLevel {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SensitivityScoreLevel {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A reference to a StoredInfoType to use with scanning.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredType {
    /// Resource name of the requested `StoredInfoType`, for example
    /// `organizations/433245324/storedInfoTypes/432452342` or
    /// `projects/project-id/storedInfoTypes/432452342`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Timestamp indicating when the version of the `StoredInfoType` used for
    /// inspection was created. Output-only field, populated by the system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,
}

impl StoredType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StoredType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::StoredType::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }
}

impl wkt::message::Message for StoredType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StoredType"
    }
}

/// Custom information type provided by the user. Used to find domain-specific
/// sensitive information configurable to the data in question.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomInfoType {
    /// CustomInfoType can either be a new infoType, or an extension of built-in
    /// infoType, when the name matches one of existing infoTypes and that infoType
    /// is specified in `InspectContent.info_types` field. Specifying the latter
    /// adds findings to the one detected by the system. If built-in info type is
    /// not specified in `InspectContent.info_types` list then the name is treated
    /// as a custom info type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info_type: std::option::Option<crate::model::InfoType>,

    /// Likelihood to return for this CustomInfoType. This base value can be
    /// altered by a detection rule if the finding meets the criteria specified by
    /// the rule. Defaults to `VERY_LIKELY` if not specified.
    pub likelihood: crate::model::Likelihood,

    /// Set of detection rules to apply to all findings of this CustomInfoType.
    /// Rules are applied in order that they are specified. Not supported for the
    /// `surrogate_type` CustomInfoType.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub detection_rules: std::vec::Vec<crate::model::custom_info_type::DetectionRule>,

    /// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding
    /// to be returned. It still can be used for rules matching.
    pub exclusion_type: crate::model::custom_info_type::ExclusionType,

    /// Sensitivity for this CustomInfoType. If this CustomInfoType extends an
    /// existing InfoType, the sensitivity here will take precedence over that of
    /// the original InfoType. If unset for a CustomInfoType, it will default to
    /// HIGH.
    /// This only applies to data profiling.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sensitivity_score: std::option::Option<crate::model::SensitivityScore>,

    /// Type of custom detector.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::custom_info_type::Type>,
}

impl CustomInfoType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [info_type][crate::model::CustomInfoType::info_type].
    pub fn set_info_type<T: std::convert::Into<std::option::Option<crate::model::InfoType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [likelihood][crate::model::CustomInfoType::likelihood].
    pub fn set_likelihood<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.likelihood = v.into();
        self
    }

    /// Sets the value of [exclusion_type][crate::model::CustomInfoType::exclusion_type].
    pub fn set_exclusion_type<
        T: std::convert::Into<crate::model::custom_info_type::ExclusionType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.exclusion_type = v.into();
        self
    }

    /// Sets the value of [sensitivity_score][crate::model::CustomInfoType::sensitivity_score].
    pub fn set_sensitivity_score<
        T: std::convert::Into<std::option::Option<crate::model::SensitivityScore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sensitivity_score = v.into();
        self
    }

    /// Sets the value of [detection_rules][crate::model::CustomInfoType::detection_rules].
    pub fn set_detection_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::custom_info_type::DetectionRule>,
    {
        use std::iter::Iterator;
        self.detection_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `r#type`.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::custom_info_type::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `Dictionary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_dictionary(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Dictionary>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::Dictionary(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `Regex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_regex(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::Regex>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::Regex(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `SurrogateType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_surrogate_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::custom_info_type::SurrogateType>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::SurrogateType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::CustomInfoType::r#type]
    /// if it holds a `StoredType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_stored_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StoredType>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::custom_info_type::Type::StoredType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `Dictionary`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_dictionary<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Dictionary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::custom_info_type::Type::Dictionary(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `Regex`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_regex<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::Regex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::custom_info_type::Type::Regex(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `SurrogateType`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_surrogate_type<
        T: std::convert::Into<std::boxed::Box<crate::model::custom_info_type::SurrogateType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::custom_info_type::Type::SurrogateType(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::CustomInfoType::r#type]
    /// to hold a `StoredType`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_stored_type<T: std::convert::Into<std::boxed::Box<crate::model::StoredType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::custom_info_type::Type::StoredType(v.into()));
        self
    }
}

impl wkt::message::Message for CustomInfoType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType"
    }
}

/// Defines additional types related to CustomInfoType
pub mod custom_info_type {
    #[allow(unused_imports)]
    use super::*;

    /// Custom information type based on a dictionary of words or phrases. This can
    /// be used to match sensitive information specific to the data, such as a list
    /// of employee IDs or job titles.
    ///
    /// Dictionary words are case-insensitive and all characters other than letters
    /// and digits in the unicode [Basic Multilingual
    /// Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane)
    /// will be replaced with whitespace when scanning for matches, so the
    /// dictionary phrase "Sam Johnson" will match all three phrases "sam johnson",
    /// "Sam, Johnson", and "Sam (Johnson)". Additionally, the characters
    /// surrounding any match must be of a different type than the adjacent
    /// characters within the word, so letters must be next to non-letters and
    /// digits next to non-digits. For example, the dictionary word "jen" will
    /// match the first three letters of the text "jen123" but will return no
    /// matches for "jennifer".
    ///
    /// Dictionary words containing a large number of characters that are not
    /// letters or digits may result in unexpected findings because such characters
    /// are treated as whitespace. The
    /// [limits](https://cloud.google.com/sensitive-data-protection/limits) page
    /// contains details about the size limits of dictionaries. For dictionaries
    /// that do not fit within these constraints, consider using
    /// `LargeCustomDictionaryConfig` in the `StoredInfoType` API.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Dictionary {
        /// The potential places the data can be read from.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub source: std::option::Option<crate::model::custom_info_type::dictionary::Source>,
    }

    impl Dictionary {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `source`.
        pub fn set_source<
            T: std::convert::Into<
                std::option::Option<crate::model::custom_info_type::dictionary::Source>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::custom_info_type::Dictionary::source]
        /// if it holds a `WordList`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_word_list(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>,
        > {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::custom_info_type::dictionary::Source::WordList(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [source][crate::model::custom_info_type::Dictionary::source]
        /// if it holds a `CloudStoragePath`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_cloud_storage_path(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStoragePath>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::custom_info_type::dictionary::Source::CloudStoragePath(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::custom_info_type::Dictionary::source]
        /// to hold a `WordList`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_word_list<
            T: std::convert::Into<
                std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::custom_info_type::dictionary::Source::WordList(v.into()),
            );
            self
        }

        /// Sets the value of [source][crate::model::custom_info_type::Dictionary::source]
        /// to hold a `CloudStoragePath`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_cloud_storage_path<
            T: std::convert::Into<std::boxed::Box<crate::model::CloudStoragePath>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::custom_info_type::dictionary::Source::CloudStoragePath(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Dictionary {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.Dictionary"
        }
    }

    /// Defines additional types related to Dictionary
    pub mod dictionary {
        #[allow(unused_imports)]
        use super::*;

        /// Message defining a list of words or phrases to search for in the data.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct WordList {
            /// Words or phrases defining the dictionary. The dictionary must contain
            /// at least one phrase and every phrase must contain at least 2 characters
            /// that are letters or digits. [required]
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub words: std::vec::Vec<std::string::String>,
        }

        impl WordList {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [words][crate::model::custom_info_type::dictionary::WordList::words].
            pub fn set_words<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.words = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for WordList {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList"
            }
        }

        /// The potential places the data can be read from.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Source {
            /// List of words or phrases to search for.
            WordList(std::boxed::Box<crate::model::custom_info_type::dictionary::WordList>),
            /// Newline-delimited file of words in Cloud Storage. Only a single file
            /// is accepted.
            CloudStoragePath(std::boxed::Box<crate::model::CloudStoragePath>),
        }
    }

    /// Message defining a custom regular expression.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Regex {
        /// Pattern defining the regular expression. Its syntax
        /// (<https://github.com/google/re2/wiki/Syntax>) can be found under the
        /// google/re2 repository on GitHub.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pattern: std::string::String,

        /// The index of the submatch to extract as findings. When not
        /// specified, the entire match is returned. No more than 3 may be included.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub group_indexes: std::vec::Vec<i32>,
    }

    impl Regex {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pattern][crate::model::custom_info_type::Regex::pattern].
        pub fn set_pattern<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.pattern = v.into();
            self
        }

        /// Sets the value of [group_indexes][crate::model::custom_info_type::Regex::group_indexes].
        pub fn set_group_indexes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i32>,
        {
            use std::iter::Iterator;
            self.group_indexes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Regex {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.Regex"
        }
    }

    /// Message for detecting output from deidentification transformations
    /// such as
    /// [`CryptoReplaceFfxFpeConfig`](https://cloud.google.com/sensitive-data-protection/docs/reference/rest/v2/organizations.deidentifyTemplates#cryptoreplaceffxfpeconfig).
    /// These types of transformations are
    /// those that perform pseudonymization, thereby producing a "surrogate" as
    /// output. This should be used in conjunction with a field on the
    /// transformation such as `surrogate_info_type`. This CustomInfoType does
    /// not support the use of `detection_rules`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SurrogateType {}

    impl SurrogateType {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for SurrogateType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.SurrogateType"
        }
    }

    /// Deprecated; use `InspectionRuleSet` instead. Rule for modifying a
    /// `CustomInfoType` to alter behavior under certain circumstances, depending
    /// on the specific details of the rule. Not supported for the `surrogate_type`
    /// custom infoType.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DetectionRule {
        /// Type of hotword rule.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub r#type: std::option::Option<crate::model::custom_info_type::detection_rule::Type>,
    }

    impl DetectionRule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `r#type`.
        pub fn set_type<
            T: std::convert::Into<
                std::option::Option<crate::model::custom_info_type::detection_rule::Type>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// The value of [r#type][crate::model::custom_info_type::DetectionRule::r#type]
        /// if it holds a `HotwordRule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_hotword_rule(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
        > {
            #[allow(unreachable_patterns)]
            self.r#type.as_ref().and_then(|v| match v {
                crate::model::custom_info_type::detection_rule::Type::HotwordRule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#type][crate::model::custom_info_type::DetectionRule::r#type]
        /// to hold a `HotwordRule`.
        ///
        /// Note that all the setters affecting `r#type` are
        /// mutually exclusive.
        pub fn set_hotword_rule<
            T: std::convert::Into<
                std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = std::option::Option::Some(
                crate::model::custom_info_type::detection_rule::Type::HotwordRule(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for DetectionRule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule"
        }
    }

    /// Defines additional types related to DetectionRule
    pub mod detection_rule {
        #[allow(unused_imports)]
        use super::*;

        /// Message for specifying a window around a finding to apply a detection
        /// rule.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Proximity {
            /// Number of characters before the finding to consider. For tabular data,
            /// if you want to modify the likelihood of an entire column of findngs,
            /// set this to 1. For more information, see
            /// [Hotword example: Set the match likelihood of a table column]
            /// (<https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes-likelihood#match-column-values>).
            pub window_before: i32,

            /// Number of characters after the finding to consider.
            pub window_after: i32,
        }

        impl Proximity {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [window_before][crate::model::custom_info_type::detection_rule::Proximity::window_before].
            pub fn set_window_before<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.window_before = v.into();
                self
            }

            /// Sets the value of [window_after][crate::model::custom_info_type::detection_rule::Proximity::window_after].
            pub fn set_window_after<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.window_after = v.into();
                self
            }
        }

        impl wkt::message::Message for Proximity {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity"
            }
        }

        /// Message for specifying an adjustment to the likelihood of a finding as
        /// part of a detection rule.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct LikelihoodAdjustment {
            /// How the likelihood will be modified.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub adjustment: std::option::Option<
                crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment,
            >,
        }

        impl LikelihoodAdjustment {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of `adjustment`.
            pub fn set_adjustment<T: std::convert::Into<std::option::Option<crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment>>>(mut self, v: T) -> Self
            {
                self.adjustment = v.into();
                self
            }

            /// The value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// if it holds a `FixedLikelihood`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_fixed_likelihood(&self) -> std::option::Option<&crate::model::Likelihood> {
                #[allow(unreachable_patterns)]
                self.adjustment.as_ref().and_then(|v| match v {
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::FixedLikelihood(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// if it holds a `RelativeLikelihood`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_relative_likelihood(&self) -> std::option::Option<&i32> {
                #[allow(unreachable_patterns)]
                self.adjustment.as_ref().and_then(|v| match v {
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::RelativeLikelihood(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// to hold a `FixedLikelihood`.
            ///
            /// Note that all the setters affecting `adjustment` are
            /// mutually exclusive.
            pub fn set_fixed_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
                mut self,
                v: T,
            ) -> Self {
                self.adjustment = std::option::Option::Some(
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::FixedLikelihood(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [adjustment][crate::model::custom_info_type::detection_rule::LikelihoodAdjustment::adjustment]
            /// to hold a `RelativeLikelihood`.
            ///
            /// Note that all the setters affecting `adjustment` are
            /// mutually exclusive.
            pub fn set_relative_likelihood<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.adjustment = std::option::Option::Some(
                    crate::model::custom_info_type::detection_rule::likelihood_adjustment::Adjustment::RelativeLikelihood(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for LikelihoodAdjustment {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment"
            }
        }

        /// Defines additional types related to LikelihoodAdjustment
        pub mod likelihood_adjustment {
            #[allow(unused_imports)]
            use super::*;

            /// How the likelihood will be modified.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Adjustment {
                /// Set the likelihood of a finding to a fixed value.
                FixedLikelihood(crate::model::Likelihood),
                /// Increase or decrease the likelihood by the specified number of
                /// levels. For example, if a finding would be `POSSIBLE` without the
                /// detection rule and `relative_likelihood` is 1, then it is upgraded to
                /// `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`.
                /// Likelihood may never drop below `VERY_UNLIKELY` or exceed
                /// `VERY_LIKELY`, so applying an adjustment of 1 followed by an
                /// adjustment of -1 when base likelihood is `VERY_LIKELY` will result in
                /// a final likelihood of `LIKELY`.
                RelativeLikelihood(i32),
            }
        }

        /// The rule that adjusts the likelihood of findings within a certain
        /// proximity of hotwords.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct HotwordRule {
            /// Regular expression pattern defining what qualifies as a hotword.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub hotword_regex: std::option::Option<crate::model::custom_info_type::Regex>,

            /// Range of characters within which the entire hotword must reside.
            /// The total length of the window cannot exceed 1000 characters.
            /// The finding itself will be included in the window, so that hotwords can
            /// be used to match substrings of the finding itself. Suppose you
            /// want Cloud DLP to promote the likelihood of the phone number
            /// regex "\(\d{3}\) \d{3}-\d{4}" if the area code is known to be the
            /// area code of a company's office. In this case, use the hotword regex
            /// "\(xxx\)", where "xxx" is the area code in question.
            ///
            /// For tabular data, if you want to modify the likelihood of an entire
            /// column of findngs, see
            /// [Hotword example: Set the match likelihood of a table column]
            /// (<https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes-likelihood#match-column-values>).
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub proximity:
                std::option::Option<crate::model::custom_info_type::detection_rule::Proximity>,

            /// Likelihood adjustment to apply to all matching findings.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub likelihood_adjustment: std::option::Option<
                crate::model::custom_info_type::detection_rule::LikelihoodAdjustment,
            >,
        }

        impl HotwordRule {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [hotword_regex][crate::model::custom_info_type::detection_rule::HotwordRule::hotword_regex].
            pub fn set_hotword_regex<
                T: std::convert::Into<std::option::Option<crate::model::custom_info_type::Regex>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.hotword_regex = v.into();
                self
            }

            /// Sets the value of [proximity][crate::model::custom_info_type::detection_rule::HotwordRule::proximity].
            pub fn set_proximity<
                T: std::convert::Into<
                    std::option::Option<crate::model::custom_info_type::detection_rule::Proximity>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.proximity = v.into();
                self
            }

            /// Sets the value of [likelihood_adjustment][crate::model::custom_info_type::detection_rule::HotwordRule::likelihood_adjustment].
            pub fn set_likelihood_adjustment<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::custom_info_type::detection_rule::LikelihoodAdjustment,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.likelihood_adjustment = v.into();
                self
            }
        }

        impl wkt::message::Message for HotwordRule {
            fn typename() -> &'static str {
                "type.googleapis.com/google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule"
            }
        }

        /// Type of hotword rule.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Type {
            /// Hotword-based detection rule.
            HotwordRule(
                std::boxed::Box<crate::model::custom_info_type::detection_rule::HotwordRule>,
            ),
        }
    }

    /// Type of exclusion rule.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ExclusionType(i32);

    impl ExclusionType {
        /// A finding of this custom info type will not be excluded from results.
        pub const EXCLUSION_TYPE_UNSPECIFIED: ExclusionType = ExclusionType::new(0);

        /// A finding of this custom info type will be excluded from final results,
        /// but can still affect rule execution.
        pub const EXCLUSION_TYPE_EXCLUDE: ExclusionType = ExclusionType::new(1);

        /// Creates a new ExclusionType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EXCLUSION_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("EXCLUSION_TYPE_EXCLUDE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EXCLUSION_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::EXCLUSION_TYPE_UNSPECIFIED)
                }
                "EXCLUSION_TYPE_EXCLUDE" => std::option::Option::Some(Self::EXCLUSION_TYPE_EXCLUDE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ExclusionType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ExclusionType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of custom detector.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// A list of phrases to detect as a CustomInfoType.
        Dictionary(std::boxed::Box<crate::model::custom_info_type::Dictionary>),
        /// Regular expression based CustomInfoType.
        Regex(std::boxed::Box<crate::model::custom_info_type::Regex>),
        /// Message for detecting output from deidentification transformations that
        /// support reversing.
        SurrogateType(std::boxed::Box<crate::model::custom_info_type::SurrogateType>),
        /// Load an existing `StoredInfoType` resource for use in
        /// `InspectDataSource`. Not currently supported in `InspectContent`.
        StoredType(std::boxed::Box<crate::model::StoredType>),
    }
}

/// General identifier of a data field in a storage service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FieldId {
    /// Name describing the field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl FieldId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FieldId::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for FieldId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.FieldId"
    }
}

/// Datastore partition ID.
/// A partition ID identifies a grouping of entities. The grouping is always
/// by project and namespace, however the namespace ID may be empty.
///
/// A partition ID contains several dimensions:
/// project ID and namespace ID.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PartitionId {
    /// The ID of the project to which the entities belong.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// If not empty, the ID of the namespace to which the entities belong.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub namespace_id: std::string::String,
}

impl PartitionId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PartitionId::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [namespace_id][crate::model::PartitionId::namespace_id].
    pub fn set_namespace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace_id = v.into();
        self
    }
}

impl wkt::message::Message for PartitionId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.PartitionId"
    }
}

/// A representation of a Datastore kind.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KindExpression {
    /// The name of the kind.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl KindExpression {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KindExpression::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for KindExpression {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.KindExpression"
    }
}

/// Options defining a data set within Google Cloud Datastore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatastoreOptions {
    /// A partition ID identifies a grouping of entities. The grouping is always
    /// by project and namespace, however the namespace ID may be empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub partition_id: std::option::Option<crate::model::PartitionId>,

    /// The kind to process.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kind: std::option::Option<crate::model::KindExpression>,
}

impl DatastoreOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partition_id][crate::model::DatastoreOptions::partition_id].
    pub fn set_partition_id<
        T: std::convert::Into<std::option::Option<crate::model::PartitionId>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partition_id = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::DatastoreOptions::kind].
    pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::KindExpression>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for DatastoreOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatastoreOptions"
    }
}

/// Message representing a set of files in a Cloud Storage bucket. Regular
/// expressions are used to allow fine-grained control over which files in the
/// bucket to include.
///
/// Included files are those that match at least one item in `include_regex` and
/// do not match any items in `exclude_regex`. Note that a file that matches
/// items from both lists will _not_ be included. For a match to occur, the
/// entire file path (i.e., everything in the url after the bucket name) must
/// match the regular expression.
///
/// For example, given the input `{bucket_name: "mybucket", include_regex:
/// ["directory1/.*"], exclude_regex:
/// ["directory1/excluded.*"]}`:
///
/// * `gs://mybucket/directory1/myfile` will be included
/// * `gs://mybucket/directory1/directory2/myfile` will be included (`.*` matches
///   across `/`)
/// * `gs://mybucket/directory0/directory1/myfile` will _not_ be included (the
///   full path doesn't match any items in `include_regex`)
/// * `gs://mybucket/directory1/excludedfile` will _not_ be included (the path
///   matches an item in `exclude_regex`)
///
/// If `include_regex` is left empty, it will match all files by default
/// (this is equivalent to setting `include_regex: [".*"]`).
///
/// Some other common use cases:
///
/// * `{bucket_name: "mybucket", exclude_regex: [".*\.pdf"]}` will include all
///   files in `mybucket` except for .pdf files
/// * `{bucket_name: "mybucket", include_regex: ["directory/[^/]+"]}` will
///   include all files directly under `gs://mybucket/directory/`, without matching
///   across `/`
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageRegexFileSet {
    /// The name of a Cloud Storage bucket. Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name: std::string::String,

    /// A list of regular expressions matching file paths to include. All files in
    /// the bucket that match at least one of these regular expressions will be
    /// included in the set of files, except for those that also match an item in
    /// `exclude_regex`. Leaving this field empty will match all files by default
    /// (this is equivalent to including `.*` in the list).
    ///
    /// Regular expressions use RE2
    /// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
    /// under the google/re2 repository on GitHub.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub include_regex: std::vec::Vec<std::string::String>,

    /// A list of regular expressions matching file paths to exclude. All files in
    /// the bucket that match at least one of these regular expressions will be
    /// excluded from the scan.
    ///
    /// Regular expressions use RE2
    /// [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
    /// under the google/re2 repository on GitHub.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exclude_regex: std::vec::Vec<std::string::String>,
}

impl CloudStorageRegexFileSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::CloudStorageRegexFileSet::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [include_regex][crate::model::CloudStorageRegexFileSet::include_regex].
    pub fn set_include_regex<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.include_regex = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclude_regex][crate::model::CloudStorageRegexFileSet::exclude_regex].
    pub fn set_exclude_regex<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclude_regex = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudStorageRegexFileSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageRegexFileSet"
    }
}

/// Options defining a file or a set of files within a Cloud Storage
/// bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageOptions {
    /// The set of one or more files to scan.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_set: std::option::Option<crate::model::cloud_storage_options::FileSet>,

    /// Max number of bytes to scan from a file. If a scanned file's size is bigger
    /// than this value then the rest of the bytes are omitted. Only one of
    /// `bytes_limit_per_file` and `bytes_limit_per_file_percent` can be specified.
    /// This field can't be set if de-identification is requested. For certain file
    /// types, setting this field has no effect. For more information, see [Limits
    /// on bytes scanned per
    /// file](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types#max-byte-size-per-file).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub bytes_limit_per_file: i64,

    /// Max percentage of bytes to scan from a file. The rest are omitted. The
    /// number of bytes scanned is rounded down. Must be between 0 and 100,
    /// inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
    /// bytes_limit_per_file and bytes_limit_per_file_percent can be specified.
    /// This field can't be set if de-identification is requested. For certain file
    /// types, setting this field has no effect. For more information, see [Limits
    /// on bytes scanned per
    /// file](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types#max-byte-size-per-file).
    pub bytes_limit_per_file_percent: i32,

    /// List of file type groups to include in the scan.
    /// If empty, all files are scanned and available data format processors
    /// are applied. In addition, the binary content of the selected files
    /// is always scanned as well.
    /// Images are scanned only as binary if the specified region
    /// does not support image inspection and no file_types were specified.
    /// Image inspection is restricted to 'global', 'us', 'asia', and 'europe'.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_types: std::vec::Vec<crate::model::FileType>,

    /// How to sample the data.
    pub sample_method: crate::model::cloud_storage_options::SampleMethod,

    /// Limits the number of files to scan to this percentage of the input FileSet.
    /// Number of files scanned is rounded down. Must be between 0 and 100,
    /// inclusively. Both 0 and 100 means no limit. Defaults to 0.
    pub files_limit_percent: i32,
}

impl CloudStorageOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_set][crate::model::CloudStorageOptions::file_set].
    pub fn set_file_set<
        T: std::convert::Into<std::option::Option<crate::model::cloud_storage_options::FileSet>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_set = v.into();
        self
    }

    /// Sets the value of [bytes_limit_per_file][crate::model::CloudStorageOptions::bytes_limit_per_file].
    pub fn set_bytes_limit_per_file<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_limit_per_file = v.into();
        self
    }

    /// Sets the value of [bytes_limit_per_file_percent][crate::model::CloudStorageOptions::bytes_limit_per_file_percent].
    pub fn set_bytes_limit_per_file_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.bytes_limit_per_file_percent = v.into();
        self
    }

    /// Sets the value of [sample_method][crate::model::CloudStorageOptions::sample_method].
    pub fn set_sample_method<
        T: std::convert::Into<crate::model::cloud_storage_options::SampleMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_method = v.into();
        self
    }

    /// Sets the value of [files_limit_percent][crate::model::CloudStorageOptions::files_limit_percent].
    pub fn set_files_limit_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.files_limit_percent = v.into();
        self
    }

    /// Sets the value of [file_types][crate::model::CloudStorageOptions::file_types].
    pub fn set_file_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileType>,
    {
        use std::iter::Iterator;
        self.file_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudStorageOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageOptions"
    }
}

/// Defines additional types related to CloudStorageOptions
pub mod cloud_storage_options {
    #[allow(unused_imports)]
    use super::*;

    /// Set of files to scan.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FileSet {
        /// The Cloud Storage url of the file(s) to scan, in the format
        /// `gs://<bucket>/<path>`. Trailing wildcard in the path is allowed.
        ///
        /// If the url ends in a trailing slash, the bucket or directory represented
        /// by the url will be scanned non-recursively (content in sub-directories
        /// will not be scanned). This means that `gs://mybucket/` is equivalent to
        /// `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to
        /// `gs://mybucket/directory/*`.
        ///
        /// Exactly one of `url` or `regex_file_set` must be set.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub url: std::string::String,

        /// The regex-filtered set of files to scan. Exactly one of `url` or
        /// `regex_file_set` must be set.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub regex_file_set: std::option::Option<crate::model::CloudStorageRegexFileSet>,
    }

    impl FileSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [url][crate::model::cloud_storage_options::FileSet::url].
        pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.url = v.into();
            self
        }

        /// Sets the value of [regex_file_set][crate::model::cloud_storage_options::FileSet::regex_file_set].
        pub fn set_regex_file_set<
            T: std::convert::Into<std::option::Option<crate::model::CloudStorageRegexFileSet>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.regex_file_set = v.into();
            self
        }
    }

    impl wkt::message::Message for FileSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.CloudStorageOptions.FileSet"
        }
    }

    /// How to sample bytes if not all bytes are scanned. Meaningful only when used
    /// in conjunction with bytes_limit_per_file. If not specified, scanning would
    /// start from the top.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SampleMethod(i32);

    impl SampleMethod {
        /// No sampling.
        pub const SAMPLE_METHOD_UNSPECIFIED: SampleMethod = SampleMethod::new(0);

        /// Scan from the top (default).
        pub const TOP: SampleMethod = SampleMethod::new(1);

        /// For each file larger than bytes_limit_per_file, randomly pick the offset
        /// to start scanning. The scanned bytes are contiguous.
        pub const RANDOM_START: SampleMethod = SampleMethod::new(2);

        /// Creates a new SampleMethod instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SAMPLE_METHOD_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("TOP"),
                2 => std::borrow::Cow::Borrowed("RANDOM_START"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SAMPLE_METHOD_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SAMPLE_METHOD_UNSPECIFIED)
                }
                "TOP" => std::option::Option::Some(Self::TOP),
                "RANDOM_START" => std::option::Option::Some(Self::RANDOM_START),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SampleMethod {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SampleMethod {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message representing a set of files in Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageFileSet {
    /// The url, in the format `gs://<bucket>/<path>`. Trailing wildcard in the
    /// path is allowed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,
}

impl CloudStorageFileSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::CloudStorageFileSet::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageFileSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStorageFileSet"
    }
}

/// Message representing a single file or path in Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStoragePath {
    /// A URL representing a file or path (no wildcards) in Cloud Storage.
    /// Example: `gs://[BUCKET_NAME]/dictionary.txt`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,
}

impl CloudStoragePath {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::CloudStoragePath::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for CloudStoragePath {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.CloudStoragePath"
    }
}

/// Options defining BigQuery table and row identifiers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryOptions {
    /// Complete BigQuery table reference.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_reference: std::option::Option<crate::model::BigQueryTable>,

    /// Table fields that may uniquely identify a row within the table. When
    /// `actions.saveFindings.outputConfig.table` is specified, the values of
    /// columns specified here are available in the output table under
    /// `location.content_locations.record_location.record_key.id_values`. Nested
    /// fields such as `person.birthdate.year` are allowed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub identifying_fields: std::vec::Vec<crate::model::FieldId>,

    /// Max number of rows to scan. If the table has more rows than this value, the
    /// rest of the rows are omitted. If not set, or if set to 0, all rows will be
    /// scanned. Only one of rows_limit and rows_limit_percent can be specified.
    /// Cannot be used in conjunction with TimespanConfig.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub rows_limit: i64,

    /// Max percentage of rows to scan. The rest are omitted. The number of rows
    /// scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and
    /// 100 means no limit. Defaults to 0. Only one of rows_limit and
    /// rows_limit_percent can be specified. Cannot be used in conjunction with
    /// TimespanConfig.
    ///
    /// Caution: A [known
    /// issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#bq-sampling)
    /// is causing the `rowsLimitPercent` field to behave unexpectedly. We
    /// recommend using `rowsLimit` instead.
    pub rows_limit_percent: i32,

    /// How to sample the data.
    pub sample_method: crate::model::big_query_options::SampleMethod,

    /// References to fields excluded from scanning. This allows you to skip
    /// inspection of entire columns which you know have no findings.
    /// When inspecting a table, we recommend that you inspect all columns.
    /// Otherwise, findings might be affected because hints from excluded columns
    /// will not be used.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub excluded_fields: std::vec::Vec<crate::model::FieldId>,

    /// Limit scanning only to these fields.
    /// When inspecting a table, we recommend that you inspect all columns.
    /// Otherwise, findings might be affected because hints from excluded columns
    /// will not be used.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub included_fields: std::vec::Vec<crate::model::FieldId>,
}

impl BigQueryOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_reference][crate::model::BigQueryOptions::table_reference].
    pub fn set_table_reference<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_reference = v.into();
        self
    }

    /// Sets the value of [rows_limit][crate::model::BigQueryOptions::rows_limit].
    pub fn set_rows_limit<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.rows_limit = v.into();
        self
    }

    /// Sets the value of [rows_limit_percent][crate::model::BigQueryOptions::rows_limit_percent].
    pub fn set_rows_limit_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rows_limit_percent = v.into();
        self
    }

    /// Sets the value of [sample_method][crate::model::BigQueryOptions::sample_method].
    pub fn set_sample_method<
        T: std::convert::Into<crate::model::big_query_options::SampleMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_method = v.into();
        self
    }

    /// Sets the value of [identifying_fields][crate::model::BigQueryOptions::identifying_fields].
    pub fn set_identifying_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.identifying_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [excluded_fields][crate::model::BigQueryOptions::excluded_fields].
    pub fn set_excluded_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.excluded_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [included_fields][crate::model::BigQueryOptions::included_fields].
    pub fn set_included_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.included_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigQueryOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryOptions"
    }
}

/// Defines additional types related to BigQueryOptions
pub mod big_query_options {
    #[allow(unused_imports)]
    use super::*;

    /// How to sample rows if not all rows are scanned. Meaningful only when used
    /// in conjunction with either rows_limit or rows_limit_percent. If not
    /// specified, rows are scanned in the order BigQuery reads them.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SampleMethod(i32);

    impl SampleMethod {
        /// No sampling.
        pub const SAMPLE_METHOD_UNSPECIFIED: SampleMethod = SampleMethod::new(0);

        /// Scan groups of rows in the order BigQuery provides (default). Multiple
        /// groups of rows may be scanned in parallel, so results may not appear in
        /// the same order the rows are read.
        pub const TOP: SampleMethod = SampleMethod::new(1);

        /// Randomly pick groups of rows to scan.
        pub const RANDOM_START: SampleMethod = SampleMethod::new(2);

        /// Creates a new SampleMethod instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SAMPLE_METHOD_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("TOP"),
                2 => std::borrow::Cow::Borrowed("RANDOM_START"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SAMPLE_METHOD_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SAMPLE_METHOD_UNSPECIFIED)
                }
                "TOP" => std::option::Option::Some(Self::TOP),
                "RANDOM_START" => std::option::Option::Some(Self::RANDOM_START),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SampleMethod {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SampleMethod {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Shared message indicating Cloud storage type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageConfig {
    /// Configuration of the timespan of the items to include in scanning.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timespan_config: std::option::Option<crate::model::storage_config::TimespanConfig>,

    /// Type of storage system to inspect.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::storage_config::Type>,
}

impl StorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timespan_config][crate::model::StorageConfig::timespan_config].
    pub fn set_timespan_config<
        T: std::convert::Into<std::option::Option<crate::model::storage_config::TimespanConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.timespan_config = v.into();
        self
    }

    /// Sets the value of `r#type`.
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::storage_config::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `DatastoreOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_datastore_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatastoreOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::DatastoreOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `CloudStorageOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_storage_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::CloudStorageOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `BigQueryOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_big_query_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::BigQueryOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::StorageConfig::r#type]
    /// if it holds a `HybridOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_hybrid_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HybridOptions>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::storage_config::Type::HybridOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `DatastoreOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_datastore_options<
        T: std::convert::Into<std::boxed::Box<crate::model::DatastoreOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::storage_config::Type::DatastoreOptions(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `CloudStorageOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_cloud_storage_options<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::storage_config::Type::CloudStorageOptions(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `BigQueryOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_big_query_options<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::storage_config::Type::BigQueryOptions(v.into()),
        );
        self
    }

    /// Sets the value of [r#type][crate::model::StorageConfig::r#type]
    /// to hold a `HybridOptions`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_hybrid_options<
        T: std::convert::Into<std::boxed::Box<crate::model::HybridOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::storage_config::Type::HybridOptions(v.into()));
        self
    }
}

impl wkt::message::Message for StorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.StorageConfig"
    }
}

/// Defines additional types related to StorageConfig
pub mod storage_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of the timespan of the items to include in scanning.
    /// Currently only supported when inspecting Cloud Storage and BigQuery.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TimespanConfig {
        /// Exclude files, tables, or rows older than this value.
        /// If not set, no lower time limit is applied.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Exclude files, tables, or rows newer than this value.
        /// If not set, no upper time limit is applied.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub end_time: std::option::Option<wkt::Timestamp>,

        /// Specification of the field containing the timestamp of scanned items.
        /// Used for data sources like Datastore and BigQuery.
        ///
        /// **For BigQuery**
        ///
        /// If this value is not specified and the table was modified between the
        /// given start and end times, the entire table will be scanned. If this
        /// value is specified, then rows are filtered based on the given start and
        /// end times. Rows with a `NULL` value in the provided BigQuery column are
        /// skipped.
        /// Valid data types of the provided BigQuery column are: `INTEGER`, `DATE`,
        /// `TIMESTAMP`, and `DATETIME`.
        ///
        /// If your BigQuery table is [partitioned at ingestion
        /// time](https://cloud.google.com/bigquery/docs/partitioned-tables#ingestion_time),
        /// you can use any of the following pseudo-columns as your timestamp field.
        /// When used with Cloud DLP, these pseudo-column names are case sensitive.
        ///
        /// - `_PARTITIONTIME`
        /// - `_PARTITIONDATE`
        /// - `_PARTITION_LOAD_TIME`
        ///
        /// **For Datastore**
        ///
        /// If this value is specified, then entities are filtered based on the given
        /// start and end times. If an entity does not contain the provided timestamp
        /// property or contains empty or invalid values, then it is included.
        /// Valid data types of the provided timestamp property are: `TIMESTAMP`.
        ///
        /// See the
        /// [known
        /// issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#bq-timespan)
        /// related to this operation.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub timestamp_field: std::option::Option<crate::model::FieldId>,

        /// When the job is started by a JobTrigger we will automatically figure out
        /// a valid start_time to avoid scanning files that have not been modified
        /// since the last time the JobTrigger executed. This will be based on the
        /// time of the execution of the last run of the JobTrigger or the timespan
        /// end_time used in the last run of the JobTrigger.
        ///
        /// **For BigQuery**
        ///
        /// Inspect jobs triggered by automatic population will scan data that is at
        /// least three hours old when the job starts. This is because streaming
        /// buffer rows are not read during inspection and reading up to the current
        /// timestamp will result in skipped rows.
        ///
        /// See the [known
        /// issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#recently-streamed-data)
        /// related to this operation.
        pub enable_auto_population_of_timespan_config: bool,
    }

    impl TimespanConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::storage_config::TimespanConfig::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }

        /// Sets the value of [end_time][crate::model::storage_config::TimespanConfig::end_time].
        pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.end_time = v.into();
            self
        }

        /// Sets the value of [timestamp_field][crate::model::storage_config::TimespanConfig::timestamp_field].
        pub fn set_timestamp_field<
            T: std::convert::Into<std::option::Option<crate::model::FieldId>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.timestamp_field = v.into();
            self
        }

        /// Sets the value of [enable_auto_population_of_timespan_config][crate::model::storage_config::TimespanConfig::enable_auto_population_of_timespan_config].
        pub fn set_enable_auto_population_of_timespan_config<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.enable_auto_population_of_timespan_config = v.into();
            self
        }
    }

    impl wkt::message::Message for TimespanConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.StorageConfig.TimespanConfig"
        }
    }

    /// Type of storage system to inspect.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// Google Cloud Datastore options.
        DatastoreOptions(std::boxed::Box<crate::model::DatastoreOptions>),
        /// Cloud Storage options.
        CloudStorageOptions(std::boxed::Box<crate::model::CloudStorageOptions>),
        /// BigQuery options.
        BigQueryOptions(std::boxed::Box<crate::model::BigQueryOptions>),
        /// Hybrid inspection options.
        HybridOptions(std::boxed::Box<crate::model::HybridOptions>),
    }
}

/// Configuration to control jobs where the content being inspected is outside
/// of Google Cloud Platform.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridOptions {
    /// A short description of where the data is coming from. Will be stored once
    /// in the job. 256 max length.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// These are labels that each inspection request must include within their
    /// 'finding_labels' map. Request may contain others, but any missing one of
    /// these will be rejected.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// No more than 10 keys can be required.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub required_finding_label_keys: std::vec::Vec<std::string::String>,

    /// To organize findings, these labels will be added to each finding.
    ///
    /// Label keys must be between 1 and 63 characters long and must conform
    /// to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    ///
    /// Label values must be between 0 and 63 characters long and must conform
    /// to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
    ///
    /// No more than 10 labels can be associated with a given finding.
    ///
    /// Examples:
    ///
    /// * `"environment" : "production"`
    /// * `"pipeline" : "etl"`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// If the container is a table, additional information to make findings
    /// meaningful such as the columns that are primary keys.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_options: std::option::Option<crate::model::TableOptions>,
}

impl HybridOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::HybridOptions::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [table_options][crate::model::HybridOptions::table_options].
    pub fn set_table_options<
        T: std::convert::Into<std::option::Option<crate::model::TableOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_options = v.into();
        self
    }

    /// Sets the value of [required_finding_label_keys][crate::model::HybridOptions::required_finding_label_keys].
    pub fn set_required_finding_label_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.required_finding_label_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::HybridOptions::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for HybridOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.HybridOptions"
    }
}

/// Row key for identifying a record in BigQuery table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryKey {
    /// Complete BigQuery table reference.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_reference: std::option::Option<crate::model::BigQueryTable>,

    /// Row number inferred at the time the table was scanned. This value is
    /// nondeterministic, cannot be queried, and may be null for inspection
    /// jobs. To locate findings within a table, specify
    /// `inspect_job.storage_config.big_query_options.identifying_fields` in
    /// `CreateDlpJobRequest`.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub row_number: i64,
}

impl BigQueryKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_reference][crate::model::BigQueryKey::table_reference].
    pub fn set_table_reference<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_reference = v.into();
        self
    }

    /// Sets the value of [row_number][crate::model::BigQueryKey::row_number].
    pub fn set_row_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_number = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryKey"
    }
}

/// Record key for a finding in Cloud Datastore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatastoreKey {
    /// Datastore entity key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_key: std::option::Option<crate::model::Key>,
}

impl DatastoreKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_key][crate::model::DatastoreKey::entity_key].
    pub fn set_entity_key<T: std::convert::Into<std::option::Option<crate::model::Key>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_key = v.into();
        self
    }
}

impl wkt::message::Message for DatastoreKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.DatastoreKey"
    }
}

/// A unique identifier for a Datastore entity.
/// If a key's partition ID or any of its path kinds or names are
/// reserved/read-only, the key is reserved/read-only.
/// A reserved/read-only key is forbidden in certain documented contexts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Key {
    /// Entities are partitioned into subsets, currently identified by a project
    /// ID and namespace ID.
    /// Queries are scoped to a single partition.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub partition_id: std::option::Option<crate::model::PartitionId>,

    /// The entity path.
    /// An entity path consists of one or more elements composed of a kind and a
    /// string or numerical identifier, which identify entities. The first
    /// element identifies a _root entity_, the second element identifies
    /// a _child_ of the root entity, the third element identifies a child of the
    /// second entity, and so forth. The entities identified by all prefixes of
    /// the path are called the element's _ancestors_.
    ///
    /// A path can never be empty, and a path can have at most 100 elements.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub path: std::vec::Vec<crate::model::key::PathElement>,
}

impl Key {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partition_id][crate::model::Key::partition_id].
    pub fn set_partition_id<
        T: std::convert::Into<std::option::Option<crate::model::PartitionId>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partition_id = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Key::path].
    pub fn set_path<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::key::PathElement>,
    {
        use std::iter::Iterator;
        self.path = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Key {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.Key"
    }
}

/// Defines additional types related to Key
pub mod key {
    #[allow(unused_imports)]
    use super::*;

    /// A (kind, ID/name) pair used to construct a key path.
    ///
    /// If either name or ID is set, the element is complete.
    /// If neither is set, the element is incomplete.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PathElement {
        /// The kind of the entity.
        /// A kind matching regex `__.*__` is reserved/read-only.
        /// A kind must not contain more than 1500 bytes when UTF-8 encoded.
        /// Cannot be `""`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kind: std::string::String,

        /// The type of ID.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub id_type: std::option::Option<crate::model::key::path_element::IdType>,
    }

    impl PathElement {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::key::PathElement::kind].
        pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kind = v.into();
            self
        }

        /// Sets the value of `id_type`.
        pub fn set_id_type<
            T: std::convert::Into<std::option::Option<crate::model::key::path_element::IdType>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.id_type = v.into();
            self
        }

        /// The value of [id_type][crate::model::key::PathElement::id_type]
        /// if it holds a `Id`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_id(&self) -> std::option::Option<&i64> {
            #[allow(unreachable_patterns)]
            self.id_type.as_ref().and_then(|v| match v {
                crate::model::key::path_element::IdType::Id(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [id_type][crate::model::key::PathElement::id_type]
        /// if it holds a `Name`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_name(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.id_type.as_ref().and_then(|v| match v {
                crate::model::key::path_element::IdType::Name(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [id_type][crate::model::key::PathElement::id_type]
        /// to hold a `Id`.
        ///
        /// Note that all the setters affecting `id_type` are
        /// mutually exclusive.
        pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.id_type =
                std::option::Option::Some(crate::model::key::path_element::IdType::Id(v.into()));
            self
        }

        /// Sets the value of [id_type][crate::model::key::PathElement::id_type]
        /// to hold a `Name`.
        ///
        /// Note that all the setters affecting `id_type` are
        /// mutually exclusive.
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id_type =
                std::option::Option::Some(crate::model::key::path_element::IdType::Name(v.into()));
            self
        }
    }

    impl wkt::message::Message for PathElement {
        fn typename() -> &'static str {
            "type.googleapis.com/google.privacy.dlp.v2.Key.PathElement"
        }
    }

    /// Defines additional types related to PathElement
    pub mod path_element {
        #[allow(unused_imports)]
        use super::*;

        /// The type of ID.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum IdType {
            /// The auto-allocated ID of the entity.
            /// Never equal to zero. Values less than zero are discouraged and may not
            /// be supported in the future.
            Id(i64),
            /// The name of the entity.
            /// A name matching regex `__.*__` is reserved/read-only.
            /// A name must not be more than 1500 bytes when UTF-8 encoded.
            /// Cannot be `""`.
            Name(std::string::String),
        }
    }
}

/// Message for a unique key indicating a record that contains a finding.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecordKey {
    /// Values of identifying columns in the given row. Order of values matches
    /// the order of `identifying_fields` specified in the scanning request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub id_values: std::vec::Vec<std::string::String>,

    /// Type of key
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::record_key::Type>,
}

impl RecordKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id_values][crate::model::RecordKey::id_values].
    pub fn set_id_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.id_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `r#type`.
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::record_key::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::RecordKey::r#type]
    /// if it holds a `DatastoreKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_datastore_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatastoreKey>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::record_key::Type::DatastoreKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [r#type][crate::model::RecordKey::r#type]
    /// if it holds a `BigQueryKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_big_query_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryKey>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::record_key::Type::BigQueryKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::RecordKey::r#type]
    /// to hold a `DatastoreKey`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_datastore_key<T: std::convert::Into<std::boxed::Box<crate::model::DatastoreKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::record_key::Type::DatastoreKey(v.into()));
        self
    }

    /// Sets the value of [r#type][crate::model::RecordKey::r#type]
    /// to hold a `BigQueryKey`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    pub fn set_big_query_key<T: std::convert::Into<std::boxed::Box<crate::model::BigQueryKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type =
            std::option::Option::Some(crate::model::record_key::Type::BigQueryKey(v.into()));
        self
    }
}

impl wkt::message::Message for RecordKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.RecordKey"
    }
}

/// Defines additional types related to RecordKey
pub mod record_key {
    #[allow(unused_imports)]
    use super::*;

    /// Type of key
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Type {
        /// BigQuery key
        DatastoreKey(std::boxed::Box<crate::model::DatastoreKey>),
        /// Datastore key
        BigQueryKey(std::boxed::Box<crate::model::BigQueryKey>),
    }
}

/// Message defining the location of a BigQuery table. A table is uniquely
/// identified  by its project_id, dataset_id, and table_name. Within a query
/// a table is often referenced with a string in the format of:
/// `<project_id>:<dataset_id>.<table_id>` or
/// `<project_id>.<dataset_id>.<table_id>`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryTable {
    /// The Google Cloud project ID of the project containing the table.
    /// If omitted, project ID is inferred from the API call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Dataset ID of the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Name of the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,
}

impl BigQueryTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::BigQueryTable::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::BigQueryTable::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::BigQueryTable::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryTable"
    }
}

/// Message defining the location of a BigQuery table with the projectId inferred
/// from the parent project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableReference {
    /// Dataset ID of the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Name of the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,
}

impl TableReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_id][crate::model::TableReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::TableReference::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }
}

impl wkt::message::Message for TableReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableReference"
    }
}

/// Message defining a field of a BigQuery table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryField {
    /// Source table of the field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table: std::option::Option<crate::model::BigQueryTable>,

    /// Designated field in the BigQuery table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<crate::model::FieldId>,
}

impl BigQueryField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::BigQueryField::table].
    pub fn set_table<T: std::convert::Into<std::option::Option<crate::model::BigQueryTable>>>(
        mut self,
        v: T,
    ) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [field][crate::model::BigQueryField::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.BigQueryField"
    }
}

/// An entity in a dataset is a field or set of fields that correspond to a
/// single person. For example, in medical records the `EntityId` might be a
/// patient identifier, or for financial records it might be an account
/// identifier. This message is used when generalizations or analysis must take
/// into account that multiple rows correspond to the same entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityId {
    /// Composite key indicating which field contains the entity identifier.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<crate::model::FieldId>,
}

impl EntityId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::EntityId::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::FieldId>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }
}

impl wkt::message::Message for EntityId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.EntityId"
    }
}

/// Instructions regarding the table content being inspected.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableOptions {
    /// The columns that are the primary keys for table objects included in
    /// ContentItem. A copy of this cell's value will stored alongside alongside
    /// each finding so that the finding can be traced to the specific row it came
    /// from. No more than 3 may be provided.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub identifying_fields: std::vec::Vec<crate::model::FieldId>,
}

impl TableOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [identifying_fields][crate::model::TableOptions::identifying_fields].
    pub fn set_identifying_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FieldId>,
    {
        use std::iter::Iterator;
        self.identifying_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.privacy.dlp.v2.TableOptions"
    }
}

/// Enum of possible outcomes of transformations. SUCCESS if transformation and
/// storing of transformation was successful, otherwise, reason for not
/// transforming.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct TransformationResultStatusType(i32);

impl TransformationResultStatusType {
    /// Unused.
    pub const STATE_TYPE_UNSPECIFIED: TransformationResultStatusType =
        TransformationResultStatusType::new(0);

    /// This will be set when a finding could not be transformed (i.e. outside user
    /// set bucket range).
    pub const INVALID_TRANSFORM: TransformationResultStatusType =
        TransformationResultStatusType::new(1);

    /// This will be set when a BigQuery transformation was successful but could
    /// not be stored back in BigQuery because the transformed row exceeds
    /// BigQuery's max row size.
    pub const BIGQUERY_MAX_ROW_SIZE_EXCEEDED: TransformationResultStatusType =
        TransformationResultStatusType::new(2);

    /// This will be set when there is a finding in the custom metadata of a file,
    /// but at the write time of the transformed file, this key / value pair is
    /// unretrievable.
    pub const METADATA_UNRETRIEVABLE: TransformationResultStatusType =
        TransformationResultStatusType::new(3);

    /// This will be set when the transformation and storing of it is successful.
    pub const SUCCESS: TransformationResultStatusType = TransformationResultStatusType::new(4);

    /// Creates a new TransformationResultStatusType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("STATE_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("INVALID_TRANSFORM"),
            2 => std::borrow::Cow::Borrowed("BIGQUERY_MAX_ROW_SIZE_EXCEEDED"),
            3 => std::borrow::Cow::Borrowed("METADATA_UNRETRIEVABLE"),
            4 => std::borrow::Cow::Borrowed("SUCCESS"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "STATE_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_TYPE_UNSPECIFIED),
            "INVALID_TRANSFORM" => std::option::Option::Some(Self::INVALID_TRANSFORM),
            "BIGQUERY_MAX_ROW_SIZE_EXCEEDED" => {
                std::option::Option::Some(Self::BIGQUERY_MAX_ROW_SIZE_EXCEEDED)
            }
            "METADATA_UNRETRIEVABLE" => std::option::Option::Some(Self::METADATA_UNRETRIEVABLE),
            "SUCCESS" => std::option::Option::Some(Self::SUCCESS),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for TransformationResultStatusType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for TransformationResultStatusType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Describes functionality of a given container in its original format.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct TransformationContainerType(i32);

impl TransformationContainerType {
    /// Unused.
    pub const TRANSFORM_UNKNOWN_CONTAINER: TransformationContainerType =
        TransformationContainerType::new(0);

    /// Body of a file.
    pub const TRANSFORM_BODY: TransformationContainerType = TransformationContainerType::new(1);

    /// Metadata for a file.
    pub const TRANSFORM_METADATA: TransformationContainerType = TransformationContainerType::new(2);

    /// A table.
    pub const TRANSFORM_TABLE: TransformationContainerType = TransformationContainerType::new(3);

    /// Creates a new TransformationContainerType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("TRANSFORM_UNKNOWN_CONTAINER"),
            1 => std::borrow::Cow::Borrowed("TRANSFORM_BODY"),
            2 => std::borrow::Cow::Borrowed("TRANSFORM_METADATA"),
            3 => std::borrow::Cow::Borrowed("TRANSFORM_TABLE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "TRANSFORM_UNKNOWN_CONTAINER" => {
                std::option::Option::Some(Self::TRANSFORM_UNKNOWN_CONTAINER)
            }
            "TRANSFORM_BODY" => std::option::Option::Some(Self::TRANSFORM_BODY),
            "TRANSFORM_METADATA" => std::option::Option::Some(Self::TRANSFORM_METADATA),
            "TRANSFORM_TABLE" => std::option::Option::Some(Self::TRANSFORM_TABLE),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for TransformationContainerType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for TransformationContainerType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// An enum of rules that can be used to transform a value. Can be a
/// record suppression, or one of the transformation rules specified under
/// `PrimitiveTransformation`.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct TransformationType(i32);

impl TransformationType {
    /// Unused
    pub const TRANSFORMATION_TYPE_UNSPECIFIED: TransformationType = TransformationType::new(0);

    /// Record suppression
    pub const RECORD_SUPPRESSION: TransformationType = TransformationType::new(1);

    /// Replace value
    pub const REPLACE_VALUE: TransformationType = TransformationType::new(2);

    /// Replace value using a dictionary.
    pub const REPLACE_DICTIONARY: TransformationType = TransformationType::new(15);

    /// Redact
    pub const REDACT: TransformationType = TransformationType::new(3);

    /// Character mask
    pub const CHARACTER_MASK: TransformationType = TransformationType::new(4);

    /// FFX-FPE
    pub const CRYPTO_REPLACE_FFX_FPE: TransformationType = TransformationType::new(5);

    /// Fixed size bucketing
    pub const FIXED_SIZE_BUCKETING: TransformationType = TransformationType::new(6);

    /// Bucketing
    pub const BUCKETING: TransformationType = TransformationType::new(7);

    /// Replace with info type
    pub const REPLACE_WITH_INFO_TYPE: TransformationType = TransformationType::new(8);

    /// Time part
    pub const TIME_PART: TransformationType = TransformationType::new(9);

    /// Crypto hash
    pub const CRYPTO_HASH: TransformationType = TransformationType::new(10);

    /// Date shift
    pub const DATE_SHIFT: TransformationType = TransformationType::new(12);

    /// Deterministic crypto
    pub const CRYPTO_DETERMINISTIC_CONFIG: TransformationType = TransformationType::new(13);

    /// Redact image
    pub const REDACT_IMAGE: TransformationType = TransformationType::new(14);

    /// Creates a new TransformationType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("TRANSFORMATION_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("RECORD_SUPPRESSION"),
            2 => std::borrow::Cow::Borrowed("REPLACE_VALUE"),
            3 => std::borrow::Cow::Borrowed("REDACT"),
            4 => std::borrow::Cow::Borrowed("CHARACTER_MASK"),
            5 => std::borrow::Cow::Borrowed("CRYPTO_REPLACE_FFX_FPE"),
            6 => std::borrow::Cow::Borrowed("FIXED_SIZE_BUCKETING"),
            7 => std::borrow::Cow::Borrowed("BUCKETING"),
            8 => std::borrow::Cow::Borrowed("REPLACE_WITH_INFO_TYPE"),
            9 => std::borrow::Cow::Borrowed("TIME_PART"),
            10 => std::borrow::Cow::Borrowed("CRYPTO_HASH"),
            12 => std::borrow::Cow::Borrowed("DATE_SHIFT"),
            13 => std::borrow::Cow::Borrowed("CRYPTO_DETERMINISTIC_CONFIG"),
            14 => std::borrow::Cow::Borrowed("REDACT_IMAGE"),
            15 => std::borrow::Cow::Borrowed("REPLACE_DICTIONARY"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "TRANSFORMATION_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::TRANSFORMATION_TYPE_UNSPECIFIED)
            }
            "RECORD_SUPPRESSION" => std::option::Option::Some(Self::RECORD_SUPPRESSION),
            "REPLACE_VALUE" => std::option::Option::Some(Self::REPLACE_VALUE),
            "REPLACE_DICTIONARY" => std::option::Option::Some(Self::REPLACE_DICTIONARY),
            "REDACT" => std::option::Option::Some(Self::REDACT),
            "CHARACTER_MASK" => std::option::Option::Some(Self::CHARACTER_MASK),
            "CRYPTO_REPLACE_FFX_FPE" => std::option::Option::Some(Self::CRYPTO_REPLACE_FFX_FPE),
            "FIXED_SIZE_BUCKETING" => std::option::Option::Some(Self::FIXED_SIZE_BUCKETING),
            "BUCKETING" => std::option::Option::Some(Self::BUCKETING),
            "REPLACE_WITH_INFO_TYPE" => std::option::Option::Some(Self::REPLACE_WITH_INFO_TYPE),
            "TIME_PART" => std::option::Option::Some(Self::TIME_PART),
            "CRYPTO_HASH" => std::option::Option::Some(Self::CRYPTO_HASH),
            "DATE_SHIFT" => std::option::Option::Some(Self::DATE_SHIFT),
            "CRYPTO_DETERMINISTIC_CONFIG" => {
                std::option::Option::Some(Self::CRYPTO_DETERMINISTIC_CONFIG)
            }
            "REDACT_IMAGE" => std::option::Option::Some(Self::REDACT_IMAGE),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for TransformationType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for TransformationType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Whether a profile being created is the first generation or an update.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ProfileGeneration(i32);

impl ProfileGeneration {
    /// Unused.
    pub const PROFILE_GENERATION_UNSPECIFIED: ProfileGeneration = ProfileGeneration::new(0);

    /// The profile is the first profile for the resource.
    pub const PROFILE_GENERATION_NEW: ProfileGeneration = ProfileGeneration::new(1);

    /// The profile is an update to a previous profile.
    pub const PROFILE_GENERATION_UPDATE: ProfileGeneration = ProfileGeneration::new(2);

    /// Creates a new ProfileGeneration instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("PROFILE_GENERATION_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("PROFILE_GENERATION_NEW"),
            2 => std::borrow::Cow::Borrowed("PROFILE_GENERATION_UPDATE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "PROFILE_GENERATION_UNSPECIFIED" => {
                std::option::Option::Some(Self::PROFILE_GENERATION_UNSPECIFIED)
            }
            "PROFILE_GENERATION_NEW" => std::option::Option::Some(Self::PROFILE_GENERATION_NEW),
            "PROFILE_GENERATION_UPDATE" => {
                std::option::Option::Some(Self::PROFILE_GENERATION_UPDATE)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ProfileGeneration {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ProfileGeneration {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Over time new types may be added. Currently VIEW, MATERIALIZED_VIEW, and
/// non-BigLake external tables are not supported.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct BigQueryTableTypeCollection(i32);

impl BigQueryTableTypeCollection {
    /// Unused.
    pub const BIG_QUERY_COLLECTION_UNSPECIFIED: BigQueryTableTypeCollection =
        BigQueryTableTypeCollection::new(0);

    /// Automatically generate profiles for all tables, even if the table type is
    /// not yet fully supported for analysis. Profiles for unsupported tables will
    /// be generated with errors to indicate their partial support. When full
    /// support is added, the tables will automatically be profiled during the next
    /// scheduled run.
    pub const BIG_QUERY_COLLECTION_ALL_TYPES: BigQueryTableTypeCollection =
        BigQueryTableTypeCollection::new(1);

    /// Only those types fully supported will be profiled. Will expand
    /// automatically as Cloud DLP adds support for new table types. Unsupported
    /// table types will not have partial profiles generated.
    pub const BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES: BigQueryTableTypeCollection =
        BigQueryTableTypeCollection::new(2);

    /// Creates a new BigQueryTableTypeCollection instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("BIG_QUERY_COLLECTION_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("BIG_QUERY_COLLECTION_ALL_TYPES"),
            2 => std::borrow::Cow::Borrowed("BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "BIG_QUERY_COLLECTION_UNSPECIFIED" => {
                std::option::Option::Some(Self::BIG_QUERY_COLLECTION_UNSPECIFIED)
            }
            "BIG_QUERY_COLLECTION_ALL_TYPES" => {
                std::option::Option::Some(Self::BIG_QUERY_COLLECTION_ALL_TYPES)
            }
            "BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES" => {
                std::option::Option::Some(Self::BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for BigQueryTableTypeCollection {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for BigQueryTableTypeCollection {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Over time new types may be added. Currently VIEW, MATERIALIZED_VIEW, and
/// non-BigLake external tables are not supported.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct BigQueryTableType(i32);

impl BigQueryTableType {
    /// Unused.
    pub const BIG_QUERY_TABLE_TYPE_UNSPECIFIED: BigQueryTableType = BigQueryTableType::new(0);

    /// A normal BigQuery table.
    pub const BIG_QUERY_TABLE_TYPE_TABLE: BigQueryTableType = BigQueryTableType::new(1);

    /// A table that references data stored in Cloud Storage.
    pub const BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE: BigQueryTableType = BigQueryTableType::new(2);

    /// A snapshot of a BigQuery table.
    pub const BIG_QUERY_TABLE_TYPE_SNAPSHOT: BigQueryTableType = BigQueryTableType::new(3);

    /// Creates a new BigQueryTableType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("BIG_QUERY_TABLE_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("BIG_QUERY_TABLE_TYPE_TABLE"),
            2 => std::borrow::Cow::Borrowed("BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE"),
            3 => std::borrow::Cow::Borrowed("BIG_QUERY_TABLE_TYPE_SNAPSHOT"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "BIG_QUERY_TABLE_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::BIG_QUERY_TABLE_TYPE_UNSPECIFIED)
            }
            "BIG_QUERY_TABLE_TYPE_TABLE" => {
                std::option::Option::Some(Self::BIG_QUERY_TABLE_TYPE_TABLE)
            }
            "BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE" => {
                std::option::Option::Some(Self::BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE)
            }
            "BIG_QUERY_TABLE_TYPE_SNAPSHOT" => {
                std::option::Option::Some(Self::BIG_QUERY_TABLE_TYPE_SNAPSHOT)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for BigQueryTableType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for BigQueryTableType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// How frequently data profiles can be updated. New options can be added at a
/// later time.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DataProfileUpdateFrequency(i32);

impl DataProfileUpdateFrequency {
    /// Unspecified.
    pub const UPDATE_FREQUENCY_UNSPECIFIED: DataProfileUpdateFrequency =
        DataProfileUpdateFrequency::new(0);

    /// After the data profile is created, it will never be updated.
    pub const UPDATE_FREQUENCY_NEVER: DataProfileUpdateFrequency =
        DataProfileUpdateFrequency::new(1);

    /// The data profile can be updated up to once every 24 hours.
    pub const UPDATE_FREQUENCY_DAILY: DataProfileUpdateFrequency =
        DataProfileUpdateFrequency::new(2);

    /// The data profile can be updated up to once every 30 days. Default.
    pub const UPDATE_FREQUENCY_MONTHLY: DataProfileUpdateFrequency =
        DataProfileUpdateFrequency::new(4);

    /// Creates a new DataProfileUpdateFrequency instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("UPDATE_FREQUENCY_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("UPDATE_FREQUENCY_NEVER"),
            2 => std::borrow::Cow::Borrowed("UPDATE_FREQUENCY_DAILY"),
            4 => std::borrow::Cow::Borrowed("UPDATE_FREQUENCY_MONTHLY"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "UPDATE_FREQUENCY_UNSPECIFIED" => {
                std::option::Option::Some(Self::UPDATE_FREQUENCY_UNSPECIFIED)
            }
            "UPDATE_FREQUENCY_NEVER" => std::option::Option::Some(Self::UPDATE_FREQUENCY_NEVER),
            "UPDATE_FREQUENCY_DAILY" => std::option::Option::Some(Self::UPDATE_FREQUENCY_DAILY),
            "UPDATE_FREQUENCY_MONTHLY" => std::option::Option::Some(Self::UPDATE_FREQUENCY_MONTHLY),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for DataProfileUpdateFrequency {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for DataProfileUpdateFrequency {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Attributes evaluated to determine if a table has been modified. New values
/// may be added at a later time.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct BigQueryTableModification(i32);

impl BigQueryTableModification {
    /// Unused.
    pub const TABLE_MODIFICATION_UNSPECIFIED: BigQueryTableModification =
        BigQueryTableModification::new(0);

    /// A table will be considered modified when the last_modified_time from
    /// BigQuery has been updated.
    pub const TABLE_MODIFIED_TIMESTAMP: BigQueryTableModification =
        BigQueryTableModification::new(1);

    /// Creates a new BigQueryTableModification instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("TABLE_MODIFICATION_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("TABLE_MODIFIED_TIMESTAMP"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "TABLE_MODIFICATION_UNSPECIFIED" => {
                std::option::Option::Some(Self::TABLE_MODIFICATION_UNSPECIFIED)
            }
            "TABLE_MODIFIED_TIMESTAMP" => std::option::Option::Some(Self::TABLE_MODIFIED_TIMESTAMP),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for BigQueryTableModification {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for BigQueryTableModification {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Attributes evaluated to determine if a schema has been modified. New values
/// may be added at a later time.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct BigQuerySchemaModification(i32);

impl BigQuerySchemaModification {
    /// Unused
    pub const SCHEMA_MODIFICATION_UNSPECIFIED: BigQuerySchemaModification =
        BigQuerySchemaModification::new(0);

    /// Profiles should be regenerated when new columns are added to the table.
    /// Default.
    pub const SCHEMA_NEW_COLUMNS: BigQuerySchemaModification = BigQuerySchemaModification::new(1);

    /// Profiles should be regenerated when columns are removed from the table.
    pub const SCHEMA_REMOVED_COLUMNS: BigQuerySchemaModification =
        BigQuerySchemaModification::new(2);

    /// Creates a new BigQuerySchemaModification instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("SCHEMA_MODIFICATION_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("SCHEMA_NEW_COLUMNS"),
            2 => std::borrow::Cow::Borrowed("SCHEMA_REMOVED_COLUMNS"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "SCHEMA_MODIFICATION_UNSPECIFIED" => {
                std::option::Option::Some(Self::SCHEMA_MODIFICATION_UNSPECIFIED)
            }
            "SCHEMA_NEW_COLUMNS" => std::option::Option::Some(Self::SCHEMA_NEW_COLUMNS),
            "SCHEMA_REMOVED_COLUMNS" => std::option::Option::Some(Self::SCHEMA_REMOVED_COLUMNS),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for BigQuerySchemaModification {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for BigQuerySchemaModification {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Operators available for comparing the value of fields.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct RelationalOperator(i32);

impl RelationalOperator {
    /// Unused
    pub const RELATIONAL_OPERATOR_UNSPECIFIED: RelationalOperator = RelationalOperator::new(0);

    /// Equal. Attempts to match even with incompatible types.
    pub const EQUAL_TO: RelationalOperator = RelationalOperator::new(1);

    /// Not equal to. Attempts to match even with incompatible types.
    pub const NOT_EQUAL_TO: RelationalOperator = RelationalOperator::new(2);

    /// Greater than.
    pub const GREATER_THAN: RelationalOperator = RelationalOperator::new(3);

    /// Less than.
    pub const LESS_THAN: RelationalOperator = RelationalOperator::new(4);

    /// Greater than or equals.
    pub const GREATER_THAN_OR_EQUALS: RelationalOperator = RelationalOperator::new(5);

    /// Less than or equals.
    pub const LESS_THAN_OR_EQUALS: RelationalOperator = RelationalOperator::new(6);

    /// Exists
    pub const EXISTS: RelationalOperator = RelationalOperator::new(7);

    /// Creates a new RelationalOperator instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("RELATIONAL_OPERATOR_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("EQUAL_TO"),
            2 => std::borrow::Cow::Borrowed("NOT_EQUAL_TO"),
            3 => std::borrow::Cow::Borrowed("GREATER_THAN"),
            4 => std::borrow::Cow::Borrowed("LESS_THAN"),
            5 => std::borrow::Cow::Borrowed("GREATER_THAN_OR_EQUALS"),
            6 => std::borrow::Cow::Borrowed("LESS_THAN_OR_EQUALS"),
            7 => std::borrow::Cow::Borrowed("EXISTS"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "RELATIONAL_OPERATOR_UNSPECIFIED" => {
                std::option::Option::Some(Self::RELATIONAL_OPERATOR_UNSPECIFIED)
            }
            "EQUAL_TO" => std::option::Option::Some(Self::EQUAL_TO),
            "NOT_EQUAL_TO" => std::option::Option::Some(Self::NOT_EQUAL_TO),
            "GREATER_THAN" => std::option::Option::Some(Self::GREATER_THAN),
            "LESS_THAN" => std::option::Option::Some(Self::LESS_THAN),
            "GREATER_THAN_OR_EQUALS" => std::option::Option::Some(Self::GREATER_THAN_OR_EQUALS),
            "LESS_THAN_OR_EQUALS" => std::option::Option::Some(Self::LESS_THAN_OR_EQUALS),
            "EXISTS" => std::option::Option::Some(Self::EXISTS),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for RelationalOperator {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for RelationalOperator {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Type of the match which can be applied to different ways of matching, like
/// Dictionary, regular expression and intersecting with findings of another
/// info type.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MatchingType(i32);

impl MatchingType {
    /// Invalid.
    pub const MATCHING_TYPE_UNSPECIFIED: MatchingType = MatchingType::new(0);

    /// Full match.
    ///
    /// - Dictionary: join of Dictionary results matched complete finding quote
    /// - Regex: all regex matches fill a finding quote start to end
    /// - Exclude info type: completely inside affecting info types findings
    pub const MATCHING_TYPE_FULL_MATCH: MatchingType = MatchingType::new(1);

    /// Partial match.
    ///
    /// - Dictionary: at least one of the tokens in the finding matches
    /// - Regex: substring of the finding matches
    /// - Exclude info type: intersects with affecting info types findings
    pub const MATCHING_TYPE_PARTIAL_MATCH: MatchingType = MatchingType::new(2);

    /// Inverse match.
    ///
    /// - Dictionary: no tokens in the finding match the dictionary
    /// - Regex: finding doesn't match the regex
    /// - Exclude info type: no intersection with affecting info types findings
    pub const MATCHING_TYPE_INVERSE_MATCH: MatchingType = MatchingType::new(3);

    /// Creates a new MatchingType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("MATCHING_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("MATCHING_TYPE_FULL_MATCH"),
            2 => std::borrow::Cow::Borrowed("MATCHING_TYPE_PARTIAL_MATCH"),
            3 => std::borrow::Cow::Borrowed("MATCHING_TYPE_INVERSE_MATCH"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "MATCHING_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::MATCHING_TYPE_UNSPECIFIED)
            }
            "MATCHING_TYPE_FULL_MATCH" => std::option::Option::Some(Self::MATCHING_TYPE_FULL_MATCH),
            "MATCHING_TYPE_PARTIAL_MATCH" => {
                std::option::Option::Some(Self::MATCHING_TYPE_PARTIAL_MATCH)
            }
            "MATCHING_TYPE_INVERSE_MATCH" => {
                std::option::Option::Some(Self::MATCHING_TYPE_INVERSE_MATCH)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for MatchingType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for MatchingType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Deprecated and unused.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ContentOption(i32);

impl ContentOption {
    /// Includes entire content of a file or a data stream.
    pub const CONTENT_UNSPECIFIED: ContentOption = ContentOption::new(0);

    /// Text content within the data, excluding any metadata.
    pub const CONTENT_TEXT: ContentOption = ContentOption::new(1);

    /// Images found in the data.
    pub const CONTENT_IMAGE: ContentOption = ContentOption::new(2);

    /// Creates a new ContentOption instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("CONTENT_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("CONTENT_TEXT"),
            2 => std::borrow::Cow::Borrowed("CONTENT_IMAGE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "CONTENT_UNSPECIFIED" => std::option::Option::Some(Self::CONTENT_UNSPECIFIED),
            "CONTENT_TEXT" => std::option::Option::Some(Self::CONTENT_TEXT),
            "CONTENT_IMAGE" => std::option::Option::Some(Self::CONTENT_IMAGE),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ContentOption {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ContentOption {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Type of metadata containing the finding.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MetadataType(i32);

impl MetadataType {
    /// Unused
    pub const METADATATYPE_UNSPECIFIED: MetadataType = MetadataType::new(0);

    /// General file metadata provided by Cloud Storage.
    pub const STORAGE_METADATA: MetadataType = MetadataType::new(2);

    /// Creates a new MetadataType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("METADATATYPE_UNSPECIFIED"),
            2 => std::borrow::Cow::Borrowed("STORAGE_METADATA"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "METADATATYPE_UNSPECIFIED" => std::option::Option::Some(Self::METADATATYPE_UNSPECIFIED),
            "STORAGE_METADATA" => std::option::Option::Some(Self::STORAGE_METADATA),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for MetadataType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for MetadataType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Parts of the APIs which use certain infoTypes.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct InfoTypeSupportedBy(i32);

impl InfoTypeSupportedBy {
    /// Unused.
    pub const ENUM_TYPE_UNSPECIFIED: InfoTypeSupportedBy = InfoTypeSupportedBy::new(0);

    /// Supported by the inspect operations.
    pub const INSPECT: InfoTypeSupportedBy = InfoTypeSupportedBy::new(1);

    /// Supported by the risk analysis operations.
    pub const RISK_ANALYSIS: InfoTypeSupportedBy = InfoTypeSupportedBy::new(2);

    /// Creates a new InfoTypeSupportedBy instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("ENUM_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("INSPECT"),
            2 => std::borrow::Cow::Borrowed("RISK_ANALYSIS"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "ENUM_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::ENUM_TYPE_UNSPECIFIED),
            "INSPECT" => std::option::Option::Some(Self::INSPECT),
            "RISK_ANALYSIS" => std::option::Option::Some(Self::RISK_ANALYSIS),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for InfoTypeSupportedBy {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for InfoTypeSupportedBy {
    fn default() -> Self {
        Self::new(0)
    }
}

/// An enum to represent the various types of DLP jobs.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DlpJobType(i32);

impl DlpJobType {
    /// Defaults to INSPECT_JOB.
    pub const DLP_JOB_TYPE_UNSPECIFIED: DlpJobType = DlpJobType::new(0);

    /// The job inspected Google Cloud for sensitive data.
    pub const INSPECT_JOB: DlpJobType = DlpJobType::new(1);

    /// The job executed a Risk Analysis computation.
    pub const RISK_ANALYSIS_JOB: DlpJobType = DlpJobType::new(2);

    /// Creates a new DlpJobType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("DLP_JOB_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("INSPECT_JOB"),
            2 => std::borrow::Cow::Borrowed("RISK_ANALYSIS_JOB"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "DLP_JOB_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::DLP_JOB_TYPE_UNSPECIFIED),
            "INSPECT_JOB" => std::option::Option::Some(Self::INSPECT_JOB),
            "RISK_ANALYSIS_JOB" => std::option::Option::Some(Self::RISK_ANALYSIS_JOB),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for DlpJobType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for DlpJobType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// State of a StoredInfoType version.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct StoredInfoTypeState(i32);

impl StoredInfoTypeState {
    /// Unused
    pub const STORED_INFO_TYPE_STATE_UNSPECIFIED: StoredInfoTypeState = StoredInfoTypeState::new(0);

    /// StoredInfoType version is being created.
    pub const PENDING: StoredInfoTypeState = StoredInfoTypeState::new(1);

    /// StoredInfoType version is ready for use.
    pub const READY: StoredInfoTypeState = StoredInfoTypeState::new(2);

    /// StoredInfoType creation failed. All relevant error messages are returned in
    /// the `StoredInfoTypeVersion` message.
    pub const FAILED: StoredInfoTypeState = StoredInfoTypeState::new(3);

    /// StoredInfoType is no longer valid because artifacts stored in
    /// user-controlled storage were modified. To fix an invalid StoredInfoType,
    /// use the `UpdateStoredInfoType` method to create a new version.
    pub const INVALID: StoredInfoTypeState = StoredInfoTypeState::new(4);

    /// Creates a new StoredInfoTypeState instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("STORED_INFO_TYPE_STATE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("PENDING"),
            2 => std::borrow::Cow::Borrowed("READY"),
            3 => std::borrow::Cow::Borrowed("FAILED"),
            4 => std::borrow::Cow::Borrowed("INVALID"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "STORED_INFO_TYPE_STATE_UNSPECIFIED" => {
                std::option::Option::Some(Self::STORED_INFO_TYPE_STATE_UNSPECIFIED)
            }
            "PENDING" => std::option::Option::Some(Self::PENDING),
            "READY" => std::option::Option::Some(Self::READY),
            "FAILED" => std::option::Option::Some(Self::FAILED),
            "INVALID" => std::option::Option::Some(Self::INVALID),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for StoredInfoTypeState {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for StoredInfoTypeState {
    fn default() -> Self {
        Self::new(0)
    }
}

/// How broadly the data in the resource has been shared. New items may be added
/// over time. A higher number means more restricted.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ResourceVisibility(i32);

impl ResourceVisibility {
    /// Unused.
    pub const RESOURCE_VISIBILITY_UNSPECIFIED: ResourceVisibility = ResourceVisibility::new(0);

    /// Visible to any user.
    pub const RESOURCE_VISIBILITY_PUBLIC: ResourceVisibility = ResourceVisibility::new(10);

    /// May contain public items.
    /// For example, if a Cloud Storage bucket has uniform bucket level access
    /// disabled, some objects inside it may be public, but none are known yet.
    pub const RESOURCE_VISIBILITY_INCONCLUSIVE: ResourceVisibility = ResourceVisibility::new(15);

    /// Visible only to specific users.
    pub const RESOURCE_VISIBILITY_RESTRICTED: ResourceVisibility = ResourceVisibility::new(20);

    /// Creates a new ResourceVisibility instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("RESOURCE_VISIBILITY_UNSPECIFIED"),
            10 => std::borrow::Cow::Borrowed("RESOURCE_VISIBILITY_PUBLIC"),
            15 => std::borrow::Cow::Borrowed("RESOURCE_VISIBILITY_INCONCLUSIVE"),
            20 => std::borrow::Cow::Borrowed("RESOURCE_VISIBILITY_RESTRICTED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "RESOURCE_VISIBILITY_UNSPECIFIED" => {
                std::option::Option::Some(Self::RESOURCE_VISIBILITY_UNSPECIFIED)
            }
            "RESOURCE_VISIBILITY_PUBLIC" => {
                std::option::Option::Some(Self::RESOURCE_VISIBILITY_PUBLIC)
            }
            "RESOURCE_VISIBILITY_INCONCLUSIVE" => {
                std::option::Option::Some(Self::RESOURCE_VISIBILITY_INCONCLUSIVE)
            }
            "RESOURCE_VISIBILITY_RESTRICTED" => {
                std::option::Option::Some(Self::RESOURCE_VISIBILITY_RESTRICTED)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ResourceVisibility {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ResourceVisibility {
    fn default() -> Self {
        Self::new(0)
    }
}

/// How a resource is encrypted.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct EncryptionStatus(i32);

impl EncryptionStatus {
    /// Unused.
    pub const ENCRYPTION_STATUS_UNSPECIFIED: EncryptionStatus = EncryptionStatus::new(0);

    /// Google manages server-side encryption keys on your behalf.
    pub const ENCRYPTION_GOOGLE_MANAGED: EncryptionStatus = EncryptionStatus::new(1);

    /// Customer provides the key.
    pub const ENCRYPTION_CUSTOMER_MANAGED: EncryptionStatus = EncryptionStatus::new(2);

    /// Creates a new EncryptionStatus instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("ENCRYPTION_STATUS_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("ENCRYPTION_GOOGLE_MANAGED"),
            2 => std::borrow::Cow::Borrowed("ENCRYPTION_CUSTOMER_MANAGED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "ENCRYPTION_STATUS_UNSPECIFIED" => {
                std::option::Option::Some(Self::ENCRYPTION_STATUS_UNSPECIFIED)
            }
            "ENCRYPTION_GOOGLE_MANAGED" => {
                std::option::Option::Some(Self::ENCRYPTION_GOOGLE_MANAGED)
            }
            "ENCRYPTION_CUSTOMER_MANAGED" => {
                std::option::Option::Some(Self::ENCRYPTION_CUSTOMER_MANAGED)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for EncryptionStatus {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for EncryptionStatus {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Bucketized nullness percentage levels. A higher level means a higher
/// percentage of the column is null.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct NullPercentageLevel(i32);

impl NullPercentageLevel {
    /// Unused.
    pub const NULL_PERCENTAGE_LEVEL_UNSPECIFIED: NullPercentageLevel = NullPercentageLevel::new(0);

    /// Very few null entries.
    pub const NULL_PERCENTAGE_VERY_LOW: NullPercentageLevel = NullPercentageLevel::new(1);

    /// Some null entries.
    pub const NULL_PERCENTAGE_LOW: NullPercentageLevel = NullPercentageLevel::new(2);

    /// A few null entries.
    pub const NULL_PERCENTAGE_MEDIUM: NullPercentageLevel = NullPercentageLevel::new(3);

    /// A lot of null entries.
    pub const NULL_PERCENTAGE_HIGH: NullPercentageLevel = NullPercentageLevel::new(4);

    /// Creates a new NullPercentageLevel instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("NULL_PERCENTAGE_LEVEL_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("NULL_PERCENTAGE_VERY_LOW"),
            2 => std::borrow::Cow::Borrowed("NULL_PERCENTAGE_LOW"),
            3 => std::borrow::Cow::Borrowed("NULL_PERCENTAGE_MEDIUM"),
            4 => std::borrow::Cow::Borrowed("NULL_PERCENTAGE_HIGH"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "NULL_PERCENTAGE_LEVEL_UNSPECIFIED" => {
                std::option::Option::Some(Self::NULL_PERCENTAGE_LEVEL_UNSPECIFIED)
            }
            "NULL_PERCENTAGE_VERY_LOW" => std::option::Option::Some(Self::NULL_PERCENTAGE_VERY_LOW),
            "NULL_PERCENTAGE_LOW" => std::option::Option::Some(Self::NULL_PERCENTAGE_LOW),
            "NULL_PERCENTAGE_MEDIUM" => std::option::Option::Some(Self::NULL_PERCENTAGE_MEDIUM),
            "NULL_PERCENTAGE_HIGH" => std::option::Option::Some(Self::NULL_PERCENTAGE_HIGH),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for NullPercentageLevel {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for NullPercentageLevel {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Bucketized uniqueness score levels. A higher uniqueness score is a strong
/// signal that the column may contain a unique identifier like user id. A low
/// value indicates that the column contains few unique values like booleans or
/// other classifiers.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct UniquenessScoreLevel(i32);

impl UniquenessScoreLevel {
    /// Some columns do not have estimated uniqueness. Possible reasons include
    /// having too few values.
    pub const UNIQUENESS_SCORE_LEVEL_UNSPECIFIED: UniquenessScoreLevel =
        UniquenessScoreLevel::new(0);

    /// Low uniqueness, possibly a boolean, enum or similiarly typed column.
    pub const UNIQUENESS_SCORE_LOW: UniquenessScoreLevel = UniquenessScoreLevel::new(1);

    /// Medium uniqueness.
    pub const UNIQUENESS_SCORE_MEDIUM: UniquenessScoreLevel = UniquenessScoreLevel::new(2);

    /// High uniqueness, possibly a column of free text or unique identifiers.
    pub const UNIQUENESS_SCORE_HIGH: UniquenessScoreLevel = UniquenessScoreLevel::new(3);

    /// Creates a new UniquenessScoreLevel instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("UNIQUENESS_SCORE_LEVEL_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("UNIQUENESS_SCORE_LOW"),
            2 => std::borrow::Cow::Borrowed("UNIQUENESS_SCORE_MEDIUM"),
            3 => std::borrow::Cow::Borrowed("UNIQUENESS_SCORE_HIGH"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "UNIQUENESS_SCORE_LEVEL_UNSPECIFIED" => {
                std::option::Option::Some(Self::UNIQUENESS_SCORE_LEVEL_UNSPECIFIED)
            }
            "UNIQUENESS_SCORE_LOW" => std::option::Option::Some(Self::UNIQUENESS_SCORE_LOW),
            "UNIQUENESS_SCORE_MEDIUM" => std::option::Option::Some(Self::UNIQUENESS_SCORE_MEDIUM),
            "UNIQUENESS_SCORE_HIGH" => std::option::Option::Some(Self::UNIQUENESS_SCORE_HIGH),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for UniquenessScoreLevel {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for UniquenessScoreLevel {
    fn default() -> Self {
        Self::new(0)
    }
}

/// State of the connection.
/// New values may be added over time.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ConnectionState(i32);

impl ConnectionState {
    /// Unused
    pub const CONNECTION_STATE_UNSPECIFIED: ConnectionState = ConnectionState::new(0);

    /// The DLP API automatically created this connection during an initial scan,
    /// and it is awaiting full configuration by a user.
    pub const MISSING_CREDENTIALS: ConnectionState = ConnectionState::new(1);

    /// A configured connection that has not encountered any errors.
    pub const AVAILABLE: ConnectionState = ConnectionState::new(2);

    /// A configured connection that encountered errors during its last use. It
    /// will not be used again until it is set to AVAILABLE.
    ///
    /// If the resolution requires external action, then the client must send a
    /// request to set the status to AVAILABLE when the connection is ready for
    /// use. If the resolution doesn't require external action, then any changes to
    /// the connection properties will automatically mark it as AVAILABLE.
    pub const ERROR: ConnectionState = ConnectionState::new(3);

    /// Creates a new ConnectionState instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("CONNECTION_STATE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("MISSING_CREDENTIALS"),
            2 => std::borrow::Cow::Borrowed("AVAILABLE"),
            3 => std::borrow::Cow::Borrowed("ERROR"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "CONNECTION_STATE_UNSPECIFIED" => {
                std::option::Option::Some(Self::CONNECTION_STATE_UNSPECIFIED)
            }
            "MISSING_CREDENTIALS" => std::option::Option::Some(Self::MISSING_CREDENTIALS),
            "AVAILABLE" => std::option::Option::Some(Self::AVAILABLE),
            "ERROR" => std::option::Option::Some(Self::ERROR),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ConnectionState {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ConnectionState {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Coarse-grained confidence level of how well a particular finding
/// satisfies the criteria to match a particular infoType.
///
/// Likelihood is calculated based on the number of signals a
/// finding has that implies that the finding matches the infoType. For
/// example, a string that has an '@' and a '.com' is more likely to be a
/// match for an email address than a string that only has an '@'.
///
/// In general, the highest likelihood level has the strongest signals that
/// indicate a match. That is, a finding with a high likelihood has a low chance
/// of being a false positive.
///
/// For more information about each likelihood level
/// and how likelihood works, see [Match
/// likelihood](https://cloud.google.com/sensitive-data-protection/docs/likelihood).
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct Likelihood(i32);

impl Likelihood {
    /// Default value; same as POSSIBLE.
    pub const LIKELIHOOD_UNSPECIFIED: Likelihood = Likelihood::new(0);

    /// Highest chance of a false positive.
    pub const VERY_UNLIKELY: Likelihood = Likelihood::new(1);

    /// High chance of a false positive.
    pub const UNLIKELY: Likelihood = Likelihood::new(2);

    /// Some matching signals. The default value.
    pub const POSSIBLE: Likelihood = Likelihood::new(3);

    /// Low chance of a false positive.
    pub const LIKELY: Likelihood = Likelihood::new(4);

    /// Confidence level is high. Lowest chance of a false positive.
    pub const VERY_LIKELY: Likelihood = Likelihood::new(5);

    /// Creates a new Likelihood instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("LIKELIHOOD_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("VERY_UNLIKELY"),
            2 => std::borrow::Cow::Borrowed("UNLIKELY"),
            3 => std::borrow::Cow::Borrowed("POSSIBLE"),
            4 => std::borrow::Cow::Borrowed("LIKELY"),
            5 => std::borrow::Cow::Borrowed("VERY_LIKELY"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "LIKELIHOOD_UNSPECIFIED" => std::option::Option::Some(Self::LIKELIHOOD_UNSPECIFIED),
            "VERY_UNLIKELY" => std::option::Option::Some(Self::VERY_UNLIKELY),
            "UNLIKELY" => std::option::Option::Some(Self::UNLIKELY),
            "POSSIBLE" => std::option::Option::Some(Self::POSSIBLE),
            "LIKELY" => std::option::Option::Some(Self::LIKELY),
            "VERY_LIKELY" => std::option::Option::Some(Self::VERY_LIKELY),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for Likelihood {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for Likelihood {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Definitions of file type groups to scan. New types will be added to this
/// list.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct FileType(i32);

impl FileType {
    /// Includes all files.
    pub const FILE_TYPE_UNSPECIFIED: FileType = FileType::new(0);

    /// Includes all file extensions not covered by another entry. Binary
    /// scanning attempts to convert the content of the file to utf_8 to scan
    /// the file.
    /// If you wish to avoid this fall back, specify one or more of the other
    /// file types in your storage scan.
    pub const BINARY_FILE: FileType = FileType::new(1);

    /// Included file extensions:
    /// asc,asp, aspx, brf, c, cc,cfm, cgi, cpp, csv, cxx, c++, cs, css, dart,
    /// dat, dot, eml,, epbub, ged, go, h, hh, hpp, hxx, h++, hs, html, htm,
    /// mkd, markdown, m, ml, mli, perl, pl, plist, pm, php, phtml, pht,
    /// properties, py, pyw, rb, rbw, rs, rss,  rc, scala, sh, sql, swift, tex,
    /// shtml, shtm, xhtml, lhs, ics, ini, java, js, json, jsonl, kix, kml,
    /// ocaml, md, txt, text, tsv, vb, vcard, vcs, wml, xcodeproj, xml, xsl, xsd,
    /// yml, yaml.
    pub const TEXT_FILE: FileType = FileType::new(2);

    /// Included file extensions:
    /// bmp, gif, jpg, jpeg, jpe, png. Setting
    /// [bytes_limit_per_file][google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file]
    /// or
    /// [bytes_limit_per_file_percent][google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file]
    /// has no effect on image files. Image inspection is restricted to the
    /// `global`, `us`, `asia`, and `europe` regions.
    ///
    /// [google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file]: crate::model::CloudStorageOptions::bytes_limit_per_file
    pub const IMAGE: FileType = FileType::new(3);

    /// Microsoft Word files larger than 30 MB will be scanned as binary files.
    /// Included file extensions:
    /// docx, dotx, docm, dotm. Setting `bytes_limit_per_file` or
    /// `bytes_limit_per_file_percent` has no effect on Word files.
    pub const WORD: FileType = FileType::new(5);

    /// PDF files larger than 30 MB will be scanned as binary files.
    /// Included file extensions:
    /// pdf. Setting `bytes_limit_per_file` or `bytes_limit_per_file_percent`
    /// has no effect on PDF files.
    pub const PDF: FileType = FileType::new(6);

    /// Included file extensions:
    /// avro
    pub const AVRO: FileType = FileType::new(7);

    /// Included file extensions:
    /// csv
    pub const CSV: FileType = FileType::new(8);

    /// Included file extensions:
    /// tsv
    pub const TSV: FileType = FileType::new(9);

    /// Microsoft PowerPoint files larger than 30 MB will be scanned as binary
    /// files. Included file extensions:
    /// pptx, pptm, potx, potm, pot. Setting `bytes_limit_per_file` or
    /// `bytes_limit_per_file_percent` has no effect on PowerPoint files.
    pub const POWERPOINT: FileType = FileType::new(11);

    /// Microsoft Excel files larger than 30 MB will be scanned as binary files.
    /// Included file extensions:
    /// xlsx, xlsm, xltx, xltm. Setting `bytes_limit_per_file` or
    /// `bytes_limit_per_file_percent` has no effect on Excel files.
    pub const EXCEL: FileType = FileType::new(12);

    /// Creates a new FileType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("FILE_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("BINARY_FILE"),
            2 => std::borrow::Cow::Borrowed("TEXT_FILE"),
            3 => std::borrow::Cow::Borrowed("IMAGE"),
            5 => std::borrow::Cow::Borrowed("WORD"),
            6 => std::borrow::Cow::Borrowed("PDF"),
            7 => std::borrow::Cow::Borrowed("AVRO"),
            8 => std::borrow::Cow::Borrowed("CSV"),
            9 => std::borrow::Cow::Borrowed("TSV"),
            11 => std::borrow::Cow::Borrowed("POWERPOINT"),
            12 => std::borrow::Cow::Borrowed("EXCEL"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "FILE_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::FILE_TYPE_UNSPECIFIED),
            "BINARY_FILE" => std::option::Option::Some(Self::BINARY_FILE),
            "TEXT_FILE" => std::option::Option::Some(Self::TEXT_FILE),
            "IMAGE" => std::option::Option::Some(Self::IMAGE),
            "WORD" => std::option::Option::Some(Self::WORD),
            "PDF" => std::option::Option::Some(Self::PDF),
            "AVRO" => std::option::Option::Some(Self::AVRO),
            "CSV" => std::option::Option::Some(Self::CSV),
            "TSV" => std::option::Option::Some(Self::TSV),
            "POWERPOINT" => std::option::Option::Some(Self::POWERPOINT),
            "EXCEL" => std::option::Option::Some(Self::EXCEL),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for FileType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for FileType {
    fn default() -> Self {
        Self::new(0)
    }
}
