// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A Backup of a Cloud Firestore Database.
///
/// The backup contains all documents and index configurations for the given
/// database at a specific point in time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Backup {
    /// Output only. The unique resource name of the Backup.
    ///
    /// Format is `projects/{project}/locations/{location}/backups/{backup}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Name of the Firestore database that the backup is from.
    ///
    /// Format is `projects/{project}/databases/{database}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Output only. The system-generated UUID4 for the Firestore database that the
    /// backup is from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_uid: std::string::String,

    /// Output only. The backup contains an externally consistent copy of the
    /// database at this time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this backup expires.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Statistics about the backup.
    ///
    /// This data only becomes available after the backup is fully materialized to
    /// secondary storage. This field will be empty till then.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stats: std::option::Option<crate::model::backup::Stats>,

    /// Output only. The current state of the backup.
    pub state: crate::model::backup::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [database][crate::model::Backup::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [database_uid][crate::model::Backup::database_uid].
    pub fn set_database_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_uid = v.into();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::Backup::snapshot_time].
    pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [stats][crate::model::Backup::stats].
    pub fn set_stats<T: std::convert::Into<std::option::Option<crate::model::backup::Stats>>>(
        mut self,
        v: T,
    ) -> Self {
        self.stats = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Backup"
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// Backup specific statistics.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Stats {
        /// Output only. Summation of the size of all documents and index entries in
        /// the backup, measured in bytes.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub size_bytes: i64,

        /// Output only. The total number of documents contained in the backup.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub document_count: i64,

        /// Output only. The total number of index entries contained in the backup.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub index_count: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Stats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [size_bytes][crate::model::backup::Stats::size_bytes].
        pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.size_bytes = v.into();
            self
        }

        /// Sets the value of [document_count][crate::model::backup::Stats::document_count].
        pub fn set_document_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.document_count = v.into();
            self
        }

        /// Sets the value of [index_count][crate::model::backup::Stats::index_count].
        pub fn set_index_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.index_count = v.into();
            self
        }
    }

    impl wkt::message::Message for Stats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Backup.Stats"
        }
    }

    /// Indicate the current state of the backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unspecified.
        Unspecified,
        /// The pending backup is still being created. Operations on the
        /// backup will be rejected in this state.
        Creating,
        /// The backup is complete and ready to use.
        Ready,
        /// The backup is not available at this moment.
        NotAvailable,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::NotAvailable => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::NotAvailable => std::option::Option::Some("NOT_AVAILABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::NotAvailable,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "NOT_AVAILABLE" => Self::NotAvailable,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::NotAvailable => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.firestore.admin.v1.Backup.State",
            ))
        }
    }
}

/// A Cloud Firestore Database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Database {
    /// The resource name of the Database.
    /// Format: `projects/{project}/databases/{database}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The system-generated UUID4 for this Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The timestamp at which this database was created. Databases
    /// created before 2016 do not populate create_time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this database was most recently
    /// updated. Note this only includes updates to the database resource and not
    /// data contained by the database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this database was deleted. Only set if
    /// the database has been deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// The location of the database. Available locations are listed at
    /// <https://cloud.google.com/firestore/docs/locations>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    /// The type of the database.
    /// See <https://cloud.google.com/datastore/docs/firestore-or-datastore> for
    /// information about how to choose.
    #[serde(rename = "type")]
    pub r#type: crate::model::database::DatabaseType,

    /// The concurrency control mode to use for this database.
    pub concurrency_mode: crate::model::database::ConcurrencyMode,

    /// Output only. The period during which past versions of data are retained in
    /// the database.
    ///
    /// Any [read][google.firestore.v1.GetDocumentRequest.read_time]
    /// or [query][google.firestore.v1.ListDocumentsRequest.read_time] can specify
    /// a `read_time` within this window, and will read the state of the database
    /// at that time.
    ///
    /// If the PITR feature is enabled, the retention period is 7 days. Otherwise,
    /// the retention period is 1 hour.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version_retention_period: std::option::Option<wkt::Duration>,

    /// Output only. The earliest timestamp at which older versions of the data can
    /// be read from the database. See [version_retention_period] above; this field
    /// is populated with `now - version_retention_period`.
    ///
    /// This value is continuously updated, and becomes stale the moment it is
    /// queried. If you are using this value to recover data, make sure to account
    /// for the time from the moment when the value is queried to the moment when
    /// you initiate the recovery.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub earliest_version_time: std::option::Option<wkt::Timestamp>,

    /// Whether to enable the PITR feature on this database.
    pub point_in_time_recovery_enablement: crate::model::database::PointInTimeRecoveryEnablement,

    /// The App Engine integration mode to use for this database.
    pub app_engine_integration_mode: crate::model::database::AppEngineIntegrationMode,

    /// Output only. The key_prefix for this database. This key_prefix is used, in
    /// combination with the project ID ("\<key prefix\>~\<project id\>") to construct
    /// the application ID that is returned from the Cloud Datastore APIs in Google
    /// App Engine first generation runtimes.
    ///
    /// This value may be empty in which case the appid to use for URL-encoded keys
    /// is the project_id (eg: foo instead of v~foo).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_prefix: std::string::String,

    /// State of delete protection for the database.
    pub delete_protection_state: crate::model::database::DeleteProtectionState,

    /// Optional. Presence indicates CMEK is enabled for this database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cmek_config: std::option::Option<crate::model::database::CmekConfig>,

    /// Output only. The database resource's prior database ID. This field is only
    /// populated for deleted databases.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub previous_id: std::string::String,

    /// Output only. Information about the provenance of this database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_info: std::option::Option<crate::model::database::SourceInfo>,

    /// Output only. Background: Free tier is the ability of a Firestore database
    /// to use a small amount of resources every day without being charged. Once
    /// usage exceeds the free tier limit further usage is charged.
    ///
    /// Whether this database can make use of the free tier. Only one database
    /// per project can be eligible for the free tier.
    ///
    /// The first (or next) database that is created in a project without a free
    /// tier database will be marked as eligible for the free tier. Databases that
    /// are created while there is a free tier database will not be eligible for
    /// the free tier.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub free_tier: std::option::Option<bool>,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Immutable. The edition of the database.
    pub database_edition: crate::model::database::DatabaseEdition,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Database {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Database::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Database::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Database::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Database::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Database::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::Database::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Database::type].
    pub fn set_type<T: std::convert::Into<crate::model::database::DatabaseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [concurrency_mode][crate::model::Database::concurrency_mode].
    pub fn set_concurrency_mode<T: std::convert::Into<crate::model::database::ConcurrencyMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.concurrency_mode = v.into();
        self
    }

    /// Sets the value of [version_retention_period][crate::model::Database::version_retention_period].
    pub fn set_version_retention_period<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version_retention_period = v.into();
        self
    }

    /// Sets the value of [earliest_version_time][crate::model::Database::earliest_version_time].
    pub fn set_earliest_version_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.earliest_version_time = v.into();
        self
    }

    /// Sets the value of [point_in_time_recovery_enablement][crate::model::Database::point_in_time_recovery_enablement].
    pub fn set_point_in_time_recovery_enablement<
        T: std::convert::Into<crate::model::database::PointInTimeRecoveryEnablement>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.point_in_time_recovery_enablement = v.into();
        self
    }

    /// Sets the value of [app_engine_integration_mode][crate::model::Database::app_engine_integration_mode].
    pub fn set_app_engine_integration_mode<
        T: std::convert::Into<crate::model::database::AppEngineIntegrationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.app_engine_integration_mode = v.into();
        self
    }

    /// Sets the value of [key_prefix][crate::model::Database::key_prefix].
    pub fn set_key_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_prefix = v.into();
        self
    }

    /// Sets the value of [delete_protection_state][crate::model::Database::delete_protection_state].
    pub fn set_delete_protection_state<
        T: std::convert::Into<crate::model::database::DeleteProtectionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.delete_protection_state = v.into();
        self
    }

    /// Sets the value of [cmek_config][crate::model::Database::cmek_config].
    pub fn set_cmek_config<
        T: std::convert::Into<std::option::Option<crate::model::database::CmekConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cmek_config = v.into();
        self
    }

    /// Sets the value of [previous_id][crate::model::Database::previous_id].
    pub fn set_previous_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.previous_id = v.into();
        self
    }

    /// Sets the value of [source_info][crate::model::Database::source_info].
    pub fn set_source_info<
        T: std::convert::Into<std::option::Option<crate::model::database::SourceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_info = v.into();
        self
    }

    /// Sets the value of [free_tier][crate::model::Database::free_tier].
    pub fn set_free_tier<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.free_tier = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Database::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [database_edition][crate::model::Database::database_edition].
    pub fn set_database_edition<T: std::convert::Into<crate::model::database::DatabaseEdition>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_edition = v.into();
        self
    }
}

impl wkt::message::Message for Database {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Database"
    }
}

/// Defines additional types related to [Database].
pub mod database {
    #[allow(unused_imports)]
    use super::*;

    /// The CMEK (Customer Managed Encryption Key) configuration for a Firestore
    /// database. If not present, the database is secured by the default Google
    /// encryption key.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CmekConfig {
        /// Required. Only keys in the same location as this database are allowed to
        /// be used for encryption.
        ///
        /// For Firestore's nam5 multi-region, this corresponds to Cloud KMS
        /// multi-region us. For Firestore's eur3 multi-region, this corresponds to
        /// Cloud KMS multi-region europe. See
        /// <https://cloud.google.com/kms/docs/locations>.
        ///
        /// The expected format is
        /// `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key_name: std::string::String,

        /// Output only. Currently in-use [KMS key
        /// versions](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions).
        /// During [key rotation](https://cloud.google.com/kms/docs/key-rotation),
        /// there can be multiple in-use key versions.
        ///
        /// The expected format is
        /// `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{key_version}`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub active_key_version: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CmekConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key_name][crate::model::database::CmekConfig::kms_key_name].
        pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_name = v.into();
            self
        }

        /// Sets the value of [active_key_version][crate::model::database::CmekConfig::active_key_version].
        pub fn set_active_key_version<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.active_key_version = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CmekConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Database.CmekConfig"
        }
    }

    /// Information about the provenance of this database.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SourceInfo {
        /// The associated long-running operation. This field may not be set after
        /// the operation has completed. Format:
        /// `projects/{project}/databases/{database}/operations/{operation}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub operation: std::string::String,

        /// The source from which this database is derived.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub source: std::option::Option<crate::model::database::source_info::Source>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SourceInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::database::SourceInfo::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [source][crate::model::database::SourceInfo::source].
        ///
        /// Note that all the setters affecting `source` are mutually
        /// exclusive.
        pub fn set_source<
            T: std::convert::Into<std::option::Option<crate::model::database::source_info::Source>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::database::SourceInfo::source]
        /// if it holds a `Backup`, `None` if the field is not set or
        /// holds a different branch.
        pub fn backup(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::database::source_info::BackupSource>>
        {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::database::source_info::Source::Backup(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::database::SourceInfo::source]
        /// to hold a `Backup`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_backup<
            T: std::convert::Into<std::boxed::Box<crate::model::database::source_info::BackupSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::database::source_info::Source::Backup(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for SourceInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Database.SourceInfo"
        }
    }

    /// Defines additional types related to [SourceInfo].
    pub mod source_info {
        #[allow(unused_imports)]
        use super::*;

        /// Information about a backup that was used to restore a database.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BackupSource {
            /// The resource name of the backup that was used to restore this
            /// database. Format:
            /// `projects/{project}/locations/{location}/backups/{backup}`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub backup: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BackupSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [backup][crate::model::database::source_info::BackupSource::backup].
            pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.backup = v.into();
                self
            }
        }

        impl wkt::message::Message for BackupSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.SourceInfo.BackupSource"
            }
        }

        /// The source from which this database is derived.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Source {
            /// If set, this database was restored from the specified backup (or a
            /// snapshot thereof).
            Backup(std::boxed::Box<crate::model::database::source_info::BackupSource>),
        }
    }

    /// Encryption configuration for a new database being created from another
    /// source.
    ///
    /// The source could be a [Backup][google.firestore.admin.v1.Backup] .
    ///
    /// [google.firestore.admin.v1.Backup]: crate::model::Backup
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EncryptionConfig {
        /// The method for encrypting the database.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub encryption_type:
            std::option::Option<crate::model::database::encryption_config::EncryptionType>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EncryptionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type].
        ///
        /// Note that all the setters affecting `encryption_type` are mutually
        /// exclusive.
        pub fn set_encryption_type<
            T: std::convert::Into<
                    std::option::Option<crate::model::database::encryption_config::EncryptionType>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = v.into();
            self
        }

        /// The value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// if it holds a `GoogleDefaultEncryption`, `None` if the field is not set or
        /// holds a different branch.
        pub fn google_default_encryption(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::database::encryption_config::GoogleDefaultEncryptionOptions,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.encryption_type.as_ref().and_then(|v| match v {
                crate::model::database::encryption_config::EncryptionType::GoogleDefaultEncryption(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// to hold a `GoogleDefaultEncryption`.
        ///
        /// Note that all the setters affecting `encryption_type` are
        /// mutually exclusive.
        pub fn set_google_default_encryption<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::database::encryption_config::GoogleDefaultEncryptionOptions,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = std::option::Option::Some(
                crate::model::database::encryption_config::EncryptionType::GoogleDefaultEncryption(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// if it holds a `UseSourceEncryption`, `None` if the field is not set or
        /// holds a different branch.
        pub fn use_source_encryption(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::database::encryption_config::SourceEncryptionOptions>,
        > {
            #[allow(unreachable_patterns)]
            self.encryption_type.as_ref().and_then(|v| match v {
                crate::model::database::encryption_config::EncryptionType::UseSourceEncryption(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// to hold a `UseSourceEncryption`.
        ///
        /// Note that all the setters affecting `encryption_type` are
        /// mutually exclusive.
        pub fn set_use_source_encryption<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::database::encryption_config::SourceEncryptionOptions,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = std::option::Option::Some(
                crate::model::database::encryption_config::EncryptionType::UseSourceEncryption(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// if it holds a `CustomerManagedEncryption`, `None` if the field is not set or
        /// holds a different branch.
        pub fn customer_managed_encryption(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::database::encryption_config::CustomerManagedEncryptionOptions,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.encryption_type.as_ref().and_then(|v| match v {
                crate::model::database::encryption_config::EncryptionType::CustomerManagedEncryption(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// to hold a `CustomerManagedEncryption`.
        ///
        /// Note that all the setters affecting `encryption_type` are
        /// mutually exclusive.
        pub fn set_customer_managed_encryption<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::database::encryption_config::CustomerManagedEncryptionOptions,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = std::option::Option::Some(
                crate::model::database::encryption_config::EncryptionType::CustomerManagedEncryption(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for EncryptionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig"
        }
    }

    /// Defines additional types related to [EncryptionConfig].
    pub mod encryption_config {
        #[allow(unused_imports)]
        use super::*;

        /// The configuration options for using Google default encryption.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct GoogleDefaultEncryptionOptions {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl GoogleDefaultEncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for GoogleDefaultEncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig.GoogleDefaultEncryptionOptions"
            }
        }

        /// The configuration options for using the same encryption method as the
        /// source.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SourceEncryptionOptions {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SourceEncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for SourceEncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig.SourceEncryptionOptions"
            }
        }

        /// The configuration options for using CMEK (Customer Managed Encryption
        /// Key) encryption.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CustomerManagedEncryptionOptions {
            /// Required. Only keys in the same location as the database are allowed to
            /// be used for encryption.
            ///
            /// For Firestore's nam5 multi-region, this corresponds to Cloud KMS
            /// multi-region us. For Firestore's eur3 multi-region, this corresponds to
            /// Cloud KMS multi-region europe. See
            /// <https://cloud.google.com/kms/docs/locations>.
            ///
            /// The expected format is
            /// `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub kms_key_name: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomerManagedEncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [kms_key_name][crate::model::database::encryption_config::CustomerManagedEncryptionOptions::kms_key_name].
            pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.kms_key_name = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomerManagedEncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig.CustomerManagedEncryptionOptions"
            }
        }

        /// The method for encrypting the database.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum EncryptionType {
            /// Use Google default encryption.
            GoogleDefaultEncryption(
                std::boxed::Box<
                    crate::model::database::encryption_config::GoogleDefaultEncryptionOptions,
                >,
            ),
            /// The database will use the same encryption configuration as the source.
            UseSourceEncryption(
                std::boxed::Box<crate::model::database::encryption_config::SourceEncryptionOptions>,
            ),
            /// Use Customer Managed Encryption Keys (CMEK) for encryption.
            CustomerManagedEncryption(
                std::boxed::Box<
                    crate::model::database::encryption_config::CustomerManagedEncryptionOptions,
                >,
            ),
        }
    }

    /// The type of the database.
    /// See <https://cloud.google.com/datastore/docs/firestore-or-datastore> for
    /// information about how to choose.
    ///
    /// Mode changes are only allowed if the database is empty.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseType {
        /// Not used.
        Unspecified,
        /// Firestore Native Mode
        FirestoreNative,
        /// Firestore in Datastore Mode.
        DatastoreMode,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseType::value] or
        /// [DatabaseType::name].
        UnknownValue(database_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FirestoreNative => std::option::Option::Some(1),
                Self::DatastoreMode => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_TYPE_UNSPECIFIED"),
                Self::FirestoreNative => std::option::Option::Some("FIRESTORE_NATIVE"),
                Self::DatastoreMode => std::option::Option::Some("DATASTORE_MODE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FirestoreNative,
                2 => Self::DatastoreMode,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "FIRESTORE_NATIVE" => Self::FirestoreNative,
                "DATASTORE_MODE" => Self::DatastoreMode,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FirestoreNative => serializer.serialize_i32(1),
                Self::DatastoreMode => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseType>::new(
                ".google.firestore.admin.v1.Database.DatabaseType",
            ))
        }
    }

    /// The type of concurrency control mode for transactions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConcurrencyMode {
        /// Not used.
        Unspecified,
        /// Use optimistic concurrency control by default. This mode is available
        /// for Cloud Firestore databases.
        Optimistic,
        /// Use pessimistic concurrency control by default. This mode is available
        /// for Cloud Firestore databases.
        ///
        /// This is the default setting for Cloud Firestore.
        Pessimistic,
        /// Use optimistic concurrency control with entity groups by default.
        ///
        /// This is the only available mode for Cloud Datastore.
        ///
        /// This mode is also available for Cloud Firestore with Datastore Mode but
        /// is not recommended.
        OptimisticWithEntityGroups,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConcurrencyMode::value] or
        /// [ConcurrencyMode::name].
        UnknownValue(concurrency_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod concurrency_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConcurrencyMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Optimistic => std::option::Option::Some(1),
                Self::Pessimistic => std::option::Option::Some(2),
                Self::OptimisticWithEntityGroups => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONCURRENCY_MODE_UNSPECIFIED"),
                Self::Optimistic => std::option::Option::Some("OPTIMISTIC"),
                Self::Pessimistic => std::option::Option::Some("PESSIMISTIC"),
                Self::OptimisticWithEntityGroups => {
                    std::option::Option::Some("OPTIMISTIC_WITH_ENTITY_GROUPS")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConcurrencyMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConcurrencyMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConcurrencyMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Optimistic,
                2 => Self::Pessimistic,
                3 => Self::OptimisticWithEntityGroups,
                _ => Self::UnknownValue(concurrency_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConcurrencyMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONCURRENCY_MODE_UNSPECIFIED" => Self::Unspecified,
                "OPTIMISTIC" => Self::Optimistic,
                "PESSIMISTIC" => Self::Pessimistic,
                "OPTIMISTIC_WITH_ENTITY_GROUPS" => Self::OptimisticWithEntityGroups,
                _ => Self::UnknownValue(concurrency_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConcurrencyMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Optimistic => serializer.serialize_i32(1),
                Self::Pessimistic => serializer.serialize_i32(2),
                Self::OptimisticWithEntityGroups => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConcurrencyMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConcurrencyMode>::new(
                ".google.firestore.admin.v1.Database.ConcurrencyMode",
            ))
        }
    }

    /// Point In Time Recovery feature enablement.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PointInTimeRecoveryEnablement {
        /// Not used.
        Unspecified,
        /// Reads are supported on selected versions of the data from within the past
        /// 7 days:
        ///
        /// * Reads against any timestamp within the past hour
        /// * Reads against 1-minute snapshots beyond 1 hour and within 7 days
        ///
        /// `version_retention_period` and `earliest_version_time` can be
        /// used to determine the supported versions.
        PointInTimeRecoveryEnabled,
        /// Reads are supported on any version of the data from within the past 1
        /// hour.
        PointInTimeRecoveryDisabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PointInTimeRecoveryEnablement::value] or
        /// [PointInTimeRecoveryEnablement::name].
        UnknownValue(point_in_time_recovery_enablement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod point_in_time_recovery_enablement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PointInTimeRecoveryEnablement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PointInTimeRecoveryEnabled => std::option::Option::Some(1),
                Self::PointInTimeRecoveryDisabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED")
                }
                Self::PointInTimeRecoveryEnabled => {
                    std::option::Option::Some("POINT_IN_TIME_RECOVERY_ENABLED")
                }
                Self::PointInTimeRecoveryDisabled => {
                    std::option::Option::Some("POINT_IN_TIME_RECOVERY_DISABLED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PointInTimeRecoveryEnablement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PointInTimeRecoveryEnablement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PointInTimeRecoveryEnablement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PointInTimeRecoveryEnabled,
                2 => Self::PointInTimeRecoveryDisabled,
                _ => Self::UnknownValue(point_in_time_recovery_enablement::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PointInTimeRecoveryEnablement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED" => Self::Unspecified,
                "POINT_IN_TIME_RECOVERY_ENABLED" => Self::PointInTimeRecoveryEnabled,
                "POINT_IN_TIME_RECOVERY_DISABLED" => Self::PointInTimeRecoveryDisabled,
                _ => Self::UnknownValue(point_in_time_recovery_enablement::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PointInTimeRecoveryEnablement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PointInTimeRecoveryEnabled => serializer.serialize_i32(1),
                Self::PointInTimeRecoveryDisabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PointInTimeRecoveryEnablement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PointInTimeRecoveryEnablement>::new(
                    ".google.firestore.admin.v1.Database.PointInTimeRecoveryEnablement",
                ),
            )
        }
    }

    /// The type of App Engine integration mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AppEngineIntegrationMode {
        /// Not used.
        Unspecified,
        /// If an App Engine application exists in the same region as this database,
        /// App Engine configuration will impact this database. This includes
        /// disabling of the application & database, as well as disabling writes to
        /// the database.
        Enabled,
        /// App Engine has no effect on the ability of this database to serve
        /// requests.
        ///
        /// This is the default setting for databases created with the Firestore API.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AppEngineIntegrationMode::value] or
        /// [AppEngineIntegrationMode::name].
        UnknownValue(app_engine_integration_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod app_engine_integration_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AppEngineIntegrationMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED")
                }
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AppEngineIntegrationMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AppEngineIntegrationMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AppEngineIntegrationMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(app_engine_integration_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AppEngineIntegrationMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(app_engine_integration_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AppEngineIntegrationMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AppEngineIntegrationMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<AppEngineIntegrationMode>::new(
                    ".google.firestore.admin.v1.Database.AppEngineIntegrationMode",
                ),
            )
        }
    }

    /// The delete protection state of the database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DeleteProtectionState {
        /// The default value. Delete protection type is not specified
        Unspecified,
        /// Delete protection is disabled
        DeleteProtectionDisabled,
        /// Delete protection is enabled
        DeleteProtectionEnabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DeleteProtectionState::value] or
        /// [DeleteProtectionState::name].
        UnknownValue(delete_protection_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod delete_protection_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DeleteProtectionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DeleteProtectionDisabled => std::option::Option::Some(1),
                Self::DeleteProtectionEnabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DELETE_PROTECTION_STATE_UNSPECIFIED")
                }
                Self::DeleteProtectionDisabled => {
                    std::option::Option::Some("DELETE_PROTECTION_DISABLED")
                }
                Self::DeleteProtectionEnabled => {
                    std::option::Option::Some("DELETE_PROTECTION_ENABLED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DeleteProtectionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DeleteProtectionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DeleteProtectionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DeleteProtectionDisabled,
                2 => Self::DeleteProtectionEnabled,
                _ => Self::UnknownValue(delete_protection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DeleteProtectionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DELETE_PROTECTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "DELETE_PROTECTION_DISABLED" => Self::DeleteProtectionDisabled,
                "DELETE_PROTECTION_ENABLED" => Self::DeleteProtectionEnabled,
                _ => Self::UnknownValue(delete_protection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DeleteProtectionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DeleteProtectionDisabled => serializer.serialize_i32(1),
                Self::DeleteProtectionEnabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DeleteProtectionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeleteProtectionState>::new(
                ".google.firestore.admin.v1.Database.DeleteProtectionState",
            ))
        }
    }

    /// The edition of the database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseEdition {
        /// Not used.
        Unspecified,
        /// Standard edition.
        ///
        /// This is the default setting if not specified.
        Standard,
        /// Enterprise edition.
        Enterprise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseEdition::value] or
        /// [DatabaseEdition::name].
        UnknownValue(database_edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseEdition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Enterprise => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_EDITION_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseEdition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseEdition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseEdition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::Enterprise,
                _ => Self::UnknownValue(database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseEdition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_EDITION_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                "ENTERPRISE" => Self::Enterprise,
                _ => Self::UnknownValue(database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseEdition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Enterprise => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseEdition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEdition>::new(
                ".google.firestore.admin.v1.Database.DatabaseEdition",
            ))
        }
    }
}

/// Represents a single field in the database.
///
/// Fields are grouped by their "Collection Group", which represent all
/// collections in the database with the same ID.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Field {
    /// Required. A field name of the form:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_path}`
    ///
    /// A field path can be a simple field name, e.g. `address` or a path to fields
    /// within `map_value` , e.g. `address.city`,
    /// or a special field path. The only valid special field is `*`, which
    /// represents any field.
    ///
    /// Field paths can be quoted using `` ` `` (backtick). The only character that
    /// must be escaped within a quoted field path is the backtick character
    /// itself, escaped using a backslash. Special characters in field paths that
    /// must be quoted include: `*`, `.`,
    /// `` ` `` (backtick), `[`, `]`, as well as any ascii symbolic characters.
    ///
    /// Examples:
    /// `` `address.city` `` represents a field named `address.city`, not the map
    /// key `city` in the field `address`. `` `*` `` represents a field named `*`,
    /// not any field.
    ///
    /// A special `Field` contains the default indexing settings for all fields.
    /// This field's resource name is:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/__default__/fields/*`
    /// Indexes defined on this `Field` will be applied to all fields which do not
    /// have their own `Field` index configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The index configuration for this field. If unset, field indexing will
    /// revert to the configuration defined by the `ancestor_field`. To
    /// explicitly remove all indexes for this field, specify an index config
    /// with an empty list of indexes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_config: std::option::Option<crate::model::field::IndexConfig>,

    /// The TTL configuration for this `Field`.
    /// Setting or unsetting this will enable or disable the TTL for
    /// documents that have this `Field`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ttl_config: std::option::Option<crate::model::field::TtlConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Field {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Field::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [index_config][crate::model::Field::index_config].
    pub fn set_index_config<
        T: std::convert::Into<std::option::Option<crate::model::field::IndexConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_config = v.into();
        self
    }

    /// Sets the value of [ttl_config][crate::model::Field::ttl_config].
    pub fn set_ttl_config<
        T: std::convert::Into<std::option::Option<crate::model::field::TtlConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ttl_config = v.into();
        self
    }
}

impl wkt::message::Message for Field {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Field"
    }
}

/// Defines additional types related to [Field].
pub mod field {
    #[allow(unused_imports)]
    use super::*;

    /// The index configuration for this field.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IndexConfig {
        /// The indexes supported for this field.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub indexes: std::vec::Vec<crate::model::Index>,

        /// Output only. When true, the `Field`'s index configuration is set from the
        /// configuration specified by the `ancestor_field`.
        /// When false, the `Field`'s index configuration is defined explicitly.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub uses_ancestor_config: bool,

        /// Output only. Specifies the resource name of the `Field` from which this
        /// field's index configuration is set (when `uses_ancestor_config` is true),
        /// or from which it *would* be set if this field had no index configuration
        /// (when `uses_ancestor_config` is false).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub ancestor_field: std::string::String,

        /// Output only
        /// When true, the `Field`'s index configuration is in the process of being
        /// reverted. Once complete, the index config will transition to the same
        /// state as the field specified by `ancestor_field`, at which point
        /// `uses_ancestor_config` will be `true` and `reverting` will be `false`.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub reverting: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IndexConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [indexes][crate::model::field::IndexConfig::indexes].
        pub fn set_indexes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Index>,
        {
            use std::iter::Iterator;
            self.indexes = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [uses_ancestor_config][crate::model::field::IndexConfig::uses_ancestor_config].
        pub fn set_uses_ancestor_config<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.uses_ancestor_config = v.into();
            self
        }

        /// Sets the value of [ancestor_field][crate::model::field::IndexConfig::ancestor_field].
        pub fn set_ancestor_field<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ancestor_field = v.into();
            self
        }

        /// Sets the value of [reverting][crate::model::field::IndexConfig::reverting].
        pub fn set_reverting<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.reverting = v.into();
            self
        }
    }

    impl wkt::message::Message for IndexConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Field.IndexConfig"
        }
    }

    /// The TTL (time-to-live) configuration for documents that have this `Field`
    /// set.
    ///
    /// Storing a timestamp value into a TTL-enabled field will be treated as
    /// the document's absolute expiration time. Timestamp values in the past
    /// indicate that the document is eligible for immediate expiration. Using any
    /// other data type or leaving the field absent will disable expiration for the
    /// individual document.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TtlConfig {
        /// Output only. The state of the TTL configuration.
        pub state: crate::model::field::ttl_config::State,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TtlConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::field::TtlConfig::state].
        pub fn set_state<T: std::convert::Into<crate::model::field::ttl_config::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }
    }

    impl wkt::message::Message for TtlConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Field.TtlConfig"
        }
    }

    /// Defines additional types related to [TtlConfig].
    pub mod ttl_config {
        #[allow(unused_imports)]
        use super::*;

        /// The state of applying the TTL configuration to all documents.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// The state is unspecified or unknown.
            Unspecified,
            /// The TTL is being applied. There is an active long-running operation to
            /// track the change. Newly written documents will have TTLs applied as
            /// requested. Requested TTLs on existing documents are still being
            /// processed. When TTLs on all existing documents have been processed, the
            /// state will move to 'ACTIVE'.
            Creating,
            /// The TTL is active for all documents.
            Active,
            /// The TTL configuration could not be enabled for all existing documents.
            /// Newly written documents will continue to have their TTL applied.
            /// The LRO returned when last attempting to enable TTL for this `Field`
            /// has failed, and may have more details.
            NeedsRepair,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Creating => std::option::Option::Some(1),
                    Self::Active => std::option::Option::Some(2),
                    Self::NeedsRepair => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Creating => std::option::Option::Some("CREATING"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::NeedsRepair => std::option::Option::Some("NEEDS_REPAIR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Creating,
                    2 => Self::Active,
                    3 => Self::NeedsRepair,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "CREATING" => Self::Creating,
                    "ACTIVE" => Self::Active,
                    "NEEDS_REPAIR" => Self::NeedsRepair,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Creating => serializer.serialize_i32(1),
                    Self::Active => serializer.serialize_i32(2),
                    Self::NeedsRepair => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.firestore.admin.v1.Field.TtlConfig.State",
                ))
            }
        }
    }
}

/// A request to list the Firestore Databases in all locations for a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatabasesRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// If true, also returns deleted resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub show_deleted: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatabasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListDatabasesRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListDatabasesRequest"
    }
}

/// The request for
/// [FirestoreAdmin.CreateDatabase][google.firestore.admin.v1.FirestoreAdmin.CreateDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateDatabase]: crate::client::FirestoreAdmin::create_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatabaseRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Database to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub database: std::option::Option<crate::model::Database>,

    /// Required. The ID to use for the database, which will become the final
    /// component of the database's resource name.
    ///
    /// This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/
    /// with first character a letter and the last a letter or a number. Must not
    /// be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.
    ///
    /// "(default)" database ID is also valid.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatabaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [database][crate::model::CreateDatabaseRequest::database].
    pub fn set_database<T: std::convert::Into<std::option::Option<crate::model::Database>>>(
        mut self,
        v: T,
    ) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [database_id][crate::model::CreateDatabaseRequest::database_id].
    pub fn set_database_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateDatabaseRequest"
    }
}

/// Metadata related to the create database operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatabaseMetadata {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CreateDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateDatabaseMetadata"
    }
}

/// The list of databases for a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatabasesResponse {
    /// The databases in the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub databases: std::vec::Vec<crate::model::Database>,

    /// In the event that data about individual databases cannot be listed they
    /// will be recorded here.
    ///
    /// An example entry might be: projects/some_project/locations/some_location
    /// This can happen if the Cloud Region that the Database resides in is
    /// currently unavailable.  In this case we can't fetch all the details about
    /// the database. You may be able to get a more detailed error message
    /// (or possibly fetch the resource) by sending a 'Get' request for the
    /// resource or a 'List' request for the specific location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [databases][crate::model::ListDatabasesResponse::databases].
    pub fn set_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Database>,
    {
        use std::iter::Iterator;
        self.databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDatabasesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListDatabasesResponse"
    }
}

/// The request for
/// [FirestoreAdmin.GetDatabase][google.firestore.admin.v1.FirestoreAdmin.GetDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetDatabase]: crate::client::FirestoreAdmin::get_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDatabaseRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetDatabaseRequest"
    }
}

/// The request for
/// [FirestoreAdmin.UpdateDatabase][google.firestore.admin.v1.FirestoreAdmin.UpdateDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateDatabase]: crate::client::FirestoreAdmin::update_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDatabaseRequest {
    /// Required. The database to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub database: std::option::Option<crate::model::Database>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::UpdateDatabaseRequest::database].
    pub fn set_database<T: std::convert::Into<std::option::Option<crate::model::Database>>>(
        mut self,
        v: T,
    ) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDatabaseRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateDatabaseRequest"
    }
}

/// Metadata related to the update database operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDatabaseMetadata {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UpdateDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateDatabaseMetadata"
    }
}

/// The request for
/// [FirestoreAdmin.DeleteDatabase][google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase]: crate::client::FirestoreAdmin::delete_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatabaseRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The current etag of the Database.
    /// If an etag is provided and does not match the current etag of the database,
    /// deletion will be blocked and a FAILED_PRECONDITION error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDatabaseRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteDatabaseRequest"
    }
}

/// Metadata related to the delete database operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatabaseMetadata {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DeleteDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteDatabaseMetadata"
    }
}

/// The request for
/// [FirestoreAdmin.CreateUserCreds][google.firestore.admin.v1.FirestoreAdmin.CreateUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateUserCreds]: crate::client::FirestoreAdmin::create_user_creds
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateUserCredsRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}/databases/{database_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The user creds to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_creds: std::option::Option<crate::model::UserCreds>,

    /// Required. The ID to use for the user creds, which will become the final
    /// component of the user creds's resource name.
    ///
    /// This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/
    /// with first character a letter and the last a letter or a number. Must not
    /// be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_creds_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUserCredsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_creds][crate::model::CreateUserCredsRequest::user_creds].
    pub fn set_user_creds<T: std::convert::Into<std::option::Option<crate::model::UserCreds>>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_creds = v.into();
        self
    }

    /// Sets the value of [user_creds_id][crate::model::CreateUserCredsRequest::user_creds_id].
    pub fn set_user_creds_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_creds_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateUserCredsRequest"
    }
}

/// The request for
/// [FirestoreAdmin.GetUserCreds][google.firestore.admin.v1.FirestoreAdmin.GetUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetUserCreds]: crate::client::FirestoreAdmin::get_user_creds
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetUserCredsRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/userCreds/{user_creds_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUserCredsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetUserCredsRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ListUserCreds][google.firestore.admin.v1.FirestoreAdmin.ListUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListUserCreds]: crate::client::FirestoreAdmin::list_user_creds
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUserCredsRequest {
    /// Required. A parent database name of the form
    /// `projects/{project_id}/databases/{database_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUserCredsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListUserCredsRequest"
    }
}

/// The response for
/// [FirestoreAdmin.ListUserCreds][google.firestore.admin.v1.FirestoreAdmin.ListUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListUserCreds]: crate::client::FirestoreAdmin::list_user_creds
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUserCredsResponse {
    /// The user creds for the database.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub user_creds: std::vec::Vec<crate::model::UserCreds>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUserCredsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_creds][crate::model::ListUserCredsResponse::user_creds].
    pub fn set_user_creds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserCreds>,
    {
        use std::iter::Iterator;
        self.user_creds = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUserCredsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListUserCredsResponse"
    }
}

/// The request for
/// [FirestoreAdmin.EnableUserCreds][google.firestore.admin.v1.FirestoreAdmin.EnableUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.EnableUserCreds]: crate::client::FirestoreAdmin::enable_user_creds
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnableUserCredsRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/userCreds/{user_creds_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnableUserCredsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EnableUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.EnableUserCredsRequest"
    }
}

/// The request for
/// [FirestoreAdmin.DisableUserCreds][google.firestore.admin.v1.FirestoreAdmin.DisableUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DisableUserCreds]: crate::client::FirestoreAdmin::disable_user_creds
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DisableUserCredsRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/userCreds/{user_creds_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DisableUserCredsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DisableUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DisableUserCredsRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ResetUserPassword][google.firestore.admin.v1.FirestoreAdmin.ResetUserPassword].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ResetUserPassword]: crate::client::FirestoreAdmin::reset_user_password
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResetUserPasswordRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/userCreds/{user_creds_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetUserPasswordRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetUserPasswordRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResetUserPasswordRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ResetUserPasswordRequest"
    }
}

/// The request for
/// [FirestoreAdmin.DeleteUserCreds][google.firestore.admin.v1.FirestoreAdmin.DeleteUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteUserCreds]: crate::client::FirestoreAdmin::delete_user_creds
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteUserCredsRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/userCreds/{user_creds_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserCredsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteUserCredsRequest"
    }
}

/// The request for
/// [FirestoreAdmin.CreateBackupSchedule][google.firestore.admin.v1.FirestoreAdmin.CreateBackupSchedule].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateBackupSchedule]: crate::client::FirestoreAdmin::create_backup_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupScheduleRequest {
    /// Required. The parent database.
    ///
    /// Format `projects/{project}/databases/{database}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The backup schedule to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_schedule: std::option::Option<crate::model::BackupSchedule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupScheduleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_schedule][crate::model::CreateBackupScheduleRequest::backup_schedule].
    pub fn set_backup_schedule<
        T: std::convert::Into<std::option::Option<crate::model::BackupSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_schedule = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateBackupScheduleRequest"
    }
}

/// The request for
/// [FirestoreAdmin.GetBackupSchedule][google.firestore.admin.v1.FirestoreAdmin.GetBackupSchedule].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetBackupSchedule]: crate::client::FirestoreAdmin::get_backup_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupScheduleRequest {
    /// Required. The name of the backup schedule.
    ///
    /// Format
    /// `projects/{project}/databases/{database}/backupSchedules/{backup_schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetBackupScheduleRequest"
    }
}

/// The request for
/// [FirestoreAdmin.UpdateBackupSchedule][google.firestore.admin.v1.FirestoreAdmin.UpdateBackupSchedule].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateBackupSchedule]: crate::client::FirestoreAdmin::update_backup_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupScheduleRequest {
    /// Required. The backup schedule to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_schedule: std::option::Option<crate::model::BackupSchedule>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_schedule][crate::model::UpdateBackupScheduleRequest::backup_schedule].
    pub fn set_backup_schedule<
        T: std::convert::Into<std::option::Option<crate::model::BackupSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_schedule = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupScheduleRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateBackupScheduleRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ListBackupSchedules][google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules]: crate::client::FirestoreAdmin::list_backup_schedules
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupSchedulesRequest {
    /// Required. The parent database.
    ///
    /// Format is `projects/{project}/databases/{database}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupSchedulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupSchedulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupSchedulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupSchedulesRequest"
    }
}

/// The response for
/// [FirestoreAdmin.ListBackupSchedules][google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules]: crate::client::FirestoreAdmin::list_backup_schedules
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupSchedulesResponse {
    /// List of all backup schedules.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_schedules: std::vec::Vec<crate::model::BackupSchedule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupSchedulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_schedules][crate::model::ListBackupSchedulesResponse::backup_schedules].
    pub fn set_backup_schedules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupSchedule>,
    {
        use std::iter::Iterator;
        self.backup_schedules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupSchedulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupSchedulesResponse"
    }
}

/// The request for [FirestoreAdmin.DeleteBackupSchedules][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupScheduleRequest {
    /// Required. The name of the backup schedule.
    ///
    /// Format
    /// `projects/{project}/databases/{database}/backupSchedules/{backup_schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteBackupScheduleRequest"
    }
}

/// The request for
/// [FirestoreAdmin.CreateIndex][google.firestore.admin.v1.FirestoreAdmin.CreateIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateIndex]: crate::client::FirestoreAdmin::create_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The composite index to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index: std::option::Option<crate::model::Index>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIndexRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [index][crate::model::CreateIndexRequest::index].
    pub fn set_index<T: std::convert::Into<std::option::Option<crate::model::Index>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index = v.into();
        self
    }
}

impl wkt::message::Message for CreateIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateIndexRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ListIndexes][google.firestore.admin.v1.FirestoreAdmin.ListIndexes].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListIndexes]: crate::client::FirestoreAdmin::list_indexes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The filter to apply to list results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The number of results to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, returned from a previous call to
    /// [FirestoreAdmin.ListIndexes][google.firestore.admin.v1.FirestoreAdmin.ListIndexes],
    /// that may be used to get the next page of results.
    ///
    /// [google.firestore.admin.v1.FirestoreAdmin.ListIndexes]: crate::client::FirestoreAdmin::list_indexes
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIndexesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIndexesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListIndexesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIndexesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIndexesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListIndexesRequest"
    }
}

/// The response for
/// [FirestoreAdmin.ListIndexes][google.firestore.admin.v1.FirestoreAdmin.ListIndexes].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListIndexes]: crate::client::FirestoreAdmin::list_indexes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesResponse {
    /// The requested indexes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub indexes: std::vec::Vec<crate::model::Index>,

    /// A page token that may be used to request another page of results. If blank,
    /// this is the last page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIndexesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [indexes][crate::model::ListIndexesResponse::indexes].
    pub fn set_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Index>,
    {
        use std::iter::Iterator;
        self.indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListIndexesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListIndexesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIndexesResponse {
    type PageItem = crate::model::Index;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.indexes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [FirestoreAdmin.GetIndex][google.firestore.admin.v1.FirestoreAdmin.GetIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetIndex]: crate::client::FirestoreAdmin::get_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIndexRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIndexRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetIndexRequest"
    }
}

/// The request for
/// [FirestoreAdmin.DeleteIndex][google.firestore.admin.v1.FirestoreAdmin.DeleteIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteIndex]: crate::client::FirestoreAdmin::delete_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIndexRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIndexRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteIndexRequest"
    }
}

/// The request for
/// [FirestoreAdmin.UpdateField][google.firestore.admin.v1.FirestoreAdmin.UpdateField].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateField]: crate::client::FirestoreAdmin::update_field
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFieldRequest {
    /// Required. The field to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<crate::model::Field>,

    /// A mask, relative to the field. If specified, only configuration specified
    /// by this field_mask will be updated in the field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::UpdateFieldRequest::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::Field>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFieldRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateFieldRequest"
    }
}

/// The request for
/// [FirestoreAdmin.GetField][google.firestore.admin.v1.FirestoreAdmin.GetField].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetField]: crate::client::FirestoreAdmin::get_field
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFieldRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetFieldRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFieldsRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The filter to apply to list results. Currently,
    /// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields]
    /// only supports listing fields that have been explicitly overridden. To issue
    /// this query, call
    /// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields]
    /// with a filter that includes `indexConfig.usesAncestorConfig:false` or
    /// `ttlConfig:*`.
    ///
    /// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The number of results to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, returned from a previous call to
    /// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields],
    /// that may be used to get the next page of results.
    ///
    /// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFieldsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFieldsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFieldsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFieldsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFieldsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFieldsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListFieldsRequest"
    }
}

/// The response for
/// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFieldsResponse {
    /// The requested fields.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<crate::model::Field>,

    /// A page token that may be used to request another page of results. If blank,
    /// this is the last page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFieldsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fields][crate::model::ListFieldsResponse::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Field>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFieldsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFieldsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListFieldsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFieldsResponse {
    type PageItem = crate::model::Field;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.fields
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [FirestoreAdmin.ExportDocuments][google.firestore.admin.v1.FirestoreAdmin.ExportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ExportDocuments]: crate::client::FirestoreAdmin::export_documents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDocumentsRequest {
    /// Required. Database to export. Should be of the form:
    /// `projects/{project_id}/databases/{database_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Which collection IDs to export. Unspecified means all collections. Each
    /// collection ID in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// The output URI. Currently only supports Google Cloud Storage URIs of the
    /// form: `gs://BUCKET_NAME[/NAMESPACE_PATH]`, where `BUCKET_NAME` is the name
    /// of the Google Cloud Storage bucket and `NAMESPACE_PATH` is an optional
    /// Google Cloud Storage namespace path. When
    /// choosing a name, be sure to consider Google Cloud Storage naming
    /// guidelines: <https://cloud.google.com/storage/docs/naming>.
    /// If the URI is a bucket (without a namespace path), a prefix will be
    /// generated based on the start time.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri_prefix: std::string::String,

    /// An empty list represents all namespaces. This is the preferred
    /// usage for databases that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the database has data in non-default namespaces, but doesn't want
    /// to include them. Each namespace in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,

    /// The timestamp that corresponds to the version of the database to be
    /// exported. The timestamp must be in the past, rounded to the minute and not
    /// older than
    /// [earliestVersionTime][google.firestore.admin.v1.Database.earliest_version_time].
    /// If specified, then the exported documents will represent a consistent view
    /// of the database at the provided time. Otherwise, there are no guarantees
    /// about the consistency of the exported documents.
    ///
    /// [google.firestore.admin.v1.Database.earliest_version_time]: crate::model::Database::earliest_version_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportDocumentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::ExportDocumentsRequest::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [output_uri_prefix][crate::model::ExportDocumentsRequest::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ExportDocumentsRequest::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::ExportDocumentsRequest::snapshot_time].
    pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_time = v.into();
        self
    }
}

impl wkt::message::Message for ExportDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ExportDocumentsRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ImportDocuments][google.firestore.admin.v1.FirestoreAdmin.ImportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ImportDocuments]: crate::client::FirestoreAdmin::import_documents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDocumentsRequest {
    /// Required. Database to import into. Should be of the form:
    /// `projects/{project_id}/databases/{database_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Which collection IDs to import. Unspecified means all collections included
    /// in the import. Each collection ID in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Location of the exported files.
    /// This must match the output_uri_prefix of an ExportDocumentsResponse from
    /// an export that has completed successfully.
    /// See:
    /// [google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix][google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix].
    ///
    /// [google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix]: crate::model::ExportDocumentsResponse::output_uri_prefix
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_uri_prefix: std::string::String,

    /// An empty list represents all namespaces. This is the preferred
    /// usage for databases that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the database has data in non-default namespaces, but doesn't want
    /// to include them. Each namespace in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportDocumentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::ImportDocumentsRequest::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [input_uri_prefix][crate::model::ImportDocumentsRequest::input_uri_prefix].
    pub fn set_input_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_uri_prefix = v.into();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ImportDocumentsRequest::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ImportDocumentsRequest"
    }
}

/// The request for
/// [FirestoreAdmin.BulkDeleteDocuments][google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments].
///
/// When both collection_ids and namespace_ids are set, only documents satisfying
/// both conditions will be deleted.
///
/// Requests with namespace_ids and collection_ids both empty will be rejected.
/// Please use
/// [FirestoreAdmin.DeleteDatabase][google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase]
/// instead.
///
/// [google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments]: crate::client::FirestoreAdmin::bulk_delete_documents
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase]: crate::client::FirestoreAdmin::delete_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDeleteDocumentsRequest {
    /// Required. Database to operate. Should be of the form:
    /// `projects/{project_id}/databases/{database_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. IDs of the collection groups to delete. Unspecified means all
    /// collection groups.
    ///
    /// Each collection group in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Optional. Namespaces to delete.
    ///
    /// An empty list means all namespaces. This is the recommended
    /// usage for databases that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the database has data in non-default namespaces, but doesn't want
    /// to delete from them.
    ///
    /// Each namespace in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BulkDeleteDocumentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::BulkDeleteDocumentsRequest::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::BulkDeleteDocumentsRequest::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BulkDeleteDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BulkDeleteDocumentsRequest"
    }
}

/// The response for
/// [FirestoreAdmin.BulkDeleteDocuments][google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments]: crate::client::FirestoreAdmin::bulk_delete_documents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDeleteDocumentsResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteDocumentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BulkDeleteDocumentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BulkDeleteDocumentsResponse"
    }
}

/// The request for
/// [FirestoreAdmin.GetBackup][google.firestore.admin.v1.FirestoreAdmin.GetBackup].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetBackup]: crate::client::FirestoreAdmin::get_backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Name of the backup to fetch.
    ///
    /// Format is `projects/{project}/locations/{location}/backups/{backup}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetBackupRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ListBackups][google.firestore.admin.v1.FirestoreAdmin.ListBackups].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackups]: crate::client::FirestoreAdmin::list_backups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The location to list backups from.
    ///
    /// Format is `projects/{project}/locations/{location}`.
    /// Use `{location} = '-'` to list backups from all locations for the given
    /// project. This allows listing backups from a single location or from all
    /// locations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// An expression that filters the list of returned backups.
    ///
    /// A filter expression consists of a field name, a comparison operator, and a
    /// value for filtering.
    /// The value must be a string, a number, or a boolean. The comparison operator
    /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
    /// Colon `:` is the contains operator. Filter rules are not case sensitive.
    ///
    /// The following fields in the [Backup][google.firestore.admin.v1.Backup] are
    /// eligible for filtering:
    ///
    /// * `database_uid` (supports `=` only)
    ///
    /// [google.firestore.admin.v1.Backup]: crate::model::Backup
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupsRequest"
    }
}

/// The response for
/// [FirestoreAdmin.ListBackups][google.firestore.admin.v1.FirestoreAdmin.ListBackups].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackups]: crate::client::FirestoreAdmin::list_backups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// List of all backups for the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// List of locations that existing backups were not able to be fetched from.
    ///
    /// Instead of failing the entire requests when a single location is
    /// unreachable, this response returns a partial result set and list of
    /// locations unable to be reached here. The request can be retried against a
    /// single location to get a concrete error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupsResponse"
    }
}

/// The request for
/// [FirestoreAdmin.DeleteBackup][google.firestore.admin.v1.FirestoreAdmin.DeleteBackup].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteBackup]: crate::client::FirestoreAdmin::delete_backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Name of the backup to delete.
    ///
    /// format is `projects/{project}/locations/{location}/backups/{backup}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteBackupRequest"
    }
}

/// The request message for
/// [FirestoreAdmin.RestoreDatabase][google.firestore.admin.v1.FirestoreAdmin.RestoreDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.RestoreDatabase]: crate::client::FirestoreAdmin::restore_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreDatabaseRequest {
    /// Required. The project to restore the database in. Format is
    /// `projects/{project_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to use for the database, which will become the final
    /// component of the database's resource name. This database ID must not be
    /// associated with an existing database.
    ///
    /// This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/
    /// with first character a letter and the last a letter or a number. Must not
    /// be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.
    ///
    /// "(default)" database ID is also valid.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_id: std::string::String,

    /// Required. Backup to restore from. Must be from the same project as the
    /// parent.
    ///
    /// The restored database will be created in the same location as the source
    /// backup.
    ///
    /// Format is: `projects/{project_id}/locations/{location}/backups/{backup}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup: std::string::String,

    /// Optional. Encryption configuration for the restored database.
    ///
    /// If this field is not specified, the restored database will use
    /// the same encryption configuration as the backup, namely
    /// [use_source_encryption][google.firestore.admin.v1.Database.EncryptionConfig.use_source_encryption].
    ///
    /// [google.firestore.admin.v1.Database.EncryptionConfig.use_source_encryption]: crate::model::database::EncryptionConfig::encryption_type
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::database::EncryptionConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RestoreDatabaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [database_id][crate::model::RestoreDatabaseRequest::database_id].
    pub fn set_database_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_id = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::RestoreDatabaseRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::RestoreDatabaseRequest::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::database::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }
}

impl wkt::message::Message for RestoreDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.RestoreDatabaseRequest"
    }
}

/// Cloud Firestore indexes enable simple and complex queries against
/// documents in a database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Index {
    /// Output only. A server defined name for this index.
    /// The form of this name for composite indexes will be:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{composite_index_id}`
    /// For single field indexes, this field will be empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Indexes with a collection query scope specified allow queries
    /// against a collection that is the child of a specific document, specified at
    /// query time, and that has the same collection ID.
    ///
    /// Indexes with a collection group query scope specified allow queries against
    /// all collections descended from a specific document, specified at query
    /// time, and that have the same collection ID as this index.
    pub query_scope: crate::model::index::QueryScope,

    /// The API scope supported by this index.
    pub api_scope: crate::model::index::ApiScope,

    /// The fields supported by this index.
    ///
    /// For composite indexes, this requires a minimum of 2 and a maximum of 100
    /// fields. The last field entry is always for the field path `__name__`. If,
    /// on creation, `__name__` was not specified as the last field, it will be
    /// added automatically with the same direction as that of the last field
    /// defined. If the final field in a composite index is not directional, the
    /// `__name__` will be ordered ASCENDING (unless explicitly specified).
    ///
    /// For single field indexes, this will always be exactly one entry with a
    /// field path equal to the field path of the associated field.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<crate::model::index::IndexField>,

    /// Output only. The serving state of the index.
    pub state: crate::model::index::State,

    /// Immutable. The density configuration of the index.
    pub density: crate::model::index::Density,

    /// Optional. Whether the index is multikey. By default, the index is not
    /// multikey. For non-multikey indexes, none of the paths in the index
    /// definition reach or traverse an array, except via an explicit array index.
    /// For multikey indexes, at most one of the paths in the index definition
    /// reach or traverse an array, except via an explicit array index. Violations
    /// will result in errors.
    ///
    /// Note this field only applies to index with MONGODB_COMPATIBLE_API ApiScope.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub multikey: bool,

    /// Optional. The number of shards for the index.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub shard_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Index {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Index::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [query_scope][crate::model::Index::query_scope].
    pub fn set_query_scope<T: std::convert::Into<crate::model::index::QueryScope>>(
        mut self,
        v: T,
    ) -> Self {
        self.query_scope = v.into();
        self
    }

    /// Sets the value of [api_scope][crate::model::Index::api_scope].
    pub fn set_api_scope<T: std::convert::Into<crate::model::index::ApiScope>>(
        mut self,
        v: T,
    ) -> Self {
        self.api_scope = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::Index::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::index::IndexField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::Index::state].
    pub fn set_state<T: std::convert::Into<crate::model::index::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [density][crate::model::Index::density].
    pub fn set_density<T: std::convert::Into<crate::model::index::Density>>(
        mut self,
        v: T,
    ) -> Self {
        self.density = v.into();
        self
    }

    /// Sets the value of [multikey][crate::model::Index::multikey].
    pub fn set_multikey<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.multikey = v.into();
        self
    }

    /// Sets the value of [shard_count][crate::model::Index::shard_count].
    pub fn set_shard_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.shard_count = v.into();
        self
    }
}

impl wkt::message::Message for Index {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Index"
    }
}

/// Defines additional types related to [Index].
pub mod index {
    #[allow(unused_imports)]
    use super::*;

    /// A field in an index.
    /// The field_path describes which field is indexed, the value_mode describes
    /// how the field value is indexed.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IndexField {
        /// Can be __name__.
        /// For single field indexes, this must match the name of the field or may
        /// be omitted.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub field_path: std::string::String,

        /// How the field value is indexed.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value_mode: std::option::Option<crate::model::index::index_field::ValueMode>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IndexField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field_path][crate::model::index::IndexField::field_path].
        pub fn set_field_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field_path = v.into();
            self
        }

        /// Sets the value of [value_mode][crate::model::index::IndexField::value_mode].
        ///
        /// Note that all the setters affecting `value_mode` are mutually
        /// exclusive.
        pub fn set_value_mode<
            T: std::convert::Into<std::option::Option<crate::model::index::index_field::ValueMode>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = v.into();
            self
        }

        /// The value of [value_mode][crate::model::index::IndexField::value_mode]
        /// if it holds a `Order`, `None` if the field is not set or
        /// holds a different branch.
        pub fn order(&self) -> std::option::Option<&crate::model::index::index_field::Order> {
            #[allow(unreachable_patterns)]
            self.value_mode.as_ref().and_then(|v| match v {
                crate::model::index::index_field::ValueMode::Order(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value_mode][crate::model::index::IndexField::value_mode]
        /// to hold a `Order`.
        ///
        /// Note that all the setters affecting `value_mode` are
        /// mutually exclusive.
        pub fn set_order<T: std::convert::Into<crate::model::index::index_field::Order>>(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = std::option::Option::Some(
                crate::model::index::index_field::ValueMode::Order(v.into()),
            );
            self
        }

        /// The value of [value_mode][crate::model::index::IndexField::value_mode]
        /// if it holds a `ArrayConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn array_config(
            &self,
        ) -> std::option::Option<&crate::model::index::index_field::ArrayConfig> {
            #[allow(unreachable_patterns)]
            self.value_mode.as_ref().and_then(|v| match v {
                crate::model::index::index_field::ValueMode::ArrayConfig(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value_mode][crate::model::index::IndexField::value_mode]
        /// to hold a `ArrayConfig`.
        ///
        /// Note that all the setters affecting `value_mode` are
        /// mutually exclusive.
        pub fn set_array_config<
            T: std::convert::Into<crate::model::index::index_field::ArrayConfig>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = std::option::Option::Some(
                crate::model::index::index_field::ValueMode::ArrayConfig(v.into()),
            );
            self
        }

        /// The value of [value_mode][crate::model::index::IndexField::value_mode]
        /// if it holds a `VectorConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn vector_config(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::index::index_field::VectorConfig>>
        {
            #[allow(unreachable_patterns)]
            self.value_mode.as_ref().and_then(|v| match v {
                crate::model::index::index_field::ValueMode::VectorConfig(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value_mode][crate::model::index::IndexField::value_mode]
        /// to hold a `VectorConfig`.
        ///
        /// Note that all the setters affecting `value_mode` are
        /// mutually exclusive.
        pub fn set_vector_config<
            T: std::convert::Into<std::boxed::Box<crate::model::index::index_field::VectorConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = std::option::Option::Some(
                crate::model::index::index_field::ValueMode::VectorConfig(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for IndexField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Index.IndexField"
        }
    }

    /// Defines additional types related to [IndexField].
    pub mod index_field {
        #[allow(unused_imports)]
        use super::*;

        /// The index configuration to support vector search operations
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct VectorConfig {
            /// Required. The vector dimension this configuration applies to.
            ///
            /// The resulting index will only include vectors of this dimension, and
            /// can be used for vector search with the same dimension.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub dimension: i32,

            /// The type of index used.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub r#type: std::option::Option<crate::model::index::index_field::vector_config::Type>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl VectorConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [dimension][crate::model::index::index_field::VectorConfig::dimension].
            pub fn set_dimension<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.dimension = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::index::index_field::VectorConfig::type].
            ///
            /// Note that all the setters affecting `r#type` are mutually
            /// exclusive.
            pub fn set_type<
                T: std::convert::Into<
                        std::option::Option<crate::model::index::index_field::vector_config::Type>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// The value of [r#type][crate::model::index::index_field::VectorConfig::r#type]
            /// if it holds a `Flat`, `None` if the field is not set or
            /// holds a different branch.
            pub fn flat(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::index::index_field::vector_config::FlatIndex>,
            > {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::index::index_field::vector_config::Type::Flat(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::index::index_field::VectorConfig::r#type]
            /// to hold a `Flat`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_flat<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::index::index_field::vector_config::FlatIndex>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::index::index_field::vector_config::Type::Flat(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for VectorConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Index.IndexField.VectorConfig"
            }
        }

        /// Defines additional types related to [VectorConfig].
        pub mod vector_config {
            #[allow(unused_imports)]
            use super::*;

            /// An index that stores vectors in a flat data structure, and supports
            /// exhaustive search.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct FlatIndex {
                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl FlatIndex {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for FlatIndex {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.firestore.admin.v1.Index.IndexField.VectorConfig.FlatIndex"
                }
            }

            /// The type of index used.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Type {
                /// Indicates the vector index is a flat index.
                Flat(std::boxed::Box<crate::model::index::index_field::vector_config::FlatIndex>),
            }
        }

        /// The supported orderings.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Order {
            /// The ordering is unspecified. Not a valid option.
            Unspecified,
            /// The field is ordered by ascending field value.
            Ascending,
            /// The field is ordered by descending field value.
            Descending,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Order::value] or
            /// [Order::name].
            UnknownValue(order::UnknownValue),
        }

        #[doc(hidden)]
        pub mod order {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Order {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Ascending => std::option::Option::Some(1),
                    Self::Descending => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ORDER_UNSPECIFIED"),
                    Self::Ascending => std::option::Option::Some("ASCENDING"),
                    Self::Descending => std::option::Option::Some("DESCENDING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Order {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Order {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Order {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Ascending,
                    2 => Self::Descending,
                    _ => Self::UnknownValue(order::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Order {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ORDER_UNSPECIFIED" => Self::Unspecified,
                    "ASCENDING" => Self::Ascending,
                    "DESCENDING" => Self::Descending,
                    _ => Self::UnknownValue(order::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Order {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Ascending => serializer.serialize_i32(1),
                    Self::Descending => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Order {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Order>::new(
                    ".google.firestore.admin.v1.Index.IndexField.Order",
                ))
            }
        }

        /// The supported array value configurations.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ArrayConfig {
            /// The index does not support additional array queries.
            Unspecified,
            /// The index supports array containment queries.
            Contains,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ArrayConfig::value] or
            /// [ArrayConfig::name].
            UnknownValue(array_config::UnknownValue),
        }

        #[doc(hidden)]
        pub mod array_config {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ArrayConfig {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Contains => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ARRAY_CONFIG_UNSPECIFIED"),
                    Self::Contains => std::option::Option::Some("CONTAINS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ArrayConfig {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ArrayConfig {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ArrayConfig {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Contains,
                    _ => Self::UnknownValue(array_config::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ArrayConfig {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ARRAY_CONFIG_UNSPECIFIED" => Self::Unspecified,
                    "CONTAINS" => Self::Contains,
                    _ => Self::UnknownValue(array_config::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ArrayConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Contains => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ArrayConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ArrayConfig>::new(
                    ".google.firestore.admin.v1.Index.IndexField.ArrayConfig",
                ))
            }
        }

        /// How the field value is indexed.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum ValueMode {
            /// Indicates that this field supports ordering by the specified order or
            /// comparing using =, !=, <, <=, >, >=.
            Order(crate::model::index::index_field::Order),
            /// Indicates that this field supports operations on `array_value`s.
            ArrayConfig(crate::model::index::index_field::ArrayConfig),
            /// Indicates that this field supports nearest neighbor and distance
            /// operations on vector.
            VectorConfig(std::boxed::Box<crate::model::index::index_field::VectorConfig>),
        }
    }

    /// Query Scope defines the scope at which a query is run. This is specified on
    /// a StructuredQuery's `from` field.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum QueryScope {
        /// The query scope is unspecified. Not a valid option.
        Unspecified,
        /// Indexes with a collection query scope specified allow queries
        /// against a collection that is the child of a specific document, specified
        /// at query time, and that has the collection ID specified by the index.
        Collection,
        /// Indexes with a collection group query scope specified allow queries
        /// against all collections that has the collection ID specified by the
        /// index.
        CollectionGroup,
        /// Include all the collections's ancestor in the index. Only available for
        /// Datastore Mode databases.
        CollectionRecursive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [QueryScope::value] or
        /// [QueryScope::name].
        UnknownValue(query_scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod query_scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl QueryScope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Collection => std::option::Option::Some(1),
                Self::CollectionGroup => std::option::Option::Some(2),
                Self::CollectionRecursive => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("QUERY_SCOPE_UNSPECIFIED"),
                Self::Collection => std::option::Option::Some("COLLECTION"),
                Self::CollectionGroup => std::option::Option::Some("COLLECTION_GROUP"),
                Self::CollectionRecursive => std::option::Option::Some("COLLECTION_RECURSIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for QueryScope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for QueryScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for QueryScope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Collection,
                2 => Self::CollectionGroup,
                3 => Self::CollectionRecursive,
                _ => Self::UnknownValue(query_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for QueryScope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "QUERY_SCOPE_UNSPECIFIED" => Self::Unspecified,
                "COLLECTION" => Self::Collection,
                "COLLECTION_GROUP" => Self::CollectionGroup,
                "COLLECTION_RECURSIVE" => Self::CollectionRecursive,
                _ => Self::UnknownValue(query_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for QueryScope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Collection => serializer.serialize_i32(1),
                Self::CollectionGroup => serializer.serialize_i32(2),
                Self::CollectionRecursive => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for QueryScope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<QueryScope>::new(
                ".google.firestore.admin.v1.Index.QueryScope",
            ))
        }
    }

    /// API Scope defines the APIs (Firestore Native, or Firestore in
    /// Datastore Mode) that are supported for queries.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ApiScope {
        /// The index can only be used by the Firestore Native query API.
        /// This is the default.
        AnyApi,
        /// The index can only be used by the Firestore in Datastore Mode query API.
        DatastoreModeApi,
        /// The index can only be used by the MONGODB_COMPATIBLE_API.
        MongodbCompatibleApi,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ApiScope::value] or
        /// [ApiScope::name].
        UnknownValue(api_scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod api_scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ApiScope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::AnyApi => std::option::Option::Some(0),
                Self::DatastoreModeApi => std::option::Option::Some(1),
                Self::MongodbCompatibleApi => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::AnyApi => std::option::Option::Some("ANY_API"),
                Self::DatastoreModeApi => std::option::Option::Some("DATASTORE_MODE_API"),
                Self::MongodbCompatibleApi => std::option::Option::Some("MONGODB_COMPATIBLE_API"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ApiScope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ApiScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ApiScope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::AnyApi,
                1 => Self::DatastoreModeApi,
                2 => Self::MongodbCompatibleApi,
                _ => Self::UnknownValue(api_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ApiScope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANY_API" => Self::AnyApi,
                "DATASTORE_MODE_API" => Self::DatastoreModeApi,
                "MONGODB_COMPATIBLE_API" => Self::MongodbCompatibleApi,
                _ => Self::UnknownValue(api_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ApiScope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::AnyApi => serializer.serialize_i32(0),
                Self::DatastoreModeApi => serializer.serialize_i32(1),
                Self::MongodbCompatibleApi => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ApiScope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ApiScope>::new(
                ".google.firestore.admin.v1.Index.ApiScope",
            ))
        }
    }

    /// The state of an index. During index creation, an index will be in the
    /// `CREATING` state. If the index is created successfully, it will transition
    /// to the `READY` state. If the index creation encounters a problem, the index
    /// will transition to the `NEEDS_REPAIR` state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unspecified.
        Unspecified,
        /// The index is being created.
        /// There is an active long-running operation for the index.
        /// The index is updated when writing a document.
        /// Some index data may exist.
        Creating,
        /// The index is ready to be used.
        /// The index is updated when writing a document.
        /// The index is fully populated from all stored documents it applies to.
        Ready,
        /// The index was being created, but something went wrong.
        /// There is no active long-running operation for the index,
        /// and the most recently finished long-running operation failed.
        /// The index is not updated when writing a document.
        /// Some index data may exist.
        /// Use the google.longrunning.Operations API to determine why the operation
        /// that last attempted to create this index failed, then re-create the
        /// index.
        NeedsRepair,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::NeedsRepair => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::NeedsRepair => std::option::Option::Some("NEEDS_REPAIR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::NeedsRepair,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "NEEDS_REPAIR" => Self::NeedsRepair,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::NeedsRepair => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.firestore.admin.v1.Index.State",
            ))
        }
    }

    /// The density configuration for the index.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Density {
        /// Unspecified. It will use database default setting. This value is input
        /// only.
        Unspecified,
        /// In order for an index entry to be added, the document must
        /// contain all fields specified in the index.
        ///
        /// This is the only allowed value for indexes having ApiScope `ANY_API` and
        /// `DATASTORE_MODE_API`.
        SparseAll,
        /// In order for an index entry to be added, the document must
        /// contain at least one of the fields specified in the index.
        /// Non-existent fields are treated as having a NULL value when generating
        /// index entries.
        SparseAny,
        /// An index entry will be added regardless of whether the
        /// document contains any of the fields specified in the index.
        /// Non-existent fields are treated as having a NULL value when generating
        /// index entries.
        Dense,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Density::value] or
        /// [Density::name].
        UnknownValue(density::UnknownValue),
    }

    #[doc(hidden)]
    pub mod density {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Density {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SparseAll => std::option::Option::Some(1),
                Self::SparseAny => std::option::Option::Some(2),
                Self::Dense => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DENSITY_UNSPECIFIED"),
                Self::SparseAll => std::option::Option::Some("SPARSE_ALL"),
                Self::SparseAny => std::option::Option::Some("SPARSE_ANY"),
                Self::Dense => std::option::Option::Some("DENSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Density {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Density {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Density {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SparseAll,
                2 => Self::SparseAny,
                3 => Self::Dense,
                _ => Self::UnknownValue(density::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Density {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DENSITY_UNSPECIFIED" => Self::Unspecified,
                "SPARSE_ALL" => Self::SparseAll,
                "SPARSE_ANY" => Self::SparseAny,
                "DENSE" => Self::Dense,
                _ => Self::UnknownValue(density::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Density {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SparseAll => serializer.serialize_i32(1),
                Self::SparseAny => serializer.serialize_i32(2),
                Self::Dense => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Density {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Density>::new(
                ".google.firestore.admin.v1.Index.Density",
            ))
        }
    }
}

/// The metadata message for
/// [google.cloud.location.Location.metadata][google.cloud.location.Location.metadata].
///
/// [google.cloud.location.Location.metadata]: location::model::Location::metadata
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.LocationMetadata"
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.CreateIndex][google.firestore.admin.v1.FirestoreAdmin.CreateIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateIndex]: crate::client::FirestoreAdmin::create_index
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexOperationMetadata {
    /// The time this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The index resource that this operation is acting on. For example:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index: std::string::String,

    /// The state of the operation.
    pub state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::IndexOperationMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::IndexOperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [index][crate::model::IndexOperationMetadata::index].
    pub fn set_index<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [state][crate::model::IndexOperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::IndexOperationMetadata::progress_documents].
    pub fn set_progress_documents<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_documents = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::IndexOperationMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }
}

impl wkt::message::Message for IndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.IndexOperationMetadata"
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.UpdateField][google.firestore.admin.v1.FirestoreAdmin.UpdateField].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateField]: crate::client::FirestoreAdmin::update_field
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FieldOperationMetadata {
    /// The time this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The field resource that this operation is acting on. For example:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_path}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field: std::string::String,

    /// A list of
    /// [IndexConfigDelta][google.firestore.admin.v1.FieldOperationMetadata.IndexConfigDelta],
    /// which describe the intent of this operation.
    ///
    /// [google.firestore.admin.v1.FieldOperationMetadata.IndexConfigDelta]: crate::model::field_operation_metadata::IndexConfigDelta
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub index_config_deltas:
        std::vec::Vec<crate::model::field_operation_metadata::IndexConfigDelta>,

    /// The state of the operation.
    pub state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Describes the deltas of TTL configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ttl_config_delta:
        std::option::Option<crate::model::field_operation_metadata::TtlConfigDelta>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FieldOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::FieldOperationMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::FieldOperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [field][crate::model::FieldOperationMetadata::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [index_config_deltas][crate::model::FieldOperationMetadata::index_config_deltas].
    pub fn set_index_config_deltas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::field_operation_metadata::IndexConfigDelta>,
    {
        use std::iter::Iterator;
        self.index_config_deltas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::FieldOperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::FieldOperationMetadata::progress_documents].
    pub fn set_progress_documents<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_documents = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::FieldOperationMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [ttl_config_delta][crate::model::FieldOperationMetadata::ttl_config_delta].
    pub fn set_ttl_config_delta<
        T: std::convert::Into<
                std::option::Option<crate::model::field_operation_metadata::TtlConfigDelta>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ttl_config_delta = v.into();
        self
    }
}

impl wkt::message::Message for FieldOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.FieldOperationMetadata"
    }
}

/// Defines additional types related to [FieldOperationMetadata].
pub mod field_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Information about an index configuration change.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IndexConfigDelta {
        /// Specifies how the index is changing.
        pub change_type: crate::model::field_operation_metadata::index_config_delta::ChangeType,

        /// The index being changed.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub index: std::option::Option<crate::model::Index>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IndexConfigDelta {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [change_type][crate::model::field_operation_metadata::IndexConfigDelta::change_type].
        pub fn set_change_type<
            T: std::convert::Into<
                    crate::model::field_operation_metadata::index_config_delta::ChangeType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.change_type = v.into();
            self
        }

        /// Sets the value of [index][crate::model::field_operation_metadata::IndexConfigDelta::index].
        pub fn set_index<T: std::convert::Into<std::option::Option<crate::model::Index>>>(
            mut self,
            v: T,
        ) -> Self {
            self.index = v.into();
            self
        }
    }

    impl wkt::message::Message for IndexConfigDelta {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.FieldOperationMetadata.IndexConfigDelta"
        }
    }

    /// Defines additional types related to [IndexConfigDelta].
    pub mod index_config_delta {
        #[allow(unused_imports)]
        use super::*;

        /// Specifies how the index is changing.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ChangeType {
            /// The type of change is not specified or known.
            Unspecified,
            /// The single field index is being added.
            Add,
            /// The single field index is being removed.
            Remove,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ChangeType::value] or
            /// [ChangeType::name].
            UnknownValue(change_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod change_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ChangeType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Add => std::option::Option::Some(1),
                    Self::Remove => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CHANGE_TYPE_UNSPECIFIED"),
                    Self::Add => std::option::Option::Some("ADD"),
                    Self::Remove => std::option::Option::Some("REMOVE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ChangeType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ChangeType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ChangeType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Add,
                    2 => Self::Remove,
                    _ => Self::UnknownValue(change_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ChangeType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CHANGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "ADD" => Self::Add,
                    "REMOVE" => Self::Remove,
                    _ => Self::UnknownValue(change_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ChangeType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Add => serializer.serialize_i32(1),
                    Self::Remove => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ChangeType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ChangeType>::new(
                    ".google.firestore.admin.v1.FieldOperationMetadata.IndexConfigDelta.ChangeType",
                ))
            }
        }
    }

    /// Information about a TTL configuration change.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TtlConfigDelta {
        /// Specifies how the TTL configuration is changing.
        pub change_type: crate::model::field_operation_metadata::ttl_config_delta::ChangeType,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TtlConfigDelta {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [change_type][crate::model::field_operation_metadata::TtlConfigDelta::change_type].
        pub fn set_change_type<
            T: std::convert::Into<
                    crate::model::field_operation_metadata::ttl_config_delta::ChangeType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.change_type = v.into();
            self
        }
    }

    impl wkt::message::Message for TtlConfigDelta {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.FieldOperationMetadata.TtlConfigDelta"
        }
    }

    /// Defines additional types related to [TtlConfigDelta].
    pub mod ttl_config_delta {
        #[allow(unused_imports)]
        use super::*;

        /// Specifies how the TTL config is changing.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ChangeType {
            /// The type of change is not specified or known.
            Unspecified,
            /// The TTL config is being added.
            Add,
            /// The TTL config is being removed.
            Remove,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ChangeType::value] or
            /// [ChangeType::name].
            UnknownValue(change_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod change_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ChangeType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Add => std::option::Option::Some(1),
                    Self::Remove => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CHANGE_TYPE_UNSPECIFIED"),
                    Self::Add => std::option::Option::Some("ADD"),
                    Self::Remove => std::option::Option::Some("REMOVE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ChangeType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ChangeType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ChangeType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Add,
                    2 => Self::Remove,
                    _ => Self::UnknownValue(change_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ChangeType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CHANGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "ADD" => Self::Add,
                    "REMOVE" => Self::Remove,
                    _ => Self::UnknownValue(change_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ChangeType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Add => serializer.serialize_i32(1),
                    Self::Remove => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ChangeType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ChangeType>::new(
                    ".google.firestore.admin.v1.FieldOperationMetadata.TtlConfigDelta.ChangeType",
                ))
            }
        }
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.ExportDocuments][google.firestore.admin.v1.FirestoreAdmin.ExportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ExportDocuments]: crate::client::FirestoreAdmin::export_documents
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDocumentsMetadata {
    /// The time this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The state of the export operation.
    pub operation_state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Which collection IDs are being exported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Where the documents are being exported to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri_prefix: std::string::String,

    /// Which namespace IDs are being exported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,

    /// The timestamp that corresponds to the version of the database that is being
    /// exported. If unspecified, there are no guarantees about the consistency of
    /// the documents being exported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportDocumentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::ExportDocumentsMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ExportDocumentsMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [operation_state][crate::model::ExportDocumentsMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::ExportDocumentsMetadata::progress_documents].
    pub fn set_progress_documents<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_documents = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ExportDocumentsMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::ExportDocumentsMetadata::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [output_uri_prefix][crate::model::ExportDocumentsMetadata::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ExportDocumentsMetadata::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::ExportDocumentsMetadata::snapshot_time].
    pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_time = v.into();
        self
    }
}

impl wkt::message::Message for ExportDocumentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ExportDocumentsMetadata"
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.ImportDocuments][google.firestore.admin.v1.FirestoreAdmin.ImportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ImportDocuments]: crate::client::FirestoreAdmin::import_documents
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDocumentsMetadata {
    /// The time this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The state of the import operation.
    pub operation_state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Which collection IDs are being imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// The location of the documents being imported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_uri_prefix: std::string::String,

    /// Which namespace IDs are being imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportDocumentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::ImportDocumentsMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ImportDocumentsMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [operation_state][crate::model::ImportDocumentsMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::ImportDocumentsMetadata::progress_documents].
    pub fn set_progress_documents<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_documents = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ImportDocumentsMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::ImportDocumentsMetadata::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [input_uri_prefix][crate::model::ImportDocumentsMetadata::input_uri_prefix].
    pub fn set_input_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_uri_prefix = v.into();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ImportDocumentsMetadata::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportDocumentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ImportDocumentsMetadata"
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.BulkDeleteDocuments][google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments]: crate::client::FirestoreAdmin::bulk_delete_documents
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDeleteDocumentsMetadata {
    /// The time this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The state of the operation.
    pub operation_state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// The IDs of the collection groups that are being deleted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Which namespace IDs are being deleted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,

    /// The timestamp that corresponds to the version of the database that is being
    /// read to get the list of documents to delete. This time can also be used as
    /// the timestamp of PITR in case of disaster recovery (subject to PITR window
    /// limit).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteDocumentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::BulkDeleteDocumentsMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BulkDeleteDocumentsMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [operation_state][crate::model::BulkDeleteDocumentsMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::BulkDeleteDocumentsMetadata::progress_documents].
    pub fn set_progress_documents<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_documents = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::BulkDeleteDocumentsMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::BulkDeleteDocumentsMetadata::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::BulkDeleteDocumentsMetadata::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::BulkDeleteDocumentsMetadata::snapshot_time].
    pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_time = v.into();
        self
    }
}

impl wkt::message::Message for BulkDeleteDocumentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BulkDeleteDocumentsMetadata"
    }
}

/// Returned in the [google.longrunning.Operation][google.longrunning.Operation]
/// response field.
///
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDocumentsResponse {
    /// Location of the output files. This can be used to begin an import
    /// into Cloud Firestore (this project or another project) after the operation
    /// completes successfully.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri_prefix: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportDocumentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri_prefix][crate::model::ExportDocumentsResponse::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }
}

impl wkt::message::Message for ExportDocumentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ExportDocumentsResponse"
    }
}

/// Metadata for the [long-running operation][google.longrunning.Operation] from
/// the [RestoreDatabase][google.firestore.admin.v1.RestoreDatabase] request.
///
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreDatabaseMetadata {
    /// The time the restore was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the restore finished, unset for ongoing restores.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The operation state of the restore.
    pub operation_state: crate::model::OperationState,

    /// The name of the database being restored to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// The name of the backup restoring from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup: std::string::String,

    /// How far along the restore is as an estimated percentage of remaining time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_percentage: std::option::Option<crate::model::Progress>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::RestoreDatabaseMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::RestoreDatabaseMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [operation_state][crate::model::RestoreDatabaseMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [database][crate::model::RestoreDatabaseMetadata::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::RestoreDatabaseMetadata::backup].
    pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [progress_percentage][crate::model::RestoreDatabaseMetadata::progress_percentage].
    pub fn set_progress_percentage<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_percentage = v.into();
        self
    }
}

impl wkt::message::Message for RestoreDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.RestoreDatabaseMetadata"
    }
}

/// Describes the progress of the operation.
/// Unit of work is generic and must be interpreted based on where
/// [Progress][google.firestore.admin.v1.Progress] is used.
///
/// [google.firestore.admin.v1.Progress]: crate::model::Progress
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Progress {
    /// The amount of work estimated.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub estimated_work: i64,

    /// The amount of work completed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub completed_work: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Progress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [estimated_work][crate::model::Progress::estimated_work].
    pub fn set_estimated_work<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.estimated_work = v.into();
        self
    }

    /// Sets the value of [completed_work][crate::model::Progress::completed_work].
    pub fn set_completed_work<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.completed_work = v.into();
        self
    }
}

impl wkt::message::Message for Progress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Progress"
    }
}

/// A backup schedule for a Cloud Firestore Database.
///
/// This resource is owned by the database it is backing up, and is deleted along
/// with the database. The actual backups are not though.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupSchedule {
    /// Output only. The unique backup schedule identifier across all locations and
    /// databases for the given project.
    ///
    /// This will be auto-assigned.
    ///
    /// Format is
    /// `projects/{project}/databases/{database}/backupSchedules/{backup_schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp at which this backup schedule was created and
    /// effective since.
    ///
    /// No backups will be created for this schedule before this time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this backup schedule was most recently
    /// updated. When a backup schedule is first created, this is the same as
    /// create_time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// At what relative time in the future, compared to its creation time,
    /// the backup should be deleted, e.g. keep backups for 7 days.
    ///
    /// The maximum supported retention period is 14 weeks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retention: std::option::Option<wkt::Duration>,

    /// A oneof field to represent when backups will be taken.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub recurrence: std::option::Option<crate::model::backup_schedule::Recurrence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupSchedule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupSchedule::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::BackupSchedule::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [retention][crate::model::BackupSchedule::retention].
    pub fn set_retention<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.retention = v.into();
        self
    }

    /// Sets the value of [recurrence][crate::model::BackupSchedule::recurrence].
    ///
    /// Note that all the setters affecting `recurrence` are mutually
    /// exclusive.
    pub fn set_recurrence<
        T: std::convert::Into<std::option::Option<crate::model::backup_schedule::Recurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = v.into();
        self
    }

    /// The value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// if it holds a `DailyRecurrence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn daily_recurrence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DailyRecurrence>> {
        #[allow(unreachable_patterns)]
        self.recurrence.as_ref().and_then(|v| match v {
            crate::model::backup_schedule::Recurrence::DailyRecurrence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// to hold a `DailyRecurrence`.
    ///
    /// Note that all the setters affecting `recurrence` are
    /// mutually exclusive.
    pub fn set_daily_recurrence<
        T: std::convert::Into<std::boxed::Box<crate::model::DailyRecurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = std::option::Option::Some(
            crate::model::backup_schedule::Recurrence::DailyRecurrence(v.into()),
        );
        self
    }

    /// The value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// if it holds a `WeeklyRecurrence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn weekly_recurrence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WeeklyRecurrence>> {
        #[allow(unreachable_patterns)]
        self.recurrence.as_ref().and_then(|v| match v {
            crate::model::backup_schedule::Recurrence::WeeklyRecurrence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// to hold a `WeeklyRecurrence`.
    ///
    /// Note that all the setters affecting `recurrence` are
    /// mutually exclusive.
    pub fn set_weekly_recurrence<
        T: std::convert::Into<std::boxed::Box<crate::model::WeeklyRecurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = std::option::Option::Some(
            crate::model::backup_schedule::Recurrence::WeeklyRecurrence(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackupSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BackupSchedule"
    }
}

/// Defines additional types related to [BackupSchedule].
pub mod backup_schedule {
    #[allow(unused_imports)]
    use super::*;

    /// A oneof field to represent when backups will be taken.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Recurrence {
        /// For a schedule that runs daily.
        DailyRecurrence(std::boxed::Box<crate::model::DailyRecurrence>),
        /// For a schedule that runs weekly on a specific day.
        WeeklyRecurrence(std::boxed::Box<crate::model::WeeklyRecurrence>),
    }
}

/// Represents a recurring schedule that runs every day.
///
/// The time zone is UTC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DailyRecurrence {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DailyRecurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DailyRecurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DailyRecurrence"
    }
}

/// Represents a recurring schedule that runs on a specified day of the week.
///
/// The time zone is UTC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WeeklyRecurrence {
    /// The day of week to run.
    ///
    /// DAY_OF_WEEK_UNSPECIFIED is not allowed.
    pub day: gtype::model::DayOfWeek,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeeklyRecurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day][crate::model::WeeklyRecurrence::day].
    pub fn set_day<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day = v.into();
        self
    }
}

impl wkt::message::Message for WeeklyRecurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.WeeklyRecurrence"
    }
}

/// A Cloud Firestore User Creds.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserCreds {
    /// Identifier. The resource name of the UserCreds.
    /// Format:
    /// `projects/{project}/databases/{database}/userCreds/{user_creds}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time the user creds were created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the user creds were last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Whether the user creds are enabled or disabled. Defaults to
    /// ENABLED on creation.
    pub state: crate::model::user_creds::State,

    /// Output only. The plaintext server-generated password for the user creds.
    /// Only populated in responses for CreateUserCreds and ResetUserPassword.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secure_password: std::string::String,

    /// Identity associated with this User Creds.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub user_creds_identity: std::option::Option<crate::model::user_creds::UserCredsIdentity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserCreds {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UserCreds::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::UserCreds::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::UserCreds::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UserCreds::state].
    pub fn set_state<T: std::convert::Into<crate::model::user_creds::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [secure_password][crate::model::UserCreds::secure_password].
    pub fn set_secure_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secure_password = v.into();
        self
    }

    /// Sets the value of [user_creds_identity][crate::model::UserCreds::user_creds_identity].
    ///
    /// Note that all the setters affecting `user_creds_identity` are mutually
    /// exclusive.
    pub fn set_user_creds_identity<
        T: std::convert::Into<std::option::Option<crate::model::user_creds::UserCredsIdentity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_creds_identity = v.into();
        self
    }

    /// The value of [user_creds_identity][crate::model::UserCreds::user_creds_identity]
    /// if it holds a `ResourceIdentity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource_identity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::user_creds::ResourceIdentity>> {
        #[allow(unreachable_patterns)]
        self.user_creds_identity.as_ref().and_then(|v| match v {
            crate::model::user_creds::UserCredsIdentity::ResourceIdentity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [user_creds_identity][crate::model::UserCreds::user_creds_identity]
    /// to hold a `ResourceIdentity`.
    ///
    /// Note that all the setters affecting `user_creds_identity` are
    /// mutually exclusive.
    pub fn set_resource_identity<
        T: std::convert::Into<std::boxed::Box<crate::model::user_creds::ResourceIdentity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_creds_identity = std::option::Option::Some(
            crate::model::user_creds::UserCredsIdentity::ResourceIdentity(v.into()),
        );
        self
    }
}

impl wkt::message::Message for UserCreds {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UserCreds"
    }
}

/// Defines additional types related to [UserCreds].
pub mod user_creds {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a Resource Identity principal.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResourceIdentity {
        /// Output only. Principal identifier string.
        /// See: <https://cloud.google.com/iam/docs/principal-identifiers>
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub principal: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceIdentity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [principal][crate::model::user_creds::ResourceIdentity::principal].
        pub fn set_principal<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.principal = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceIdentity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.UserCreds.ResourceIdentity"
        }
    }

    /// The state of the user creds (ENABLED or DISABLED).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. Should not be used.
        Unspecified,
        /// The user creds are enabled.
        Enabled,
        /// The user creds are disabled.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.firestore.admin.v1.UserCreds.State",
            ))
        }
    }

    /// Identity associated with this User Creds.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum UserCredsIdentity {
        /// Resource Identity descriptor.
        ResourceIdentity(std::boxed::Box<crate::model::user_creds::ResourceIdentity>),
    }
}

/// Describes the state of the operation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperationState {
    /// Unspecified.
    Unspecified,
    /// Request is being prepared for processing.
    Initializing,
    /// Request is actively being processed.
    Processing,
    /// Request is in the process of being cancelled after user called
    /// google.longrunning.Operations.CancelOperation on the operation.
    Cancelling,
    /// Request has been processed and is in its finalization stage.
    Finalizing,
    /// Request has completed successfully.
    Successful,
    /// Request has finished being processed, but encountered an error.
    Failed,
    /// Request has finished being cancelled after user called
    /// google.longrunning.Operations.CancelOperation.
    Cancelled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperationState::value] or
    /// [OperationState::name].
    UnknownValue(operation_state::UnknownValue),
}

#[doc(hidden)]
pub mod operation_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperationState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Initializing => std::option::Option::Some(1),
            Self::Processing => std::option::Option::Some(2),
            Self::Cancelling => std::option::Option::Some(3),
            Self::Finalizing => std::option::Option::Some(4),
            Self::Successful => std::option::Option::Some(5),
            Self::Failed => std::option::Option::Some(6),
            Self::Cancelled => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OPERATION_STATE_UNSPECIFIED"),
            Self::Initializing => std::option::Option::Some("INITIALIZING"),
            Self::Processing => std::option::Option::Some("PROCESSING"),
            Self::Cancelling => std::option::Option::Some("CANCELLING"),
            Self::Finalizing => std::option::Option::Some("FINALIZING"),
            Self::Successful => std::option::Option::Some("SUCCESSFUL"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::Cancelled => std::option::Option::Some("CANCELLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperationState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperationState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperationState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Initializing,
            2 => Self::Processing,
            3 => Self::Cancelling,
            4 => Self::Finalizing,
            5 => Self::Successful,
            6 => Self::Failed,
            7 => Self::Cancelled,
            _ => Self::UnknownValue(operation_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperationState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OPERATION_STATE_UNSPECIFIED" => Self::Unspecified,
            "INITIALIZING" => Self::Initializing,
            "PROCESSING" => Self::Processing,
            "CANCELLING" => Self::Cancelling,
            "FINALIZING" => Self::Finalizing,
            "SUCCESSFUL" => Self::Successful,
            "FAILED" => Self::Failed,
            "CANCELLED" => Self::Cancelled,
            _ => Self::UnknownValue(operation_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperationState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Initializing => serializer.serialize_i32(1),
            Self::Processing => serializer.serialize_i32(2),
            Self::Cancelling => serializer.serialize_i32(3),
            Self::Finalizing => serializer.serialize_i32(4),
            Self::Successful => serializer.serialize_i32(5),
            Self::Failed => serializer.serialize_i32(6),
            Self::Cancelled => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationState>::new(
            ".google.firestore.admin.v1.OperationState",
        ))
    }
}
