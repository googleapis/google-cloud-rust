// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A Backup of a Cloud Firestore Database.
///
/// The backup contains all documents and index configurations for the given
/// database at a specific point in time.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Backup {
    /// Output only. The unique resource name of the Backup.
    ///
    /// Format is `projects/{project}/locations/{location}/backups/{backup}`.
    pub name: std::string::String,

    /// Output only. Name of the Firestore database that the backup is from.
    ///
    /// Format is `projects/{project}/databases/{database}`.
    pub database: std::string::String,

    /// Output only. The system-generated UUID4 for the Firestore database that the
    /// backup is from.
    pub database_uid: std::string::String,

    /// Output only. The backup contains an externally consistent copy of the
    /// database at this time.
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this backup expires.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Statistics about the backup.
    ///
    /// This data only becomes available after the backup is fully materialized to
    /// secondary storage. This field will be empty till then.
    pub stats: std::option::Option<crate::model::backup::Stats>,

    /// Output only. The current state of the backup.
    pub state: crate::model::backup::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [database][crate::model::Backup::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [database_uid][crate::model::Backup::database_uid].
    pub fn set_database_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_uid = v.into();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::Backup::snapshot_time].
    pub fn set_snapshot_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot_time][crate::model::Backup::snapshot_time].
    pub fn set_or_clear_snapshot_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stats][crate::model::Backup::stats].
    pub fn set_stats<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::backup::Stats>,
    {
        self.stats = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stats][crate::model::Backup::stats].
    pub fn set_or_clear_stats<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::backup::Stats>,
    {
        self.stats = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Backup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Backup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __database,
            __database_uid,
            __snapshot_time,
            __expire_time,
            __stats,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Backup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "database" => Ok(__FieldTag::__database),
                            "databaseUid" => Ok(__FieldTag::__database_uid),
                            "database_uid" => Ok(__FieldTag::__database_uid),
                            "snapshotTime" => Ok(__FieldTag::__snapshot_time),
                            "snapshot_time" => Ok(__FieldTag::__snapshot_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "stats" => Ok(__FieldTag::__stats),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Backup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Backup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_uid => {
                            if !fields.insert(__FieldTag::__database_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_uid",
                                ));
                            }
                            result.database_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot_time => {
                            if !fields.insert(__FieldTag::__snapshot_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_time",
                                ));
                            }
                            result.snapshot_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__stats => {
                            if !fields.insert(__FieldTag::__stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stats",
                                ));
                            }
                            result.stats = map
                                .next_value::<std::option::Option<crate::model::backup::Stats>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::backup::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Backup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.database_uid.is_empty() {
            state.serialize_entry("databaseUid", &self.database_uid)?;
        }
        if self.snapshot_time.is_some() {
            state.serialize_entry("snapshotTime", &self.snapshot_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if self.stats.is_some() {
            state.serialize_entry("stats", &self.stats)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// Backup specific statistics.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Stats {
        /// Output only. Summation of the size of all documents and index entries in
        /// the backup, measured in bytes.
        pub size_bytes: i64,

        /// Output only. The total number of documents contained in the backup.
        pub document_count: i64,

        /// Output only. The total number of index entries contained in the backup.
        pub index_count: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Stats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [size_bytes][crate::model::backup::Stats::size_bytes].
        pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.size_bytes = v.into();
            self
        }

        /// Sets the value of [document_count][crate::model::backup::Stats::document_count].
        pub fn set_document_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.document_count = v.into();
            self
        }

        /// Sets the value of [index_count][crate::model::backup::Stats::index_count].
        pub fn set_index_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.index_count = v.into();
            self
        }
    }

    impl wkt::message::Message for Stats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Backup.Stats"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Stats {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __size_bytes,
                __document_count,
                __index_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Stats")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sizeBytes" => Ok(__FieldTag::__size_bytes),
                                "size_bytes" => Ok(__FieldTag::__size_bytes),
                                "documentCount" => Ok(__FieldTag::__document_count),
                                "document_count" => Ok(__FieldTag::__document_count),
                                "indexCount" => Ok(__FieldTag::__index_count),
                                "index_count" => Ok(__FieldTag::__index_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Stats;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Stats")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__size_bytes => {
                                if !fields.insert(__FieldTag::__size_bytes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for size_bytes",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.size_bytes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__document_count => {
                                if !fields.insert(__FieldTag::__document_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for document_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.document_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__index_count => {
                                if !fields.insert(__FieldTag::__index_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for index_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.index_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Stats {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.size_bytes) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("sizeBytes", &__With(&self.size_bytes))?;
            }
            if !wkt::internal::is_default(&self.document_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("documentCount", &__With(&self.document_count))?;
            }
            if !wkt::internal::is_default(&self.index_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("indexCount", &__With(&self.index_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Indicate the current state of the backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unspecified.
        Unspecified,
        /// The pending backup is still being created. Operations on the
        /// backup will be rejected in this state.
        Creating,
        /// The backup is complete and ready to use.
        Ready,
        /// The backup is not available at this moment.
        NotAvailable,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::NotAvailable => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::NotAvailable => std::option::Option::Some("NOT_AVAILABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::NotAvailable,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "NOT_AVAILABLE" => Self::NotAvailable,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::NotAvailable => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.firestore.admin.v1.Backup.State",
            ))
        }
    }
}

/// A Cloud Firestore Database.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Database {
    /// The resource name of the Database.
    /// Format: `projects/{project}/databases/{database}`
    pub name: std::string::String,

    /// Output only. The system-generated UUID4 for this Database.
    pub uid: std::string::String,

    /// Output only. The timestamp at which this database was created. Databases
    /// created before 2016 do not populate create_time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this database was most recently
    /// updated. Note this only includes updates to the database resource and not
    /// data contained by the database.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this database was deleted. Only set if
    /// the database has been deleted.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// The location of the database. Available locations are listed at
    /// <https://cloud.google.com/firestore/docs/locations>.
    pub location_id: std::string::String,

    /// The type of the database.
    /// See <https://cloud.google.com/datastore/docs/firestore-or-datastore> for
    /// information about how to choose.
    pub r#type: crate::model::database::DatabaseType,

    /// The concurrency control mode to use for this database.
    pub concurrency_mode: crate::model::database::ConcurrencyMode,

    /// Output only. The period during which past versions of data are retained in
    /// the database.
    ///
    /// Any [read][google.firestore.v1.GetDocumentRequest.read_time]
    /// or [query][google.firestore.v1.ListDocumentsRequest.read_time] can specify
    /// a `read_time` within this window, and will read the state of the database
    /// at that time.
    ///
    /// If the PITR feature is enabled, the retention period is 7 days. Otherwise,
    /// the retention period is 1 hour.
    pub version_retention_period: std::option::Option<wkt::Duration>,

    /// Output only. The earliest timestamp at which older versions of the data can
    /// be read from the database. See [version_retention_period] above; this field
    /// is populated with `now - version_retention_period`.
    ///
    /// This value is continuously updated, and becomes stale the moment it is
    /// queried. If you are using this value to recover data, make sure to account
    /// for the time from the moment when the value is queried to the moment when
    /// you initiate the recovery.
    pub earliest_version_time: std::option::Option<wkt::Timestamp>,

    /// Whether to enable the PITR feature on this database.
    pub point_in_time_recovery_enablement: crate::model::database::PointInTimeRecoveryEnablement,

    /// The App Engine integration mode to use for this database.
    pub app_engine_integration_mode: crate::model::database::AppEngineIntegrationMode,

    /// Output only. The key_prefix for this database. This key_prefix is used, in
    /// combination with the project ID ("\<key prefix\>~\<project id\>") to construct
    /// the application ID that is returned from the Cloud Datastore APIs in Google
    /// App Engine first generation runtimes.
    ///
    /// This value may be empty in which case the appid to use for URL-encoded keys
    /// is the project_id (eg: foo instead of v~foo).
    pub key_prefix: std::string::String,

    /// State of delete protection for the database.
    pub delete_protection_state: crate::model::database::DeleteProtectionState,

    /// Optional. Presence indicates CMEK is enabled for this database.
    pub cmek_config: std::option::Option<crate::model::database::CmekConfig>,

    /// Output only. The database resource's prior database ID. This field is only
    /// populated for deleted databases.
    pub previous_id: std::string::String,

    /// Output only. Information about the provenance of this database.
    pub source_info: std::option::Option<crate::model::database::SourceInfo>,

    /// Optional. Input only. Immutable. Tag keys/values directly bound to this
    /// resource. For example:
    /// "123/environment": "production",
    /// "123/costCenter": "marketing"
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Background: Free tier is the ability of a Firestore database
    /// to use a small amount of resources every day without being charged. Once
    /// usage exceeds the free tier limit further usage is charged.
    ///
    /// Whether this database can make use of the free tier. Only one database
    /// per project can be eligible for the free tier.
    ///
    /// The first (or next) database that is created in a project without a free
    /// tier database will be marked as eligible for the free tier. Databases that
    /// are created while there is a free tier database will not be eligible for
    /// the free tier.
    pub free_tier: std::option::Option<bool>,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Immutable. The edition of the database.
    pub database_edition: crate::model::database::DatabaseEdition,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Database {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Database::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Database::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Database::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Database::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Database::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Database::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Database::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Database::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location_id][crate::model::Database::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Database::type].
    pub fn set_type<T: std::convert::Into<crate::model::database::DatabaseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [concurrency_mode][crate::model::Database::concurrency_mode].
    pub fn set_concurrency_mode<T: std::convert::Into<crate::model::database::ConcurrencyMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.concurrency_mode = v.into();
        self
    }

    /// Sets the value of [version_retention_period][crate::model::Database::version_retention_period].
    pub fn set_version_retention_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.version_retention_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version_retention_period][crate::model::Database::version_retention_period].
    pub fn set_or_clear_version_retention_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.version_retention_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [earliest_version_time][crate::model::Database::earliest_version_time].
    pub fn set_earliest_version_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.earliest_version_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [earliest_version_time][crate::model::Database::earliest_version_time].
    pub fn set_or_clear_earliest_version_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.earliest_version_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [point_in_time_recovery_enablement][crate::model::Database::point_in_time_recovery_enablement].
    pub fn set_point_in_time_recovery_enablement<
        T: std::convert::Into<crate::model::database::PointInTimeRecoveryEnablement>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.point_in_time_recovery_enablement = v.into();
        self
    }

    /// Sets the value of [app_engine_integration_mode][crate::model::Database::app_engine_integration_mode].
    pub fn set_app_engine_integration_mode<
        T: std::convert::Into<crate::model::database::AppEngineIntegrationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.app_engine_integration_mode = v.into();
        self
    }

    /// Sets the value of [key_prefix][crate::model::Database::key_prefix].
    pub fn set_key_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_prefix = v.into();
        self
    }

    /// Sets the value of [delete_protection_state][crate::model::Database::delete_protection_state].
    pub fn set_delete_protection_state<
        T: std::convert::Into<crate::model::database::DeleteProtectionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.delete_protection_state = v.into();
        self
    }

    /// Sets the value of [cmek_config][crate::model::Database::cmek_config].
    pub fn set_cmek_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::database::CmekConfig>,
    {
        self.cmek_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cmek_config][crate::model::Database::cmek_config].
    pub fn set_or_clear_cmek_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::database::CmekConfig>,
    {
        self.cmek_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [previous_id][crate::model::Database::previous_id].
    pub fn set_previous_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.previous_id = v.into();
        self
    }

    /// Sets the value of [source_info][crate::model::Database::source_info].
    pub fn set_source_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::database::SourceInfo>,
    {
        self.source_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_info][crate::model::Database::source_info].
    pub fn set_or_clear_source_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::database::SourceInfo>,
    {
        self.source_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::Database::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [free_tier][crate::model::Database::free_tier].
    pub fn set_free_tier<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.free_tier = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [free_tier][crate::model::Database::free_tier].
    pub fn set_or_clear_free_tier<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.free_tier = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Database::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [database_edition][crate::model::Database::database_edition].
    pub fn set_database_edition<T: std::convert::Into<crate::model::database::DatabaseEdition>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_edition = v.into();
        self
    }
}

impl wkt::message::Message for Database {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Database"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Database {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __delete_time,
            __location_id,
            __type,
            __concurrency_mode,
            __version_retention_period,
            __earliest_version_time,
            __point_in_time_recovery_enablement,
            __app_engine_integration_mode,
            __key_prefix,
            __delete_protection_state,
            __cmek_config,
            __previous_id,
            __source_info,
            __tags,
            __free_tier,
            __etag,
            __database_edition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Database")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            "type" => Ok(__FieldTag::__type),
                            "concurrencyMode" => Ok(__FieldTag::__concurrency_mode),
                            "concurrency_mode" => Ok(__FieldTag::__concurrency_mode),
                            "versionRetentionPeriod" => Ok(__FieldTag::__version_retention_period),
                            "version_retention_period" => {
                                Ok(__FieldTag::__version_retention_period)
                            }
                            "earliestVersionTime" => Ok(__FieldTag::__earliest_version_time),
                            "earliest_version_time" => Ok(__FieldTag::__earliest_version_time),
                            "pointInTimeRecoveryEnablement" => {
                                Ok(__FieldTag::__point_in_time_recovery_enablement)
                            }
                            "point_in_time_recovery_enablement" => {
                                Ok(__FieldTag::__point_in_time_recovery_enablement)
                            }
                            "appEngineIntegrationMode" => {
                                Ok(__FieldTag::__app_engine_integration_mode)
                            }
                            "app_engine_integration_mode" => {
                                Ok(__FieldTag::__app_engine_integration_mode)
                            }
                            "keyPrefix" => Ok(__FieldTag::__key_prefix),
                            "key_prefix" => Ok(__FieldTag::__key_prefix),
                            "deleteProtectionState" => Ok(__FieldTag::__delete_protection_state),
                            "delete_protection_state" => Ok(__FieldTag::__delete_protection_state),
                            "cmekConfig" => Ok(__FieldTag::__cmek_config),
                            "cmek_config" => Ok(__FieldTag::__cmek_config),
                            "previousId" => Ok(__FieldTag::__previous_id),
                            "previous_id" => Ok(__FieldTag::__previous_id),
                            "sourceInfo" => Ok(__FieldTag::__source_info),
                            "source_info" => Ok(__FieldTag::__source_info),
                            "tags" => Ok(__FieldTag::__tags),
                            "freeTier" => Ok(__FieldTag::__free_tier),
                            "free_tier" => Ok(__FieldTag::__free_tier),
                            "etag" => Ok(__FieldTag::__etag),
                            "databaseEdition" => Ok(__FieldTag::__database_edition),
                            "database_edition" => Ok(__FieldTag::__database_edition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Database;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Database")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::database::DatabaseType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__concurrency_mode => {
                            if !fields.insert(__FieldTag::__concurrency_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for concurrency_mode",
                                ));
                            }
                            result.concurrency_mode = map.next_value::<std::option::Option<crate::model::database::ConcurrencyMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__version_retention_period => {
                            if !fields.insert(__FieldTag::__version_retention_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_retention_period",
                                ));
                            }
                            result.version_retention_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__earliest_version_time => {
                            if !fields.insert(__FieldTag::__earliest_version_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for earliest_version_time",
                                ));
                            }
                            result.earliest_version_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__point_in_time_recovery_enablement => {
                            if !fields.insert(__FieldTag::__point_in_time_recovery_enablement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for point_in_time_recovery_enablement",
                                ));
                            }
                            result.point_in_time_recovery_enablement = map
                                .next_value::<std::option::Option<
                                    crate::model::database::PointInTimeRecoveryEnablement,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_engine_integration_mode => {
                            if !fields.insert(__FieldTag::__app_engine_integration_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_integration_mode",
                                ));
                            }
                            result.app_engine_integration_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::database::AppEngineIntegrationMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_prefix => {
                            if !fields.insert(__FieldTag::__key_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_prefix",
                                ));
                            }
                            result.key_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delete_protection_state => {
                            if !fields.insert(__FieldTag::__delete_protection_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_protection_state",
                                ));
                            }
                            result.delete_protection_state =
                                map.next_value::<std::option::Option<
                                    crate::model::database::DeleteProtectionState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cmek_config => {
                            if !fields.insert(__FieldTag::__cmek_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cmek_config",
                                ));
                            }
                            result.cmek_config = map.next_value::<std::option::Option<crate::model::database::CmekConfig>>()?
                                ;
                        }
                        __FieldTag::__previous_id => {
                            if !fields.insert(__FieldTag::__previous_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for previous_id",
                                ));
                            }
                            result.previous_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_info => {
                            if !fields.insert(__FieldTag::__source_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_info",
                                ));
                            }
                            result.source_info = map.next_value::<std::option::Option<crate::model::database::SourceInfo>>()?
                                ;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__free_tier => {
                            if !fields.insert(__FieldTag::__free_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for free_tier",
                                ));
                            }
                            result.free_tier = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_edition => {
                            if !fields.insert(__FieldTag::__database_edition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_edition",
                                ));
                            }
                            result.database_edition = map.next_value::<std::option::Option<crate::model::database::DatabaseEdition>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Database {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.concurrency_mode) {
            state.serialize_entry("concurrencyMode", &self.concurrency_mode)?;
        }
        if self.version_retention_period.is_some() {
            state.serialize_entry("versionRetentionPeriod", &self.version_retention_period)?;
        }
        if self.earliest_version_time.is_some() {
            state.serialize_entry("earliestVersionTime", &self.earliest_version_time)?;
        }
        if !wkt::internal::is_default(&self.point_in_time_recovery_enablement) {
            state.serialize_entry(
                "pointInTimeRecoveryEnablement",
                &self.point_in_time_recovery_enablement,
            )?;
        }
        if !wkt::internal::is_default(&self.app_engine_integration_mode) {
            state.serialize_entry(
                "appEngineIntegrationMode",
                &self.app_engine_integration_mode,
            )?;
        }
        if !self.key_prefix.is_empty() {
            state.serialize_entry("keyPrefix", &self.key_prefix)?;
        }
        if !wkt::internal::is_default(&self.delete_protection_state) {
            state.serialize_entry("deleteProtectionState", &self.delete_protection_state)?;
        }
        if self.cmek_config.is_some() {
            state.serialize_entry("cmekConfig", &self.cmek_config)?;
        }
        if !self.previous_id.is_empty() {
            state.serialize_entry("previousId", &self.previous_id)?;
        }
        if self.source_info.is_some() {
            state.serialize_entry("sourceInfo", &self.source_info)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if self.free_tier.is_some() {
            state.serialize_entry("freeTier", &self.free_tier)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.database_edition) {
            state.serialize_entry("databaseEdition", &self.database_edition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Database].
pub mod database {
    #[allow(unused_imports)]
    use super::*;

    /// The CMEK (Customer Managed Encryption Key) configuration for a Firestore
    /// database. If not present, the database is secured by the default Google
    /// encryption key.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CmekConfig {
        /// Required. Only keys in the same location as this database are allowed to
        /// be used for encryption.
        ///
        /// For Firestore's nam5 multi-region, this corresponds to Cloud KMS
        /// multi-region us. For Firestore's eur3 multi-region, this corresponds to
        /// Cloud KMS multi-region europe. See
        /// <https://cloud.google.com/kms/docs/locations>.
        ///
        /// The expected format is
        /// `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
        pub kms_key_name: std::string::String,

        /// Output only. Currently in-use [KMS key
        /// versions](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions).
        /// During [key rotation](https://cloud.google.com/kms/docs/key-rotation),
        /// there can be multiple in-use key versions.
        ///
        /// The expected format is
        /// `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{key_version}`.
        pub active_key_version: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CmekConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key_name][crate::model::database::CmekConfig::kms_key_name].
        pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_name = v.into();
            self
        }

        /// Sets the value of [active_key_version][crate::model::database::CmekConfig::active_key_version].
        pub fn set_active_key_version<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.active_key_version = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CmekConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Database.CmekConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CmekConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __kms_key_name,
                __active_key_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CmekConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                                "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                                "activeKeyVersion" => Ok(__FieldTag::__active_key_version),
                                "active_key_version" => Ok(__FieldTag::__active_key_version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CmekConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CmekConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__kms_key_name => {
                                if !fields.insert(__FieldTag::__kms_key_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key_name",
                                    ));
                                }
                                result.kms_key_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__active_key_version => {
                                if !fields.insert(__FieldTag::__active_key_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for active_key_version",
                                    ));
                                }
                                result.active_key_version = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CmekConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.kms_key_name.is_empty() {
                state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
            }
            if !self.active_key_version.is_empty() {
                state.serialize_entry("activeKeyVersion", &self.active_key_version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Information about the provenance of this database.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SourceInfo {
        /// The associated long-running operation. This field may not be set after
        /// the operation has completed. Format:
        /// `projects/{project}/databases/{database}/operations/{operation}`.
        pub operation: std::string::String,

        /// The source from which this database is derived.
        pub source: std::option::Option<crate::model::database::source_info::Source>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SourceInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::database::SourceInfo::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [source][crate::model::database::SourceInfo::source].
        ///
        /// Note that all the setters affecting `source` are mutually
        /// exclusive.
        pub fn set_source<
            T: std::convert::Into<std::option::Option<crate::model::database::source_info::Source>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::database::SourceInfo::source]
        /// if it holds a `Backup`, `None` if the field is not set or
        /// holds a different branch.
        pub fn backup(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::database::source_info::BackupSource>>
        {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::database::source_info::Source::Backup(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::database::SourceInfo::source]
        /// to hold a `Backup`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_backup<
            T: std::convert::Into<std::boxed::Box<crate::model::database::source_info::BackupSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::database::source_info::Source::Backup(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for SourceInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Database.SourceInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SourceInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __backup,
                __operation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SourceInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "backup" => Ok(__FieldTag::__backup),
                                "operation" => Ok(__FieldTag::__operation),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SourceInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SourceInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__backup => {
                                if !fields.insert(__FieldTag::__backup) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for backup",
                                    ));
                                }
                                if result.source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source`, a oneof with full ID .google.firestore.admin.v1.Database.SourceInfo.backup, latest field was backup",
                                    ));
                                }
                                result.source = std::option::Option::Some(
                                    crate::model::database::source_info::Source::Backup(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::database::source_info::BackupSource,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__operation => {
                                if !fields.insert(__FieldTag::__operation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for operation",
                                    ));
                                }
                                result.operation = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SourceInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.backup() {
                state.serialize_entry("backup", value)?;
            }
            if !self.operation.is_empty() {
                state.serialize_entry("operation", &self.operation)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SourceInfo].
    pub mod source_info {
        #[allow(unused_imports)]
        use super::*;

        /// Information about a backup that was used to restore a database.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BackupSource {
            /// The resource name of the backup that was used to restore this
            /// database. Format:
            /// `projects/{project}/locations/{location}/backups/{backup}`.
            pub backup: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BackupSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [backup][crate::model::database::source_info::BackupSource::backup].
            pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.backup = v.into();
                self
            }
        }

        impl wkt::message::Message for BackupSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.SourceInfo.BackupSource"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BackupSource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __backup,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BackupSource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "backup" => Ok(__FieldTag::__backup),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BackupSource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BackupSource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__backup => {
                                    if !fields.insert(__FieldTag::__backup) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for backup"),
                                        );
                                    }
                                    result.backup = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BackupSource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.backup.is_empty() {
                    state.serialize_entry("backup", &self.backup)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The source from which this database is derived.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Source {
            /// If set, this database was restored from the specified backup (or a
            /// snapshot thereof).
            Backup(std::boxed::Box<crate::model::database::source_info::BackupSource>),
        }
    }

    /// Encryption configuration for a new database being created from another
    /// source.
    ///
    /// The source could be a [Backup][google.firestore.admin.v1.Backup] .
    ///
    /// [google.firestore.admin.v1.Backup]: crate::model::Backup
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EncryptionConfig {
        /// The method for encrypting the database.
        pub encryption_type:
            std::option::Option<crate::model::database::encryption_config::EncryptionType>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EncryptionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type].
        ///
        /// Note that all the setters affecting `encryption_type` are mutually
        /// exclusive.
        pub fn set_encryption_type<
            T: std::convert::Into<
                    std::option::Option<crate::model::database::encryption_config::EncryptionType>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = v.into();
            self
        }

        /// The value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// if it holds a `GoogleDefaultEncryption`, `None` if the field is not set or
        /// holds a different branch.
        pub fn google_default_encryption(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::database::encryption_config::GoogleDefaultEncryptionOptions,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.encryption_type.as_ref().and_then(|v| match v {
                crate::model::database::encryption_config::EncryptionType::GoogleDefaultEncryption(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// to hold a `GoogleDefaultEncryption`.
        ///
        /// Note that all the setters affecting `encryption_type` are
        /// mutually exclusive.
        pub fn set_google_default_encryption<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::database::encryption_config::GoogleDefaultEncryptionOptions,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = std::option::Option::Some(
                crate::model::database::encryption_config::EncryptionType::GoogleDefaultEncryption(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// if it holds a `UseSourceEncryption`, `None` if the field is not set or
        /// holds a different branch.
        pub fn use_source_encryption(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::database::encryption_config::SourceEncryptionOptions>,
        > {
            #[allow(unreachable_patterns)]
            self.encryption_type.as_ref().and_then(|v| match v {
                crate::model::database::encryption_config::EncryptionType::UseSourceEncryption(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// to hold a `UseSourceEncryption`.
        ///
        /// Note that all the setters affecting `encryption_type` are
        /// mutually exclusive.
        pub fn set_use_source_encryption<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::database::encryption_config::SourceEncryptionOptions,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = std::option::Option::Some(
                crate::model::database::encryption_config::EncryptionType::UseSourceEncryption(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// if it holds a `CustomerManagedEncryption`, `None` if the field is not set or
        /// holds a different branch.
        pub fn customer_managed_encryption(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::database::encryption_config::CustomerManagedEncryptionOptions,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.encryption_type.as_ref().and_then(|v| match v {
                crate::model::database::encryption_config::EncryptionType::CustomerManagedEncryption(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// to hold a `CustomerManagedEncryption`.
        ///
        /// Note that all the setters affecting `encryption_type` are
        /// mutually exclusive.
        pub fn set_customer_managed_encryption<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::database::encryption_config::CustomerManagedEncryptionOptions,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = std::option::Option::Some(
                crate::model::database::encryption_config::EncryptionType::CustomerManagedEncryption(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for EncryptionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EncryptionConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __google_default_encryption,
                __use_source_encryption,
                __customer_managed_encryption,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EncryptionConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "googleDefaultEncryption" => {
                                    Ok(__FieldTag::__google_default_encryption)
                                }
                                "google_default_encryption" => {
                                    Ok(__FieldTag::__google_default_encryption)
                                }
                                "useSourceEncryption" => Ok(__FieldTag::__use_source_encryption),
                                "use_source_encryption" => Ok(__FieldTag::__use_source_encryption),
                                "customerManagedEncryption" => {
                                    Ok(__FieldTag::__customer_managed_encryption)
                                }
                                "customer_managed_encryption" => {
                                    Ok(__FieldTag::__customer_managed_encryption)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EncryptionConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EncryptionConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__google_default_encryption => {
                                if !fields.insert(__FieldTag::__google_default_encryption) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for google_default_encryption",
                                    ));
                                }
                                if result.encryption_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `encryption_type`, a oneof with full ID .google.firestore.admin.v1.Database.EncryptionConfig.google_default_encryption, latest field was googleDefaultEncryption",
                                    ));
                                }
                                result.encryption_type = std::option::Option::Some(
                                    crate::model::database::encryption_config::EncryptionType::GoogleDefaultEncryption(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::database::encryption_config::GoogleDefaultEncryptionOptions>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__use_source_encryption => {
                                if !fields.insert(__FieldTag::__use_source_encryption) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for use_source_encryption",
                                    ));
                                }
                                if result.encryption_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `encryption_type`, a oneof with full ID .google.firestore.admin.v1.Database.EncryptionConfig.use_source_encryption, latest field was useSourceEncryption",
                                    ));
                                }
                                result.encryption_type = std::option::Option::Some(
                                    crate::model::database::encryption_config::EncryptionType::UseSourceEncryption(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::database::encryption_config::SourceEncryptionOptions>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__customer_managed_encryption => {
                                if !fields.insert(__FieldTag::__customer_managed_encryption) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for customer_managed_encryption",
                                    ));
                                }
                                if result.encryption_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `encryption_type`, a oneof with full ID .google.firestore.admin.v1.Database.EncryptionConfig.customer_managed_encryption, latest field was customerManagedEncryption",
                                    ));
                                }
                                result.encryption_type = std::option::Option::Some(
                                    crate::model::database::encryption_config::EncryptionType::CustomerManagedEncryption(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::database::encryption_config::CustomerManagedEncryptionOptions>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EncryptionConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.google_default_encryption() {
                state.serialize_entry("googleDefaultEncryption", value)?;
            }
            if let Some(value) = self.use_source_encryption() {
                state.serialize_entry("useSourceEncryption", value)?;
            }
            if let Some(value) = self.customer_managed_encryption() {
                state.serialize_entry("customerManagedEncryption", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [EncryptionConfig].
    pub mod encryption_config {
        #[allow(unused_imports)]
        use super::*;

        /// The configuration options for using Google default encryption.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct GoogleDefaultEncryptionOptions {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl GoogleDefaultEncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for GoogleDefaultEncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig.GoogleDefaultEncryptionOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for GoogleDefaultEncryptionOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter
                                    .write_str("a field name for GoogleDefaultEncryptionOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = GoogleDefaultEncryptionOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct GoogleDefaultEncryptionOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for GoogleDefaultEncryptionOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The configuration options for using the same encryption method as the
        /// source.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct SourceEncryptionOptions {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SourceEncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for SourceEncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig.SourceEncryptionOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for SourceEncryptionOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for SourceEncryptionOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = SourceEncryptionOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct SourceEncryptionOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for SourceEncryptionOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The configuration options for using CMEK (Customer Managed Encryption
        /// Key) encryption.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CustomerManagedEncryptionOptions {
            /// Required. Only keys in the same location as the database are allowed to
            /// be used for encryption.
            ///
            /// For Firestore's nam5 multi-region, this corresponds to Cloud KMS
            /// multi-region us. For Firestore's eur3 multi-region, this corresponds to
            /// Cloud KMS multi-region europe. See
            /// <https://cloud.google.com/kms/docs/locations>.
            ///
            /// The expected format is
            /// `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
            pub kms_key_name: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomerManagedEncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [kms_key_name][crate::model::database::encryption_config::CustomerManagedEncryptionOptions::kms_key_name].
            pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.kms_key_name = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomerManagedEncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig.CustomerManagedEncryptionOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CustomerManagedEncryptionOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __kms_key_name,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter
                                    .write_str("a field name for CustomerManagedEncryptionOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                                    "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CustomerManagedEncryptionOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CustomerManagedEncryptionOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__kms_key_name => {
                                    if !fields.insert(__FieldTag::__kms_key_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for kms_key_name",
                                            ),
                                        );
                                    }
                                    result.kms_key_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CustomerManagedEncryptionOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.kms_key_name.is_empty() {
                    state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The method for encrypting the database.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum EncryptionType {
            /// Use Google default encryption.
            GoogleDefaultEncryption(
                std::boxed::Box<
                    crate::model::database::encryption_config::GoogleDefaultEncryptionOptions,
                >,
            ),
            /// The database will use the same encryption configuration as the source.
            UseSourceEncryption(
                std::boxed::Box<crate::model::database::encryption_config::SourceEncryptionOptions>,
            ),
            /// Use Customer Managed Encryption Keys (CMEK) for encryption.
            CustomerManagedEncryption(
                std::boxed::Box<
                    crate::model::database::encryption_config::CustomerManagedEncryptionOptions,
                >,
            ),
        }
    }

    /// The type of the database.
    /// See <https://cloud.google.com/datastore/docs/firestore-or-datastore> for
    /// information about how to choose.
    ///
    /// Mode changes are only allowed if the database is empty.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseType {
        /// Not used.
        Unspecified,
        /// Firestore Native Mode
        FirestoreNative,
        /// Firestore in Datastore Mode.
        DatastoreMode,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseType::value] or
        /// [DatabaseType::name].
        UnknownValue(database_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FirestoreNative => std::option::Option::Some(1),
                Self::DatastoreMode => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_TYPE_UNSPECIFIED"),
                Self::FirestoreNative => std::option::Option::Some("FIRESTORE_NATIVE"),
                Self::DatastoreMode => std::option::Option::Some("DATASTORE_MODE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FirestoreNative,
                2 => Self::DatastoreMode,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "FIRESTORE_NATIVE" => Self::FirestoreNative,
                "DATASTORE_MODE" => Self::DatastoreMode,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FirestoreNative => serializer.serialize_i32(1),
                Self::DatastoreMode => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseType>::new(
                ".google.firestore.admin.v1.Database.DatabaseType",
            ))
        }
    }

    /// The type of concurrency control mode for transactions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConcurrencyMode {
        /// Not used.
        Unspecified,
        /// Use optimistic concurrency control by default. This mode is available
        /// for Cloud Firestore databases.
        Optimistic,
        /// Use pessimistic concurrency control by default. This mode is available
        /// for Cloud Firestore databases.
        ///
        /// This is the default setting for Cloud Firestore.
        Pessimistic,
        /// Use optimistic concurrency control with entity groups by default.
        ///
        /// This is the only available mode for Cloud Datastore.
        ///
        /// This mode is also available for Cloud Firestore with Datastore Mode but
        /// is not recommended.
        OptimisticWithEntityGroups,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConcurrencyMode::value] or
        /// [ConcurrencyMode::name].
        UnknownValue(concurrency_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod concurrency_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConcurrencyMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Optimistic => std::option::Option::Some(1),
                Self::Pessimistic => std::option::Option::Some(2),
                Self::OptimisticWithEntityGroups => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONCURRENCY_MODE_UNSPECIFIED"),
                Self::Optimistic => std::option::Option::Some("OPTIMISTIC"),
                Self::Pessimistic => std::option::Option::Some("PESSIMISTIC"),
                Self::OptimisticWithEntityGroups => {
                    std::option::Option::Some("OPTIMISTIC_WITH_ENTITY_GROUPS")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConcurrencyMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConcurrencyMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConcurrencyMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Optimistic,
                2 => Self::Pessimistic,
                3 => Self::OptimisticWithEntityGroups,
                _ => Self::UnknownValue(concurrency_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConcurrencyMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONCURRENCY_MODE_UNSPECIFIED" => Self::Unspecified,
                "OPTIMISTIC" => Self::Optimistic,
                "PESSIMISTIC" => Self::Pessimistic,
                "OPTIMISTIC_WITH_ENTITY_GROUPS" => Self::OptimisticWithEntityGroups,
                _ => Self::UnknownValue(concurrency_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConcurrencyMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Optimistic => serializer.serialize_i32(1),
                Self::Pessimistic => serializer.serialize_i32(2),
                Self::OptimisticWithEntityGroups => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConcurrencyMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConcurrencyMode>::new(
                ".google.firestore.admin.v1.Database.ConcurrencyMode",
            ))
        }
    }

    /// Point In Time Recovery feature enablement.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PointInTimeRecoveryEnablement {
        /// Not used.
        Unspecified,
        /// Reads are supported on selected versions of the data from within the past
        /// 7 days:
        ///
        /// * Reads against any timestamp within the past hour
        /// * Reads against 1-minute snapshots beyond 1 hour and within 7 days
        ///
        /// `version_retention_period` and `earliest_version_time` can be
        /// used to determine the supported versions.
        PointInTimeRecoveryEnabled,
        /// Reads are supported on any version of the data from within the past 1
        /// hour.
        PointInTimeRecoveryDisabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PointInTimeRecoveryEnablement::value] or
        /// [PointInTimeRecoveryEnablement::name].
        UnknownValue(point_in_time_recovery_enablement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod point_in_time_recovery_enablement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PointInTimeRecoveryEnablement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PointInTimeRecoveryEnabled => std::option::Option::Some(1),
                Self::PointInTimeRecoveryDisabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED")
                }
                Self::PointInTimeRecoveryEnabled => {
                    std::option::Option::Some("POINT_IN_TIME_RECOVERY_ENABLED")
                }
                Self::PointInTimeRecoveryDisabled => {
                    std::option::Option::Some("POINT_IN_TIME_RECOVERY_DISABLED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PointInTimeRecoveryEnablement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PointInTimeRecoveryEnablement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PointInTimeRecoveryEnablement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PointInTimeRecoveryEnabled,
                2 => Self::PointInTimeRecoveryDisabled,
                _ => Self::UnknownValue(point_in_time_recovery_enablement::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PointInTimeRecoveryEnablement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED" => Self::Unspecified,
                "POINT_IN_TIME_RECOVERY_ENABLED" => Self::PointInTimeRecoveryEnabled,
                "POINT_IN_TIME_RECOVERY_DISABLED" => Self::PointInTimeRecoveryDisabled,
                _ => Self::UnknownValue(point_in_time_recovery_enablement::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PointInTimeRecoveryEnablement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PointInTimeRecoveryEnabled => serializer.serialize_i32(1),
                Self::PointInTimeRecoveryDisabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PointInTimeRecoveryEnablement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PointInTimeRecoveryEnablement>::new(
                    ".google.firestore.admin.v1.Database.PointInTimeRecoveryEnablement",
                ),
            )
        }
    }

    /// The type of App Engine integration mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AppEngineIntegrationMode {
        /// Not used.
        Unspecified,
        /// If an App Engine application exists in the same region as this database,
        /// App Engine configuration will impact this database. This includes
        /// disabling of the application & database, as well as disabling writes to
        /// the database.
        Enabled,
        /// App Engine has no effect on the ability of this database to serve
        /// requests.
        ///
        /// This is the default setting for databases created with the Firestore API.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AppEngineIntegrationMode::value] or
        /// [AppEngineIntegrationMode::name].
        UnknownValue(app_engine_integration_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod app_engine_integration_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AppEngineIntegrationMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED")
                }
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AppEngineIntegrationMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AppEngineIntegrationMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AppEngineIntegrationMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(app_engine_integration_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AppEngineIntegrationMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(app_engine_integration_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AppEngineIntegrationMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AppEngineIntegrationMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<AppEngineIntegrationMode>::new(
                    ".google.firestore.admin.v1.Database.AppEngineIntegrationMode",
                ),
            )
        }
    }

    /// The delete protection state of the database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DeleteProtectionState {
        /// The default value. Delete protection type is not specified
        Unspecified,
        /// Delete protection is disabled
        DeleteProtectionDisabled,
        /// Delete protection is enabled
        DeleteProtectionEnabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DeleteProtectionState::value] or
        /// [DeleteProtectionState::name].
        UnknownValue(delete_protection_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod delete_protection_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DeleteProtectionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DeleteProtectionDisabled => std::option::Option::Some(1),
                Self::DeleteProtectionEnabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DELETE_PROTECTION_STATE_UNSPECIFIED")
                }
                Self::DeleteProtectionDisabled => {
                    std::option::Option::Some("DELETE_PROTECTION_DISABLED")
                }
                Self::DeleteProtectionEnabled => {
                    std::option::Option::Some("DELETE_PROTECTION_ENABLED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DeleteProtectionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DeleteProtectionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DeleteProtectionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DeleteProtectionDisabled,
                2 => Self::DeleteProtectionEnabled,
                _ => Self::UnknownValue(delete_protection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DeleteProtectionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DELETE_PROTECTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "DELETE_PROTECTION_DISABLED" => Self::DeleteProtectionDisabled,
                "DELETE_PROTECTION_ENABLED" => Self::DeleteProtectionEnabled,
                _ => Self::UnknownValue(delete_protection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DeleteProtectionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DeleteProtectionDisabled => serializer.serialize_i32(1),
                Self::DeleteProtectionEnabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DeleteProtectionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeleteProtectionState>::new(
                ".google.firestore.admin.v1.Database.DeleteProtectionState",
            ))
        }
    }

    /// The edition of the database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseEdition {
        /// Not used.
        Unspecified,
        /// Standard edition.
        ///
        /// This is the default setting if not specified.
        Standard,
        /// Enterprise edition.
        Enterprise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseEdition::value] or
        /// [DatabaseEdition::name].
        UnknownValue(database_edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseEdition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Enterprise => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_EDITION_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseEdition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseEdition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseEdition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::Enterprise,
                _ => Self::UnknownValue(database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseEdition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_EDITION_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                "ENTERPRISE" => Self::Enterprise,
                _ => Self::UnknownValue(database_edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseEdition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Enterprise => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseEdition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEdition>::new(
                ".google.firestore.admin.v1.Database.DatabaseEdition",
            ))
        }
    }
}

/// Represents a single field in the database.
///
/// Fields are grouped by their "Collection Group", which represent all
/// collections in the database with the same ID.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Field {
    /// Required. A field name of the form:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_path}`
    ///
    /// A field path can be a simple field name, e.g. `address` or a path to fields
    /// within `map_value` , e.g. `address.city`,
    /// or a special field path. The only valid special field is `*`, which
    /// represents any field.
    ///
    /// Field paths can be quoted using `` ` `` (backtick). The only character that
    /// must be escaped within a quoted field path is the backtick character
    /// itself, escaped using a backslash. Special characters in field paths that
    /// must be quoted include: `*`, `.`,
    /// `` ` `` (backtick), `[`, `]`, as well as any ascii symbolic characters.
    ///
    /// Examples:
    /// `` `address.city` `` represents a field named `address.city`, not the map
    /// key `city` in the field `address`. `` `*` `` represents a field named `*`,
    /// not any field.
    ///
    /// A special `Field` contains the default indexing settings for all fields.
    /// This field's resource name is:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/__default__/fields/*`
    /// Indexes defined on this `Field` will be applied to all fields which do not
    /// have their own `Field` index configuration.
    pub name: std::string::String,

    /// The index configuration for this field. If unset, field indexing will
    /// revert to the configuration defined by the `ancestor_field`. To
    /// explicitly remove all indexes for this field, specify an index config
    /// with an empty list of indexes.
    pub index_config: std::option::Option<crate::model::field::IndexConfig>,

    /// The TTL configuration for this `Field`.
    /// Setting or unsetting this will enable or disable the TTL for
    /// documents that have this `Field`.
    pub ttl_config: std::option::Option<crate::model::field::TtlConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Field {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Field::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [index_config][crate::model::Field::index_config].
    pub fn set_index_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::field::IndexConfig>,
    {
        self.index_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index_config][crate::model::Field::index_config].
    pub fn set_or_clear_index_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::field::IndexConfig>,
    {
        self.index_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ttl_config][crate::model::Field::ttl_config].
    pub fn set_ttl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::field::TtlConfig>,
    {
        self.ttl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ttl_config][crate::model::Field::ttl_config].
    pub fn set_or_clear_ttl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::field::TtlConfig>,
    {
        self.ttl_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Field {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Field"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Field {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __index_config,
            __ttl_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Field")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "indexConfig" => Ok(__FieldTag::__index_config),
                            "index_config" => Ok(__FieldTag::__index_config),
                            "ttlConfig" => Ok(__FieldTag::__ttl_config),
                            "ttl_config" => Ok(__FieldTag::__ttl_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Field;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Field")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index_config => {
                            if !fields.insert(__FieldTag::__index_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_config",
                                ));
                            }
                            result.index_config = map.next_value::<std::option::Option<crate::model::field::IndexConfig>>()?
                                ;
                        }
                        __FieldTag::__ttl_config => {
                            if !fields.insert(__FieldTag::__ttl_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl_config",
                                ));
                            }
                            result.ttl_config = map
                                .next_value::<std::option::Option<crate::model::field::TtlConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Field {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.index_config.is_some() {
            state.serialize_entry("indexConfig", &self.index_config)?;
        }
        if self.ttl_config.is_some() {
            state.serialize_entry("ttlConfig", &self.ttl_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Field].
pub mod field {
    #[allow(unused_imports)]
    use super::*;

    /// The index configuration for this field.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IndexConfig {
        /// The indexes supported for this field.
        pub indexes: std::vec::Vec<crate::model::Index>,

        /// Output only. When true, the `Field`'s index configuration is set from the
        /// configuration specified by the `ancestor_field`.
        /// When false, the `Field`'s index configuration is defined explicitly.
        pub uses_ancestor_config: bool,

        /// Output only. Specifies the resource name of the `Field` from which this
        /// field's index configuration is set (when `uses_ancestor_config` is true),
        /// or from which it *would* be set if this field had no index configuration
        /// (when `uses_ancestor_config` is false).
        pub ancestor_field: std::string::String,

        /// Output only
        /// When true, the `Field`'s index configuration is in the process of being
        /// reverted. Once complete, the index config will transition to the same
        /// state as the field specified by `ancestor_field`, at which point
        /// `uses_ancestor_config` will be `true` and `reverting` will be `false`.
        pub reverting: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IndexConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [indexes][crate::model::field::IndexConfig::indexes].
        pub fn set_indexes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Index>,
        {
            use std::iter::Iterator;
            self.indexes = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [uses_ancestor_config][crate::model::field::IndexConfig::uses_ancestor_config].
        pub fn set_uses_ancestor_config<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.uses_ancestor_config = v.into();
            self
        }

        /// Sets the value of [ancestor_field][crate::model::field::IndexConfig::ancestor_field].
        pub fn set_ancestor_field<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ancestor_field = v.into();
            self
        }

        /// Sets the value of [reverting][crate::model::field::IndexConfig::reverting].
        pub fn set_reverting<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.reverting = v.into();
            self
        }
    }

    impl wkt::message::Message for IndexConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Field.IndexConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IndexConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __indexes,
                __uses_ancestor_config,
                __ancestor_field,
                __reverting,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IndexConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "indexes" => Ok(__FieldTag::__indexes),
                                "usesAncestorConfig" => Ok(__FieldTag::__uses_ancestor_config),
                                "uses_ancestor_config" => Ok(__FieldTag::__uses_ancestor_config),
                                "ancestorField" => Ok(__FieldTag::__ancestor_field),
                                "ancestor_field" => Ok(__FieldTag::__ancestor_field),
                                "reverting" => Ok(__FieldTag::__reverting),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IndexConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IndexConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__indexes => {
                                if !fields.insert(__FieldTag::__indexes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for indexes",
                                    ));
                                }
                                result.indexes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Index>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__uses_ancestor_config => {
                                if !fields.insert(__FieldTag::__uses_ancestor_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uses_ancestor_config",
                                    ));
                                }
                                result.uses_ancestor_config = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ancestor_field => {
                                if !fields.insert(__FieldTag::__ancestor_field) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ancestor_field",
                                    ));
                                }
                                result.ancestor_field = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__reverting => {
                                if !fields.insert(__FieldTag::__reverting) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reverting",
                                    ));
                                }
                                result.reverting = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IndexConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.indexes.is_empty() {
                state.serialize_entry("indexes", &self.indexes)?;
            }
            if !wkt::internal::is_default(&self.uses_ancestor_config) {
                state.serialize_entry("usesAncestorConfig", &self.uses_ancestor_config)?;
            }
            if !self.ancestor_field.is_empty() {
                state.serialize_entry("ancestorField", &self.ancestor_field)?;
            }
            if !wkt::internal::is_default(&self.reverting) {
                state.serialize_entry("reverting", &self.reverting)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The TTL (time-to-live) configuration for documents that have this `Field`
    /// set.
    ///
    /// Storing a timestamp value into a TTL-enabled field will be treated as
    /// the document's absolute expiration time. Timestamp values in the past
    /// indicate that the document is eligible for immediate expiration. Using any
    /// other data type or leaving the field absent will disable expiration for the
    /// individual document.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TtlConfig {
        /// Output only. The state of the TTL configuration.
        pub state: crate::model::field::ttl_config::State,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TtlConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::field::TtlConfig::state].
        pub fn set_state<T: std::convert::Into<crate::model::field::ttl_config::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }
    }

    impl wkt::message::Message for TtlConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Field.TtlConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TtlConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TtlConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TtlConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TtlConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::field::ttl_config::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TtlConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TtlConfig].
    pub mod ttl_config {
        #[allow(unused_imports)]
        use super::*;

        /// The state of applying the TTL configuration to all documents.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// The state is unspecified or unknown.
            Unspecified,
            /// The TTL is being applied. There is an active long-running operation to
            /// track the change. Newly written documents will have TTLs applied as
            /// requested. Requested TTLs on existing documents are still being
            /// processed. When TTLs on all existing documents have been processed, the
            /// state will move to 'ACTIVE'.
            Creating,
            /// The TTL is active for all documents.
            Active,
            /// The TTL configuration could not be enabled for all existing documents.
            /// Newly written documents will continue to have their TTL applied.
            /// The LRO returned when last attempting to enable TTL for this `Field`
            /// has failed, and may have more details.
            NeedsRepair,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Creating => std::option::Option::Some(1),
                    Self::Active => std::option::Option::Some(2),
                    Self::NeedsRepair => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Creating => std::option::Option::Some("CREATING"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::NeedsRepair => std::option::Option::Some("NEEDS_REPAIR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Creating,
                    2 => Self::Active,
                    3 => Self::NeedsRepair,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "CREATING" => Self::Creating,
                    "ACTIVE" => Self::Active,
                    "NEEDS_REPAIR" => Self::NeedsRepair,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Creating => serializer.serialize_i32(1),
                    Self::Active => serializer.serialize_i32(2),
                    Self::NeedsRepair => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.firestore.admin.v1.Field.TtlConfig.State",
                ))
            }
        }
    }
}

/// A request to list the Firestore Databases in all locations for a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatabasesRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}`
    pub parent: std::string::String,

    /// If true, also returns deleted resources.
    pub show_deleted: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatabasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListDatabasesRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListDatabasesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatabasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __show_deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatabasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "showDeleted" => Ok(__FieldTag::__show_deleted),
                            "show_deleted" => Ok(__FieldTag::__show_deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatabasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatabasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__show_deleted => {
                            if !fields.insert(__FieldTag::__show_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_deleted",
                                ));
                            }
                            result.show_deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatabasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.show_deleted) {
            state.serialize_entry("showDeleted", &self.show_deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.CreateDatabase][google.firestore.admin.v1.FirestoreAdmin.CreateDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateDatabase]: crate::client::FirestoreAdmin::create_database
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDatabaseRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}`
    pub parent: std::string::String,

    /// Required. The Database to create.
    pub database: std::option::Option<crate::model::Database>,

    /// Required. The ID to use for the database, which will become the final
    /// component of the database's resource name.
    ///
    /// This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/
    /// with first character a letter and the last a letter or a number. Must not
    /// be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.
    ///
    /// "(default)" database ID is also valid.
    pub database_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatabaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [database][crate::model::CreateDatabaseRequest::database].
    pub fn set_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database][crate::model::CreateDatabaseRequest::database].
    pub fn set_or_clear_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.database = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_id][crate::model::CreateDatabaseRequest::database_id].
    pub fn set_database_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __database,
            __database_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "database" => Ok(__FieldTag::__database),
                            "databaseId" => Ok(__FieldTag::__database_id),
                            "database_id" => Ok(__FieldTag::__database_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database =
                                map.next_value::<std::option::Option<crate::model::Database>>()?;
                        }
                        __FieldTag::__database_id => {
                            if !fields.insert(__FieldTag::__database_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_id",
                                ));
                            }
                            result.database_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.database.is_some() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.database_id.is_empty() {
            state.serialize_entry("databaseId", &self.database_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata related to the create database operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDatabaseMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CreateDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateDatabaseMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDatabaseMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDatabaseMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDatabaseMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDatabaseMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDatabaseMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The list of databases for a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatabasesResponse {
    /// The databases in the project.
    pub databases: std::vec::Vec<crate::model::Database>,

    /// In the event that data about individual databases cannot be listed they
    /// will be recorded here.
    ///
    /// An example entry might be: projects/some_project/locations/some_location
    /// This can happen if the Cloud Region that the Database resides in is
    /// currently unavailable.  In this case we can't fetch all the details about
    /// the database. You may be able to get a more detailed error message
    /// (or possibly fetch the resource) by sending a 'Get' request for the
    /// resource or a 'List' request for the specific location.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [databases][crate::model::ListDatabasesResponse::databases].
    pub fn set_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Database>,
    {
        use std::iter::Iterator;
        self.databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDatabasesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListDatabasesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatabasesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __databases,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatabasesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "databases" => Ok(__FieldTag::__databases),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatabasesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatabasesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__databases => {
                            if !fields.insert(__FieldTag::__databases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for databases",
                                ));
                            }
                            result.databases = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Database>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatabasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.databases.is_empty() {
            state.serialize_entry("databases", &self.databases)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.GetDatabase][google.firestore.admin.v1.FirestoreAdmin.GetDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetDatabase]: crate::client::FirestoreAdmin::get_database
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDatabaseRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.UpdateDatabase][google.firestore.admin.v1.FirestoreAdmin.UpdateDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateDatabase]: crate::client::FirestoreAdmin::update_database
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDatabaseRequest {
    /// Required. The database to update.
    pub database: std::option::Option<crate::model::Database>,

    /// The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::UpdateDatabaseRequest::database].
    pub fn set_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database][crate::model::UpdateDatabaseRequest::database].
    pub fn set_or_clear_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.database = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDatabaseRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDatabaseRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database =
                                map.next_value::<std::option::Option<crate::model::Database>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.database.is_some() {
            state.serialize_entry("database", &self.database)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata related to the update database operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDatabaseMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UpdateDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateDatabaseMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDatabaseMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDatabaseMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDatabaseMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDatabaseMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDatabaseMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.DeleteDatabase][google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase]: crate::client::FirestoreAdmin::delete_database
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDatabaseRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}`
    pub name: std::string::String,

    /// The current etag of the Database.
    /// If an etag is provided and does not match the current etag of the database,
    /// deletion will be blocked and a FAILED_PRECONDITION error will be returned.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDatabaseRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata related to the delete database operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDatabaseMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DeleteDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteDatabaseMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDatabaseMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDatabaseMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDatabaseMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDatabaseMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDatabaseMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.CreateUserCreds][google.firestore.admin.v1.FirestoreAdmin.CreateUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateUserCreds]: crate::client::FirestoreAdmin::create_user_creds
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateUserCredsRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}/databases/{database_id}`
    pub parent: std::string::String,

    /// Required. The user creds to create.
    pub user_creds: std::option::Option<crate::model::UserCreds>,

    /// Required. The ID to use for the user creds, which will become the final
    /// component of the user creds's resource name.
    ///
    /// This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/
    /// with first character a letter and the last a letter or a number. Must not
    /// be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.
    pub user_creds_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUserCredsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_creds][crate::model::CreateUserCredsRequest::user_creds].
    pub fn set_user_creds<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCreds>,
    {
        self.user_creds = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_creds][crate::model::CreateUserCredsRequest::user_creds].
    pub fn set_or_clear_user_creds<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCreds>,
    {
        self.user_creds = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_creds_id][crate::model::CreateUserCredsRequest::user_creds_id].
    pub fn set_user_creds_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_creds_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateUserCredsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateUserCredsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __user_creds,
            __user_creds_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateUserCredsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "userCreds" => Ok(__FieldTag::__user_creds),
                            "user_creds" => Ok(__FieldTag::__user_creds),
                            "userCredsId" => Ok(__FieldTag::__user_creds_id),
                            "user_creds_id" => Ok(__FieldTag::__user_creds_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateUserCredsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateUserCredsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_creds => {
                            if !fields.insert(__FieldTag::__user_creds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_creds",
                                ));
                            }
                            result.user_creds =
                                map.next_value::<std::option::Option<crate::model::UserCreds>>()?;
                        }
                        __FieldTag::__user_creds_id => {
                            if !fields.insert(__FieldTag::__user_creds_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_creds_id",
                                ));
                            }
                            result.user_creds_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateUserCredsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.user_creds.is_some() {
            state.serialize_entry("userCreds", &self.user_creds)?;
        }
        if !self.user_creds_id.is_empty() {
            state.serialize_entry("userCredsId", &self.user_creds_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.GetUserCreds][google.firestore.admin.v1.FirestoreAdmin.GetUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetUserCreds]: crate::client::FirestoreAdmin::get_user_creds
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetUserCredsRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/userCreds/{user_creds_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUserCredsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetUserCredsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetUserCredsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetUserCredsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetUserCredsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetUserCredsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetUserCredsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.ListUserCreds][google.firestore.admin.v1.FirestoreAdmin.ListUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListUserCreds]: crate::client::FirestoreAdmin::list_user_creds
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUserCredsRequest {
    /// Required. A parent database name of the form
    /// `projects/{project_id}/databases/{database_id}`
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUserCredsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListUserCredsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUserCredsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUserCredsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUserCredsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUserCredsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUserCredsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response for
/// [FirestoreAdmin.ListUserCreds][google.firestore.admin.v1.FirestoreAdmin.ListUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListUserCreds]: crate::client::FirestoreAdmin::list_user_creds
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUserCredsResponse {
    /// The user creds for the database.
    pub user_creds: std::vec::Vec<crate::model::UserCreds>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUserCredsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_creds][crate::model::ListUserCredsResponse::user_creds].
    pub fn set_user_creds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserCreds>,
    {
        use std::iter::Iterator;
        self.user_creds = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUserCredsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListUserCredsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUserCredsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_creds,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUserCredsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userCreds" => Ok(__FieldTag::__user_creds),
                            "user_creds" => Ok(__FieldTag::__user_creds),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUserCredsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUserCredsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_creds => {
                            if !fields.insert(__FieldTag::__user_creds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_creds",
                                ));
                            }
                            result.user_creds = map.next_value::<std::option::Option<std::vec::Vec<crate::model::UserCreds>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUserCredsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_creds.is_empty() {
            state.serialize_entry("userCreds", &self.user_creds)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.EnableUserCreds][google.firestore.admin.v1.FirestoreAdmin.EnableUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.EnableUserCreds]: crate::client::FirestoreAdmin::enable_user_creds
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableUserCredsRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/userCreds/{user_creds_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnableUserCredsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EnableUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.EnableUserCredsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnableUserCredsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnableUserCredsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnableUserCredsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableUserCredsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnableUserCredsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.DisableUserCreds][google.firestore.admin.v1.FirestoreAdmin.DisableUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DisableUserCreds]: crate::client::FirestoreAdmin::disable_user_creds
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableUserCredsRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/userCreds/{user_creds_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DisableUserCredsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DisableUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DisableUserCredsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisableUserCredsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisableUserCredsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisableUserCredsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisableUserCredsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisableUserCredsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.ResetUserPassword][google.firestore.admin.v1.FirestoreAdmin.ResetUserPassword].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ResetUserPassword]: crate::client::FirestoreAdmin::reset_user_password
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResetUserPasswordRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/userCreds/{user_creds_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetUserPasswordRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetUserPasswordRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResetUserPasswordRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ResetUserPasswordRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResetUserPasswordRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResetUserPasswordRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResetUserPasswordRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResetUserPasswordRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResetUserPasswordRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.DeleteUserCreds][google.firestore.admin.v1.FirestoreAdmin.DeleteUserCreds].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteUserCreds]: crate::client::FirestoreAdmin::delete_user_creds
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteUserCredsRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/userCreds/{user_creds_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUserCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserCredsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteUserCredsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteUserCredsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteUserCredsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteUserCredsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteUserCredsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteUserCredsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.CreateBackupSchedule][google.firestore.admin.v1.FirestoreAdmin.CreateBackupSchedule].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateBackupSchedule]: crate::client::FirestoreAdmin::create_backup_schedule
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupScheduleRequest {
    /// Required. The parent database.
    ///
    /// Format `projects/{project}/databases/{database}`
    pub parent: std::string::String,

    /// Required. The backup schedule to create.
    pub backup_schedule: std::option::Option<crate::model::BackupSchedule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupScheduleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_schedule][crate::model::CreateBackupScheduleRequest::backup_schedule].
    pub fn set_backup_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupSchedule>,
    {
        self.backup_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_schedule][crate::model::CreateBackupScheduleRequest::backup_schedule].
    pub fn set_or_clear_backup_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupSchedule>,
    {
        self.backup_schedule = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateBackupScheduleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupScheduleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_schedule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupScheduleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupSchedule" => Ok(__FieldTag::__backup_schedule),
                            "backup_schedule" => Ok(__FieldTag::__backup_schedule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupScheduleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupScheduleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_schedule => {
                            if !fields.insert(__FieldTag::__backup_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_schedule",
                                ));
                            }
                            result.backup_schedule = map
                                .next_value::<std::option::Option<crate::model::BackupSchedule>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupScheduleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.backup_schedule.is_some() {
            state.serialize_entry("backupSchedule", &self.backup_schedule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.GetBackupSchedule][google.firestore.admin.v1.FirestoreAdmin.GetBackupSchedule].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetBackupSchedule]: crate::client::FirestoreAdmin::get_backup_schedule
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupScheduleRequest {
    /// Required. The name of the backup schedule.
    ///
    /// Format
    /// `projects/{project}/databases/{database}/backupSchedules/{backup_schedule}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetBackupScheduleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupScheduleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupScheduleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupScheduleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupScheduleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupScheduleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.UpdateBackupSchedule][google.firestore.admin.v1.FirestoreAdmin.UpdateBackupSchedule].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateBackupSchedule]: crate::client::FirestoreAdmin::update_backup_schedule
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupScheduleRequest {
    /// Required. The backup schedule to update.
    pub backup_schedule: std::option::Option<crate::model::BackupSchedule>,

    /// The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_schedule][crate::model::UpdateBackupScheduleRequest::backup_schedule].
    pub fn set_backup_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupSchedule>,
    {
        self.backup_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_schedule][crate::model::UpdateBackupScheduleRequest::backup_schedule].
    pub fn set_or_clear_backup_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupSchedule>,
    {
        self.backup_schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupScheduleRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupScheduleRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateBackupScheduleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBackupScheduleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_schedule,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBackupScheduleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupSchedule" => Ok(__FieldTag::__backup_schedule),
                            "backup_schedule" => Ok(__FieldTag::__backup_schedule),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBackupScheduleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBackupScheduleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_schedule => {
                            if !fields.insert(__FieldTag::__backup_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_schedule",
                                ));
                            }
                            result.backup_schedule = map
                                .next_value::<std::option::Option<crate::model::BackupSchedule>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBackupScheduleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backup_schedule.is_some() {
            state.serialize_entry("backupSchedule", &self.backup_schedule)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.ListBackupSchedules][google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules]: crate::client::FirestoreAdmin::list_backup_schedules
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupSchedulesRequest {
    /// Required. The parent database.
    ///
    /// Format is `projects/{project}/databases/{database}`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupSchedulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupSchedulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupSchedulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupSchedulesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupSchedulesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupSchedulesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupSchedulesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupSchedulesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupSchedulesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response for
/// [FirestoreAdmin.ListBackupSchedules][google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules]: crate::client::FirestoreAdmin::list_backup_schedules
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupSchedulesResponse {
    /// List of all backup schedules.
    pub backup_schedules: std::vec::Vec<crate::model::BackupSchedule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupSchedulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_schedules][crate::model::ListBackupSchedulesResponse::backup_schedules].
    pub fn set_backup_schedules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupSchedule>,
    {
        use std::iter::Iterator;
        self.backup_schedules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupSchedulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupSchedulesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupSchedulesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_schedules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupSchedulesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupSchedules" => Ok(__FieldTag::__backup_schedules),
                            "backup_schedules" => Ok(__FieldTag::__backup_schedules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupSchedulesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupSchedulesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_schedules => {
                            if !fields.insert(__FieldTag::__backup_schedules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_schedules",
                                ));
                            }
                            result.backup_schedules =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BackupSchedule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupSchedulesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_schedules.is_empty() {
            state.serialize_entry("backupSchedules", &self.backup_schedules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for [FirestoreAdmin.DeleteBackupSchedules][].
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupScheduleRequest {
    /// Required. The name of the backup schedule.
    ///
    /// Format
    /// `projects/{project}/databases/{database}/backupSchedules/{backup_schedule}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteBackupScheduleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupScheduleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupScheduleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupScheduleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupScheduleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupScheduleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.CreateIndex][google.firestore.admin.v1.FirestoreAdmin.CreateIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateIndex]: crate::client::FirestoreAdmin::create_index
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateIndexRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
    pub parent: std::string::String,

    /// Required. The composite index to create.
    pub index: std::option::Option<crate::model::Index>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIndexRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [index][crate::model::CreateIndexRequest::index].
    pub fn set_index<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Index>,
    {
        self.index = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index][crate::model::CreateIndexRequest::index].
    pub fn set_or_clear_index<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Index>,
    {
        self.index = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateIndexRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateIndexRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __index,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateIndexRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "index" => Ok(__FieldTag::__index),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateIndexRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateIndexRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            result.index =
                                map.next_value::<std::option::Option<crate::model::Index>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateIndexRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.index.is_some() {
            state.serialize_entry("index", &self.index)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.ListIndexes][google.firestore.admin.v1.FirestoreAdmin.ListIndexes].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListIndexes]: crate::client::FirestoreAdmin::list_indexes
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIndexesRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
    pub parent: std::string::String,

    /// The filter to apply to list results.
    pub filter: std::string::String,

    /// The number of results to return.
    pub page_size: i32,

    /// A page token, returned from a previous call to
    /// [FirestoreAdmin.ListIndexes][google.firestore.admin.v1.FirestoreAdmin.ListIndexes],
    /// that may be used to get the next page of results.
    ///
    /// [google.firestore.admin.v1.FirestoreAdmin.ListIndexes]: crate::client::FirestoreAdmin::list_indexes
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIndexesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIndexesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListIndexesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIndexesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIndexesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListIndexesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIndexesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIndexesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIndexesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIndexesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIndexesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response for
/// [FirestoreAdmin.ListIndexes][google.firestore.admin.v1.FirestoreAdmin.ListIndexes].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListIndexes]: crate::client::FirestoreAdmin::list_indexes
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIndexesResponse {
    /// The requested indexes.
    pub indexes: std::vec::Vec<crate::model::Index>,

    /// A page token that may be used to request another page of results. If blank,
    /// this is the last page.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIndexesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [indexes][crate::model::ListIndexesResponse::indexes].
    pub fn set_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Index>,
    {
        use std::iter::Iterator;
        self.indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListIndexesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListIndexesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIndexesResponse {
    type PageItem = crate::model::Index;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.indexes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIndexesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __indexes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIndexesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "indexes" => Ok(__FieldTag::__indexes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIndexesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIndexesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__indexes => {
                            if !fields.insert(__FieldTag::__indexes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for indexes",
                                ));
                            }
                            result.indexes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Index>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIndexesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.indexes.is_empty() {
            state.serialize_entry("indexes", &self.indexes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.GetIndex][google.firestore.admin.v1.FirestoreAdmin.GetIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetIndex]: crate::client::FirestoreAdmin::get_index
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetIndexRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIndexRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetIndexRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetIndexRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetIndexRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetIndexRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetIndexRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetIndexRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.DeleteIndex][google.firestore.admin.v1.FirestoreAdmin.DeleteIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteIndex]: crate::client::FirestoreAdmin::delete_index
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteIndexRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIndexRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteIndexRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteIndexRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteIndexRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteIndexRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteIndexRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteIndexRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.UpdateField][google.firestore.admin.v1.FirestoreAdmin.UpdateField].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateField]: crate::client::FirestoreAdmin::update_field
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateFieldRequest {
    /// Required. The field to be updated.
    pub field: std::option::Option<crate::model::Field>,

    /// A mask, relative to the field. If specified, only configuration specified
    /// by this field_mask will be updated in the field.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::UpdateFieldRequest::field].
    pub fn set_field<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Field>,
    {
        self.field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field][crate::model::UpdateFieldRequest::field].
    pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Field>,
    {
        self.field = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFieldRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateFieldRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateFieldRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateFieldRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateFieldRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateFieldRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateFieldRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field =
                                map.next_value::<std::option::Option<crate::model::Field>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateFieldRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.field.is_some() {
            state.serialize_entry("field", &self.field)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.GetField][google.firestore.admin.v1.FirestoreAdmin.GetField].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetField]: crate::client::FirestoreAdmin::get_field
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFieldRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetFieldRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFieldRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFieldRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFieldRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFieldRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetFieldRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFieldsRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
    pub parent: std::string::String,

    /// The filter to apply to list results. Currently,
    /// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields]
    /// only supports listing fields that have been explicitly overridden. To issue
    /// this query, call
    /// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields]
    /// with a filter that includes `indexConfig.usesAncestorConfig:false` or
    /// `ttlConfig:*`.
    ///
    /// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
    pub filter: std::string::String,

    /// The number of results to return.
    pub page_size: i32,

    /// A page token, returned from a previous call to
    /// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields],
    /// that may be used to get the next page of results.
    ///
    /// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFieldsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFieldsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFieldsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFieldsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFieldsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFieldsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListFieldsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFieldsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFieldsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFieldsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFieldsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFieldsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response for
/// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFieldsResponse {
    /// The requested fields.
    pub fields: std::vec::Vec<crate::model::Field>,

    /// A page token that may be used to request another page of results. If blank,
    /// this is the last page.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFieldsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fields][crate::model::ListFieldsResponse::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Field>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFieldsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFieldsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListFieldsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFieldsResponse {
    type PageItem = crate::model::Field;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.fields
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFieldsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fields,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFieldsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fields" => Ok(__FieldTag::__fields),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFieldsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFieldsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Field>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFieldsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.ExportDocuments][google.firestore.admin.v1.FirestoreAdmin.ExportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ExportDocuments]: crate::client::FirestoreAdmin::export_documents
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportDocumentsRequest {
    /// Required. Database to export. Should be of the form:
    /// `projects/{project_id}/databases/{database_id}`.
    pub name: std::string::String,

    /// Which collection IDs to export. Unspecified means all collections. Each
    /// collection ID in this list must be unique.
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// The output URI. Currently only supports Google Cloud Storage URIs of the
    /// form: `gs://BUCKET_NAME[/NAMESPACE_PATH]`, where `BUCKET_NAME` is the name
    /// of the Google Cloud Storage bucket and `NAMESPACE_PATH` is an optional
    /// Google Cloud Storage namespace path. When
    /// choosing a name, be sure to consider Google Cloud Storage naming
    /// guidelines: <https://cloud.google.com/storage/docs/naming>.
    /// If the URI is a bucket (without a namespace path), a prefix will be
    /// generated based on the start time.
    pub output_uri_prefix: std::string::String,

    /// An empty list represents all namespaces. This is the preferred
    /// usage for databases that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the database has data in non-default namespaces, but doesn't want
    /// to include them. Each namespace in this list must be unique.
    pub namespace_ids: std::vec::Vec<std::string::String>,

    /// The timestamp that corresponds to the version of the database to be
    /// exported. The timestamp must be in the past, rounded to the minute and not
    /// older than
    /// [earliestVersionTime][google.firestore.admin.v1.Database.earliest_version_time].
    /// If specified, then the exported documents will represent a consistent view
    /// of the database at the provided time. Otherwise, there are no guarantees
    /// about the consistency of the exported documents.
    ///
    /// [google.firestore.admin.v1.Database.earliest_version_time]: crate::model::Database::earliest_version_time
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportDocumentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::ExportDocumentsRequest::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [output_uri_prefix][crate::model::ExportDocumentsRequest::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ExportDocumentsRequest::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::ExportDocumentsRequest::snapshot_time].
    pub fn set_snapshot_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot_time][crate::model::ExportDocumentsRequest::snapshot_time].
    pub fn set_or_clear_snapshot_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExportDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ExportDocumentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportDocumentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __collection_ids,
            __output_uri_prefix,
            __namespace_ids,
            __snapshot_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportDocumentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "collectionIds" => Ok(__FieldTag::__collection_ids),
                            "collection_ids" => Ok(__FieldTag::__collection_ids),
                            "outputUriPrefix" => Ok(__FieldTag::__output_uri_prefix),
                            "output_uri_prefix" => Ok(__FieldTag::__output_uri_prefix),
                            "namespaceIds" => Ok(__FieldTag::__namespace_ids),
                            "namespace_ids" => Ok(__FieldTag::__namespace_ids),
                            "snapshotTime" => Ok(__FieldTag::__snapshot_time),
                            "snapshot_time" => Ok(__FieldTag::__snapshot_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportDocumentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportDocumentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collection_ids => {
                            if !fields.insert(__FieldTag::__collection_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_ids",
                                ));
                            }
                            result.collection_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__output_uri_prefix => {
                            if !fields.insert(__FieldTag::__output_uri_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_uri_prefix",
                                ));
                            }
                            result.output_uri_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__namespace_ids => {
                            if !fields.insert(__FieldTag::__namespace_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace_ids",
                                ));
                            }
                            result.namespace_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__snapshot_time => {
                            if !fields.insert(__FieldTag::__snapshot_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_time",
                                ));
                            }
                            result.snapshot_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportDocumentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.collection_ids.is_empty() {
            state.serialize_entry("collectionIds", &self.collection_ids)?;
        }
        if !self.output_uri_prefix.is_empty() {
            state.serialize_entry("outputUriPrefix", &self.output_uri_prefix)?;
        }
        if !self.namespace_ids.is_empty() {
            state.serialize_entry("namespaceIds", &self.namespace_ids)?;
        }
        if self.snapshot_time.is_some() {
            state.serialize_entry("snapshotTime", &self.snapshot_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.ImportDocuments][google.firestore.admin.v1.FirestoreAdmin.ImportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ImportDocuments]: crate::client::FirestoreAdmin::import_documents
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportDocumentsRequest {
    /// Required. Database to import into. Should be of the form:
    /// `projects/{project_id}/databases/{database_id}`.
    pub name: std::string::String,

    /// Which collection IDs to import. Unspecified means all collections included
    /// in the import. Each collection ID in this list must be unique.
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Location of the exported files.
    /// This must match the output_uri_prefix of an ExportDocumentsResponse from
    /// an export that has completed successfully.
    /// See:
    /// [google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix][google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix].
    ///
    /// [google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix]: crate::model::ExportDocumentsResponse::output_uri_prefix
    pub input_uri_prefix: std::string::String,

    /// An empty list represents all namespaces. This is the preferred
    /// usage for databases that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the database has data in non-default namespaces, but doesn't want
    /// to include them. Each namespace in this list must be unique.
    pub namespace_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportDocumentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::ImportDocumentsRequest::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [input_uri_prefix][crate::model::ImportDocumentsRequest::input_uri_prefix].
    pub fn set_input_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_uri_prefix = v.into();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ImportDocumentsRequest::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ImportDocumentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportDocumentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __collection_ids,
            __input_uri_prefix,
            __namespace_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportDocumentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "collectionIds" => Ok(__FieldTag::__collection_ids),
                            "collection_ids" => Ok(__FieldTag::__collection_ids),
                            "inputUriPrefix" => Ok(__FieldTag::__input_uri_prefix),
                            "input_uri_prefix" => Ok(__FieldTag::__input_uri_prefix),
                            "namespaceIds" => Ok(__FieldTag::__namespace_ids),
                            "namespace_ids" => Ok(__FieldTag::__namespace_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportDocumentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportDocumentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collection_ids => {
                            if !fields.insert(__FieldTag::__collection_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_ids",
                                ));
                            }
                            result.collection_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__input_uri_prefix => {
                            if !fields.insert(__FieldTag::__input_uri_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_uri_prefix",
                                ));
                            }
                            result.input_uri_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__namespace_ids => {
                            if !fields.insert(__FieldTag::__namespace_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace_ids",
                                ));
                            }
                            result.namespace_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportDocumentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.collection_ids.is_empty() {
            state.serialize_entry("collectionIds", &self.collection_ids)?;
        }
        if !self.input_uri_prefix.is_empty() {
            state.serialize_entry("inputUriPrefix", &self.input_uri_prefix)?;
        }
        if !self.namespace_ids.is_empty() {
            state.serialize_entry("namespaceIds", &self.namespace_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.BulkDeleteDocuments][google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments].
///
/// When both collection_ids and namespace_ids are set, only documents satisfying
/// both conditions will be deleted.
///
/// Requests with namespace_ids and collection_ids both empty will be rejected.
/// Please use
/// [FirestoreAdmin.DeleteDatabase][google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase]
/// instead.
///
/// [google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments]: crate::client::FirestoreAdmin::bulk_delete_documents
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase]: crate::client::FirestoreAdmin::delete_database
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkDeleteDocumentsRequest {
    /// Required. Database to operate. Should be of the form:
    /// `projects/{project_id}/databases/{database_id}`.
    pub name: std::string::String,

    /// Optional. IDs of the collection groups to delete. Unspecified means all
    /// collection groups.
    ///
    /// Each collection group in this list must be unique.
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Optional. Namespaces to delete.
    ///
    /// An empty list means all namespaces. This is the recommended
    /// usage for databases that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the database has data in non-default namespaces, but doesn't want
    /// to delete from them.
    ///
    /// Each namespace in this list must be unique.
    pub namespace_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BulkDeleteDocumentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::BulkDeleteDocumentsRequest::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::BulkDeleteDocumentsRequest::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BulkDeleteDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BulkDeleteDocumentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkDeleteDocumentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __collection_ids,
            __namespace_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkDeleteDocumentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "collectionIds" => Ok(__FieldTag::__collection_ids),
                            "collection_ids" => Ok(__FieldTag::__collection_ids),
                            "namespaceIds" => Ok(__FieldTag::__namespace_ids),
                            "namespace_ids" => Ok(__FieldTag::__namespace_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkDeleteDocumentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkDeleteDocumentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collection_ids => {
                            if !fields.insert(__FieldTag::__collection_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_ids",
                                ));
                            }
                            result.collection_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__namespace_ids => {
                            if !fields.insert(__FieldTag::__namespace_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace_ids",
                                ));
                            }
                            result.namespace_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkDeleteDocumentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.collection_ids.is_empty() {
            state.serialize_entry("collectionIds", &self.collection_ids)?;
        }
        if !self.namespace_ids.is_empty() {
            state.serialize_entry("namespaceIds", &self.namespace_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response for
/// [FirestoreAdmin.BulkDeleteDocuments][google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments]: crate::client::FirestoreAdmin::bulk_delete_documents
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkDeleteDocumentsResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteDocumentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BulkDeleteDocumentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BulkDeleteDocumentsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkDeleteDocumentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkDeleteDocumentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkDeleteDocumentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkDeleteDocumentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkDeleteDocumentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.GetBackup][google.firestore.admin.v1.FirestoreAdmin.GetBackup].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetBackup]: crate::client::FirestoreAdmin::get_backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Name of the backup to fetch.
    ///
    /// Format is `projects/{project}/locations/{location}/backups/{backup}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.ListBackups][google.firestore.admin.v1.FirestoreAdmin.ListBackups].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackups]: crate::client::FirestoreAdmin::list_backups
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The location to list backups from.
    ///
    /// Format is `projects/{project}/locations/{location}`.
    /// Use `{location} = '-'` to list backups from all locations for the given
    /// project. This allows listing backups from a single location or from all
    /// locations.
    pub parent: std::string::String,

    /// An expression that filters the list of returned backups.
    ///
    /// A filter expression consists of a field name, a comparison operator, and a
    /// value for filtering.
    /// The value must be a string, a number, or a boolean. The comparison operator
    /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
    /// Colon `:` is the contains operator. Filter rules are not case sensitive.
    ///
    /// The following fields in the [Backup][google.firestore.admin.v1.Backup] are
    /// eligible for filtering:
    ///
    /// * `database_uid` (supports `=` only)
    ///
    /// [google.firestore.admin.v1.Backup]: crate::model::Backup
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response for
/// [FirestoreAdmin.ListBackups][google.firestore.admin.v1.FirestoreAdmin.ListBackups].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackups]: crate::client::FirestoreAdmin::list_backups
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// List of all backups for the project.
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// List of locations that existing backups were not able to be fetched from.
    ///
    /// Instead of failing the entire requests when a single location is
    /// unreachable, this response returns a partial result set and list of
    /// locations unable to be reached here. The request can be retried against a
    /// single location to get a concrete error.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backups,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backups" => Ok(__FieldTag::__backups),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backups => {
                            if !fields.insert(__FieldTag::__backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backups",
                                ));
                            }
                            result.backups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Backup>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backups.is_empty() {
            state.serialize_entry("backups", &self.backups)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [FirestoreAdmin.DeleteBackup][google.firestore.admin.v1.FirestoreAdmin.DeleteBackup].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteBackup]: crate::client::FirestoreAdmin::delete_backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Name of the backup to delete.
    ///
    /// format is `projects/{project}/locations/{location}/backups/{backup}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [FirestoreAdmin.RestoreDatabase][google.firestore.admin.v1.FirestoreAdmin.RestoreDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.RestoreDatabase]: crate::client::FirestoreAdmin::restore_database
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreDatabaseRequest {
    /// Required. The project to restore the database in. Format is
    /// `projects/{project_id}`.
    pub parent: std::string::String,

    /// Required. The ID to use for the database, which will become the final
    /// component of the database's resource name. This database ID must not be
    /// associated with an existing database.
    ///
    /// This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/
    /// with first character a letter and the last a letter or a number. Must not
    /// be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.
    ///
    /// "(default)" database ID is also valid.
    pub database_id: std::string::String,

    /// Required. Backup to restore from. Must be from the same project as the
    /// parent.
    ///
    /// The restored database will be created in the same location as the source
    /// backup.
    ///
    /// Format is: `projects/{project_id}/locations/{location}/backups/{backup}`
    pub backup: std::string::String,

    /// Optional. Encryption configuration for the restored database.
    ///
    /// If this field is not specified, the restored database will use
    /// the same encryption configuration as the backup, namely
    /// [use_source_encryption][google.firestore.admin.v1.Database.EncryptionConfig.use_source_encryption].
    ///
    /// [google.firestore.admin.v1.Database.EncryptionConfig.use_source_encryption]: crate::model::database::EncryptionConfig::encryption_type
    pub encryption_config: std::option::Option<crate::model::database::EncryptionConfig>,

    /// Optional. Immutable. Tags to be bound to the restored database.
    ///
    /// The tags should be provided in the format of
    /// `tagKeys/{tag_key_id} -> tagValues/{tag_value_id}`.
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RestoreDatabaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [database_id][crate::model::RestoreDatabaseRequest::database_id].
    pub fn set_database_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_id = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::RestoreDatabaseRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::RestoreDatabaseRequest::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::database::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::RestoreDatabaseRequest::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::database::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::RestoreDatabaseRequest::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RestoreDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.RestoreDatabaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreDatabaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __database_id,
            __backup,
            __encryption_config,
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreDatabaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "databaseId" => Ok(__FieldTag::__database_id),
                            "database_id" => Ok(__FieldTag::__database_id),
                            "backup" => Ok(__FieldTag::__backup),
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreDatabaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreDatabaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_id => {
                            if !fields.insert(__FieldTag::__database_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_id",
                                ));
                            }
                            result.database_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map.next_value::<std::option::Option<crate::model::database::EncryptionConfig>>()?
                                ;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreDatabaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.database_id.is_empty() {
            state.serialize_entry("databaseId", &self.database_id)?;
        }
        if !self.backup.is_empty() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Cloud Firestore indexes enable simple and complex queries against
/// documents in a database.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Index {
    /// Output only. A server defined name for this index.
    /// The form of this name for composite indexes will be:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{composite_index_id}`
    /// For single field indexes, this field will be empty.
    pub name: std::string::String,

    /// Indexes with a collection query scope specified allow queries
    /// against a collection that is the child of a specific document, specified at
    /// query time, and that has the same collection ID.
    ///
    /// Indexes with a collection group query scope specified allow queries against
    /// all collections descended from a specific document, specified at query
    /// time, and that have the same collection ID as this index.
    pub query_scope: crate::model::index::QueryScope,

    /// The API scope supported by this index.
    pub api_scope: crate::model::index::ApiScope,

    /// The fields supported by this index.
    ///
    /// For composite indexes, this requires a minimum of 2 and a maximum of 100
    /// fields. The last field entry is always for the field path `__name__`. If,
    /// on creation, `__name__` was not specified as the last field, it will be
    /// added automatically with the same direction as that of the last field
    /// defined. If the final field in a composite index is not directional, the
    /// `__name__` will be ordered ASCENDING (unless explicitly specified).
    ///
    /// For single field indexes, this will always be exactly one entry with a
    /// field path equal to the field path of the associated field.
    pub fields: std::vec::Vec<crate::model::index::IndexField>,

    /// Output only. The serving state of the index.
    pub state: crate::model::index::State,

    /// Immutable. The density configuration of the index.
    pub density: crate::model::index::Density,

    /// Optional. Whether the index is multikey. By default, the index is not
    /// multikey. For non-multikey indexes, none of the paths in the index
    /// definition reach or traverse an array, except via an explicit array index.
    /// For multikey indexes, at most one of the paths in the index definition
    /// reach or traverse an array, except via an explicit array index. Violations
    /// will result in errors.
    ///
    /// Note this field only applies to index with MONGODB_COMPATIBLE_API ApiScope.
    pub multikey: bool,

    /// Optional. The number of shards for the index.
    pub shard_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Index {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Index::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [query_scope][crate::model::Index::query_scope].
    pub fn set_query_scope<T: std::convert::Into<crate::model::index::QueryScope>>(
        mut self,
        v: T,
    ) -> Self {
        self.query_scope = v.into();
        self
    }

    /// Sets the value of [api_scope][crate::model::Index::api_scope].
    pub fn set_api_scope<T: std::convert::Into<crate::model::index::ApiScope>>(
        mut self,
        v: T,
    ) -> Self {
        self.api_scope = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::Index::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::index::IndexField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::Index::state].
    pub fn set_state<T: std::convert::Into<crate::model::index::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [density][crate::model::Index::density].
    pub fn set_density<T: std::convert::Into<crate::model::index::Density>>(
        mut self,
        v: T,
    ) -> Self {
        self.density = v.into();
        self
    }

    /// Sets the value of [multikey][crate::model::Index::multikey].
    pub fn set_multikey<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.multikey = v.into();
        self
    }

    /// Sets the value of [shard_count][crate::model::Index::shard_count].
    pub fn set_shard_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.shard_count = v.into();
        self
    }
}

impl wkt::message::Message for Index {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Index"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Index {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __query_scope,
            __api_scope,
            __fields,
            __state,
            __density,
            __multikey,
            __shard_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Index")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "queryScope" => Ok(__FieldTag::__query_scope),
                            "query_scope" => Ok(__FieldTag::__query_scope),
                            "apiScope" => Ok(__FieldTag::__api_scope),
                            "api_scope" => Ok(__FieldTag::__api_scope),
                            "fields" => Ok(__FieldTag::__fields),
                            "state" => Ok(__FieldTag::__state),
                            "density" => Ok(__FieldTag::__density),
                            "multikey" => Ok(__FieldTag::__multikey),
                            "shardCount" => Ok(__FieldTag::__shard_count),
                            "shard_count" => Ok(__FieldTag::__shard_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Index;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Index")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_scope => {
                            if !fields.insert(__FieldTag::__query_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_scope",
                                ));
                            }
                            result.query_scope = map
                                .next_value::<std::option::Option<crate::model::index::QueryScope>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_scope => {
                            if !fields.insert(__FieldTag::__api_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_scope",
                                ));
                            }
                            result.api_scope = map
                                .next_value::<std::option::Option<crate::model::index::ApiScope>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::index::IndexField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::index::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__density => {
                            if !fields.insert(__FieldTag::__density) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for density",
                                ));
                            }
                            result.density = map
                                .next_value::<std::option::Option<crate::model::index::Density>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__multikey => {
                            if !fields.insert(__FieldTag::__multikey) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multikey",
                                ));
                            }
                            result.multikey = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shard_count => {
                            if !fields.insert(__FieldTag::__shard_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shard_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shard_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Index {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.query_scope) {
            state.serialize_entry("queryScope", &self.query_scope)?;
        }
        if !wkt::internal::is_default(&self.api_scope) {
            state.serialize_entry("apiScope", &self.api_scope)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.density) {
            state.serialize_entry("density", &self.density)?;
        }
        if !wkt::internal::is_default(&self.multikey) {
            state.serialize_entry("multikey", &self.multikey)?;
        }
        if !wkt::internal::is_default(&self.shard_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("shardCount", &__With(&self.shard_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Index].
pub mod index {
    #[allow(unused_imports)]
    use super::*;

    /// A field in an index.
    /// The field_path describes which field is indexed, the value_mode describes
    /// how the field value is indexed.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IndexField {
        /// Can be __name__.
        /// For single field indexes, this must match the name of the field or may
        /// be omitted.
        pub field_path: std::string::String,

        /// How the field value is indexed.
        pub value_mode: std::option::Option<crate::model::index::index_field::ValueMode>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IndexField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field_path][crate::model::index::IndexField::field_path].
        pub fn set_field_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field_path = v.into();
            self
        }

        /// Sets the value of [value_mode][crate::model::index::IndexField::value_mode].
        ///
        /// Note that all the setters affecting `value_mode` are mutually
        /// exclusive.
        pub fn set_value_mode<
            T: std::convert::Into<std::option::Option<crate::model::index::index_field::ValueMode>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = v.into();
            self
        }

        /// The value of [value_mode][crate::model::index::IndexField::value_mode]
        /// if it holds a `Order`, `None` if the field is not set or
        /// holds a different branch.
        pub fn order(&self) -> std::option::Option<&crate::model::index::index_field::Order> {
            #[allow(unreachable_patterns)]
            self.value_mode.as_ref().and_then(|v| match v {
                crate::model::index::index_field::ValueMode::Order(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value_mode][crate::model::index::IndexField::value_mode]
        /// to hold a `Order`.
        ///
        /// Note that all the setters affecting `value_mode` are
        /// mutually exclusive.
        pub fn set_order<T: std::convert::Into<crate::model::index::index_field::Order>>(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = std::option::Option::Some(
                crate::model::index::index_field::ValueMode::Order(v.into()),
            );
            self
        }

        /// The value of [value_mode][crate::model::index::IndexField::value_mode]
        /// if it holds a `ArrayConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn array_config(
            &self,
        ) -> std::option::Option<&crate::model::index::index_field::ArrayConfig> {
            #[allow(unreachable_patterns)]
            self.value_mode.as_ref().and_then(|v| match v {
                crate::model::index::index_field::ValueMode::ArrayConfig(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value_mode][crate::model::index::IndexField::value_mode]
        /// to hold a `ArrayConfig`.
        ///
        /// Note that all the setters affecting `value_mode` are
        /// mutually exclusive.
        pub fn set_array_config<
            T: std::convert::Into<crate::model::index::index_field::ArrayConfig>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = std::option::Option::Some(
                crate::model::index::index_field::ValueMode::ArrayConfig(v.into()),
            );
            self
        }

        /// The value of [value_mode][crate::model::index::IndexField::value_mode]
        /// if it holds a `VectorConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn vector_config(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::index::index_field::VectorConfig>>
        {
            #[allow(unreachable_patterns)]
            self.value_mode.as_ref().and_then(|v| match v {
                crate::model::index::index_field::ValueMode::VectorConfig(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value_mode][crate::model::index::IndexField::value_mode]
        /// to hold a `VectorConfig`.
        ///
        /// Note that all the setters affecting `value_mode` are
        /// mutually exclusive.
        pub fn set_vector_config<
            T: std::convert::Into<std::boxed::Box<crate::model::index::index_field::VectorConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = std::option::Option::Some(
                crate::model::index::index_field::ValueMode::VectorConfig(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for IndexField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Index.IndexField"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IndexField {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __field_path,
                __order,
                __array_config,
                __vector_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IndexField")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "fieldPath" => Ok(__FieldTag::__field_path),
                                "field_path" => Ok(__FieldTag::__field_path),
                                "order" => Ok(__FieldTag::__order),
                                "arrayConfig" => Ok(__FieldTag::__array_config),
                                "array_config" => Ok(__FieldTag::__array_config),
                                "vectorConfig" => Ok(__FieldTag::__vector_config),
                                "vector_config" => Ok(__FieldTag::__vector_config),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IndexField;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IndexField")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__field_path => {
                                if !fields.insert(__FieldTag::__field_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field_path",
                                    ));
                                }
                                result.field_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__order => {
                                if !fields.insert(__FieldTag::__order) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for order",
                                    ));
                                }
                                if result.value_mode.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value_mode`, a oneof with full ID .google.firestore.admin.v1.Index.IndexField.order, latest field was order",
                                    ));
                                }
                                result.value_mode = std::option::Option::Some(
                                    crate::model::index::index_field::ValueMode::Order(
                                        map.next_value::<std::option::Option<
                                            crate::model::index::index_field::Order,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__array_config => {
                                if !fields.insert(__FieldTag::__array_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for array_config",
                                    ));
                                }
                                if result.value_mode.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value_mode`, a oneof with full ID .google.firestore.admin.v1.Index.IndexField.array_config, latest field was arrayConfig",
                                    ));
                                }
                                result.value_mode = std::option::Option::Some(
                                    crate::model::index::index_field::ValueMode::ArrayConfig(
                                        map.next_value::<std::option::Option<
                                            crate::model::index::index_field::ArrayConfig,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__vector_config => {
                                if !fields.insert(__FieldTag::__vector_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vector_config",
                                    ));
                                }
                                if result.value_mode.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value_mode`, a oneof with full ID .google.firestore.admin.v1.Index.IndexField.vector_config, latest field was vectorConfig",
                                    ));
                                }
                                result.value_mode = std::option::Option::Some(
                                    crate::model::index::index_field::ValueMode::VectorConfig(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::index::index_field::VectorConfig,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IndexField {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.field_path.is_empty() {
                state.serialize_entry("fieldPath", &self.field_path)?;
            }
            if let Some(value) = self.order() {
                state.serialize_entry("order", value)?;
            }
            if let Some(value) = self.array_config() {
                state.serialize_entry("arrayConfig", value)?;
            }
            if let Some(value) = self.vector_config() {
                state.serialize_entry("vectorConfig", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [IndexField].
    pub mod index_field {
        #[allow(unused_imports)]
        use super::*;

        /// The index configuration to support vector search operations
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct VectorConfig {
            /// Required. The vector dimension this configuration applies to.
            ///
            /// The resulting index will only include vectors of this dimension, and
            /// can be used for vector search with the same dimension.
            pub dimension: i32,

            /// The type of index used.
            pub r#type: std::option::Option<crate::model::index::index_field::vector_config::Type>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl VectorConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [dimension][crate::model::index::index_field::VectorConfig::dimension].
            pub fn set_dimension<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.dimension = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::index::index_field::VectorConfig::type].
            ///
            /// Note that all the setters affecting `r#type` are mutually
            /// exclusive.
            pub fn set_type<
                T: std::convert::Into<
                        std::option::Option<crate::model::index::index_field::vector_config::Type>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// The value of [r#type][crate::model::index::index_field::VectorConfig::r#type]
            /// if it holds a `Flat`, `None` if the field is not set or
            /// holds a different branch.
            pub fn flat(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::index::index_field::vector_config::FlatIndex>,
            > {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::index::index_field::vector_config::Type::Flat(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::index::index_field::VectorConfig::r#type]
            /// to hold a `Flat`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_flat<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::index::index_field::vector_config::FlatIndex>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::index::index_field::vector_config::Type::Flat(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for VectorConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Index.IndexField.VectorConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for VectorConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __dimension,
                    __flat,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for VectorConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "dimension" => Ok(__FieldTag::__dimension),
                                    "flat" => Ok(__FieldTag::__flat),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = VectorConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct VectorConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__dimension => {
                                    if !fields.insert(__FieldTag::__dimension) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for dimension",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.dimension =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__flat => {
                                    if !fields.insert(__FieldTag::__flat) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for flat"),
                                        );
                                    }
                                    if result.r#type.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `r#type`, a oneof with full ID .google.firestore.admin.v1.Index.IndexField.VectorConfig.flat, latest field was flat",
                                            ),
                                        );
                                    }
                                    result.r#type = std::option::Option::Some(
                                        crate::model::index::index_field::vector_config::Type::Flat(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::index::index_field::vector_config::FlatIndex>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for VectorConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.dimension) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("dimension", &__With(&self.dimension))?;
                }
                if let Some(value) = self.flat() {
                    state.serialize_entry("flat", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [VectorConfig].
        pub mod vector_config {
            #[allow(unused_imports)]
            use super::*;

            /// An index that stores vectors in a flat data structure, and supports
            /// exhaustive search.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct FlatIndex {
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl FlatIndex {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for FlatIndex {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.firestore.admin.v1.Index.IndexField.VectorConfig.FlatIndex"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for FlatIndex {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for FlatIndex")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    Ok(__FieldTag::Unknown(value.to_string()))
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = FlatIndex;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct FlatIndex")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for FlatIndex {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// The type of index used.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Type {
                /// Indicates the vector index is a flat index.
                Flat(std::boxed::Box<crate::model::index::index_field::vector_config::FlatIndex>),
            }
        }

        /// The supported orderings.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Order {
            /// The ordering is unspecified. Not a valid option.
            Unspecified,
            /// The field is ordered by ascending field value.
            Ascending,
            /// The field is ordered by descending field value.
            Descending,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Order::value] or
            /// [Order::name].
            UnknownValue(order::UnknownValue),
        }

        #[doc(hidden)]
        pub mod order {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Order {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Ascending => std::option::Option::Some(1),
                    Self::Descending => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ORDER_UNSPECIFIED"),
                    Self::Ascending => std::option::Option::Some("ASCENDING"),
                    Self::Descending => std::option::Option::Some("DESCENDING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Order {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Order {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Order {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Ascending,
                    2 => Self::Descending,
                    _ => Self::UnknownValue(order::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Order {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ORDER_UNSPECIFIED" => Self::Unspecified,
                    "ASCENDING" => Self::Ascending,
                    "DESCENDING" => Self::Descending,
                    _ => Self::UnknownValue(order::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Order {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Ascending => serializer.serialize_i32(1),
                    Self::Descending => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Order {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Order>::new(
                    ".google.firestore.admin.v1.Index.IndexField.Order",
                ))
            }
        }

        /// The supported array value configurations.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ArrayConfig {
            /// The index does not support additional array queries.
            Unspecified,
            /// The index supports array containment queries.
            Contains,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ArrayConfig::value] or
            /// [ArrayConfig::name].
            UnknownValue(array_config::UnknownValue),
        }

        #[doc(hidden)]
        pub mod array_config {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ArrayConfig {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Contains => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ARRAY_CONFIG_UNSPECIFIED"),
                    Self::Contains => std::option::Option::Some("CONTAINS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ArrayConfig {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ArrayConfig {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ArrayConfig {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Contains,
                    _ => Self::UnknownValue(array_config::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ArrayConfig {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ARRAY_CONFIG_UNSPECIFIED" => Self::Unspecified,
                    "CONTAINS" => Self::Contains,
                    _ => Self::UnknownValue(array_config::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ArrayConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Contains => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ArrayConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ArrayConfig>::new(
                    ".google.firestore.admin.v1.Index.IndexField.ArrayConfig",
                ))
            }
        }

        /// How the field value is indexed.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ValueMode {
            /// Indicates that this field supports ordering by the specified order or
            /// comparing using =, !=, <, <=, >, >=.
            Order(crate::model::index::index_field::Order),
            /// Indicates that this field supports operations on `array_value`s.
            ArrayConfig(crate::model::index::index_field::ArrayConfig),
            /// Indicates that this field supports nearest neighbor and distance
            /// operations on vector.
            VectorConfig(std::boxed::Box<crate::model::index::index_field::VectorConfig>),
        }
    }

    /// Query Scope defines the scope at which a query is run. This is specified on
    /// a StructuredQuery's `from` field.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum QueryScope {
        /// The query scope is unspecified. Not a valid option.
        Unspecified,
        /// Indexes with a collection query scope specified allow queries
        /// against a collection that is the child of a specific document, specified
        /// at query time, and that has the collection ID specified by the index.
        Collection,
        /// Indexes with a collection group query scope specified allow queries
        /// against all collections that has the collection ID specified by the
        /// index.
        CollectionGroup,
        /// Include all the collections's ancestor in the index. Only available for
        /// Datastore Mode databases.
        CollectionRecursive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [QueryScope::value] or
        /// [QueryScope::name].
        UnknownValue(query_scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod query_scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl QueryScope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Collection => std::option::Option::Some(1),
                Self::CollectionGroup => std::option::Option::Some(2),
                Self::CollectionRecursive => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("QUERY_SCOPE_UNSPECIFIED"),
                Self::Collection => std::option::Option::Some("COLLECTION"),
                Self::CollectionGroup => std::option::Option::Some("COLLECTION_GROUP"),
                Self::CollectionRecursive => std::option::Option::Some("COLLECTION_RECURSIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for QueryScope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for QueryScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for QueryScope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Collection,
                2 => Self::CollectionGroup,
                3 => Self::CollectionRecursive,
                _ => Self::UnknownValue(query_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for QueryScope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "QUERY_SCOPE_UNSPECIFIED" => Self::Unspecified,
                "COLLECTION" => Self::Collection,
                "COLLECTION_GROUP" => Self::CollectionGroup,
                "COLLECTION_RECURSIVE" => Self::CollectionRecursive,
                _ => Self::UnknownValue(query_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for QueryScope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Collection => serializer.serialize_i32(1),
                Self::CollectionGroup => serializer.serialize_i32(2),
                Self::CollectionRecursive => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for QueryScope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<QueryScope>::new(
                ".google.firestore.admin.v1.Index.QueryScope",
            ))
        }
    }

    /// API Scope defines the APIs (Firestore Native, or Firestore in
    /// Datastore Mode) that are supported for queries.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ApiScope {
        /// The index can only be used by the Firestore Native query API.
        /// This is the default.
        AnyApi,
        /// The index can only be used by the Firestore in Datastore Mode query API.
        DatastoreModeApi,
        /// The index can only be used by the MONGODB_COMPATIBLE_API.
        MongodbCompatibleApi,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ApiScope::value] or
        /// [ApiScope::name].
        UnknownValue(api_scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod api_scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ApiScope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::AnyApi => std::option::Option::Some(0),
                Self::DatastoreModeApi => std::option::Option::Some(1),
                Self::MongodbCompatibleApi => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::AnyApi => std::option::Option::Some("ANY_API"),
                Self::DatastoreModeApi => std::option::Option::Some("DATASTORE_MODE_API"),
                Self::MongodbCompatibleApi => std::option::Option::Some("MONGODB_COMPATIBLE_API"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ApiScope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ApiScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ApiScope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::AnyApi,
                1 => Self::DatastoreModeApi,
                2 => Self::MongodbCompatibleApi,
                _ => Self::UnknownValue(api_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ApiScope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANY_API" => Self::AnyApi,
                "DATASTORE_MODE_API" => Self::DatastoreModeApi,
                "MONGODB_COMPATIBLE_API" => Self::MongodbCompatibleApi,
                _ => Self::UnknownValue(api_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ApiScope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::AnyApi => serializer.serialize_i32(0),
                Self::DatastoreModeApi => serializer.serialize_i32(1),
                Self::MongodbCompatibleApi => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ApiScope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ApiScope>::new(
                ".google.firestore.admin.v1.Index.ApiScope",
            ))
        }
    }

    /// The state of an index. During index creation, an index will be in the
    /// `CREATING` state. If the index is created successfully, it will transition
    /// to the `READY` state. If the index creation encounters a problem, the index
    /// will transition to the `NEEDS_REPAIR` state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unspecified.
        Unspecified,
        /// The index is being created.
        /// There is an active long-running operation for the index.
        /// The index is updated when writing a document.
        /// Some index data may exist.
        Creating,
        /// The index is ready to be used.
        /// The index is updated when writing a document.
        /// The index is fully populated from all stored documents it applies to.
        Ready,
        /// The index was being created, but something went wrong.
        /// There is no active long-running operation for the index,
        /// and the most recently finished long-running operation failed.
        /// The index is not updated when writing a document.
        /// Some index data may exist.
        /// Use the google.longrunning.Operations API to determine why the operation
        /// that last attempted to create this index failed, then re-create the
        /// index.
        NeedsRepair,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::NeedsRepair => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::NeedsRepair => std::option::Option::Some("NEEDS_REPAIR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::NeedsRepair,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "NEEDS_REPAIR" => Self::NeedsRepair,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::NeedsRepair => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.firestore.admin.v1.Index.State",
            ))
        }
    }

    /// The density configuration for the index.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Density {
        /// Unspecified. It will use database default setting. This value is input
        /// only.
        Unspecified,
        /// In order for an index entry to be added, the document must
        /// contain all fields specified in the index.
        ///
        /// This is the only allowed value for indexes having ApiScope `ANY_API` and
        /// `DATASTORE_MODE_API`.
        SparseAll,
        /// In order for an index entry to be added, the document must
        /// contain at least one of the fields specified in the index.
        /// Non-existent fields are treated as having a NULL value when generating
        /// index entries.
        SparseAny,
        /// An index entry will be added regardless of whether the
        /// document contains any of the fields specified in the index.
        /// Non-existent fields are treated as having a NULL value when generating
        /// index entries.
        Dense,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Density::value] or
        /// [Density::name].
        UnknownValue(density::UnknownValue),
    }

    #[doc(hidden)]
    pub mod density {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Density {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SparseAll => std::option::Option::Some(1),
                Self::SparseAny => std::option::Option::Some(2),
                Self::Dense => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DENSITY_UNSPECIFIED"),
                Self::SparseAll => std::option::Option::Some("SPARSE_ALL"),
                Self::SparseAny => std::option::Option::Some("SPARSE_ANY"),
                Self::Dense => std::option::Option::Some("DENSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Density {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Density {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Density {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SparseAll,
                2 => Self::SparseAny,
                3 => Self::Dense,
                _ => Self::UnknownValue(density::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Density {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DENSITY_UNSPECIFIED" => Self::Unspecified,
                "SPARSE_ALL" => Self::SparseAll,
                "SPARSE_ANY" => Self::SparseAny,
                "DENSE" => Self::Dense,
                _ => Self::UnknownValue(density::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Density {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SparseAll => serializer.serialize_i32(1),
                Self::SparseAny => serializer.serialize_i32(2),
                Self::Dense => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Density {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Density>::new(
                ".google.firestore.admin.v1.Index.Density",
            ))
        }
    }
}

/// The metadata message for
/// [google.cloud.location.Location.metadata][google.cloud.location.Location.metadata].
///
/// [google.cloud.location.Location.metadata]: location::model::Location::metadata
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.LocationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.CreateIndex][google.firestore.admin.v1.FirestoreAdmin.CreateIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateIndex]: crate::client::FirestoreAdmin::create_index
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IndexOperationMetadata {
    /// The time this operation started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The index resource that this operation is acting on. For example:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`
    pub index: std::string::String,

    /// The state of the operation.
    pub state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::IndexOperationMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::IndexOperationMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::IndexOperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::IndexOperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [index][crate::model::IndexOperationMetadata::index].
    pub fn set_index<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [state][crate::model::IndexOperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::IndexOperationMetadata::progress_documents].
    pub fn set_progress_documents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_documents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_documents][crate::model::IndexOperationMetadata::progress_documents].
    pub fn set_or_clear_progress_documents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_documents = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_bytes][crate::model::IndexOperationMetadata::progress_bytes].
    pub fn set_progress_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_bytes][crate::model::IndexOperationMetadata::progress_bytes].
    pub fn set_or_clear_progress_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.IndexOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IndexOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __index,
            __state,
            __progress_documents,
            __progress_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IndexOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "index" => Ok(__FieldTag::__index),
                            "state" => Ok(__FieldTag::__state),
                            "progressDocuments" => Ok(__FieldTag::__progress_documents),
                            "progress_documents" => Ok(__FieldTag::__progress_documents),
                            "progressBytes" => Ok(__FieldTag::__progress_bytes),
                            "progress_bytes" => Ok(__FieldTag::__progress_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IndexOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IndexOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            result.index = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress_documents => {
                            if !fields.insert(__FieldTag::__progress_documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_documents",
                                ));
                            }
                            result.progress_documents =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__progress_bytes => {
                            if !fields.insert(__FieldTag::__progress_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_bytes",
                                ));
                            }
                            result.progress_bytes =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IndexOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.index.is_empty() {
            state.serialize_entry("index", &self.index)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.progress_documents.is_some() {
            state.serialize_entry("progressDocuments", &self.progress_documents)?;
        }
        if self.progress_bytes.is_some() {
            state.serialize_entry("progressBytes", &self.progress_bytes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.UpdateField][google.firestore.admin.v1.FirestoreAdmin.UpdateField].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateField]: crate::client::FirestoreAdmin::update_field
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FieldOperationMetadata {
    /// The time this operation started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The field resource that this operation is acting on. For example:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_path}`
    pub field: std::string::String,

    /// A list of
    /// [IndexConfigDelta][google.firestore.admin.v1.FieldOperationMetadata.IndexConfigDelta],
    /// which describe the intent of this operation.
    ///
    /// [google.firestore.admin.v1.FieldOperationMetadata.IndexConfigDelta]: crate::model::field_operation_metadata::IndexConfigDelta
    pub index_config_deltas:
        std::vec::Vec<crate::model::field_operation_metadata::IndexConfigDelta>,

    /// The state of the operation.
    pub state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Describes the deltas of TTL configuration.
    pub ttl_config_delta:
        std::option::Option<crate::model::field_operation_metadata::TtlConfigDelta>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FieldOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::FieldOperationMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::FieldOperationMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::FieldOperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::FieldOperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field][crate::model::FieldOperationMetadata::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [index_config_deltas][crate::model::FieldOperationMetadata::index_config_deltas].
    pub fn set_index_config_deltas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::field_operation_metadata::IndexConfigDelta>,
    {
        use std::iter::Iterator;
        self.index_config_deltas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::FieldOperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::FieldOperationMetadata::progress_documents].
    pub fn set_progress_documents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_documents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_documents][crate::model::FieldOperationMetadata::progress_documents].
    pub fn set_or_clear_progress_documents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_documents = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_bytes][crate::model::FieldOperationMetadata::progress_bytes].
    pub fn set_progress_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_bytes][crate::model::FieldOperationMetadata::progress_bytes].
    pub fn set_or_clear_progress_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ttl_config_delta][crate::model::FieldOperationMetadata::ttl_config_delta].
    pub fn set_ttl_config_delta<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::field_operation_metadata::TtlConfigDelta>,
    {
        self.ttl_config_delta = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ttl_config_delta][crate::model::FieldOperationMetadata::ttl_config_delta].
    pub fn set_or_clear_ttl_config_delta<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::field_operation_metadata::TtlConfigDelta>,
    {
        self.ttl_config_delta = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FieldOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.FieldOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FieldOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __field,
            __index_config_deltas,
            __state,
            __progress_documents,
            __progress_bytes,
            __ttl_config_delta,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FieldOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "field" => Ok(__FieldTag::__field),
                            "indexConfigDeltas" => Ok(__FieldTag::__index_config_deltas),
                            "index_config_deltas" => Ok(__FieldTag::__index_config_deltas),
                            "state" => Ok(__FieldTag::__state),
                            "progressDocuments" => Ok(__FieldTag::__progress_documents),
                            "progress_documents" => Ok(__FieldTag::__progress_documents),
                            "progressBytes" => Ok(__FieldTag::__progress_bytes),
                            "progress_bytes" => Ok(__FieldTag::__progress_bytes),
                            "ttlConfigDelta" => Ok(__FieldTag::__ttl_config_delta),
                            "ttl_config_delta" => Ok(__FieldTag::__ttl_config_delta),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FieldOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FieldOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index_config_deltas => {
                            if !fields.insert(__FieldTag::__index_config_deltas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_config_deltas",
                                ));
                            }
                            result.index_config_deltas = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::field_operation_metadata::IndexConfigDelta,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress_documents => {
                            if !fields.insert(__FieldTag::__progress_documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_documents",
                                ));
                            }
                            result.progress_documents =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__progress_bytes => {
                            if !fields.insert(__FieldTag::__progress_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_bytes",
                                ));
                            }
                            result.progress_bytes =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__ttl_config_delta => {
                            if !fields.insert(__FieldTag::__ttl_config_delta) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl_config_delta",
                                ));
                            }
                            result.ttl_config_delta = map.next_value::<std::option::Option<
                                crate::model::field_operation_metadata::TtlConfigDelta,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FieldOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.field.is_empty() {
            state.serialize_entry("field", &self.field)?;
        }
        if !self.index_config_deltas.is_empty() {
            state.serialize_entry("indexConfigDeltas", &self.index_config_deltas)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.progress_documents.is_some() {
            state.serialize_entry("progressDocuments", &self.progress_documents)?;
        }
        if self.progress_bytes.is_some() {
            state.serialize_entry("progressBytes", &self.progress_bytes)?;
        }
        if self.ttl_config_delta.is_some() {
            state.serialize_entry("ttlConfigDelta", &self.ttl_config_delta)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FieldOperationMetadata].
pub mod field_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Information about an index configuration change.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IndexConfigDelta {
        /// Specifies how the index is changing.
        pub change_type: crate::model::field_operation_metadata::index_config_delta::ChangeType,

        /// The index being changed.
        pub index: std::option::Option<crate::model::Index>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IndexConfigDelta {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [change_type][crate::model::field_operation_metadata::IndexConfigDelta::change_type].
        pub fn set_change_type<
            T: std::convert::Into<
                    crate::model::field_operation_metadata::index_config_delta::ChangeType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.change_type = v.into();
            self
        }

        /// Sets the value of [index][crate::model::field_operation_metadata::IndexConfigDelta::index].
        pub fn set_index<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Index>,
        {
            self.index = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [index][crate::model::field_operation_metadata::IndexConfigDelta::index].
        pub fn set_or_clear_index<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Index>,
        {
            self.index = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for IndexConfigDelta {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.FieldOperationMetadata.IndexConfigDelta"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IndexConfigDelta {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __change_type,
                __index,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IndexConfigDelta")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "changeType" => Ok(__FieldTag::__change_type),
                                "change_type" => Ok(__FieldTag::__change_type),
                                "index" => Ok(__FieldTag::__index),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IndexConfigDelta;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IndexConfigDelta")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__change_type => {
                                if !fields.insert(__FieldTag::__change_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for change_type",
                                    ));
                                }
                                result.change_type = map.next_value::<std::option::Option<crate::model::field_operation_metadata::index_config_delta::ChangeType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__index => {
                                if !fields.insert(__FieldTag::__index) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for index",
                                    ));
                                }
                                result.index =
                                    map.next_value::<std::option::Option<crate::model::Index>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IndexConfigDelta {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.change_type) {
                state.serialize_entry("changeType", &self.change_type)?;
            }
            if self.index.is_some() {
                state.serialize_entry("index", &self.index)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [IndexConfigDelta].
    pub mod index_config_delta {
        #[allow(unused_imports)]
        use super::*;

        /// Specifies how the index is changing.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ChangeType {
            /// The type of change is not specified or known.
            Unspecified,
            /// The single field index is being added.
            Add,
            /// The single field index is being removed.
            Remove,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ChangeType::value] or
            /// [ChangeType::name].
            UnknownValue(change_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod change_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ChangeType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Add => std::option::Option::Some(1),
                    Self::Remove => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CHANGE_TYPE_UNSPECIFIED"),
                    Self::Add => std::option::Option::Some("ADD"),
                    Self::Remove => std::option::Option::Some("REMOVE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ChangeType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ChangeType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ChangeType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Add,
                    2 => Self::Remove,
                    _ => Self::UnknownValue(change_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ChangeType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CHANGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "ADD" => Self::Add,
                    "REMOVE" => Self::Remove,
                    _ => Self::UnknownValue(change_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ChangeType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Add => serializer.serialize_i32(1),
                    Self::Remove => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ChangeType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ChangeType>::new(
                    ".google.firestore.admin.v1.FieldOperationMetadata.IndexConfigDelta.ChangeType",
                ))
            }
        }
    }

    /// Information about a TTL configuration change.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TtlConfigDelta {
        /// Specifies how the TTL configuration is changing.
        pub change_type: crate::model::field_operation_metadata::ttl_config_delta::ChangeType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TtlConfigDelta {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [change_type][crate::model::field_operation_metadata::TtlConfigDelta::change_type].
        pub fn set_change_type<
            T: std::convert::Into<
                    crate::model::field_operation_metadata::ttl_config_delta::ChangeType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.change_type = v.into();
            self
        }
    }

    impl wkt::message::Message for TtlConfigDelta {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.FieldOperationMetadata.TtlConfigDelta"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TtlConfigDelta {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __change_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TtlConfigDelta")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "changeType" => Ok(__FieldTag::__change_type),
                                "change_type" => Ok(__FieldTag::__change_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TtlConfigDelta;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TtlConfigDelta")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__change_type => {
                                if !fields.insert(__FieldTag::__change_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for change_type",
                                    ));
                                }
                                result.change_type = map.next_value::<std::option::Option<crate::model::field_operation_metadata::ttl_config_delta::ChangeType>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TtlConfigDelta {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.change_type) {
                state.serialize_entry("changeType", &self.change_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TtlConfigDelta].
    pub mod ttl_config_delta {
        #[allow(unused_imports)]
        use super::*;

        /// Specifies how the TTL config is changing.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ChangeType {
            /// The type of change is not specified or known.
            Unspecified,
            /// The TTL config is being added.
            Add,
            /// The TTL config is being removed.
            Remove,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ChangeType::value] or
            /// [ChangeType::name].
            UnknownValue(change_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod change_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ChangeType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Add => std::option::Option::Some(1),
                    Self::Remove => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CHANGE_TYPE_UNSPECIFIED"),
                    Self::Add => std::option::Option::Some("ADD"),
                    Self::Remove => std::option::Option::Some("REMOVE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ChangeType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ChangeType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ChangeType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Add,
                    2 => Self::Remove,
                    _ => Self::UnknownValue(change_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ChangeType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CHANGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "ADD" => Self::Add,
                    "REMOVE" => Self::Remove,
                    _ => Self::UnknownValue(change_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ChangeType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Add => serializer.serialize_i32(1),
                    Self::Remove => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ChangeType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ChangeType>::new(
                    ".google.firestore.admin.v1.FieldOperationMetadata.TtlConfigDelta.ChangeType",
                ))
            }
        }
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.ExportDocuments][google.firestore.admin.v1.FirestoreAdmin.ExportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ExportDocuments]: crate::client::FirestoreAdmin::export_documents
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportDocumentsMetadata {
    /// The time this operation started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The state of the export operation.
    pub operation_state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Which collection IDs are being exported.
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Where the documents are being exported to.
    pub output_uri_prefix: std::string::String,

    /// Which namespace IDs are being exported.
    pub namespace_ids: std::vec::Vec<std::string::String>,

    /// The timestamp that corresponds to the version of the database that is being
    /// exported. If unspecified, there are no guarantees about the consistency of
    /// the documents being exported.
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportDocumentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::ExportDocumentsMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ExportDocumentsMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ExportDocumentsMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ExportDocumentsMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_state][crate::model::ExportDocumentsMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::ExportDocumentsMetadata::progress_documents].
    pub fn set_progress_documents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_documents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_documents][crate::model::ExportDocumentsMetadata::progress_documents].
    pub fn set_or_clear_progress_documents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_documents = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ExportDocumentsMetadata::progress_bytes].
    pub fn set_progress_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_bytes][crate::model::ExportDocumentsMetadata::progress_bytes].
    pub fn set_or_clear_progress_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [collection_ids][crate::model::ExportDocumentsMetadata::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [output_uri_prefix][crate::model::ExportDocumentsMetadata::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ExportDocumentsMetadata::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::ExportDocumentsMetadata::snapshot_time].
    pub fn set_snapshot_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot_time][crate::model::ExportDocumentsMetadata::snapshot_time].
    pub fn set_or_clear_snapshot_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExportDocumentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ExportDocumentsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportDocumentsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __operation_state,
            __progress_documents,
            __progress_bytes,
            __collection_ids,
            __output_uri_prefix,
            __namespace_ids,
            __snapshot_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportDocumentsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "operationState" => Ok(__FieldTag::__operation_state),
                            "operation_state" => Ok(__FieldTag::__operation_state),
                            "progressDocuments" => Ok(__FieldTag::__progress_documents),
                            "progress_documents" => Ok(__FieldTag::__progress_documents),
                            "progressBytes" => Ok(__FieldTag::__progress_bytes),
                            "progress_bytes" => Ok(__FieldTag::__progress_bytes),
                            "collectionIds" => Ok(__FieldTag::__collection_ids),
                            "collection_ids" => Ok(__FieldTag::__collection_ids),
                            "outputUriPrefix" => Ok(__FieldTag::__output_uri_prefix),
                            "output_uri_prefix" => Ok(__FieldTag::__output_uri_prefix),
                            "namespaceIds" => Ok(__FieldTag::__namespace_ids),
                            "namespace_ids" => Ok(__FieldTag::__namespace_ids),
                            "snapshotTime" => Ok(__FieldTag::__snapshot_time),
                            "snapshot_time" => Ok(__FieldTag::__snapshot_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportDocumentsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportDocumentsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__operation_state => {
                            if !fields.insert(__FieldTag::__operation_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_state",
                                ));
                            }
                            result.operation_state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress_documents => {
                            if !fields.insert(__FieldTag::__progress_documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_documents",
                                ));
                            }
                            result.progress_documents =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__progress_bytes => {
                            if !fields.insert(__FieldTag::__progress_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_bytes",
                                ));
                            }
                            result.progress_bytes =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__collection_ids => {
                            if !fields.insert(__FieldTag::__collection_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_ids",
                                ));
                            }
                            result.collection_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__output_uri_prefix => {
                            if !fields.insert(__FieldTag::__output_uri_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_uri_prefix",
                                ));
                            }
                            result.output_uri_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__namespace_ids => {
                            if !fields.insert(__FieldTag::__namespace_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace_ids",
                                ));
                            }
                            result.namespace_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__snapshot_time => {
                            if !fields.insert(__FieldTag::__snapshot_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_time",
                                ));
                            }
                            result.snapshot_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportDocumentsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.operation_state) {
            state.serialize_entry("operationState", &self.operation_state)?;
        }
        if self.progress_documents.is_some() {
            state.serialize_entry("progressDocuments", &self.progress_documents)?;
        }
        if self.progress_bytes.is_some() {
            state.serialize_entry("progressBytes", &self.progress_bytes)?;
        }
        if !self.collection_ids.is_empty() {
            state.serialize_entry("collectionIds", &self.collection_ids)?;
        }
        if !self.output_uri_prefix.is_empty() {
            state.serialize_entry("outputUriPrefix", &self.output_uri_prefix)?;
        }
        if !self.namespace_ids.is_empty() {
            state.serialize_entry("namespaceIds", &self.namespace_ids)?;
        }
        if self.snapshot_time.is_some() {
            state.serialize_entry("snapshotTime", &self.snapshot_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.ImportDocuments][google.firestore.admin.v1.FirestoreAdmin.ImportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ImportDocuments]: crate::client::FirestoreAdmin::import_documents
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportDocumentsMetadata {
    /// The time this operation started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The state of the import operation.
    pub operation_state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Which collection IDs are being imported.
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// The location of the documents being imported.
    pub input_uri_prefix: std::string::String,

    /// Which namespace IDs are being imported.
    pub namespace_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportDocumentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::ImportDocumentsMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ImportDocumentsMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ImportDocumentsMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ImportDocumentsMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_state][crate::model::ImportDocumentsMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::ImportDocumentsMetadata::progress_documents].
    pub fn set_progress_documents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_documents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_documents][crate::model::ImportDocumentsMetadata::progress_documents].
    pub fn set_or_clear_progress_documents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_documents = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ImportDocumentsMetadata::progress_bytes].
    pub fn set_progress_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_bytes][crate::model::ImportDocumentsMetadata::progress_bytes].
    pub fn set_or_clear_progress_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [collection_ids][crate::model::ImportDocumentsMetadata::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [input_uri_prefix][crate::model::ImportDocumentsMetadata::input_uri_prefix].
    pub fn set_input_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_uri_prefix = v.into();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ImportDocumentsMetadata::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportDocumentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ImportDocumentsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportDocumentsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __operation_state,
            __progress_documents,
            __progress_bytes,
            __collection_ids,
            __input_uri_prefix,
            __namespace_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportDocumentsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "operationState" => Ok(__FieldTag::__operation_state),
                            "operation_state" => Ok(__FieldTag::__operation_state),
                            "progressDocuments" => Ok(__FieldTag::__progress_documents),
                            "progress_documents" => Ok(__FieldTag::__progress_documents),
                            "progressBytes" => Ok(__FieldTag::__progress_bytes),
                            "progress_bytes" => Ok(__FieldTag::__progress_bytes),
                            "collectionIds" => Ok(__FieldTag::__collection_ids),
                            "collection_ids" => Ok(__FieldTag::__collection_ids),
                            "inputUriPrefix" => Ok(__FieldTag::__input_uri_prefix),
                            "input_uri_prefix" => Ok(__FieldTag::__input_uri_prefix),
                            "namespaceIds" => Ok(__FieldTag::__namespace_ids),
                            "namespace_ids" => Ok(__FieldTag::__namespace_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportDocumentsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportDocumentsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__operation_state => {
                            if !fields.insert(__FieldTag::__operation_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_state",
                                ));
                            }
                            result.operation_state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress_documents => {
                            if !fields.insert(__FieldTag::__progress_documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_documents",
                                ));
                            }
                            result.progress_documents =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__progress_bytes => {
                            if !fields.insert(__FieldTag::__progress_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_bytes",
                                ));
                            }
                            result.progress_bytes =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__collection_ids => {
                            if !fields.insert(__FieldTag::__collection_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_ids",
                                ));
                            }
                            result.collection_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__input_uri_prefix => {
                            if !fields.insert(__FieldTag::__input_uri_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_uri_prefix",
                                ));
                            }
                            result.input_uri_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__namespace_ids => {
                            if !fields.insert(__FieldTag::__namespace_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace_ids",
                                ));
                            }
                            result.namespace_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportDocumentsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.operation_state) {
            state.serialize_entry("operationState", &self.operation_state)?;
        }
        if self.progress_documents.is_some() {
            state.serialize_entry("progressDocuments", &self.progress_documents)?;
        }
        if self.progress_bytes.is_some() {
            state.serialize_entry("progressBytes", &self.progress_bytes)?;
        }
        if !self.collection_ids.is_empty() {
            state.serialize_entry("collectionIds", &self.collection_ids)?;
        }
        if !self.input_uri_prefix.is_empty() {
            state.serialize_entry("inputUriPrefix", &self.input_uri_prefix)?;
        }
        if !self.namespace_ids.is_empty() {
            state.serialize_entry("namespaceIds", &self.namespace_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.BulkDeleteDocuments][google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments]: crate::client::FirestoreAdmin::bulk_delete_documents
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkDeleteDocumentsMetadata {
    /// The time this operation started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The state of the operation.
    pub operation_state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// The IDs of the collection groups that are being deleted.
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Which namespace IDs are being deleted.
    pub namespace_ids: std::vec::Vec<std::string::String>,

    /// The timestamp that corresponds to the version of the database that is being
    /// read to get the list of documents to delete. This time can also be used as
    /// the timestamp of PITR in case of disaster recovery (subject to PITR window
    /// limit).
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteDocumentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::BulkDeleteDocumentsMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::BulkDeleteDocumentsMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BulkDeleteDocumentsMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BulkDeleteDocumentsMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_state][crate::model::BulkDeleteDocumentsMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::BulkDeleteDocumentsMetadata::progress_documents].
    pub fn set_progress_documents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_documents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_documents][crate::model::BulkDeleteDocumentsMetadata::progress_documents].
    pub fn set_or_clear_progress_documents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_documents = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_bytes][crate::model::BulkDeleteDocumentsMetadata::progress_bytes].
    pub fn set_progress_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_bytes][crate::model::BulkDeleteDocumentsMetadata::progress_bytes].
    pub fn set_or_clear_progress_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [collection_ids][crate::model::BulkDeleteDocumentsMetadata::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::BulkDeleteDocumentsMetadata::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::BulkDeleteDocumentsMetadata::snapshot_time].
    pub fn set_snapshot_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot_time][crate::model::BulkDeleteDocumentsMetadata::snapshot_time].
    pub fn set_or_clear_snapshot_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BulkDeleteDocumentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BulkDeleteDocumentsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkDeleteDocumentsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __operation_state,
            __progress_documents,
            __progress_bytes,
            __collection_ids,
            __namespace_ids,
            __snapshot_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkDeleteDocumentsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "operationState" => Ok(__FieldTag::__operation_state),
                            "operation_state" => Ok(__FieldTag::__operation_state),
                            "progressDocuments" => Ok(__FieldTag::__progress_documents),
                            "progress_documents" => Ok(__FieldTag::__progress_documents),
                            "progressBytes" => Ok(__FieldTag::__progress_bytes),
                            "progress_bytes" => Ok(__FieldTag::__progress_bytes),
                            "collectionIds" => Ok(__FieldTag::__collection_ids),
                            "collection_ids" => Ok(__FieldTag::__collection_ids),
                            "namespaceIds" => Ok(__FieldTag::__namespace_ids),
                            "namespace_ids" => Ok(__FieldTag::__namespace_ids),
                            "snapshotTime" => Ok(__FieldTag::__snapshot_time),
                            "snapshot_time" => Ok(__FieldTag::__snapshot_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkDeleteDocumentsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkDeleteDocumentsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__operation_state => {
                            if !fields.insert(__FieldTag::__operation_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_state",
                                ));
                            }
                            result.operation_state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress_documents => {
                            if !fields.insert(__FieldTag::__progress_documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_documents",
                                ));
                            }
                            result.progress_documents =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__progress_bytes => {
                            if !fields.insert(__FieldTag::__progress_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_bytes",
                                ));
                            }
                            result.progress_bytes =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::__collection_ids => {
                            if !fields.insert(__FieldTag::__collection_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_ids",
                                ));
                            }
                            result.collection_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__namespace_ids => {
                            if !fields.insert(__FieldTag::__namespace_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace_ids",
                                ));
                            }
                            result.namespace_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__snapshot_time => {
                            if !fields.insert(__FieldTag::__snapshot_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_time",
                                ));
                            }
                            result.snapshot_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkDeleteDocumentsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.operation_state) {
            state.serialize_entry("operationState", &self.operation_state)?;
        }
        if self.progress_documents.is_some() {
            state.serialize_entry("progressDocuments", &self.progress_documents)?;
        }
        if self.progress_bytes.is_some() {
            state.serialize_entry("progressBytes", &self.progress_bytes)?;
        }
        if !self.collection_ids.is_empty() {
            state.serialize_entry("collectionIds", &self.collection_ids)?;
        }
        if !self.namespace_ids.is_empty() {
            state.serialize_entry("namespaceIds", &self.namespace_ids)?;
        }
        if self.snapshot_time.is_some() {
            state.serialize_entry("snapshotTime", &self.snapshot_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Returned in the [google.longrunning.Operation][google.longrunning.Operation]
/// response field.
///
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportDocumentsResponse {
    /// Location of the output files. This can be used to begin an import
    /// into Cloud Firestore (this project or another project) after the operation
    /// completes successfully.
    pub output_uri_prefix: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportDocumentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri_prefix][crate::model::ExportDocumentsResponse::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }
}

impl wkt::message::Message for ExportDocumentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ExportDocumentsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportDocumentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __output_uri_prefix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportDocumentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "outputUriPrefix" => Ok(__FieldTag::__output_uri_prefix),
                            "output_uri_prefix" => Ok(__FieldTag::__output_uri_prefix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportDocumentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportDocumentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__output_uri_prefix => {
                            if !fields.insert(__FieldTag::__output_uri_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_uri_prefix",
                                ));
                            }
                            result.output_uri_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportDocumentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.output_uri_prefix.is_empty() {
            state.serialize_entry("outputUriPrefix", &self.output_uri_prefix)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for the [long-running operation][google.longrunning.Operation] from
/// the [RestoreDatabase][google.firestore.admin.v1.RestoreDatabase] request.
///
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreDatabaseMetadata {
    /// The time the restore was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the restore finished, unset for ongoing restores.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The operation state of the restore.
    pub operation_state: crate::model::OperationState,

    /// The name of the database being restored to.
    pub database: std::string::String,

    /// The name of the backup restoring from.
    pub backup: std::string::String,

    /// How far along the restore is as an estimated percentage of remaining time.
    pub progress_percentage: std::option::Option<crate::model::Progress>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::RestoreDatabaseMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::RestoreDatabaseMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::RestoreDatabaseMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::RestoreDatabaseMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_state][crate::model::RestoreDatabaseMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [database][crate::model::RestoreDatabaseMetadata::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::RestoreDatabaseMetadata::backup].
    pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [progress_percentage][crate::model::RestoreDatabaseMetadata::progress_percentage].
    pub fn set_progress_percentage<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_percentage = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress_percentage][crate::model::RestoreDatabaseMetadata::progress_percentage].
    pub fn set_or_clear_progress_percentage<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Progress>,
    {
        self.progress_percentage = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RestoreDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.RestoreDatabaseMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreDatabaseMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __operation_state,
            __database,
            __backup,
            __progress_percentage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreDatabaseMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "operationState" => Ok(__FieldTag::__operation_state),
                            "operation_state" => Ok(__FieldTag::__operation_state),
                            "database" => Ok(__FieldTag::__database),
                            "backup" => Ok(__FieldTag::__backup),
                            "progressPercentage" => Ok(__FieldTag::__progress_percentage),
                            "progress_percentage" => Ok(__FieldTag::__progress_percentage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreDatabaseMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreDatabaseMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__operation_state => {
                            if !fields.insert(__FieldTag::__operation_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_state",
                                ));
                            }
                            result.operation_state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress_percentage => {
                            if !fields.insert(__FieldTag::__progress_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percentage",
                                ));
                            }
                            result.progress_percentage =
                                map.next_value::<std::option::Option<crate::model::Progress>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreDatabaseMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.operation_state) {
            state.serialize_entry("operationState", &self.operation_state)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.backup.is_empty() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if self.progress_percentage.is_some() {
            state.serialize_entry("progressPercentage", &self.progress_percentage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the progress of the operation.
/// Unit of work is generic and must be interpreted based on where
/// [Progress][google.firestore.admin.v1.Progress] is used.
///
/// [google.firestore.admin.v1.Progress]: crate::model::Progress
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Progress {
    /// The amount of work estimated.
    pub estimated_work: i64,

    /// The amount of work completed.
    pub completed_work: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Progress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [estimated_work][crate::model::Progress::estimated_work].
    pub fn set_estimated_work<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.estimated_work = v.into();
        self
    }

    /// Sets the value of [completed_work][crate::model::Progress::completed_work].
    pub fn set_completed_work<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.completed_work = v.into();
        self
    }
}

impl wkt::message::Message for Progress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Progress"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Progress {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __estimated_work,
            __completed_work,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Progress")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "estimatedWork" => Ok(__FieldTag::__estimated_work),
                            "estimated_work" => Ok(__FieldTag::__estimated_work),
                            "completedWork" => Ok(__FieldTag::__completed_work),
                            "completed_work" => Ok(__FieldTag::__completed_work),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Progress;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Progress")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__estimated_work => {
                            if !fields.insert(__FieldTag::__estimated_work) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_work",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.estimated_work =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__completed_work => {
                            if !fields.insert(__FieldTag::__completed_work) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completed_work",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.completed_work =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Progress {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.estimated_work) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("estimatedWork", &__With(&self.estimated_work))?;
        }
        if !wkt::internal::is_default(&self.completed_work) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("completedWork", &__With(&self.completed_work))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A backup schedule for a Cloud Firestore Database.
///
/// This resource is owned by the database it is backing up, and is deleted along
/// with the database. The actual backups are not though.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupSchedule {
    /// Output only. The unique backup schedule identifier across all locations and
    /// databases for the given project.
    ///
    /// This will be auto-assigned.
    ///
    /// Format is
    /// `projects/{project}/databases/{database}/backupSchedules/{backup_schedule}`
    pub name: std::string::String,

    /// Output only. The timestamp at which this backup schedule was created and
    /// effective since.
    ///
    /// No backups will be created for this schedule before this time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this backup schedule was most recently
    /// updated. When a backup schedule is first created, this is the same as
    /// create_time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// At what relative time in the future, compared to its creation time,
    /// the backup should be deleted, e.g. keep backups for 7 days.
    ///
    /// The maximum supported retention period is 14 weeks.
    pub retention: std::option::Option<wkt::Duration>,

    /// A oneof field to represent when backups will be taken.
    pub recurrence: std::option::Option<crate::model::backup_schedule::Recurrence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupSchedule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupSchedule::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupSchedule::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BackupSchedule::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BackupSchedule::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retention][crate::model::BackupSchedule::retention].
    pub fn set_retention<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retention][crate::model::BackupSchedule::retention].
    pub fn set_or_clear_retention<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recurrence][crate::model::BackupSchedule::recurrence].
    ///
    /// Note that all the setters affecting `recurrence` are mutually
    /// exclusive.
    pub fn set_recurrence<
        T: std::convert::Into<std::option::Option<crate::model::backup_schedule::Recurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = v.into();
        self
    }

    /// The value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// if it holds a `DailyRecurrence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn daily_recurrence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DailyRecurrence>> {
        #[allow(unreachable_patterns)]
        self.recurrence.as_ref().and_then(|v| match v {
            crate::model::backup_schedule::Recurrence::DailyRecurrence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// to hold a `DailyRecurrence`.
    ///
    /// Note that all the setters affecting `recurrence` are
    /// mutually exclusive.
    pub fn set_daily_recurrence<
        T: std::convert::Into<std::boxed::Box<crate::model::DailyRecurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = std::option::Option::Some(
            crate::model::backup_schedule::Recurrence::DailyRecurrence(v.into()),
        );
        self
    }

    /// The value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// if it holds a `WeeklyRecurrence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn weekly_recurrence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WeeklyRecurrence>> {
        #[allow(unreachable_patterns)]
        self.recurrence.as_ref().and_then(|v| match v {
            crate::model::backup_schedule::Recurrence::WeeklyRecurrence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// to hold a `WeeklyRecurrence`.
    ///
    /// Note that all the setters affecting `recurrence` are
    /// mutually exclusive.
    pub fn set_weekly_recurrence<
        T: std::convert::Into<std::boxed::Box<crate::model::WeeklyRecurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = std::option::Option::Some(
            crate::model::backup_schedule::Recurrence::WeeklyRecurrence(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackupSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BackupSchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __retention,
            __daily_recurrence,
            __weekly_recurrence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupSchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "retention" => Ok(__FieldTag::__retention),
                            "dailyRecurrence" => Ok(__FieldTag::__daily_recurrence),
                            "daily_recurrence" => Ok(__FieldTag::__daily_recurrence),
                            "weeklyRecurrence" => Ok(__FieldTag::__weekly_recurrence),
                            "weekly_recurrence" => Ok(__FieldTag::__weekly_recurrence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupSchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupSchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__retention => {
                            if !fields.insert(__FieldTag::__retention) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention",
                                ));
                            }
                            result.retention =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__daily_recurrence => {
                            if !fields.insert(__FieldTag::__daily_recurrence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for daily_recurrence",
                                ));
                            }
                            if result.recurrence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `recurrence`, a oneof with full ID .google.firestore.admin.v1.BackupSchedule.daily_recurrence, latest field was dailyRecurrence",
                                ));
                            }
                            result.recurrence = std::option::Option::Some(
                                crate::model::backup_schedule::Recurrence::DailyRecurrence(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DailyRecurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__weekly_recurrence => {
                            if !fields.insert(__FieldTag::__weekly_recurrence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weekly_recurrence",
                                ));
                            }
                            if result.recurrence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `recurrence`, a oneof with full ID .google.firestore.admin.v1.BackupSchedule.weekly_recurrence, latest field was weeklyRecurrence",
                                ));
                            }
                            result.recurrence = std::option::Option::Some(
                                crate::model::backup_schedule::Recurrence::WeeklyRecurrence(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::WeeklyRecurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupSchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.retention.is_some() {
            state.serialize_entry("retention", &self.retention)?;
        }
        if let Some(value) = self.daily_recurrence() {
            state.serialize_entry("dailyRecurrence", value)?;
        }
        if let Some(value) = self.weekly_recurrence() {
            state.serialize_entry("weeklyRecurrence", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupSchedule].
pub mod backup_schedule {
    #[allow(unused_imports)]
    use super::*;

    /// A oneof field to represent when backups will be taken.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Recurrence {
        /// For a schedule that runs daily.
        DailyRecurrence(std::boxed::Box<crate::model::DailyRecurrence>),
        /// For a schedule that runs weekly on a specific day.
        WeeklyRecurrence(std::boxed::Box<crate::model::WeeklyRecurrence>),
    }
}

/// Represents a recurring schedule that runs every day.
///
/// The time zone is UTC.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DailyRecurrence {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DailyRecurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DailyRecurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DailyRecurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DailyRecurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DailyRecurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DailyRecurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DailyRecurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DailyRecurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a recurring schedule that runs on a specified day of the week.
///
/// The time zone is UTC.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WeeklyRecurrence {
    /// The day of week to run.
    ///
    /// DAY_OF_WEEK_UNSPECIFIED is not allowed.
    pub day: gtype::model::DayOfWeek,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeeklyRecurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day][crate::model::WeeklyRecurrence::day].
    pub fn set_day<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day = v.into();
        self
    }
}

impl wkt::message::Message for WeeklyRecurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.WeeklyRecurrence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WeeklyRecurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __day,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WeeklyRecurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "day" => Ok(__FieldTag::__day),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WeeklyRecurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WeeklyRecurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__day => {
                            if !fields.insert(__FieldTag::__day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day",
                                ));
                            }
                            result.day = map
                                .next_value::<std::option::Option<gtype::model::DayOfWeek>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WeeklyRecurrence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.day) {
            state.serialize_entry("day", &self.day)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Cloud Firestore User Creds.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UserCreds {
    /// Identifier. The resource name of the UserCreds.
    /// Format:
    /// `projects/{project}/databases/{database}/userCreds/{user_creds}`
    pub name: std::string::String,

    /// Output only. The time the user creds were created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the user creds were last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Whether the user creds are enabled or disabled. Defaults to
    /// ENABLED on creation.
    pub state: crate::model::user_creds::State,

    /// Output only. The plaintext server-generated password for the user creds.
    /// Only populated in responses for CreateUserCreds and ResetUserPassword.
    pub secure_password: std::string::String,

    /// Identity associated with this User Creds.
    pub user_creds_identity: std::option::Option<crate::model::user_creds::UserCredsIdentity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserCreds {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UserCreds::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::UserCreds::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UserCreds::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::UserCreds::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::UserCreds::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::UserCreds::state].
    pub fn set_state<T: std::convert::Into<crate::model::user_creds::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [secure_password][crate::model::UserCreds::secure_password].
    pub fn set_secure_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secure_password = v.into();
        self
    }

    /// Sets the value of [user_creds_identity][crate::model::UserCreds::user_creds_identity].
    ///
    /// Note that all the setters affecting `user_creds_identity` are mutually
    /// exclusive.
    pub fn set_user_creds_identity<
        T: std::convert::Into<std::option::Option<crate::model::user_creds::UserCredsIdentity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_creds_identity = v.into();
        self
    }

    /// The value of [user_creds_identity][crate::model::UserCreds::user_creds_identity]
    /// if it holds a `ResourceIdentity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource_identity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::user_creds::ResourceIdentity>> {
        #[allow(unreachable_patterns)]
        self.user_creds_identity.as_ref().and_then(|v| match v {
            crate::model::user_creds::UserCredsIdentity::ResourceIdentity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [user_creds_identity][crate::model::UserCreds::user_creds_identity]
    /// to hold a `ResourceIdentity`.
    ///
    /// Note that all the setters affecting `user_creds_identity` are
    /// mutually exclusive.
    pub fn set_resource_identity<
        T: std::convert::Into<std::boxed::Box<crate::model::user_creds::ResourceIdentity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_creds_identity = std::option::Option::Some(
            crate::model::user_creds::UserCredsIdentity::ResourceIdentity(v.into()),
        );
        self
    }
}

impl wkt::message::Message for UserCreds {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UserCreds"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserCreds {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __state,
            __secure_password,
            __resource_identity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserCreds")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "state" => Ok(__FieldTag::__state),
                            "securePassword" => Ok(__FieldTag::__secure_password),
                            "secure_password" => Ok(__FieldTag::__secure_password),
                            "resourceIdentity" => Ok(__FieldTag::__resource_identity),
                            "resource_identity" => Ok(__FieldTag::__resource_identity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserCreds;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserCreds")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::user_creds::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secure_password => {
                            if !fields.insert(__FieldTag::__secure_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secure_password",
                                ));
                            }
                            result.secure_password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_identity => {
                            if !fields.insert(__FieldTag::__resource_identity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_identity",
                                ));
                            }
                            if result.user_creds_identity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `user_creds_identity`, a oneof with full ID .google.firestore.admin.v1.UserCreds.resource_identity, latest field was resourceIdentity",
                                ));
                            }
                            result.user_creds_identity = std::option::Option::Some(
                                crate::model::user_creds::UserCredsIdentity::ResourceIdentity(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::user_creds::ResourceIdentity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserCreds {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.secure_password.is_empty() {
            state.serialize_entry("securePassword", &self.secure_password)?;
        }
        if let Some(value) = self.resource_identity() {
            state.serialize_entry("resourceIdentity", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [UserCreds].
pub mod user_creds {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a Resource Identity principal.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourceIdentity {
        /// Output only. Principal identifier string.
        /// See: <https://cloud.google.com/iam/docs/principal-identifiers>
        pub principal: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceIdentity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [principal][crate::model::user_creds::ResourceIdentity::principal].
        pub fn set_principal<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.principal = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceIdentity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.UserCreds.ResourceIdentity"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResourceIdentity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __principal,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResourceIdentity")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "principal" => Ok(__FieldTag::__principal),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResourceIdentity;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResourceIdentity")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__principal => {
                                if !fields.insert(__FieldTag::__principal) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for principal",
                                    ));
                                }
                                result.principal = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResourceIdentity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.principal.is_empty() {
                state.serialize_entry("principal", &self.principal)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The state of the user creds (ENABLED or DISABLED).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. Should not be used.
        Unspecified,
        /// The user creds are enabled.
        Enabled,
        /// The user creds are disabled.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.firestore.admin.v1.UserCreds.State",
            ))
        }
    }

    /// Identity associated with this User Creds.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserCredsIdentity {
        /// Resource Identity descriptor.
        ResourceIdentity(std::boxed::Box<crate::model::user_creds::ResourceIdentity>),
    }
}

/// Describes the state of the operation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperationState {
    /// Unspecified.
    Unspecified,
    /// Request is being prepared for processing.
    Initializing,
    /// Request is actively being processed.
    Processing,
    /// Request is in the process of being cancelled after user called
    /// google.longrunning.Operations.CancelOperation on the operation.
    Cancelling,
    /// Request has been processed and is in its finalization stage.
    Finalizing,
    /// Request has completed successfully.
    Successful,
    /// Request has finished being processed, but encountered an error.
    Failed,
    /// Request has finished being cancelled after user called
    /// google.longrunning.Operations.CancelOperation.
    Cancelled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperationState::value] or
    /// [OperationState::name].
    UnknownValue(operation_state::UnknownValue),
}

#[doc(hidden)]
pub mod operation_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperationState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Initializing => std::option::Option::Some(1),
            Self::Processing => std::option::Option::Some(2),
            Self::Cancelling => std::option::Option::Some(3),
            Self::Finalizing => std::option::Option::Some(4),
            Self::Successful => std::option::Option::Some(5),
            Self::Failed => std::option::Option::Some(6),
            Self::Cancelled => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OPERATION_STATE_UNSPECIFIED"),
            Self::Initializing => std::option::Option::Some("INITIALIZING"),
            Self::Processing => std::option::Option::Some("PROCESSING"),
            Self::Cancelling => std::option::Option::Some("CANCELLING"),
            Self::Finalizing => std::option::Option::Some("FINALIZING"),
            Self::Successful => std::option::Option::Some("SUCCESSFUL"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::Cancelled => std::option::Option::Some("CANCELLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperationState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperationState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperationState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Initializing,
            2 => Self::Processing,
            3 => Self::Cancelling,
            4 => Self::Finalizing,
            5 => Self::Successful,
            6 => Self::Failed,
            7 => Self::Cancelled,
            _ => Self::UnknownValue(operation_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperationState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OPERATION_STATE_UNSPECIFIED" => Self::Unspecified,
            "INITIALIZING" => Self::Initializing,
            "PROCESSING" => Self::Processing,
            "CANCELLING" => Self::Cancelling,
            "FINALIZING" => Self::Finalizing,
            "SUCCESSFUL" => Self::Successful,
            "FAILED" => Self::Failed,
            "CANCELLED" => Self::Cancelled,
            _ => Self::UnknownValue(operation_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperationState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Initializing => serializer.serialize_i32(1),
            Self::Processing => serializer.serialize_i32(2),
            Self::Cancelling => serializer.serialize_i32(3),
            Self::Finalizing => serializer.serialize_i32(4),
            Self::Successful => serializer.serialize_i32(5),
            Self::Failed => serializer.serialize_i32(6),
            Self::Cancelled => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationState>::new(
            ".google.firestore.admin.v1.OperationState",
        ))
    }
}
