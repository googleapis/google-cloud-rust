// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A Backup of a Cloud Firestore Database.
///
/// The backup contains all documents and index configurations for the given
/// database at a specific point in time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Backup {
    /// Output only. The unique resource name of the Backup.
    ///
    /// Format is `projects/{project}/locations/{location}/backups/{backup}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Name of the Firestore database that the backup is from.
    ///
    /// Format is `projects/{project}/databases/{database}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Output only. The system-generated UUID4 for the Firestore database that the
    /// backup is from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_uid: std::string::String,

    /// Output only. The backup contains an externally consistent copy of the
    /// database at this time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this backup expires.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Statistics about the backup.
    ///
    /// This data only becomes available after the backup is fully materialized to
    /// secondary storage. This field will be empty till then.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stats: std::option::Option<crate::model::backup::Stats>,

    /// Output only. The current state of the backup.
    pub state: crate::model::backup::State,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [database][crate::model::Backup::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [database_uid][crate::model::Backup::database_uid].
    pub fn set_database_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_uid = v.into();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::Backup::snapshot_time].
    pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [stats][crate::model::Backup::stats].
    pub fn set_stats<T: std::convert::Into<std::option::Option<crate::model::backup::Stats>>>(
        mut self,
        v: T,
    ) -> Self {
        self.stats = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Backup"
    }
}

/// Defines additional types related to Backup
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// Backup specific statistics.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Stats {
        /// Output only. Summation of the size of all documents and index entries in
        /// the backup, measured in bytes.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub size_bytes: i64,

        /// Output only. The total number of documents contained in the backup.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub document_count: i64,

        /// Output only. The total number of index entries contained in the backup.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub index_count: i64,
    }

    impl Stats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [size_bytes][crate::model::backup::Stats::size_bytes].
        pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.size_bytes = v.into();
            self
        }

        /// Sets the value of [document_count][crate::model::backup::Stats::document_count].
        pub fn set_document_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.document_count = v.into();
            self
        }

        /// Sets the value of [index_count][crate::model::backup::Stats::index_count].
        pub fn set_index_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.index_count = v.into();
            self
        }
    }

    impl wkt::message::Message for Stats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Backup.Stats"
        }
    }

    /// Indicate the current state of the backup.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// The state is unspecified.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The pending backup is still being created. Operations on the
        /// backup will be rejected in this state.
        pub const CREATING: State = State::new("CREATING");

        /// The backup is complete and ready to use.
        pub const READY: State = State::new("READY");

        /// The backup is not available at this moment.
        pub const NOT_AVAILABLE: State = State::new("NOT_AVAILABLE");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// A Cloud Firestore Database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Database {
    /// The resource name of the Database.
    /// Format: `projects/{project}/databases/{database}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The system-generated UUID4 for this Database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The timestamp at which this database was created. Databases
    /// created before 2016 do not populate create_time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this database was most recently
    /// updated. Note this only includes updates to the database resource and not
    /// data contained by the database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this database was deleted. Only set if
    /// the database has been deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// The location of the database. Available locations are listed at
    /// <https://cloud.google.com/firestore/docs/locations>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    /// The type of the database.
    /// See <https://cloud.google.com/datastore/docs/firestore-or-datastore> for
    /// information about how to choose.
    #[serde(rename = "type")]
    pub r#type: crate::model::database::DatabaseType,

    /// The concurrency control mode to use for this database.
    pub concurrency_mode: crate::model::database::ConcurrencyMode,

    /// Output only. The period during which past versions of data are retained in
    /// the database.
    ///
    /// Any [read][google.firestore.v1.GetDocumentRequest.read_time]
    /// or [query][google.firestore.v1.ListDocumentsRequest.read_time] can specify
    /// a `read_time` within this window, and will read the state of the database
    /// at that time.
    ///
    /// If the PITR feature is enabled, the retention period is 7 days. Otherwise,
    /// the retention period is 1 hour.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version_retention_period: std::option::Option<wkt::Duration>,

    /// Output only. The earliest timestamp at which older versions of the data can
    /// be read from the database. See [version_retention_period] above; this field
    /// is populated with `now - version_retention_period`.
    ///
    /// This value is continuously updated, and becomes stale the moment it is
    /// queried. If you are using this value to recover data, make sure to account
    /// for the time from the moment when the value is queried to the moment when
    /// you initiate the recovery.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub earliest_version_time: std::option::Option<wkt::Timestamp>,

    /// Whether to enable the PITR feature on this database.
    pub point_in_time_recovery_enablement: crate::model::database::PointInTimeRecoveryEnablement,

    /// The App Engine integration mode to use for this database.
    pub app_engine_integration_mode: crate::model::database::AppEngineIntegrationMode,

    /// Output only. The key_prefix for this database. This key_prefix is used, in
    /// combination with the project ID ("\<key prefix\>~\<project id\>") to construct
    /// the application ID that is returned from the Cloud Datastore APIs in Google
    /// App Engine first generation runtimes.
    ///
    /// This value may be empty in which case the appid to use for URL-encoded keys
    /// is the project_id (eg: foo instead of v~foo).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_prefix: std::string::String,

    /// State of delete protection for the database.
    pub delete_protection_state: crate::model::database::DeleteProtectionState,

    /// Optional. Presence indicates CMEK is enabled for this database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cmek_config: std::option::Option<crate::model::database::CmekConfig>,

    /// Output only. The database resource's prior database ID. This field is only
    /// populated for deleted databases.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub previous_id: std::string::String,

    /// Output only. Information about the provenance of this database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_info: std::option::Option<crate::model::database::SourceInfo>,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl Database {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Database::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Database::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Database::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Database::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Database::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::Database::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Database::type].
    pub fn set_type<T: std::convert::Into<crate::model::database::DatabaseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [concurrency_mode][crate::model::Database::concurrency_mode].
    pub fn set_concurrency_mode<T: std::convert::Into<crate::model::database::ConcurrencyMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.concurrency_mode = v.into();
        self
    }

    /// Sets the value of [version_retention_period][crate::model::Database::version_retention_period].
    pub fn set_version_retention_period<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version_retention_period = v.into();
        self
    }

    /// Sets the value of [earliest_version_time][crate::model::Database::earliest_version_time].
    pub fn set_earliest_version_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.earliest_version_time = v.into();
        self
    }

    /// Sets the value of [point_in_time_recovery_enablement][crate::model::Database::point_in_time_recovery_enablement].
    pub fn set_point_in_time_recovery_enablement<
        T: std::convert::Into<crate::model::database::PointInTimeRecoveryEnablement>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.point_in_time_recovery_enablement = v.into();
        self
    }

    /// Sets the value of [app_engine_integration_mode][crate::model::Database::app_engine_integration_mode].
    pub fn set_app_engine_integration_mode<
        T: std::convert::Into<crate::model::database::AppEngineIntegrationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.app_engine_integration_mode = v.into();
        self
    }

    /// Sets the value of [key_prefix][crate::model::Database::key_prefix].
    pub fn set_key_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_prefix = v.into();
        self
    }

    /// Sets the value of [delete_protection_state][crate::model::Database::delete_protection_state].
    pub fn set_delete_protection_state<
        T: std::convert::Into<crate::model::database::DeleteProtectionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.delete_protection_state = v.into();
        self
    }

    /// Sets the value of [cmek_config][crate::model::Database::cmek_config].
    pub fn set_cmek_config<
        T: std::convert::Into<std::option::Option<crate::model::database::CmekConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cmek_config = v.into();
        self
    }

    /// Sets the value of [previous_id][crate::model::Database::previous_id].
    pub fn set_previous_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.previous_id = v.into();
        self
    }

    /// Sets the value of [source_info][crate::model::Database::source_info].
    pub fn set_source_info<
        T: std::convert::Into<std::option::Option<crate::model::database::SourceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_info = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Database::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Database {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Database"
    }
}

/// Defines additional types related to Database
pub mod database {
    #[allow(unused_imports)]
    use super::*;

    /// The CMEK (Customer Managed Encryption Key) configuration for a Firestore
    /// database. If not present, the database is secured by the default Google
    /// encryption key.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CmekConfig {
        /// Required. Only keys in the same location as this database are allowed to
        /// be used for encryption.
        ///
        /// For Firestore's nam5 multi-region, this corresponds to Cloud KMS
        /// multi-region us. For Firestore's eur3 multi-region, this corresponds to
        /// Cloud KMS multi-region europe. See
        /// <https://cloud.google.com/kms/docs/locations>.
        ///
        /// The expected format is
        /// `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key_name: std::string::String,

        /// Output only. Currently in-use [KMS key
        /// versions](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions).
        /// During [key rotation](https://cloud.google.com/kms/docs/key-rotation),
        /// there can be multiple in-use key versions.
        ///
        /// The expected format is
        /// `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{key_version}`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub active_key_version: std::vec::Vec<std::string::String>,
    }

    impl CmekConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key_name][crate::model::database::CmekConfig::kms_key_name].
        pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_name = v.into();
            self
        }

        /// Sets the value of [active_key_version][crate::model::database::CmekConfig::active_key_version].
        pub fn set_active_key_version<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.active_key_version = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CmekConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Database.CmekConfig"
        }
    }

    /// Information about the provenance of this database.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SourceInfo {
        /// The associated long-running operation. This field may not be set after
        /// the operation has completed. Format:
        /// `projects/{project}/databases/{database}/operations/{operation}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub operation: std::string::String,

        /// The source from which this database is derived.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub source: std::option::Option<crate::model::database::source_info::Source>,
    }

    impl SourceInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::database::SourceInfo::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of `source`.
        pub fn set_source<
            T: std::convert::Into<std::option::Option<crate::model::database::source_info::Source>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::database::SourceInfo::source]
        /// if it holds a `Backup`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_backup(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::database::source_info::BackupSource>>
        {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::database::source_info::Source::Backup(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::database::SourceInfo::source]
        /// to hold a `Backup`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_backup<
            T: std::convert::Into<std::boxed::Box<crate::model::database::source_info::BackupSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::database::source_info::Source::Backup(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for SourceInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Database.SourceInfo"
        }
    }

    /// Defines additional types related to SourceInfo
    pub mod source_info {
        #[allow(unused_imports)]
        use super::*;

        /// Information about a backup that was used to restore a database.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BackupSource {
            /// The resource name of the backup that was used to restore this
            /// database. Format:
            /// `projects/{project}/locations/{location}/backups/{backup}`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub backup: std::string::String,
        }

        impl BackupSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [backup][crate::model::database::source_info::BackupSource::backup].
            pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.backup = v.into();
                self
            }
        }

        impl wkt::message::Message for BackupSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.SourceInfo.BackupSource"
            }
        }

        /// The source from which this database is derived.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Source {
            /// If set, this database was restored from the specified backup (or a
            /// snapshot thereof).
            Backup(std::boxed::Box<crate::model::database::source_info::BackupSource>),
        }
    }

    /// Encryption configuration for a new database being created from another
    /// source.
    ///
    /// The source could be a [Backup][google.firestore.admin.v1.Backup] .
    ///
    /// [google.firestore.admin.v1.Backup]: crate::model::Backup
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EncryptionConfig {
        /// The method for encrypting the database.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub encryption_type:
            std::option::Option<crate::model::database::encryption_config::EncryptionType>,
    }

    impl EncryptionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `encryption_type`.
        pub fn set_encryption_type<
            T: std::convert::Into<
                std::option::Option<crate::model::database::encryption_config::EncryptionType>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = v.into();
            self
        }

        /// The value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// if it holds a `GoogleDefaultEncryption`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_google_default_encryption(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::database::encryption_config::GoogleDefaultEncryptionOptions,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.encryption_type.as_ref().and_then(|v| match v {
                crate::model::database::encryption_config::EncryptionType::GoogleDefaultEncryption(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// if it holds a `UseSourceEncryption`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_use_source_encryption(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::database::encryption_config::SourceEncryptionOptions>,
        > {
            #[allow(unreachable_patterns)]
            self.encryption_type.as_ref().and_then(|v| match v {
                crate::model::database::encryption_config::EncryptionType::UseSourceEncryption(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// if it holds a `CustomerManagedEncryption`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_customer_managed_encryption(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::database::encryption_config::CustomerManagedEncryptionOptions,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.encryption_type.as_ref().and_then(|v| match v {
                crate::model::database::encryption_config::EncryptionType::CustomerManagedEncryption(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// to hold a `GoogleDefaultEncryption`.
        ///
        /// Note that all the setters affecting `encryption_type` are
        /// mutually exclusive.
        pub fn set_google_default_encryption<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::database::encryption_config::GoogleDefaultEncryptionOptions,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = std::option::Option::Some(
                crate::model::database::encryption_config::EncryptionType::GoogleDefaultEncryption(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// to hold a `UseSourceEncryption`.
        ///
        /// Note that all the setters affecting `encryption_type` are
        /// mutually exclusive.
        pub fn set_use_source_encryption<
            T: std::convert::Into<
                std::boxed::Box<crate::model::database::encryption_config::SourceEncryptionOptions>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = std::option::Option::Some(
                crate::model::database::encryption_config::EncryptionType::UseSourceEncryption(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [encryption_type][crate::model::database::EncryptionConfig::encryption_type]
        /// to hold a `CustomerManagedEncryption`.
        ///
        /// Note that all the setters affecting `encryption_type` are
        /// mutually exclusive.
        pub fn set_customer_managed_encryption<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::database::encryption_config::CustomerManagedEncryptionOptions,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encryption_type = std::option::Option::Some(
                crate::model::database::encryption_config::EncryptionType::CustomerManagedEncryption(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for EncryptionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig"
        }
    }

    /// Defines additional types related to EncryptionConfig
    pub mod encryption_config {
        #[allow(unused_imports)]
        use super::*;

        /// The configuration options for using Google default encryption.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct GoogleDefaultEncryptionOptions {}

        impl GoogleDefaultEncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for GoogleDefaultEncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig.GoogleDefaultEncryptionOptions"
            }
        }

        /// The configuration options for using the same encryption method as the
        /// source.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SourceEncryptionOptions {}

        impl SourceEncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for SourceEncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig.SourceEncryptionOptions"
            }
        }

        /// The configuration options for using CMEK (Customer Managed Encryption
        /// Key) encryption.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CustomerManagedEncryptionOptions {
            /// Required. Only keys in the same location as the database are allowed to
            /// be used for encryption.
            ///
            /// For Firestore's nam5 multi-region, this corresponds to Cloud KMS
            /// multi-region us. For Firestore's eur3 multi-region, this corresponds to
            /// Cloud KMS multi-region europe. See
            /// <https://cloud.google.com/kms/docs/locations>.
            ///
            /// The expected format is
            /// `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub kms_key_name: std::string::String,
        }

        impl CustomerManagedEncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [kms_key_name][crate::model::database::encryption_config::CustomerManagedEncryptionOptions::kms_key_name].
            pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.kms_key_name = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomerManagedEncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Database.EncryptionConfig.CustomerManagedEncryptionOptions"
            }
        }

        /// The method for encrypting the database.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum EncryptionType {
            /// Use Google default encryption.
            GoogleDefaultEncryption(
                std::boxed::Box<
                    crate::model::database::encryption_config::GoogleDefaultEncryptionOptions,
                >,
            ),
            /// The database will use the same encryption configuration as the source.
            UseSourceEncryption(
                std::boxed::Box<crate::model::database::encryption_config::SourceEncryptionOptions>,
            ),
            /// Use Customer Managed Encryption Keys (CMEK) for encryption.
            CustomerManagedEncryption(
                std::boxed::Box<
                    crate::model::database::encryption_config::CustomerManagedEncryptionOptions,
                >,
            ),
        }
    }

    /// The type of the database.
    /// See <https://cloud.google.com/datastore/docs/firestore-or-datastore> for
    /// information about how to choose.
    ///
    /// Mode changes are only allowed if the database is empty.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DatabaseType(std::borrow::Cow<'static, str>);

    impl DatabaseType {
        /// Creates a new DatabaseType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [DatabaseType](DatabaseType)
    pub mod database_type {
        use super::DatabaseType;

        /// Not used.
        pub const DATABASE_TYPE_UNSPECIFIED: DatabaseType =
            DatabaseType::new("DATABASE_TYPE_UNSPECIFIED");

        /// Firestore Native Mode
        pub const FIRESTORE_NATIVE: DatabaseType = DatabaseType::new("FIRESTORE_NATIVE");

        /// Firestore in Datastore Mode.
        pub const DATASTORE_MODE: DatabaseType = DatabaseType::new("DATASTORE_MODE");
    }

    impl std::convert::From<std::string::String> for DatabaseType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The type of concurrency control mode for transactions.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConcurrencyMode(std::borrow::Cow<'static, str>);

    impl ConcurrencyMode {
        /// Creates a new ConcurrencyMode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ConcurrencyMode](ConcurrencyMode)
    pub mod concurrency_mode {
        use super::ConcurrencyMode;

        /// Not used.
        pub const CONCURRENCY_MODE_UNSPECIFIED: ConcurrencyMode =
            ConcurrencyMode::new("CONCURRENCY_MODE_UNSPECIFIED");

        /// Use optimistic concurrency control by default. This mode is available
        /// for Cloud Firestore databases.
        pub const OPTIMISTIC: ConcurrencyMode = ConcurrencyMode::new("OPTIMISTIC");

        /// Use pessimistic concurrency control by default. This mode is available
        /// for Cloud Firestore databases.
        ///
        /// This is the default setting for Cloud Firestore.
        pub const PESSIMISTIC: ConcurrencyMode = ConcurrencyMode::new("PESSIMISTIC");

        /// Use optimistic concurrency control with entity groups by default.
        ///
        /// This is the only available mode for Cloud Datastore.
        ///
        /// This mode is also available for Cloud Firestore with Datastore Mode but
        /// is not recommended.
        pub const OPTIMISTIC_WITH_ENTITY_GROUPS: ConcurrencyMode =
            ConcurrencyMode::new("OPTIMISTIC_WITH_ENTITY_GROUPS");
    }

    impl std::convert::From<std::string::String> for ConcurrencyMode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Point In Time Recovery feature enablement.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct PointInTimeRecoveryEnablement(std::borrow::Cow<'static, str>);

    impl PointInTimeRecoveryEnablement {
        /// Creates a new PointInTimeRecoveryEnablement instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [PointInTimeRecoveryEnablement](PointInTimeRecoveryEnablement)
    pub mod point_in_time_recovery_enablement {
        use super::PointInTimeRecoveryEnablement;

        /// Not used.
        pub const POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED: PointInTimeRecoveryEnablement =
            PointInTimeRecoveryEnablement::new("POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED");

        /// Reads are supported on selected versions of the data from within the past
        /// 7 days:
        ///
        /// * Reads against any timestamp within the past hour
        /// * Reads against 1-minute snapshots beyond 1 hour and within 7 days
        ///
        /// `version_retention_period` and `earliest_version_time` can be
        /// used to determine the supported versions.
        pub const POINT_IN_TIME_RECOVERY_ENABLED: PointInTimeRecoveryEnablement =
            PointInTimeRecoveryEnablement::new("POINT_IN_TIME_RECOVERY_ENABLED");

        /// Reads are supported on any version of the data from within the past 1
        /// hour.
        pub const POINT_IN_TIME_RECOVERY_DISABLED: PointInTimeRecoveryEnablement =
            PointInTimeRecoveryEnablement::new("POINT_IN_TIME_RECOVERY_DISABLED");
    }

    impl std::convert::From<std::string::String> for PointInTimeRecoveryEnablement {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The type of App Engine integration mode.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AppEngineIntegrationMode(std::borrow::Cow<'static, str>);

    impl AppEngineIntegrationMode {
        /// Creates a new AppEngineIntegrationMode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [AppEngineIntegrationMode](AppEngineIntegrationMode)
    pub mod app_engine_integration_mode {
        use super::AppEngineIntegrationMode;

        /// Not used.
        pub const APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED: AppEngineIntegrationMode =
            AppEngineIntegrationMode::new("APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED");

        /// If an App Engine application exists in the same region as this database,
        /// App Engine configuration will impact this database. This includes
        /// disabling of the application & database, as well as disabling writes to
        /// the database.
        pub const ENABLED: AppEngineIntegrationMode = AppEngineIntegrationMode::new("ENABLED");

        /// App Engine has no effect on the ability of this database to serve
        /// requests.
        ///
        /// This is the default setting for databases created with the Firestore API.
        pub const DISABLED: AppEngineIntegrationMode = AppEngineIntegrationMode::new("DISABLED");
    }

    impl std::convert::From<std::string::String> for AppEngineIntegrationMode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The delete protection state of the database.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DeleteProtectionState(std::borrow::Cow<'static, str>);

    impl DeleteProtectionState {
        /// Creates a new DeleteProtectionState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [DeleteProtectionState](DeleteProtectionState)
    pub mod delete_protection_state {
        use super::DeleteProtectionState;

        /// The default value. Delete protection type is not specified
        pub const DELETE_PROTECTION_STATE_UNSPECIFIED: DeleteProtectionState =
            DeleteProtectionState::new("DELETE_PROTECTION_STATE_UNSPECIFIED");

        /// Delete protection is disabled
        pub const DELETE_PROTECTION_DISABLED: DeleteProtectionState =
            DeleteProtectionState::new("DELETE_PROTECTION_DISABLED");

        /// Delete protection is enabled
        pub const DELETE_PROTECTION_ENABLED: DeleteProtectionState =
            DeleteProtectionState::new("DELETE_PROTECTION_ENABLED");
    }

    impl std::convert::From<std::string::String> for DeleteProtectionState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Represents a single field in the database.
///
/// Fields are grouped by their "Collection Group", which represent all
/// collections in the database with the same ID.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Field {
    /// Required. A field name of the form:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_path}`
    ///
    /// A field path can be a simple field name, e.g. `address` or a path to fields
    /// within `map_value` , e.g. `address.city`,
    /// or a special field path. The only valid special field is `*`, which
    /// represents any field.
    ///
    /// Field paths can be quoted using `` ` `` (backtick). The only character that
    /// must be escaped within a quoted field path is the backtick character
    /// itself, escaped using a backslash. Special characters in field paths that
    /// must be quoted include: `*`, `.`,
    /// `` ` `` (backtick), `[`, `]`, as well as any ascii symbolic characters.
    ///
    /// Examples:
    /// `` `address.city` `` represents a field named `address.city`, not the map
    /// key `city` in the field `address`. `` `*` `` represents a field named `*`,
    /// not any field.
    ///
    /// A special `Field` contains the default indexing settings for all fields.
    /// This field's resource name is:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/__default__/fields/*`
    /// Indexes defined on this `Field` will be applied to all fields which do not
    /// have their own `Field` index configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The index configuration for this field. If unset, field indexing will
    /// revert to the configuration defined by the `ancestor_field`. To
    /// explicitly remove all indexes for this field, specify an index config
    /// with an empty list of indexes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_config: std::option::Option<crate::model::field::IndexConfig>,

    /// The TTL configuration for this `Field`.
    /// Setting or unsetting this will enable or disable the TTL for
    /// documents that have this `Field`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ttl_config: std::option::Option<crate::model::field::TtlConfig>,
}

impl Field {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Field::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [index_config][crate::model::Field::index_config].
    pub fn set_index_config<
        T: std::convert::Into<std::option::Option<crate::model::field::IndexConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_config = v.into();
        self
    }

    /// Sets the value of [ttl_config][crate::model::Field::ttl_config].
    pub fn set_ttl_config<
        T: std::convert::Into<std::option::Option<crate::model::field::TtlConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ttl_config = v.into();
        self
    }
}

impl wkt::message::Message for Field {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Field"
    }
}

/// Defines additional types related to Field
pub mod field {
    #[allow(unused_imports)]
    use super::*;

    /// The index configuration for this field.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IndexConfig {
        /// The indexes supported for this field.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub indexes: std::vec::Vec<crate::model::Index>,

        /// Output only. When true, the `Field`'s index configuration is set from the
        /// configuration specified by the `ancestor_field`.
        /// When false, the `Field`'s index configuration is defined explicitly.
        pub uses_ancestor_config: bool,

        /// Output only. Specifies the resource name of the `Field` from which this
        /// field's index configuration is set (when `uses_ancestor_config` is true),
        /// or from which it *would* be set if this field had no index configuration
        /// (when `uses_ancestor_config` is false).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub ancestor_field: std::string::String,

        /// Output only
        /// When true, the `Field`'s index configuration is in the process of being
        /// reverted. Once complete, the index config will transition to the same
        /// state as the field specified by `ancestor_field`, at which point
        /// `uses_ancestor_config` will be `true` and `reverting` will be `false`.
        pub reverting: bool,
    }

    impl IndexConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uses_ancestor_config][crate::model::field::IndexConfig::uses_ancestor_config].
        pub fn set_uses_ancestor_config<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.uses_ancestor_config = v.into();
            self
        }

        /// Sets the value of [ancestor_field][crate::model::field::IndexConfig::ancestor_field].
        pub fn set_ancestor_field<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ancestor_field = v.into();
            self
        }

        /// Sets the value of [reverting][crate::model::field::IndexConfig::reverting].
        pub fn set_reverting<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.reverting = v.into();
            self
        }

        /// Sets the value of [indexes][crate::model::field::IndexConfig::indexes].
        pub fn set_indexes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Index>,
        {
            use std::iter::Iterator;
            self.indexes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for IndexConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Field.IndexConfig"
        }
    }

    /// The TTL (time-to-live) configuration for documents that have this `Field`
    /// set.
    ///
    /// Storing a timestamp value into a TTL-enabled field will be treated as
    /// the document's absolute expiration time. Timestamp values in the past
    /// indicate that the document is eligible for immediate expiration. Using any
    /// other data type or leaving the field absent will disable expiration for the
    /// individual document.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TtlConfig {
        /// Output only. The state of the TTL configuration.
        pub state: crate::model::field::ttl_config::State,
    }

    impl TtlConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::field::TtlConfig::state].
        pub fn set_state<T: std::convert::Into<crate::model::field::ttl_config::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }
    }

    impl wkt::message::Message for TtlConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Field.TtlConfig"
        }
    }

    /// Defines additional types related to TtlConfig
    pub mod ttl_config {
        #[allow(unused_imports)]
        use super::*;

        /// The state of applying the TTL configuration to all documents.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct State(std::borrow::Cow<'static, str>);

        impl State {
            /// Creates a new State instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [State](State)
        pub mod state {
            use super::State;

            /// The state is unspecified or unknown.
            pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

            /// The TTL is being applied. There is an active long-running operation to
            /// track the change. Newly written documents will have TTLs applied as
            /// requested. Requested TTLs on existing documents are still being
            /// processed. When TTLs on all existing documents have been processed, the
            /// state will move to 'ACTIVE'.
            pub const CREATING: State = State::new("CREATING");

            /// The TTL is active for all documents.
            pub const ACTIVE: State = State::new("ACTIVE");

            /// The TTL configuration could not be enabled for all existing documents.
            /// Newly written documents will continue to have their TTL applied.
            /// The LRO returned when last attempting to enable TTL for this `Field`
            /// has failed, and may have more details.
            pub const NEEDS_REPAIR: State = State::new("NEEDS_REPAIR");
        }

        impl std::convert::From<std::string::String> for State {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }
}

/// A request to list the Firestore Databases in all locations for a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatabasesRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// If true, also returns deleted resources.
    pub show_deleted: bool,
}

impl ListDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatabasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListDatabasesRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListDatabasesRequest"
    }
}

/// The request for
/// [FirestoreAdmin.CreateDatabase][google.firestore.admin.v1.FirestoreAdmin.CreateDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateDatabase]: crate::client::FirestoreAdmin::create_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatabaseRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Database to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub database: std::option::Option<crate::model::Database>,

    /// Required. The ID to use for the database, which will become the final
    /// component of the database's resource name.
    ///
    /// This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/
    /// with first character a letter and the last a letter or a number. Must not
    /// be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.
    ///
    /// "(default)" database ID is also valid.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_id: std::string::String,
}

impl CreateDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatabaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [database][crate::model::CreateDatabaseRequest::database].
    pub fn set_database<T: std::convert::Into<std::option::Option<crate::model::Database>>>(
        mut self,
        v: T,
    ) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [database_id][crate::model::CreateDatabaseRequest::database_id].
    pub fn set_database_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateDatabaseRequest"
    }
}

/// Metadata related to the create database operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatabaseMetadata {}

impl CreateDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CreateDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateDatabaseMetadata"
    }
}

/// The list of databases for a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatabasesResponse {
    /// The databases in the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub databases: std::vec::Vec<crate::model::Database>,

    /// In the event that data about individual databases cannot be listed they
    /// will be recorded here.
    ///
    /// An example entry might be: projects/some_project/locations/some_location
    /// This can happen if the Cloud Region that the Database resides in is
    /// currently unavailable.  In this case we can't fetch all the details about
    /// the database. You may be able to get a more detailed error message
    /// (or possibly fetch the resource) by sending a 'Get' request for the
    /// resource or a 'List' request for the specific location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [databases][crate::model::ListDatabasesResponse::databases].
    pub fn set_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Database>,
    {
        use std::iter::Iterator;
        self.databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDatabasesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListDatabasesResponse"
    }
}

/// The request for
/// [FirestoreAdmin.GetDatabase][google.firestore.admin.v1.FirestoreAdmin.GetDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetDatabase]: crate::client::FirestoreAdmin::get_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDatabaseRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetDatabaseRequest"
    }
}

/// The request for
/// [FirestoreAdmin.UpdateDatabase][google.firestore.admin.v1.FirestoreAdmin.UpdateDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateDatabase]: crate::client::FirestoreAdmin::update_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDatabaseRequest {
    /// Required. The database to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub database: std::option::Option<crate::model::Database>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::UpdateDatabaseRequest::database].
    pub fn set_database<T: std::convert::Into<std::option::Option<crate::model::Database>>>(
        mut self,
        v: T,
    ) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDatabaseRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateDatabaseRequest"
    }
}

/// Metadata related to the update database operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDatabaseMetadata {}

impl UpdateDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UpdateDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateDatabaseMetadata"
    }
}

/// The request for
/// [FirestoreAdmin.DeleteDatabase][google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase]: crate::client::FirestoreAdmin::delete_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatabaseRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The current etag of the Database.
    /// If an etag is provided and does not match the current etag of the database,
    /// deletion will be blocked and a FAILED_PRECONDITION error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl DeleteDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatabaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDatabaseRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteDatabaseRequest"
    }
}

/// Metadata related to the delete database operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatabaseMetadata {}

impl DeleteDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DeleteDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteDatabaseMetadata"
    }
}

/// The request for
/// [FirestoreAdmin.CreateBackupSchedule][google.firestore.admin.v1.FirestoreAdmin.CreateBackupSchedule].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateBackupSchedule]: crate::client::FirestoreAdmin::create_backup_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupScheduleRequest {
    /// Required. The parent database.
    ///
    /// Format `projects/{project}/databases/{database}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The backup schedule to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_schedule: std::option::Option<crate::model::BackupSchedule>,
}

impl CreateBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupScheduleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_schedule][crate::model::CreateBackupScheduleRequest::backup_schedule].
    pub fn set_backup_schedule<
        T: std::convert::Into<std::option::Option<crate::model::BackupSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_schedule = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateBackupScheduleRequest"
    }
}

/// The request for
/// [FirestoreAdmin.GetBackupSchedule][google.firestore.admin.v1.FirestoreAdmin.GetBackupSchedule].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetBackupSchedule]: crate::client::FirestoreAdmin::get_backup_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupScheduleRequest {
    /// Required. The name of the backup schedule.
    ///
    /// Format
    /// `projects/{project}/databases/{database}/backupSchedules/{backup_schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetBackupScheduleRequest"
    }
}

/// The request for
/// [FirestoreAdmin.UpdateBackupSchedule][google.firestore.admin.v1.FirestoreAdmin.UpdateBackupSchedule].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateBackupSchedule]: crate::client::FirestoreAdmin::update_backup_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupScheduleRequest {
    /// Required. The backup schedule to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_schedule: std::option::Option<crate::model::BackupSchedule>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_schedule][crate::model::UpdateBackupScheduleRequest::backup_schedule].
    pub fn set_backup_schedule<
        T: std::convert::Into<std::option::Option<crate::model::BackupSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_schedule = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupScheduleRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateBackupScheduleRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ListBackupSchedules][google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules]: crate::client::FirestoreAdmin::list_backup_schedules
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupSchedulesRequest {
    /// Required. The parent database.
    ///
    /// Format is `projects/{project}/databases/{database}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,
}

impl ListBackupSchedulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupSchedulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupSchedulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupSchedulesRequest"
    }
}

/// The response for
/// [FirestoreAdmin.ListBackupSchedules][google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules]: crate::client::FirestoreAdmin::list_backup_schedules
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupSchedulesResponse {
    /// List of all backup schedules.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_schedules: std::vec::Vec<crate::model::BackupSchedule>,
}

impl ListBackupSchedulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_schedules][crate::model::ListBackupSchedulesResponse::backup_schedules].
    pub fn set_backup_schedules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupSchedule>,
    {
        use std::iter::Iterator;
        self.backup_schedules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupSchedulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupSchedulesResponse"
    }
}

/// The request for [FirestoreAdmin.DeleteBackupSchedules][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupScheduleRequest {
    /// Required. The name of the backup schedule.
    ///
    /// Format
    /// `projects/{project}/databases/{database}/backupSchedules/{backup_schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteBackupScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteBackupScheduleRequest"
    }
}

/// The request for
/// [FirestoreAdmin.CreateIndex][google.firestore.admin.v1.FirestoreAdmin.CreateIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateIndex]: crate::client::FirestoreAdmin::create_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The composite index to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index: std::option::Option<crate::model::Index>,
}

impl CreateIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIndexRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [index][crate::model::CreateIndexRequest::index].
    pub fn set_index<T: std::convert::Into<std::option::Option<crate::model::Index>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index = v.into();
        self
    }
}

impl wkt::message::Message for CreateIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.CreateIndexRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ListIndexes][google.firestore.admin.v1.FirestoreAdmin.ListIndexes].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListIndexes]: crate::client::FirestoreAdmin::list_indexes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The filter to apply to list results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The number of results to return.
    pub page_size: i32,

    /// A page token, returned from a previous call to
    /// [FirestoreAdmin.ListIndexes][google.firestore.admin.v1.FirestoreAdmin.ListIndexes],
    /// that may be used to get the next page of results.
    ///
    /// [google.firestore.admin.v1.FirestoreAdmin.ListIndexes]: crate::client::FirestoreAdmin::list_indexes
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListIndexesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIndexesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListIndexesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIndexesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIndexesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListIndexesRequest"
    }
}

/// The response for
/// [FirestoreAdmin.ListIndexes][google.firestore.admin.v1.FirestoreAdmin.ListIndexes].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListIndexes]: crate::client::FirestoreAdmin::list_indexes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesResponse {
    /// The requested indexes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub indexes: std::vec::Vec<crate::model::Index>,

    /// A page token that may be used to request another page of results. If blank,
    /// this is the last page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListIndexesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListIndexesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [indexes][crate::model::ListIndexesResponse::indexes].
    pub fn set_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Index>,
    {
        use std::iter::Iterator;
        self.indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListIndexesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListIndexesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListIndexesResponse {
    type PageItem = crate::model::Index;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.indexes
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for
/// [FirestoreAdmin.GetIndex][google.firestore.admin.v1.FirestoreAdmin.GetIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetIndex]: crate::client::FirestoreAdmin::get_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIndexRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIndexRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetIndexRequest"
    }
}

/// The request for
/// [FirestoreAdmin.DeleteIndex][google.firestore.admin.v1.FirestoreAdmin.DeleteIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteIndex]: crate::client::FirestoreAdmin::delete_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIndexRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIndexRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteIndexRequest"
    }
}

/// The request for
/// [FirestoreAdmin.UpdateField][google.firestore.admin.v1.FirestoreAdmin.UpdateField].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateField]: crate::client::FirestoreAdmin::update_field
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFieldRequest {
    /// Required. The field to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<crate::model::Field>,

    /// A mask, relative to the field. If specified, only configuration specified
    /// by this field_mask will be updated in the field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::UpdateFieldRequest::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<crate::model::Field>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFieldRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.UpdateFieldRequest"
    }
}

/// The request for
/// [FirestoreAdmin.GetField][google.firestore.admin.v1.FirestoreAdmin.GetField].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetField]: crate::client::FirestoreAdmin::get_field
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFieldRequest {
    /// Required. A name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetFieldRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFieldRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFieldRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetFieldRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFieldsRequest {
    /// Required. A parent name of the form
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The filter to apply to list results. Currently,
    /// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields]
    /// only supports listing fields that have been explicitly overridden. To issue
    /// this query, call
    /// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields]
    /// with a filter that includes `indexConfig.usesAncestorConfig:false` or
    /// `ttlConfig:*`.
    ///
    /// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The number of results to return.
    pub page_size: i32,

    /// A page token, returned from a previous call to
    /// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields],
    /// that may be used to get the next page of results.
    ///
    /// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListFieldsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFieldsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFieldsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFieldsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFieldsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFieldsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListFieldsRequest"
    }
}

/// The response for
/// [FirestoreAdmin.ListFields][google.firestore.admin.v1.FirestoreAdmin.ListFields].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListFields]: crate::client::FirestoreAdmin::list_fields
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFieldsResponse {
    /// The requested fields.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<crate::model::Field>,

    /// A page token that may be used to request another page of results. If blank,
    /// this is the last page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListFieldsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFieldsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::ListFieldsResponse::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Field>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFieldsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListFieldsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListFieldsResponse {
    type PageItem = crate::model::Field;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.fields
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for
/// [FirestoreAdmin.ExportDocuments][google.firestore.admin.v1.FirestoreAdmin.ExportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ExportDocuments]: crate::client::FirestoreAdmin::export_documents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDocumentsRequest {
    /// Required. Database to export. Should be of the form:
    /// `projects/{project_id}/databases/{database_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Which collection IDs to export. Unspecified means all collections. Each
    /// collection ID in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// The output URI. Currently only supports Google Cloud Storage URIs of the
    /// form: `gs://BUCKET_NAME[/NAMESPACE_PATH]`, where `BUCKET_NAME` is the name
    /// of the Google Cloud Storage bucket and `NAMESPACE_PATH` is an optional
    /// Google Cloud Storage namespace path. When
    /// choosing a name, be sure to consider Google Cloud Storage naming
    /// guidelines: <https://cloud.google.com/storage/docs/naming>.
    /// If the URI is a bucket (without a namespace path), a prefix will be
    /// generated based on the start time.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri_prefix: std::string::String,

    /// An empty list represents all namespaces. This is the preferred
    /// usage for databases that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the database has data in non-default namespaces, but doesn't want
    /// to include them. Each namespace in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,

    /// The timestamp that corresponds to the version of the database to be
    /// exported. The timestamp must be in the past, rounded to the minute and not
    /// older than
    /// [earliestVersionTime][google.firestore.admin.v1.Database.earliest_version_time].
    /// If specified, then the exported documents will represent a consistent view
    /// of the database at the provided time. Otherwise, there are no guarantees
    /// about the consistency of the exported documents.
    ///
    /// [google.firestore.admin.v1.Database.earliest_version_time]: crate::model::Database::earliest_version_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_time: std::option::Option<wkt::Timestamp>,
}

impl ExportDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportDocumentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [output_uri_prefix][crate::model::ExportDocumentsRequest::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::ExportDocumentsRequest::snapshot_time].
    pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_time = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::ExportDocumentsRequest::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ExportDocumentsRequest::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ExportDocumentsRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ImportDocuments][google.firestore.admin.v1.FirestoreAdmin.ImportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ImportDocuments]: crate::client::FirestoreAdmin::import_documents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDocumentsRequest {
    /// Required. Database to import into. Should be of the form:
    /// `projects/{project_id}/databases/{database_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Which collection IDs to import. Unspecified means all collections included
    /// in the import. Each collection ID in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Location of the exported files.
    /// This must match the output_uri_prefix of an ExportDocumentsResponse from
    /// an export that has completed successfully.
    /// See:
    /// [google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix][google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix].
    ///
    /// [google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix]: crate::model::ExportDocumentsResponse::output_uri_prefix
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_uri_prefix: std::string::String,

    /// An empty list represents all namespaces. This is the preferred
    /// usage for databases that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the database has data in non-default namespaces, but doesn't want
    /// to include them. Each namespace in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,
}

impl ImportDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportDocumentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [input_uri_prefix][crate::model::ImportDocumentsRequest::input_uri_prefix].
    pub fn set_input_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_uri_prefix = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::ImportDocumentsRequest::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ImportDocumentsRequest::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ImportDocumentsRequest"
    }
}

/// The request for
/// [FirestoreAdmin.BulkDeleteDocuments][google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments].
///
/// When both collection_ids and namespace_ids are set, only documents satisfying
/// both conditions will be deleted.
///
/// Requests with namespace_ids and collection_ids both empty will be rejected.
/// Please use
/// [FirestoreAdmin.DeleteDatabase][google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase]
/// instead.
///
/// [google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments]: crate::client::FirestoreAdmin::bulk_delete_documents
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase]: crate::client::FirestoreAdmin::delete_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDeleteDocumentsRequest {
    /// Required. Database to operate. Should be of the form:
    /// `projects/{project_id}/databases/{database_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. IDs of the collection groups to delete. Unspecified means all
    /// collection groups.
    ///
    /// Each collection group in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Optional. Namespaces to delete.
    ///
    /// An empty list means all namespaces. This is the recommended
    /// usage for databases that don't use namespaces.
    ///
    /// An empty string element represents the default namespace. This should be
    /// used if the database has data in non-default namespaces, but doesn't want
    /// to delete from them.
    ///
    /// Each namespace in this list must be unique.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,
}

impl BulkDeleteDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BulkDeleteDocumentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::BulkDeleteDocumentsRequest::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::BulkDeleteDocumentsRequest::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BulkDeleteDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BulkDeleteDocumentsRequest"
    }
}

/// The response for
/// [FirestoreAdmin.BulkDeleteDocuments][google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments]: crate::client::FirestoreAdmin::bulk_delete_documents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDeleteDocumentsResponse {}

impl BulkDeleteDocumentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BulkDeleteDocumentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BulkDeleteDocumentsResponse"
    }
}

/// The request for
/// [FirestoreAdmin.GetBackup][google.firestore.admin.v1.FirestoreAdmin.GetBackup].
///
/// [google.firestore.admin.v1.FirestoreAdmin.GetBackup]: crate::client::FirestoreAdmin::get_backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Name of the backup to fetch.
    ///
    /// Format is `projects/{project}/locations/{location}/backups/{backup}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.GetBackupRequest"
    }
}

/// The request for
/// [FirestoreAdmin.ListBackups][google.firestore.admin.v1.FirestoreAdmin.ListBackups].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackups]: crate::client::FirestoreAdmin::list_backups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The location to list backups from.
    ///
    /// Format is `projects/{project}/locations/{location}`.
    /// Use `{location} = '-'` to list backups from all locations for the given
    /// project. This allows listing backups from a single location or from all
    /// locations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// An expression that filters the list of returned backups.
    ///
    /// A filter expression consists of a field name, a comparison operator, and a
    /// value for filtering.
    /// The value must be a string, a number, or a boolean. The comparison operator
    /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
    /// Colon `:` is the contains operator. Filter rules are not case sensitive.
    ///
    /// The following fields in the [Backup][google.firestore.admin.v1.Backup] are
    /// eligible for filtering:
    ///
    /// * `database_uid` (supports `=` only)
    ///
    /// [google.firestore.admin.v1.Backup]: crate::model::Backup
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupsRequest"
    }
}

/// The response for
/// [FirestoreAdmin.ListBackups][google.firestore.admin.v1.FirestoreAdmin.ListBackups].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ListBackups]: crate::client::FirestoreAdmin::list_backups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// List of all backups for the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// List of locations that existing backups were not able to be fetched from.
    ///
    /// Instead of failing the entire requests when a single location is
    /// unreachable, this response returns a partial result set and list of
    /// locations unable to be reached here. The request can be retried against a
    /// single location to get a concrete error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ListBackupsResponse"
    }
}

/// The request for
/// [FirestoreAdmin.DeleteBackup][google.firestore.admin.v1.FirestoreAdmin.DeleteBackup].
///
/// [google.firestore.admin.v1.FirestoreAdmin.DeleteBackup]: crate::client::FirestoreAdmin::delete_backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Name of the backup to delete.
    ///
    /// format is `projects/{project}/locations/{location}/backups/{backup}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DeleteBackupRequest"
    }
}

/// The request message for
/// [FirestoreAdmin.RestoreDatabase][google.firestore.admin.v1.FirestoreAdmin.RestoreDatabase].
///
/// [google.firestore.admin.v1.FirestoreAdmin.RestoreDatabase]: crate::client::FirestoreAdmin::restore_database
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreDatabaseRequest {
    /// Required. The project to restore the database in. Format is
    /// `projects/{project_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to use for the database, which will become the final
    /// component of the database's resource name. This database ID must not be
    /// associated with an existing database.
    ///
    /// This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/
    /// with first character a letter and the last a letter or a number. Must not
    /// be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.
    ///
    /// "(default)" database ID is also valid.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_id: std::string::String,

    /// Required. Backup to restore from. Must be from the same project as the
    /// parent.
    ///
    /// The restored database will be created in the same location as the source
    /// backup.
    ///
    /// Format is: `projects/{project_id}/locations/{location}/backups/{backup}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup: std::string::String,

    /// Optional. Encryption configuration for the restored database.
    ///
    /// If this field is not specified, the restored database will use
    /// the same encryption configuration as the backup, namely
    /// [use_source_encryption][google.firestore.admin.v1.Database.EncryptionConfig.use_source_encryption].
    ///
    /// [google.firestore.admin.v1.Database.EncryptionConfig.use_source_encryption]: crate::model::database::EncryptionConfig::encryption_type
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::database::EncryptionConfig>,
}

impl RestoreDatabaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RestoreDatabaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [database_id][crate::model::RestoreDatabaseRequest::database_id].
    pub fn set_database_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_id = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::RestoreDatabaseRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::RestoreDatabaseRequest::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::database::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }
}

impl wkt::message::Message for RestoreDatabaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.RestoreDatabaseRequest"
    }
}

/// Cloud Firestore indexes enable simple and complex queries against
/// documents in a database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Index {
    /// Output only. A server defined name for this index.
    /// The form of this name for composite indexes will be:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{composite_index_id}`
    /// For single field indexes, this field will be empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Indexes with a collection query scope specified allow queries
    /// against a collection that is the child of a specific document, specified at
    /// query time, and that has the same collection ID.
    ///
    /// Indexes with a collection group query scope specified allow queries against
    /// all collections descended from a specific document, specified at query
    /// time, and that have the same collection ID as this index.
    pub query_scope: crate::model::index::QueryScope,

    /// The API scope supported by this index.
    pub api_scope: crate::model::index::ApiScope,

    /// The fields supported by this index.
    ///
    /// For composite indexes, this requires a minimum of 2 and a maximum of 100
    /// fields. The last field entry is always for the field path `__name__`. If,
    /// on creation, `__name__` was not specified as the last field, it will be
    /// added automatically with the same direction as that of the last field
    /// defined. If the final field in a composite index is not directional, the
    /// `__name__` will be ordered ASCENDING (unless explicitly specified).
    ///
    /// For single field indexes, this will always be exactly one entry with a
    /// field path equal to the field path of the associated field.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<crate::model::index::IndexField>,

    /// Output only. The serving state of the index.
    pub state: crate::model::index::State,
}

impl Index {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Index::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [query_scope][crate::model::Index::query_scope].
    pub fn set_query_scope<T: std::convert::Into<crate::model::index::QueryScope>>(
        mut self,
        v: T,
    ) -> Self {
        self.query_scope = v.into();
        self
    }

    /// Sets the value of [api_scope][crate::model::Index::api_scope].
    pub fn set_api_scope<T: std::convert::Into<crate::model::index::ApiScope>>(
        mut self,
        v: T,
    ) -> Self {
        self.api_scope = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Index::state].
    pub fn set_state<T: std::convert::Into<crate::model::index::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::Index::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::index::IndexField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Index {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Index"
    }
}

/// Defines additional types related to Index
pub mod index {
    #[allow(unused_imports)]
    use super::*;

    /// A field in an index.
    /// The field_path describes which field is indexed, the value_mode describes
    /// how the field value is indexed.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IndexField {
        /// Can be __name__.
        /// For single field indexes, this must match the name of the field or may
        /// be omitted.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub field_path: std::string::String,

        /// How the field value is indexed.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value_mode: std::option::Option<crate::model::index::index_field::ValueMode>,
    }

    impl IndexField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field_path][crate::model::index::IndexField::field_path].
        pub fn set_field_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field_path = v.into();
            self
        }

        /// Sets the value of `value_mode`.
        pub fn set_value_mode<
            T: std::convert::Into<std::option::Option<crate::model::index::index_field::ValueMode>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = v.into();
            self
        }

        /// The value of [value_mode][crate::model::index::IndexField::value_mode]
        /// if it holds a `Order`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_order(&self) -> std::option::Option<&crate::model::index::index_field::Order> {
            #[allow(unreachable_patterns)]
            self.value_mode.as_ref().and_then(|v| match v {
                crate::model::index::index_field::ValueMode::Order(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value_mode][crate::model::index::IndexField::value_mode]
        /// if it holds a `ArrayConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_array_config(
            &self,
        ) -> std::option::Option<&crate::model::index::index_field::ArrayConfig> {
            #[allow(unreachable_patterns)]
            self.value_mode.as_ref().and_then(|v| match v {
                crate::model::index::index_field::ValueMode::ArrayConfig(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value_mode][crate::model::index::IndexField::value_mode]
        /// if it holds a `VectorConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_vector_config(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::index::index_field::VectorConfig>>
        {
            #[allow(unreachable_patterns)]
            self.value_mode.as_ref().and_then(|v| match v {
                crate::model::index::index_field::ValueMode::VectorConfig(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value_mode][crate::model::index::IndexField::value_mode]
        /// to hold a `Order`.
        ///
        /// Note that all the setters affecting `value_mode` are
        /// mutually exclusive.
        pub fn set_order<T: std::convert::Into<crate::model::index::index_field::Order>>(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = std::option::Option::Some(
                crate::model::index::index_field::ValueMode::Order(v.into()),
            );
            self
        }

        /// Sets the value of [value_mode][crate::model::index::IndexField::value_mode]
        /// to hold a `ArrayConfig`.
        ///
        /// Note that all the setters affecting `value_mode` are
        /// mutually exclusive.
        pub fn set_array_config<
            T: std::convert::Into<crate::model::index::index_field::ArrayConfig>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = std::option::Option::Some(
                crate::model::index::index_field::ValueMode::ArrayConfig(v.into()),
            );
            self
        }

        /// Sets the value of [value_mode][crate::model::index::IndexField::value_mode]
        /// to hold a `VectorConfig`.
        ///
        /// Note that all the setters affecting `value_mode` are
        /// mutually exclusive.
        pub fn set_vector_config<
            T: std::convert::Into<std::boxed::Box<crate::model::index::index_field::VectorConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_mode = std::option::Option::Some(
                crate::model::index::index_field::ValueMode::VectorConfig(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for IndexField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.Index.IndexField"
        }
    }

    /// Defines additional types related to IndexField
    pub mod index_field {
        #[allow(unused_imports)]
        use super::*;

        /// The index configuration to support vector search operations
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct VectorConfig {
            /// Required. The vector dimension this configuration applies to.
            ///
            /// The resulting index will only include vectors of this dimension, and
            /// can be used for vector search with the same dimension.
            pub dimension: i32,

            /// The type of index used.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub r#type: std::option::Option<crate::model::index::index_field::vector_config::Type>,
        }

        impl VectorConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [dimension][crate::model::index::index_field::VectorConfig::dimension].
            pub fn set_dimension<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.dimension = v.into();
                self
            }

            /// Sets the value of `r#type`.
            pub fn set_type<
                T: std::convert::Into<
                    std::option::Option<crate::model::index::index_field::vector_config::Type>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// The value of [r#type][crate::model::index::index_field::VectorConfig::r#type]
            /// if it holds a `Flat`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_flat(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::index::index_field::vector_config::FlatIndex>,
            > {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::index::index_field::vector_config::Type::Flat(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::index::index_field::VectorConfig::r#type]
            /// to hold a `Flat`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_flat<
                T: std::convert::Into<
                    std::boxed::Box<crate::model::index::index_field::vector_config::FlatIndex>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::index::index_field::vector_config::Type::Flat(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for VectorConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.firestore.admin.v1.Index.IndexField.VectorConfig"
            }
        }

        /// Defines additional types related to VectorConfig
        pub mod vector_config {
            #[allow(unused_imports)]
            use super::*;

            /// An index that stores vectors in a flat data structure, and supports
            /// exhaustive search.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct FlatIndex {}

            impl FlatIndex {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for FlatIndex {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.firestore.admin.v1.Index.IndexField.VectorConfig.FlatIndex"
                }
            }

            /// The type of index used.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Type {
                /// Indicates the vector index is a flat index.
                Flat(std::boxed::Box<crate::model::index::index_field::vector_config::FlatIndex>),
            }
        }

        /// The supported orderings.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Order(std::borrow::Cow<'static, str>);

        impl Order {
            /// Creates a new Order instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [Order](Order)
        pub mod order {
            use super::Order;

            /// The ordering is unspecified. Not a valid option.
            pub const ORDER_UNSPECIFIED: Order = Order::new("ORDER_UNSPECIFIED");

            /// The field is ordered by ascending field value.
            pub const ASCENDING: Order = Order::new("ASCENDING");

            /// The field is ordered by descending field value.
            pub const DESCENDING: Order = Order::new("DESCENDING");
        }

        impl std::convert::From<std::string::String> for Order {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// The supported array value configurations.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ArrayConfig(std::borrow::Cow<'static, str>);

        impl ArrayConfig {
            /// Creates a new ArrayConfig instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [ArrayConfig](ArrayConfig)
        pub mod array_config {
            use super::ArrayConfig;

            /// The index does not support additional array queries.
            pub const ARRAY_CONFIG_UNSPECIFIED: ArrayConfig =
                ArrayConfig::new("ARRAY_CONFIG_UNSPECIFIED");

            /// The index supports array containment queries.
            pub const CONTAINS: ArrayConfig = ArrayConfig::new("CONTAINS");
        }

        impl std::convert::From<std::string::String> for ArrayConfig {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// How the field value is indexed.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum ValueMode {
            /// Indicates that this field supports ordering by the specified order or
            /// comparing using =, !=, <, <=, >, >=.
            Order(crate::model::index::index_field::Order),
            /// Indicates that this field supports operations on `array_value`s.
            ArrayConfig(crate::model::index::index_field::ArrayConfig),
            /// Indicates that this field supports nearest neighbor and distance
            /// operations on vector.
            VectorConfig(std::boxed::Box<crate::model::index::index_field::VectorConfig>),
        }
    }

    /// Query Scope defines the scope at which a query is run. This is specified on
    /// a StructuredQuery's `from` field.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct QueryScope(std::borrow::Cow<'static, str>);

    impl QueryScope {
        /// Creates a new QueryScope instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [QueryScope](QueryScope)
    pub mod query_scope {
        use super::QueryScope;

        /// The query scope is unspecified. Not a valid option.
        pub const QUERY_SCOPE_UNSPECIFIED: QueryScope = QueryScope::new("QUERY_SCOPE_UNSPECIFIED");

        /// Indexes with a collection query scope specified allow queries
        /// against a collection that is the child of a specific document, specified
        /// at query time, and that has the collection ID specified by the index.
        pub const COLLECTION: QueryScope = QueryScope::new("COLLECTION");

        /// Indexes with a collection group query scope specified allow queries
        /// against all collections that has the collection ID specified by the
        /// index.
        pub const COLLECTION_GROUP: QueryScope = QueryScope::new("COLLECTION_GROUP");

        /// Include all the collections's ancestor in the index. Only available for
        /// Datastore Mode databases.
        pub const COLLECTION_RECURSIVE: QueryScope = QueryScope::new("COLLECTION_RECURSIVE");
    }

    impl std::convert::From<std::string::String> for QueryScope {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// API Scope defines the APIs (Firestore Native, or Firestore in
    /// Datastore Mode) that are supported for queries.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ApiScope(std::borrow::Cow<'static, str>);

    impl ApiScope {
        /// Creates a new ApiScope instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ApiScope](ApiScope)
    pub mod api_scope {
        use super::ApiScope;

        /// The index can only be used by the Firestore Native query API.
        /// This is the default.
        pub const ANY_API: ApiScope = ApiScope::new("ANY_API");

        /// The index can only be used by the Firestore in Datastore Mode query API.
        pub const DATASTORE_MODE_API: ApiScope = ApiScope::new("DATASTORE_MODE_API");
    }

    impl std::convert::From<std::string::String> for ApiScope {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The state of an index. During index creation, an index will be in the
    /// `CREATING` state. If the index is created successfully, it will transition
    /// to the `READY` state. If the index creation encounters a problem, the index
    /// will transition to the `NEEDS_REPAIR` state.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// The state is unspecified.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The index is being created.
        /// There is an active long-running operation for the index.
        /// The index is updated when writing a document.
        /// Some index data may exist.
        pub const CREATING: State = State::new("CREATING");

        /// The index is ready to be used.
        /// The index is updated when writing a document.
        /// The index is fully populated from all stored documents it applies to.
        pub const READY: State = State::new("READY");

        /// The index was being created, but something went wrong.
        /// There is no active long-running operation for the index,
        /// and the most recently finished long-running operation failed.
        /// The index is not updated when writing a document.
        /// Some index data may exist.
        /// Use the google.longrunning.Operations API to determine why the operation
        /// that last attempted to create this index failed, then re-create the
        /// index.
        pub const NEEDS_REPAIR: State = State::new("NEEDS_REPAIR");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// The metadata message for
/// [google.cloud.location.Location.metadata][google.cloud.location.Location.metadata].
///
/// [google.cloud.location.Location.metadata]: location::model::Location::metadata
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.LocationMetadata"
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.CreateIndex][google.firestore.admin.v1.FirestoreAdmin.CreateIndex].
///
/// [google.firestore.admin.v1.FirestoreAdmin.CreateIndex]: crate::client::FirestoreAdmin::create_index
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexOperationMetadata {
    /// The time this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The index resource that this operation is acting on. For example:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index: std::string::String,

    /// The state of the operation.
    pub state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,
}

impl IndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::IndexOperationMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::IndexOperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [index][crate::model::IndexOperationMetadata::index].
    pub fn set_index<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [state][crate::model::IndexOperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::IndexOperationMetadata::progress_documents].
    pub fn set_progress_documents<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_documents = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::IndexOperationMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }
}

impl wkt::message::Message for IndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.IndexOperationMetadata"
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.UpdateField][google.firestore.admin.v1.FirestoreAdmin.UpdateField].
///
/// [google.firestore.admin.v1.FirestoreAdmin.UpdateField]: crate::client::FirestoreAdmin::update_field
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FieldOperationMetadata {
    /// The time this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The field resource that this operation is acting on. For example:
    /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_path}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field: std::string::String,

    /// A list of
    /// [IndexConfigDelta][google.firestore.admin.v1.FieldOperationMetadata.IndexConfigDelta],
    /// which describe the intent of this operation.
    ///
    /// [google.firestore.admin.v1.FieldOperationMetadata.IndexConfigDelta]: crate::model::field_operation_metadata::IndexConfigDelta
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub index_config_deltas:
        std::vec::Vec<crate::model::field_operation_metadata::IndexConfigDelta>,

    /// The state of the operation.
    pub state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Describes the deltas of TTL configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ttl_config_delta:
        std::option::Option<crate::model::field_operation_metadata::TtlConfigDelta>,
}

impl FieldOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::FieldOperationMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::FieldOperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [field][crate::model::FieldOperationMetadata::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [state][crate::model::FieldOperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::FieldOperationMetadata::progress_documents].
    pub fn set_progress_documents<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_documents = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::FieldOperationMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [ttl_config_delta][crate::model::FieldOperationMetadata::ttl_config_delta].
    pub fn set_ttl_config_delta<
        T: std::convert::Into<
            std::option::Option<crate::model::field_operation_metadata::TtlConfigDelta>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ttl_config_delta = v.into();
        self
    }

    /// Sets the value of [index_config_deltas][crate::model::FieldOperationMetadata::index_config_deltas].
    pub fn set_index_config_deltas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::field_operation_metadata::IndexConfigDelta>,
    {
        use std::iter::Iterator;
        self.index_config_deltas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FieldOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.FieldOperationMetadata"
    }
}

/// Defines additional types related to FieldOperationMetadata
pub mod field_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Information about an index configuration change.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IndexConfigDelta {
        /// Specifies how the index is changing.
        pub change_type: crate::model::field_operation_metadata::index_config_delta::ChangeType,

        /// The index being changed.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub index: std::option::Option<crate::model::Index>,
    }

    impl IndexConfigDelta {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [change_type][crate::model::field_operation_metadata::IndexConfigDelta::change_type].
        pub fn set_change_type<
            T: std::convert::Into<
                crate::model::field_operation_metadata::index_config_delta::ChangeType,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.change_type = v.into();
            self
        }

        /// Sets the value of [index][crate::model::field_operation_metadata::IndexConfigDelta::index].
        pub fn set_index<T: std::convert::Into<std::option::Option<crate::model::Index>>>(
            mut self,
            v: T,
        ) -> Self {
            self.index = v.into();
            self
        }
    }

    impl wkt::message::Message for IndexConfigDelta {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.FieldOperationMetadata.IndexConfigDelta"
        }
    }

    /// Defines additional types related to IndexConfigDelta
    pub mod index_config_delta {
        #[allow(unused_imports)]
        use super::*;

        /// Specifies how the index is changing.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ChangeType(std::borrow::Cow<'static, str>);

        impl ChangeType {
            /// Creates a new ChangeType instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [ChangeType](ChangeType)
        pub mod change_type {
            use super::ChangeType;

            /// The type of change is not specified or known.
            pub const CHANGE_TYPE_UNSPECIFIED: ChangeType =
                ChangeType::new("CHANGE_TYPE_UNSPECIFIED");

            /// The single field index is being added.
            pub const ADD: ChangeType = ChangeType::new("ADD");

            /// The single field index is being removed.
            pub const REMOVE: ChangeType = ChangeType::new("REMOVE");
        }

        impl std::convert::From<std::string::String> for ChangeType {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// Information about a TTL configuration change.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TtlConfigDelta {
        /// Specifies how the TTL configuration is changing.
        pub change_type: crate::model::field_operation_metadata::ttl_config_delta::ChangeType,
    }

    impl TtlConfigDelta {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [change_type][crate::model::field_operation_metadata::TtlConfigDelta::change_type].
        pub fn set_change_type<
            T: std::convert::Into<
                crate::model::field_operation_metadata::ttl_config_delta::ChangeType,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.change_type = v.into();
            self
        }
    }

    impl wkt::message::Message for TtlConfigDelta {
        fn typename() -> &'static str {
            "type.googleapis.com/google.firestore.admin.v1.FieldOperationMetadata.TtlConfigDelta"
        }
    }

    /// Defines additional types related to TtlConfigDelta
    pub mod ttl_config_delta {
        #[allow(unused_imports)]
        use super::*;

        /// Specifies how the TTL config is changing.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ChangeType(std::borrow::Cow<'static, str>);

        impl ChangeType {
            /// Creates a new ChangeType instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [ChangeType](ChangeType)
        pub mod change_type {
            use super::ChangeType;

            /// The type of change is not specified or known.
            pub const CHANGE_TYPE_UNSPECIFIED: ChangeType =
                ChangeType::new("CHANGE_TYPE_UNSPECIFIED");

            /// The TTL config is being added.
            pub const ADD: ChangeType = ChangeType::new("ADD");

            /// The TTL config is being removed.
            pub const REMOVE: ChangeType = ChangeType::new("REMOVE");
        }

        impl std::convert::From<std::string::String> for ChangeType {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.ExportDocuments][google.firestore.admin.v1.FirestoreAdmin.ExportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ExportDocuments]: crate::client::FirestoreAdmin::export_documents
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDocumentsMetadata {
    /// The time this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The state of the export operation.
    pub operation_state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Which collection IDs are being exported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Where the documents are being exported to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri_prefix: std::string::String,

    /// Which namespace IDs are being exported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,

    /// The timestamp that corresponds to the version of the database that is being
    /// exported. If unspecified, there are no guarantees about the consistency of
    /// the documents being exported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_time: std::option::Option<wkt::Timestamp>,
}

impl ExportDocumentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::ExportDocumentsMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ExportDocumentsMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [operation_state][crate::model::ExportDocumentsMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::ExportDocumentsMetadata::progress_documents].
    pub fn set_progress_documents<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_documents = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ExportDocumentsMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [output_uri_prefix][crate::model::ExportDocumentsMetadata::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::ExportDocumentsMetadata::snapshot_time].
    pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_time = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::ExportDocumentsMetadata::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ExportDocumentsMetadata::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportDocumentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ExportDocumentsMetadata"
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.ImportDocuments][google.firestore.admin.v1.FirestoreAdmin.ImportDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.ImportDocuments]: crate::client::FirestoreAdmin::import_documents
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDocumentsMetadata {
    /// The time this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The state of the import operation.
    pub operation_state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// Which collection IDs are being imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// The location of the documents being imported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_uri_prefix: std::string::String,

    /// Which namespace IDs are being imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,
}

impl ImportDocumentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::ImportDocumentsMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ImportDocumentsMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [operation_state][crate::model::ImportDocumentsMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::ImportDocumentsMetadata::progress_documents].
    pub fn set_progress_documents<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_documents = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::ImportDocumentsMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [input_uri_prefix][crate::model::ImportDocumentsMetadata::input_uri_prefix].
    pub fn set_input_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_uri_prefix = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::ImportDocumentsMetadata::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::ImportDocumentsMetadata::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportDocumentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ImportDocumentsMetadata"
    }
}

/// Metadata for [google.longrunning.Operation][google.longrunning.Operation]
/// results from
/// [FirestoreAdmin.BulkDeleteDocuments][google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments].
///
/// [google.firestore.admin.v1.FirestoreAdmin.BulkDeleteDocuments]: crate::client::FirestoreAdmin::bulk_delete_documents
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDeleteDocumentsMetadata {
    /// The time this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation completed. Will be unset if operation still in
    /// progress.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The state of the operation.
    pub operation_state: crate::model::OperationState,

    /// The progress, in documents, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_documents: std::option::Option<crate::model::Progress>,

    /// The progress, in bytes, of this operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_bytes: std::option::Option<crate::model::Progress>,

    /// The IDs of the collection groups that are being deleted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub collection_ids: std::vec::Vec<std::string::String>,

    /// Which namespace IDs are being deleted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub namespace_ids: std::vec::Vec<std::string::String>,

    /// The timestamp that corresponds to the version of the database that is being
    /// read to get the list of documents to delete. This time can also be used as
    /// the timestamp of PITR in case of disaster recovery (subject to PITR window
    /// limit).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_time: std::option::Option<wkt::Timestamp>,
}

impl BulkDeleteDocumentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::BulkDeleteDocumentsMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BulkDeleteDocumentsMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [operation_state][crate::model::BulkDeleteDocumentsMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [progress_documents][crate::model::BulkDeleteDocumentsMetadata::progress_documents].
    pub fn set_progress_documents<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_documents = v.into();
        self
    }

    /// Sets the value of [progress_bytes][crate::model::BulkDeleteDocumentsMetadata::progress_bytes].
    pub fn set_progress_bytes<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_bytes = v.into();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::BulkDeleteDocumentsMetadata::snapshot_time].
    pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_time = v.into();
        self
    }

    /// Sets the value of [collection_ids][crate::model::BulkDeleteDocumentsMetadata::collection_ids].
    pub fn set_collection_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [namespace_ids][crate::model::BulkDeleteDocumentsMetadata::namespace_ids].
    pub fn set_namespace_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespace_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BulkDeleteDocumentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BulkDeleteDocumentsMetadata"
    }
}

/// Returned in the [google.longrunning.Operation][google.longrunning.Operation]
/// response field.
///
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDocumentsResponse {
    /// Location of the output files. This can be used to begin an import
    /// into Cloud Firestore (this project or another project) after the operation
    /// completes successfully.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri_prefix: std::string::String,
}

impl ExportDocumentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri_prefix][crate::model::ExportDocumentsResponse::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }
}

impl wkt::message::Message for ExportDocumentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.ExportDocumentsResponse"
    }
}

/// Metadata for the [long-running operation][google.longrunning.Operation] from
/// the [RestoreDatabase][google.firestore.admin.v1.RestoreDatabase] request.
///
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreDatabaseMetadata {
    /// The time the restore was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the restore finished, unset for ongoing restores.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The operation state of the restore.
    pub operation_state: crate::model::OperationState,

    /// The name of the database being restored to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// The name of the backup restoring from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup: std::string::String,

    /// How far along the restore is as an estimated percentage of remaining time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress_percentage: std::option::Option<crate::model::Progress>,
}

impl RestoreDatabaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::RestoreDatabaseMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::RestoreDatabaseMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [operation_state][crate::model::RestoreDatabaseMetadata::operation_state].
    pub fn set_operation_state<T: std::convert::Into<crate::model::OperationState>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_state = v.into();
        self
    }

    /// Sets the value of [database][crate::model::RestoreDatabaseMetadata::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::RestoreDatabaseMetadata::backup].
    pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [progress_percentage][crate::model::RestoreDatabaseMetadata::progress_percentage].
    pub fn set_progress_percentage<
        T: std::convert::Into<std::option::Option<crate::model::Progress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress_percentage = v.into();
        self
    }
}

impl wkt::message::Message for RestoreDatabaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.RestoreDatabaseMetadata"
    }
}

/// Describes the progress of the operation.
/// Unit of work is generic and must be interpreted based on where
/// [Progress][google.firestore.admin.v1.Progress] is used.
///
/// [google.firestore.admin.v1.Progress]: crate::model::Progress
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Progress {
    /// The amount of work estimated.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub estimated_work: i64,

    /// The amount of work completed.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub completed_work: i64,
}

impl Progress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [estimated_work][crate::model::Progress::estimated_work].
    pub fn set_estimated_work<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.estimated_work = v.into();
        self
    }

    /// Sets the value of [completed_work][crate::model::Progress::completed_work].
    pub fn set_completed_work<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.completed_work = v.into();
        self
    }
}

impl wkt::message::Message for Progress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.Progress"
    }
}

/// A backup schedule for a Cloud Firestore Database.
///
/// This resource is owned by the database it is backing up, and is deleted along
/// with the database. The actual backups are not though.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupSchedule {
    /// Output only. The unique backup schedule identifier across all locations and
    /// databases for the given project.
    ///
    /// This will be auto-assigned.
    ///
    /// Format is
    /// `projects/{project}/databases/{database}/backupSchedules/{backup_schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp at which this backup schedule was created and
    /// effective since.
    ///
    /// No backups will be created for this schedule before this time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp at which this backup schedule was most recently
    /// updated. When a backup schedule is first created, this is the same as
    /// create_time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// At what relative time in the future, compared to its creation time,
    /// the backup should be deleted, e.g. keep backups for 7 days.
    ///
    /// The maximum supported retention period is 14 weeks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retention: std::option::Option<wkt::Duration>,

    /// A oneof field to represent when backups will be taken.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub recurrence: std::option::Option<crate::model::backup_schedule::Recurrence>,
}

impl BackupSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupSchedule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupSchedule::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::BackupSchedule::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [retention][crate::model::BackupSchedule::retention].
    pub fn set_retention<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.retention = v.into();
        self
    }

    /// Sets the value of `recurrence`.
    pub fn set_recurrence<
        T: std::convert::Into<std::option::Option<crate::model::backup_schedule::Recurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = v.into();
        self
    }

    /// The value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// if it holds a `DailyRecurrence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_daily_recurrence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DailyRecurrence>> {
        #[allow(unreachable_patterns)]
        self.recurrence.as_ref().and_then(|v| match v {
            crate::model::backup_schedule::Recurrence::DailyRecurrence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// if it holds a `WeeklyRecurrence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_weekly_recurrence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WeeklyRecurrence>> {
        #[allow(unreachable_patterns)]
        self.recurrence.as_ref().and_then(|v| match v {
            crate::model::backup_schedule::Recurrence::WeeklyRecurrence(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// to hold a `DailyRecurrence`.
    ///
    /// Note that all the setters affecting `recurrence` are
    /// mutually exclusive.
    pub fn set_daily_recurrence<
        T: std::convert::Into<std::boxed::Box<crate::model::DailyRecurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = std::option::Option::Some(
            crate::model::backup_schedule::Recurrence::DailyRecurrence(v.into()),
        );
        self
    }

    /// Sets the value of [recurrence][crate::model::BackupSchedule::recurrence]
    /// to hold a `WeeklyRecurrence`.
    ///
    /// Note that all the setters affecting `recurrence` are
    /// mutually exclusive.
    pub fn set_weekly_recurrence<
        T: std::convert::Into<std::boxed::Box<crate::model::WeeklyRecurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = std::option::Option::Some(
            crate::model::backup_schedule::Recurrence::WeeklyRecurrence(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackupSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.BackupSchedule"
    }
}

/// Defines additional types related to BackupSchedule
pub mod backup_schedule {
    #[allow(unused_imports)]
    use super::*;

    /// A oneof field to represent when backups will be taken.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Recurrence {
        /// For a schedule that runs daily.
        DailyRecurrence(std::boxed::Box<crate::model::DailyRecurrence>),
        /// For a schedule that runs weekly on a specific day.
        WeeklyRecurrence(std::boxed::Box<crate::model::WeeklyRecurrence>),
    }
}

/// Represents a recurring schedule that runs every day.
///
/// The time zone is UTC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DailyRecurrence {}

impl DailyRecurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DailyRecurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.DailyRecurrence"
    }
}

/// Represents a recurring schedule that runs on a specified day of the week.
///
/// The time zone is UTC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WeeklyRecurrence {
    /// The day of week to run.
    ///
    /// DAY_OF_WEEK_UNSPECIFIED is not allowed.
    pub day: gtype::model::DayOfWeek,
}

impl WeeklyRecurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day][crate::model::WeeklyRecurrence::day].
    pub fn set_day<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day = v.into();
        self
    }
}

impl wkt::message::Message for WeeklyRecurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.firestore.admin.v1.WeeklyRecurrence"
    }
}

/// Describes the state of the operation.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct OperationState(std::borrow::Cow<'static, str>);

impl OperationState {
    /// Creates a new OperationState instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [OperationState](OperationState)
pub mod operation_state {
    use super::OperationState;

    /// Unspecified.
    pub const OPERATION_STATE_UNSPECIFIED: OperationState =
        OperationState::new("OPERATION_STATE_UNSPECIFIED");

    /// Request is being prepared for processing.
    pub const INITIALIZING: OperationState = OperationState::new("INITIALIZING");

    /// Request is actively being processed.
    pub const PROCESSING: OperationState = OperationState::new("PROCESSING");

    /// Request is in the process of being cancelled after user called
    /// google.longrunning.Operations.CancelOperation on the operation.
    pub const CANCELLING: OperationState = OperationState::new("CANCELLING");

    /// Request has been processed and is in its finalization stage.
    pub const FINALIZING: OperationState = OperationState::new("FINALIZING");

    /// Request has completed successfully.
    pub const SUCCESSFUL: OperationState = OperationState::new("SUCCESSFUL");

    /// Request has finished being processed, but encountered an error.
    pub const FAILED: OperationState = OperationState::new("FAILED");

    /// Request has finished being cancelled after user called
    /// google.longrunning.Operations.CancelOperation.
    pub const CANCELLED: OperationState = OperationState::new("CANCELLED");
}

impl std::convert::From<std::string::String> for OperationState {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}
