// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::AttestationNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AttestationNote");
        debug_struct.field("hint", &self.hint);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::attestation_note::Hint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Hint");
        debug_struct.field("human_readable_name", &self.human_readable_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Jwt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Jwt");
        debug_struct.field("compact_jwt", &self.compact_jwt);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AttestationOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AttestationOccurrence");
        debug_struct.field("serialized_payload", &self.serialized_payload);
        debug_struct.field("signatures", &self.signatures);
        debug_struct.field("jwts", &self.jwts);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuildNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildNote");
        debug_struct.field("builder_version", &self.builder_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuildOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildOccurrence");
        debug_struct.field("provenance", &self.provenance);
        debug_struct.field("provenance_bytes", &self.provenance_bytes);
        debug_struct.field("intoto_provenance", &self.intoto_provenance);
        debug_struct.field("intoto_statement", &self.intoto_statement);
        debug_struct.field(
            "in_toto_slsa_provenance_v1",
            &self.in_toto_slsa_provenance_v1,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RelatedUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RelatedUrl");
        debug_struct.field("url", &self.url);
        debug_struct.field("label", &self.label);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Signature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Signature");
        debug_struct.field("signature", &self.signature);
        debug_struct.field("public_key_id", &self.public_key_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Envelope {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Envelope");
        debug_struct.field("payload", &self.payload);
        debug_struct.field("payload_type", &self.payload_type);
        debug_struct.field("signatures", &self.signatures);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EnvelopeSignature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnvelopeSignature");
        debug_struct.field("sig", &self.sig);
        debug_struct.field("keyid", &self.keyid);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FileLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FileLocation");
        debug_struct.field("file_path", &self.file_path);
        debug_struct.field("layer_details", &self.layer_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BaseImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BaseImage");
        debug_struct.field("name", &self.name);
        debug_struct.field("repository", &self.repository);
        debug_struct.field("layer_count", &self.layer_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LayerDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LayerDetails");
        debug_struct.field("index", &self.index);
        debug_struct.field("diff_id", &self.diff_id);
        debug_struct.field("chain_id", &self.chain_id);
        debug_struct.field("command", &self.command);
        debug_struct.field("base_images", &self.base_images);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::License {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("License");
        debug_struct.field("expression", &self.expression);
        debug_struct.field("comments", &self.comments);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Digest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Digest");
        debug_struct.field("algo", &self.algo);
        debug_struct.field("digest_bytes", &self.digest_bytes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ComplianceNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComplianceNote");
        debug_struct.field("title", &self.title);
        debug_struct.field("description", &self.description);
        debug_struct.field("version", &self.version);
        debug_struct.field("rationale", &self.rationale);
        debug_struct.field("remediation", &self.remediation);
        debug_struct.field("scan_instructions", &self.scan_instructions);
        debug_struct.field("compliance_type", &self.compliance_type);
        debug_struct.field("potential_impact", &self.potential_impact);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::compliance_note::CisBenchmark {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CisBenchmark");
        debug_struct.field("profile_level", &self.profile_level);
        debug_struct.field("severity", &self.severity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ComplianceVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComplianceVersion");
        debug_struct.field("cpe_uri", &self.cpe_uri);
        debug_struct.field("benchmark_document", &self.benchmark_document);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ComplianceOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComplianceOccurrence");
        debug_struct.field("non_compliant_files", &self.non_compliant_files);
        debug_struct.field("non_compliance_reason", &self.non_compliance_reason);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NonCompliantFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NonCompliantFile");
        debug_struct.field("path", &self.path);
        debug_struct.field("display_command", &self.display_command);
        debug_struct.field("reason", &self.reason);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CVSSv3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CVSSv3");
        debug_struct.field("base_score", &self.base_score);
        debug_struct.field("exploitability_score", &self.exploitability_score);
        debug_struct.field("impact_score", &self.impact_score);
        debug_struct.field("attack_vector", &self.attack_vector);
        debug_struct.field("attack_complexity", &self.attack_complexity);
        debug_struct.field("privileges_required", &self.privileges_required);
        debug_struct.field("user_interaction", &self.user_interaction);
        debug_struct.field("scope", &self.scope);
        debug_struct.field("confidentiality_impact", &self.confidentiality_impact);
        debug_struct.field("integrity_impact", &self.integrity_impact);
        debug_struct.field("availability_impact", &self.availability_impact);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Cvss {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cvss");
        debug_struct.field("base_score", &self.base_score);
        debug_struct.field("exploitability_score", &self.exploitability_score);
        debug_struct.field("impact_score", &self.impact_score);
        debug_struct.field("attack_vector", &self.attack_vector);
        debug_struct.field("attack_complexity", &self.attack_complexity);
        debug_struct.field("authentication", &self.authentication);
        debug_struct.field("privileges_required", &self.privileges_required);
        debug_struct.field("user_interaction", &self.user_interaction);
        debug_struct.field("scope", &self.scope);
        debug_struct.field("confidentiality_impact", &self.confidentiality_impact);
        debug_struct.field("integrity_impact", &self.integrity_impact);
        debug_struct.field("availability_impact", &self.availability_impact);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeploymentNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeploymentNote");
        debug_struct.field("resource_uri", &self.resource_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeploymentOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeploymentOccurrence");
        debug_struct.field("user_email", &self.user_email);
        debug_struct.field("deploy_time", &self.deploy_time);
        debug_struct.field("undeploy_time", &self.undeploy_time);
        debug_struct.field("config", &self.config);
        debug_struct.field("address", &self.address);
        debug_struct.field("resource_uri", &self.resource_uri);
        debug_struct.field("platform", &self.platform);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DiscoveryNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiscoveryNote");
        debug_struct.field("analysis_kind", &self.analysis_kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DiscoveryOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiscoveryOccurrence");
        debug_struct.field("continuous_analysis", &self.continuous_analysis);
        debug_struct.field("analysis_status", &self.analysis_status);
        debug_struct.field("analysis_completed", &self.analysis_completed);
        debug_struct.field("analysis_error", &self.analysis_error);
        debug_struct.field("analysis_status_error", &self.analysis_status_error);
        debug_struct.field("cpe", &self.cpe);
        debug_struct.field("last_scan_time", &self.last_scan_time);
        debug_struct.field("archive_time", &self.archive_time);
        debug_struct.field("sbom_status", &self.sbom_status);
        debug_struct.field("vulnerability_attestation", &self.vulnerability_attestation);
        debug_struct.field("files", &self.files);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::discovery_occurrence::AnalysisCompleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalysisCompleted");
        debug_struct.field("analysis_type", &self.analysis_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::discovery_occurrence::SBOMStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SBOMStatus");
        debug_struct.field("sbom_state", &self.sbom_state);
        debug_struct.field("error", &self.error);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::discovery_occurrence::VulnerabilityAttestation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VulnerabilityAttestation");
        debug_struct.field("last_attempt_time", &self.last_attempt_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::discovery_occurrence::File {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("File");
        debug_struct.field("name", &self.name);
        debug_struct.field("digest", &self.digest);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DSSEAttestationNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DSSEAttestationNote");
        debug_struct.field("hint", &self.hint);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::dsse_attestation_note::DSSEHint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DSSEHint");
        debug_struct.field("human_readable_name", &self.human_readable_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DSSEAttestationOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DSSEAttestationOccurrence");
        debug_struct.field("envelope", &self.envelope);
        debug_struct.field("decoded_payload", &self.decoded_payload);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Occurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Occurrence");
        debug_struct.field("name", &self.name);
        debug_struct.field("resource_uri", &self.resource_uri);
        debug_struct.field("note_name", &self.note_name);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("remediation", &self.remediation);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("envelope", &self.envelope);
        debug_struct.field("details", &self.details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Note {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Note");
        debug_struct.field("name", &self.name);
        debug_struct.field("short_description", &self.short_description);
        debug_struct.field("long_description", &self.long_description);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("related_url", &self.related_url);
        debug_struct.field("expiration_time", &self.expiration_time);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("related_note_names", &self.related_note_names);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetOccurrenceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetOccurrenceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListOccurrencesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOccurrencesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("return_partial_success", &self.return_partial_success);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListOccurrencesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOccurrencesResponse");
        debug_struct.field("occurrences", &self.occurrences);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteOccurrenceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteOccurrenceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateOccurrenceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateOccurrenceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("occurrence", &self.occurrence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateOccurrenceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateOccurrenceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("occurrence", &self.occurrence);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetNoteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetNoteRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetOccurrenceNoteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetOccurrenceNoteRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListNotesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNotesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("return_partial_success", &self.return_partial_success);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListNotesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNotesResponse");
        debug_struct.field("notes", &self.notes);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteNoteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteNoteRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateNoteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateNoteRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("note_id", &self.note_id);
        debug_struct.field("note", &self.note);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateNoteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateNoteRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("note", &self.note);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListNoteOccurrencesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNoteOccurrencesRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListNoteOccurrencesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNoteOccurrencesResponse");
        debug_struct.field("occurrences", &self.occurrences);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchCreateNotesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchCreateNotesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("notes", &self.notes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchCreateNotesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchCreateNotesResponse");
        debug_struct.field("notes", &self.notes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchCreateOccurrencesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchCreateOccurrencesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("occurrences", &self.occurrences);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchCreateOccurrencesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchCreateOccurrencesResponse");
        debug_struct.field("occurrences", &self.occurrences);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Layer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Layer");
        debug_struct.field("directive", &self.directive);
        debug_struct.field("arguments", &self.arguments);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Fingerprint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Fingerprint");
        debug_struct.field("v1_name", &self.v1_name);
        debug_struct.field("v2_blob", &self.v2_blob);
        debug_struct.field("v2_name", &self.v2_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ImageNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageNote");
        debug_struct.field("resource_url", &self.resource_url);
        debug_struct.field("fingerprint", &self.fingerprint);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ImageOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageOccurrence");
        debug_struct.field("fingerprint", &self.fingerprint);
        debug_struct.field("distance", &self.distance);
        debug_struct.field("layer_info", &self.layer_info);
        debug_struct.field("base_resource_url", &self.base_resource_url);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Recipe {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Recipe");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("defined_in_material", &self.defined_in_material);
        debug_struct.field("entry_point", &self.entry_point);
        debug_struct.field("arguments", &self.arguments);
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Completeness {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Completeness");
        debug_struct.field("arguments", &self.arguments);
        debug_struct.field("environment", &self.environment);
        debug_struct.field("materials", &self.materials);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Metadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Metadata");
        debug_struct.field("build_invocation_id", &self.build_invocation_id);
        debug_struct.field("build_started_on", &self.build_started_on);
        debug_struct.field("build_finished_on", &self.build_finished_on);
        debug_struct.field("completeness", &self.completeness);
        debug_struct.field("reproducible", &self.reproducible);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuilderConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuilderConfig");
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InTotoProvenance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InTotoProvenance");
        debug_struct.field("builder_config", &self.builder_config);
        debug_struct.field("recipe", &self.recipe);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("materials", &self.materials);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InTotoStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InTotoStatement");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("subject", &self.subject);
        debug_struct.field("predicate_type", &self.predicate_type);
        debug_struct.field("predicate", &self.predicate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Subject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Subject");
        debug_struct.field("name", &self.name);
        debug_struct.field("digest", &self.digest);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InTotoSlsaProvenanceV1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InTotoSlsaProvenanceV1");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("subject", &self.subject);
        debug_struct.field("predicate_type", &self.predicate_type);
        debug_struct.field("predicate", &self.predicate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::in_toto_slsa_provenance_v_1::SlsaProvenanceV1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaProvenanceV1");
        debug_struct.field("build_definition", &self.build_definition);
        debug_struct.field("run_details", &self.run_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::in_toto_slsa_provenance_v_1::BuildDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildDefinition");
        debug_struct.field("build_type", &self.build_type);
        debug_struct.field("external_parameters", &self.external_parameters);
        debug_struct.field("internal_parameters", &self.internal_parameters);
        debug_struct.field("resolved_dependencies", &self.resolved_dependencies);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::in_toto_slsa_provenance_v_1::ResourceDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceDescriptor");
        debug_struct.field("name", &self.name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("digest", &self.digest);
        debug_struct.field("content", &self.content);
        debug_struct.field("download_location", &self.download_location);
        debug_struct.field("media_type", &self.media_type);
        debug_struct.field("annotations", &self.annotations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::in_toto_slsa_provenance_v_1::RunDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunDetails");
        debug_struct.field("builder", &self.builder);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("byproducts", &self.byproducts);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::in_toto_slsa_provenance_v_1::ProvenanceBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProvenanceBuilder");
        debug_struct.field("id", &self.id);
        debug_struct.field("version", &self.version);
        debug_struct.field("builder_dependencies", &self.builder_dependencies);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::in_toto_slsa_provenance_v_1::BuildMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildMetadata");
        debug_struct.field("invocation_id", &self.invocation_id);
        debug_struct.field("started_on", &self.started_on);
        debug_struct.field("finished_on", &self.finished_on);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Distribution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Distribution");
        debug_struct.field("cpe_uri", &self.cpe_uri);
        debug_struct.field("architecture", &self.architecture);
        debug_struct.field("latest_version", &self.latest_version);
        debug_struct.field("maintainer", &self.maintainer);
        debug_struct.field("url", &self.url);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Location {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Location");
        debug_struct.field("cpe_uri", &self.cpe_uri);
        debug_struct.field("version", &self.version);
        debug_struct.field("path", &self.path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PackageNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PackageNote");
        debug_struct.field("name", &self.name);
        debug_struct.field("distribution", &self.distribution);
        debug_struct.field("package_type", &self.package_type);
        debug_struct.field("cpe_uri", &self.cpe_uri);
        debug_struct.field("architecture", &self.architecture);
        debug_struct.field("version", &self.version);
        debug_struct.field("maintainer", &self.maintainer);
        debug_struct.field("url", &self.url);
        debug_struct.field("description", &self.description);
        debug_struct.field("license", &self.license);
        debug_struct.field("digest", &self.digest);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PackageOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PackageOccurrence");
        debug_struct.field("name", &self.name);
        debug_struct.field("location", &self.location);
        debug_struct.field("package_type", &self.package_type);
        debug_struct.field("cpe_uri", &self.cpe_uri);
        debug_struct.field("architecture", &self.architecture);
        debug_struct.field("license", &self.license);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Version");
        debug_struct.field("epoch", &self.epoch);
        debug_struct.field("name", &self.name);
        debug_struct.field("revision", &self.revision);
        debug_struct.field("inclusive", &self.inclusive);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("full_name", &self.full_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuildProvenance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildProvenance");
        debug_struct.field("id", &self.id);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("commands", &self.commands);
        debug_struct.field("built_artifacts", &self.built_artifacts);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("creator", &self.creator);
        debug_struct.field("logs_uri", &self.logs_uri);
        debug_struct.field("source_provenance", &self.source_provenance);
        debug_struct.field("trigger_id", &self.trigger_id);
        debug_struct.field("build_options", &self.build_options);
        debug_struct.field("builder_version", &self.builder_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Source {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Source");
        debug_struct.field(
            "artifact_storage_source_uri",
            &self.artifact_storage_source_uri,
        );
        debug_struct.field("file_hashes", &self.file_hashes);
        debug_struct.field("context", &self.context);
        debug_struct.field("additional_contexts", &self.additional_contexts);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FileHashes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FileHashes");
        debug_struct.field("file_hash", &self.file_hash);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Hash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Hash");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Command {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Command");
        debug_struct.field("name", &self.name);
        debug_struct.field("env", &self.env);
        debug_struct.field("args", &self.args);
        debug_struct.field("dir", &self.dir);
        debug_struct.field("id", &self.id);
        debug_struct.field("wait_for", &self.wait_for);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Artifact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Artifact");
        debug_struct.field("checksum", &self.checksum);
        debug_struct.field("id", &self.id);
        debug_struct.field("names", &self.names);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SourceContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceContext");
        debug_struct.field("labels", &self.labels);
        debug_struct.field("context", &self.context);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AliasContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AliasContext");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloudRepoSourceContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudRepoSourceContext");
        debug_struct.field("repo_id", &self.repo_id);
        debug_struct.field("revision", &self.revision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GerritSourceContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GerritSourceContext");
        debug_struct.field("host_uri", &self.host_uri);
        debug_struct.field("gerrit_project", &self.gerrit_project);
        debug_struct.field("revision", &self.revision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitSourceContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitSourceContext");
        debug_struct.field("url", &self.url);
        debug_struct.field("revision_id", &self.revision_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RepoId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepoId");
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ProjectRepoId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProjectRepoId");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("repo_name", &self.repo_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Risk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Risk");
        debug_struct.field("cisa_kev", &self.cisa_kev);
        debug_struct.field("epss", &self.epss);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CISAKnownExploitedVulnerabilities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CISAKnownExploitedVulnerabilities");
        debug_struct.field(
            "known_ransomware_campaign_use",
            &self.known_ransomware_campaign_use,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExploitPredictionScoringSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExploitPredictionScoringSystem");
        debug_struct.field("percentile", &self.percentile);
        debug_struct.field("score", &self.score);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SBOMReferenceNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SBOMReferenceNote");
        debug_struct.field("format", &self.format);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SBOMReferenceOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SBOMReferenceOccurrence");
        debug_struct.field("payload", &self.payload);
        debug_struct.field("payload_type", &self.payload_type);
        debug_struct.field("signatures", &self.signatures);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SbomReferenceIntotoPayload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SbomReferenceIntotoPayload");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("predicate_type", &self.predicate_type);
        debug_struct.field("subject", &self.subject);
        debug_struct.field("predicate", &self.predicate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SbomReferenceIntotoPredicate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SbomReferenceIntotoPredicate");
        debug_struct.field("referrer_id", &self.referrer_id);
        debug_struct.field("location", &self.location);
        debug_struct.field("mime_type", &self.mime_type);
        debug_struct.field("digest", &self.digest);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecretNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretNote");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecretOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretOccurrence");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("locations", &self.locations);
        debug_struct.field("statuses", &self.statuses);
        debug_struct.field("data", &self.data);
        debug_struct.field("digest", &self.digest);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecretLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretLocation");
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecretStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretStatus");
        debug_struct.field("status", &self.status);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("message", &self.message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SlsaProvenance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaProvenance");
        debug_struct.field("builder", &self.builder);
        debug_struct.field("recipe", &self.recipe);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("materials", &self.materials);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::slsa_provenance::SlsaRecipe {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaRecipe");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("defined_in_material", &self.defined_in_material);
        debug_struct.field("entry_point", &self.entry_point);
        debug_struct.field("arguments", &self.arguments);
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::slsa_provenance::SlsaCompleteness {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaCompleteness");
        debug_struct.field("arguments", &self.arguments);
        debug_struct.field("environment", &self.environment);
        debug_struct.field("materials", &self.materials);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::slsa_provenance::SlsaMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaMetadata");
        debug_struct.field("build_invocation_id", &self.build_invocation_id);
        debug_struct.field("build_started_on", &self.build_started_on);
        debug_struct.field("build_finished_on", &self.build_finished_on);
        debug_struct.field("completeness", &self.completeness);
        debug_struct.field("reproducible", &self.reproducible);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::slsa_provenance::SlsaBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaBuilder");
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::slsa_provenance::Material {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Material");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("digest", &self.digest);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SlsaProvenanceZeroTwo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaProvenanceZeroTwo");
        debug_struct.field("builder", &self.builder);
        debug_struct.field("build_type", &self.build_type);
        debug_struct.field("invocation", &self.invocation);
        debug_struct.field("build_config", &self.build_config);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("materials", &self.materials);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::slsa_provenance_zero_two::SlsaBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaBuilder");
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::slsa_provenance_zero_two::SlsaMaterial {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaMaterial");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("digest", &self.digest);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::slsa_provenance_zero_two::SlsaInvocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaInvocation");
        debug_struct.field("config_source", &self.config_source);
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::slsa_provenance_zero_two::SlsaConfigSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaConfigSource");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("digest", &self.digest);
        debug_struct.field("entry_point", &self.entry_point);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::slsa_provenance_zero_two::SlsaMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaMetadata");
        debug_struct.field("build_invocation_id", &self.build_invocation_id);
        debug_struct.field("build_started_on", &self.build_started_on);
        debug_struct.field("build_finished_on", &self.build_finished_on);
        debug_struct.field("completeness", &self.completeness);
        debug_struct.field("reproducible", &self.reproducible);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::slsa_provenance_zero_two::SlsaCompleteness {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SlsaCompleteness");
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("environment", &self.environment);
        debug_struct.field("materials", &self.materials);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpgradeNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeNote");
        debug_struct.field("package", &self.package);
        debug_struct.field("version", &self.version);
        debug_struct.field("distributions", &self.distributions);
        debug_struct.field("windows_update", &self.windows_update);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpgradeDistribution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeDistribution");
        debug_struct.field("cpe_uri", &self.cpe_uri);
        debug_struct.field("classification", &self.classification);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("cve", &self.cve);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WindowsUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WindowsUpdate");
        debug_struct.field("identity", &self.identity);
        debug_struct.field("title", &self.title);
        debug_struct.field("description", &self.description);
        debug_struct.field("categories", &self.categories);
        debug_struct.field("kb_article_ids", &self.kb_article_ids);
        debug_struct.field("support_url", &self.support_url);
        debug_struct.field("last_published_timestamp", &self.last_published_timestamp);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::windows_update::Identity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Identity");
        debug_struct.field("update_id", &self.update_id);
        debug_struct.field("revision", &self.revision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::windows_update::Category {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Category");
        debug_struct.field("category_id", &self.category_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpgradeOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeOccurrence");
        debug_struct.field("package", &self.package);
        debug_struct.field("parsed_version", &self.parsed_version);
        debug_struct.field("distribution", &self.distribution);
        debug_struct.field("windows_update", &self.windows_update);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VulnerabilityAssessmentNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VulnerabilityAssessmentNote");
        debug_struct.field("title", &self.title);
        debug_struct.field("short_description", &self.short_description);
        debug_struct.field("long_description", &self.long_description);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("publisher", &self.publisher);
        debug_struct.field("product", &self.product);
        debug_struct.field("assessment", &self.assessment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vulnerability_assessment_note::Publisher {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Publisher");
        debug_struct.field("name", &self.name);
        debug_struct.field("issuing_authority", &self.issuing_authority);
        debug_struct.field("publisher_namespace", &self.publisher_namespace);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vulnerability_assessment_note::Product {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Product");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);
        debug_struct.field("identifier", &self.identifier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vulnerability_assessment_note::Assessment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Assessment");
        debug_struct.field("cve", &self.cve);
        debug_struct.field("vulnerability_id", &self.vulnerability_id);
        debug_struct.field("short_description", &self.short_description);
        debug_struct.field("long_description", &self.long_description);
        debug_struct.field("related_uris", &self.related_uris);
        debug_struct.field("state", &self.state);
        debug_struct.field("impacts", &self.impacts);
        debug_struct.field("justification", &self.justification);
        debug_struct.field("remediations", &self.remediations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vulnerability_assessment_note::assessment::Justification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Justification");
        debug_struct.field("justification_type", &self.justification_type);
        debug_struct.field("details", &self.details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vulnerability_assessment_note::assessment::Remediation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Remediation");
        debug_struct.field("remediation_type", &self.remediation_type);
        debug_struct.field("details", &self.details);
        debug_struct.field("remediation_uri", &self.remediation_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VulnerabilityNote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VulnerabilityNote");
        debug_struct.field("cvss_score", &self.cvss_score);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("details", &self.details);
        debug_struct.field("cvss_v3", &self.cvss_v3);
        debug_struct.field("windows_details", &self.windows_details);
        debug_struct.field("source_update_time", &self.source_update_time);
        debug_struct.field("cvss_version", &self.cvss_version);
        debug_struct.field("cvss_v2", &self.cvss_v2);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vulnerability_note::Detail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Detail");
        debug_struct.field("severity_name", &self.severity_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("package_type", &self.package_type);
        debug_struct.field("affected_cpe_uri", &self.affected_cpe_uri);
        debug_struct.field("affected_package", &self.affected_package);
        debug_struct.field("affected_version_start", &self.affected_version_start);
        debug_struct.field("affected_version_end", &self.affected_version_end);
        debug_struct.field("fixed_cpe_uri", &self.fixed_cpe_uri);
        debug_struct.field("fixed_package", &self.fixed_package);
        debug_struct.field("fixed_version", &self.fixed_version);
        debug_struct.field("is_obsolete", &self.is_obsolete);
        debug_struct.field("source_update_time", &self.source_update_time);
        debug_struct.field("source", &self.source);
        debug_struct.field("vendor", &self.vendor);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vulnerability_note::WindowsDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WindowsDetail");
        debug_struct.field("cpe_uri", &self.cpe_uri);
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("fixing_kbs", &self.fixing_kbs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vulnerability_note::windows_detail::KnowledgeBase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KnowledgeBase");
        debug_struct.field("name", &self.name);
        debug_struct.field("url", &self.url);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VulnerabilityOccurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VulnerabilityOccurrence");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("cvss_score", &self.cvss_score);
        debug_struct.field("cvssv3", &self.cvssv3);
        debug_struct.field("package_issue", &self.package_issue);
        debug_struct.field("short_description", &self.short_description);
        debug_struct.field("long_description", &self.long_description);
        debug_struct.field("related_urls", &self.related_urls);
        debug_struct.field("effective_severity", &self.effective_severity);
        debug_struct.field("fix_available", &self.fix_available);
        debug_struct.field("cvss_version", &self.cvss_version);
        debug_struct.field("cvss_v2", &self.cvss_v2);
        debug_struct.field("vex_assessment", &self.vex_assessment);
        debug_struct.field("extra_details", &self.extra_details);
        debug_struct.field("risk", &self.risk);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vulnerability_occurrence::PackageIssue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PackageIssue");
        debug_struct.field("affected_cpe_uri", &self.affected_cpe_uri);
        debug_struct.field("affected_package", &self.affected_package);
        debug_struct.field("affected_version", &self.affected_version);
        debug_struct.field("fixed_cpe_uri", &self.fixed_cpe_uri);
        debug_struct.field("fixed_package", &self.fixed_package);
        debug_struct.field("fixed_version", &self.fixed_version);
        debug_struct.field("fix_available", &self.fix_available);
        debug_struct.field("package_type", &self.package_type);
        debug_struct.field("effective_severity", &self.effective_severity);
        debug_struct.field("file_location", &self.file_location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vulnerability_occurrence::VexAssessment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VexAssessment");
        debug_struct.field("cve", &self.cve);
        debug_struct.field("vulnerability_id", &self.vulnerability_id);
        debug_struct.field("related_uris", &self.related_uris);
        debug_struct.field("note_name", &self.note_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("impacts", &self.impacts);
        debug_struct.field("remediations", &self.remediations);
        debug_struct.field("justification", &self.justification);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
