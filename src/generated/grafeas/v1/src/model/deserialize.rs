// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AttestationNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttestationNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hint" => Ok(__FieldTag::__hint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AttestationNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttestationNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hint => {
                            if !fields.insert(__FieldTag::__hint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hint",
                                ));
                            }
                            result.hint = map.next_value::<std::option::Option<crate::model::attestation_note::Hint>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::attestation_note::Hint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __human_readable_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Hint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "humanReadableName" => Ok(__FieldTag::__human_readable_name),
                            "human_readable_name" => Ok(__FieldTag::__human_readable_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::attestation_note::Hint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Hint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__human_readable_name => {
                            if !fields.insert(__FieldTag::__human_readable_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for human_readable_name",
                                ));
                            }
                            result.human_readable_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Jwt {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compact_jwt,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Jwt")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "compactJwt" => Ok(__FieldTag::__compact_jwt),
                            "compact_jwt" => Ok(__FieldTag::__compact_jwt),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Jwt;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Jwt")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compact_jwt => {
                            if !fields.insert(__FieldTag::__compact_jwt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compact_jwt",
                                ));
                            }
                            result.compact_jwt = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AttestationOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __serialized_payload,
            __signatures,
            __jwts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttestationOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serializedPayload" => Ok(__FieldTag::__serialized_payload),
                            "serialized_payload" => Ok(__FieldTag::__serialized_payload),
                            "signatures" => Ok(__FieldTag::__signatures),
                            "jwts" => Ok(__FieldTag::__jwts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AttestationOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttestationOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__serialized_payload => {
                            if !fields.insert(__FieldTag::__serialized_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serialized_payload",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.serialized_payload =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__signatures => {
                            if !fields.insert(__FieldTag::__signatures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signatures",
                                ));
                            }
                            result.signatures = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Signature>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jwts => {
                            if !fields.insert(__FieldTag::__jwts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jwts",
                                ));
                            }
                            result.jwts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Jwt>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BuildNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __builder_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "builderVersion" => Ok(__FieldTag::__builder_version),
                            "builder_version" => Ok(__FieldTag::__builder_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BuildNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__builder_version => {
                            if !fields.insert(__FieldTag::__builder_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder_version",
                                ));
                            }
                            result.builder_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BuildOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __provenance,
            __provenance_bytes,
            __intoto_provenance,
            __intoto_statement,
            __in_toto_slsa_provenance_v1,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "provenance" => Ok(__FieldTag::__provenance),
                            "provenanceBytes" => Ok(__FieldTag::__provenance_bytes),
                            "provenance_bytes" => Ok(__FieldTag::__provenance_bytes),
                            "intotoProvenance" => Ok(__FieldTag::__intoto_provenance),
                            "intoto_provenance" => Ok(__FieldTag::__intoto_provenance),
                            "intotoStatement" => Ok(__FieldTag::__intoto_statement),
                            "intoto_statement" => Ok(__FieldTag::__intoto_statement),
                            "inTotoSlsaProvenanceV1" => {
                                Ok(__FieldTag::__in_toto_slsa_provenance_v1)
                            }
                            "in_toto_slsa_provenance_v1" => {
                                Ok(__FieldTag::__in_toto_slsa_provenance_v1)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BuildOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__provenance => {
                            if !fields.insert(__FieldTag::__provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provenance",
                                ));
                            }
                            result.provenance = map
                                .next_value::<std::option::Option<crate::model::BuildProvenance>>(
                                )?;
                        }
                        __FieldTag::__provenance_bytes => {
                            if !fields.insert(__FieldTag::__provenance_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provenance_bytes",
                                ));
                            }
                            result.provenance_bytes = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intoto_provenance => {
                            if !fields.insert(__FieldTag::__intoto_provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intoto_provenance",
                                ));
                            }
                            result.intoto_provenance = map
                                .next_value::<std::option::Option<crate::model::InTotoProvenance>>(
                                )?;
                        }
                        __FieldTag::__intoto_statement => {
                            if !fields.insert(__FieldTag::__intoto_statement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intoto_statement",
                                ));
                            }
                            result.intoto_statement = map
                                .next_value::<std::option::Option<crate::model::InTotoStatement>>(
                                )?;
                        }
                        __FieldTag::__in_toto_slsa_provenance_v1 => {
                            if !fields.insert(__FieldTag::__in_toto_slsa_provenance_v1) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for in_toto_slsa_provenance_v1",
                                ));
                            }
                            result.in_toto_slsa_provenance_v1 = map.next_value::<std::option::Option<crate::model::InTotoSlsaProvenanceV1>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RelatedUrl {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __label,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelatedUrl")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "label" => Ok(__FieldTag::__label),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RelatedUrl;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelatedUrl")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Signature {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __signature,
            __public_key_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Signature")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "signature" => Ok(__FieldTag::__signature),
                            "publicKeyId" => Ok(__FieldTag::__public_key_id),
                            "public_key_id" => Ok(__FieldTag::__public_key_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Signature;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Signature")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__signature => {
                            if !fields.insert(__FieldTag::__signature) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signature",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.signature = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__public_key_id => {
                            if !fields.insert(__FieldTag::__public_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key_id",
                                ));
                            }
                            result.public_key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Envelope {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __payload,
            __payload_type,
            __signatures,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Envelope")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "payload" => Ok(__FieldTag::__payload),
                            "payloadType" => Ok(__FieldTag::__payload_type),
                            "payload_type" => Ok(__FieldTag::__payload_type),
                            "signatures" => Ok(__FieldTag::__signatures),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Envelope;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Envelope")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.payload = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__payload_type => {
                            if !fields.insert(__FieldTag::__payload_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload_type",
                                ));
                            }
                            result.payload_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__signatures => {
                            if !fields.insert(__FieldTag::__signatures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signatures",
                                ));
                            }
                            result.signatures =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EnvelopeSignature>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EnvelopeSignature {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sig,
            __keyid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnvelopeSignature")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sig" => Ok(__FieldTag::__sig),
                            "keyid" => Ok(__FieldTag::__keyid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EnvelopeSignature;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnvelopeSignature")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sig => {
                            if !fields.insert(__FieldTag::__sig) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sig",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sig = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__keyid => {
                            if !fields.insert(__FieldTag::__keyid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keyid",
                                ));
                            }
                            result.keyid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FileLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_path,
            __layer_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filePath" => Ok(__FieldTag::__file_path),
                            "file_path" => Ok(__FieldTag::__file_path),
                            "layerDetails" => Ok(__FieldTag::__layer_details),
                            "layer_details" => Ok(__FieldTag::__layer_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FileLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_path => {
                            if !fields.insert(__FieldTag::__file_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_path",
                                ));
                            }
                            result.file_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__layer_details => {
                            if !fields.insert(__FieldTag::__layer_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for layer_details",
                                ));
                            }
                            result.layer_details = map
                                .next_value::<std::option::Option<crate::model::LayerDetails>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BaseImage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __repository,
            __layer_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BaseImage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "repository" => Ok(__FieldTag::__repository),
                            "layerCount" => Ok(__FieldTag::__layer_count),
                            "layer_count" => Ok(__FieldTag::__layer_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BaseImage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BaseImage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            result.repository = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__layer_count => {
                            if !fields.insert(__FieldTag::__layer_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for layer_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.layer_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LayerDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __index,
            __diff_id,
            __chain_id,
            __command,
            __base_images,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LayerDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "index" => Ok(__FieldTag::__index),
                            "diffId" => Ok(__FieldTag::__diff_id),
                            "diff_id" => Ok(__FieldTag::__diff_id),
                            "chainId" => Ok(__FieldTag::__chain_id),
                            "chain_id" => Ok(__FieldTag::__chain_id),
                            "command" => Ok(__FieldTag::__command),
                            "baseImages" => Ok(__FieldTag::__base_images),
                            "base_images" => Ok(__FieldTag::__base_images),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LayerDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LayerDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.index = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__diff_id => {
                            if !fields.insert(__FieldTag::__diff_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diff_id",
                                ));
                            }
                            result.diff_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__chain_id => {
                            if !fields.insert(__FieldTag::__chain_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for chain_id",
                                ));
                            }
                            result.chain_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__command => {
                            if !fields.insert(__FieldTag::__command) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for command",
                                ));
                            }
                            result.command = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__base_images => {
                            if !fields.insert(__FieldTag::__base_images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_images",
                                ));
                            }
                            result.base_images = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BaseImage>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::License {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __expression,
            __comments,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for License")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "expression" => Ok(__FieldTag::__expression),
                            "comments" => Ok(__FieldTag::__comments),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::License;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct License")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__expression => {
                            if !fields.insert(__FieldTag::__expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expression",
                                ));
                            }
                            result.expression = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__comments => {
                            if !fields.insert(__FieldTag::__comments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for comments",
                                ));
                            }
                            result.comments = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Digest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __algo,
            __digest_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Digest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "algo" => Ok(__FieldTag::__algo),
                            "digestBytes" => Ok(__FieldTag::__digest_bytes),
                            "digest_bytes" => Ok(__FieldTag::__digest_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Digest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Digest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__algo => {
                            if !fields.insert(__FieldTag::__algo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for algo",
                                ));
                            }
                            result.algo = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest_bytes => {
                            if !fields.insert(__FieldTag::__digest_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.digest_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ComplianceNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __description,
            __version,
            __rationale,
            __remediation,
            __cis_benchmark,
            __scan_instructions,
            __impact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "description" => Ok(__FieldTag::__description),
                            "version" => Ok(__FieldTag::__version),
                            "rationale" => Ok(__FieldTag::__rationale),
                            "remediation" => Ok(__FieldTag::__remediation),
                            "cisBenchmark" => Ok(__FieldTag::__cis_benchmark),
                            "cis_benchmark" => Ok(__FieldTag::__cis_benchmark),
                            "scanInstructions" => Ok(__FieldTag::__scan_instructions),
                            "scan_instructions" => Ok(__FieldTag::__scan_instructions),
                            "impact" => Ok(__FieldTag::__impact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ComplianceNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ComplianceVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rationale => {
                            if !fields.insert(__FieldTag::__rationale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rationale",
                                ));
                            }
                            result.rationale = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remediation => {
                            if !fields.insert(__FieldTag::__remediation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remediation",
                                ));
                            }
                            result.remediation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cis_benchmark => {
                            if !fields.insert(__FieldTag::__cis_benchmark) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cis_benchmark",
                                ));
                            }
                            if result.compliance_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compliance_type`, a oneof with full ID .grafeas.v1.ComplianceNote.cis_benchmark, latest field was cisBenchmark",
                                ));
                            }
                            result.compliance_type = std::option::Option::Some(
                                crate::model::compliance_note::ComplianceType::CisBenchmark(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::compliance_note::CisBenchmark,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__scan_instructions => {
                            if !fields.insert(__FieldTag::__scan_instructions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scan_instructions",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scan_instructions =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__impact => {
                            if !fields.insert(__FieldTag::__impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for impact",
                                ));
                            }
                            if result.potential_impact.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `potential_impact`, a oneof with full ID .grafeas.v1.ComplianceNote.impact, latest field was impact",
                                ));
                            }
                            result.potential_impact = std::option::Option::Some(
                                crate::model::compliance_note::PotentialImpact::Impact(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::compliance_note::CisBenchmark {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __profile_level,
            __severity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CisBenchmark")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "profileLevel" => Ok(__FieldTag::__profile_level),
                            "profile_level" => Ok(__FieldTag::__profile_level),
                            "severity" => Ok(__FieldTag::__severity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::compliance_note::CisBenchmark;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CisBenchmark")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__profile_level => {
                            if !fields.insert(__FieldTag::__profile_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile_level",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.profile_level =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ComplianceVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpe_uri,
            __benchmark_document,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "benchmarkDocument" => Ok(__FieldTag::__benchmark_document),
                            "benchmark_document" => Ok(__FieldTag::__benchmark_document),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ComplianceVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__benchmark_document => {
                            if !fields.insert(__FieldTag::__benchmark_document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for benchmark_document",
                                ));
                            }
                            result.benchmark_document = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ComplianceOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __non_compliant_files,
            __non_compliance_reason,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nonCompliantFiles" => Ok(__FieldTag::__non_compliant_files),
                            "non_compliant_files" => Ok(__FieldTag::__non_compliant_files),
                            "nonComplianceReason" => Ok(__FieldTag::__non_compliance_reason),
                            "non_compliance_reason" => Ok(__FieldTag::__non_compliance_reason),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ComplianceOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__non_compliant_files => {
                            if !fields.insert(__FieldTag::__non_compliant_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for non_compliant_files",
                                ));
                            }
                            result.non_compliant_files =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NonCompliantFile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__non_compliance_reason => {
                            if !fields.insert(__FieldTag::__non_compliance_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for non_compliance_reason",
                                ));
                            }
                            result.non_compliance_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<crate::model::ComplianceVersion>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NonCompliantFile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __display_command,
            __reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NonCompliantFile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "displayCommand" => Ok(__FieldTag::__display_command),
                            "display_command" => Ok(__FieldTag::__display_command),
                            "reason" => Ok(__FieldTag::__reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NonCompliantFile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NonCompliantFile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_command => {
                            if !fields.insert(__FieldTag::__display_command) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_command",
                                ));
                            }
                            result.display_command = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CVSSv3 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_score,
            __exploitability_score,
            __impact_score,
            __attack_vector,
            __attack_complexity,
            __privileges_required,
            __user_interaction,
            __scope,
            __confidentiality_impact,
            __integrity_impact,
            __availability_impact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CVSSv3")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseScore" => Ok(__FieldTag::__base_score),
                            "base_score" => Ok(__FieldTag::__base_score),
                            "exploitabilityScore" => Ok(__FieldTag::__exploitability_score),
                            "exploitability_score" => Ok(__FieldTag::__exploitability_score),
                            "impactScore" => Ok(__FieldTag::__impact_score),
                            "impact_score" => Ok(__FieldTag::__impact_score),
                            "attackVector" => Ok(__FieldTag::__attack_vector),
                            "attack_vector" => Ok(__FieldTag::__attack_vector),
                            "attackComplexity" => Ok(__FieldTag::__attack_complexity),
                            "attack_complexity" => Ok(__FieldTag::__attack_complexity),
                            "privilegesRequired" => Ok(__FieldTag::__privileges_required),
                            "privileges_required" => Ok(__FieldTag::__privileges_required),
                            "userInteraction" => Ok(__FieldTag::__user_interaction),
                            "user_interaction" => Ok(__FieldTag::__user_interaction),
                            "scope" => Ok(__FieldTag::__scope),
                            "confidentialityImpact" => Ok(__FieldTag::__confidentiality_impact),
                            "confidentiality_impact" => Ok(__FieldTag::__confidentiality_impact),
                            "integrityImpact" => Ok(__FieldTag::__integrity_impact),
                            "integrity_impact" => Ok(__FieldTag::__integrity_impact),
                            "availabilityImpact" => Ok(__FieldTag::__availability_impact),
                            "availability_impact" => Ok(__FieldTag::__availability_impact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CVSSv3;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CVSSv3")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_score => {
                            if !fields.insert(__FieldTag::__base_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.base_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__exploitability_score => {
                            if !fields.insert(__FieldTag::__exploitability_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exploitability_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exploitability_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__impact_score => {
                            if !fields.insert(__FieldTag::__impact_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for impact_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.impact_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__attack_vector => {
                            if !fields.insert(__FieldTag::__attack_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_vector",
                                ));
                            }
                            result.attack_vector = map.next_value::<std::option::Option<crate::model::cvs_sv_3::AttackVector>>()?.unwrap_or_default();
                        }
                        __FieldTag::__attack_complexity => {
                            if !fields.insert(__FieldTag::__attack_complexity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_complexity",
                                ));
                            }
                            result.attack_complexity = map.next_value::<std::option::Option<crate::model::cvs_sv_3::AttackComplexity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__privileges_required => {
                            if !fields.insert(__FieldTag::__privileges_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privileges_required",
                                ));
                            }
                            result.privileges_required = map.next_value::<std::option::Option<crate::model::cvs_sv_3::PrivilegesRequired>>()?.unwrap_or_default();
                        }
                        __FieldTag::__user_interaction => {
                            if !fields.insert(__FieldTag::__user_interaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_interaction",
                                ));
                            }
                            result.user_interaction = map.next_value::<std::option::Option<crate::model::cvs_sv_3::UserInteraction>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Scope>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidentiality_impact => {
                            if !fields.insert(__FieldTag::__confidentiality_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidentiality_impact",
                                ));
                            }
                            result.confidentiality_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__integrity_impact => {
                            if !fields.insert(__FieldTag::__integrity_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integrity_impact",
                                ));
                            }
                            result.integrity_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__availability_impact => {
                            if !fields.insert(__FieldTag::__availability_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability_impact",
                                ));
                            }
                            result.availability_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Cvss {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_score,
            __exploitability_score,
            __impact_score,
            __attack_vector,
            __attack_complexity,
            __authentication,
            __privileges_required,
            __user_interaction,
            __scope,
            __confidentiality_impact,
            __integrity_impact,
            __availability_impact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cvss")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseScore" => Ok(__FieldTag::__base_score),
                            "base_score" => Ok(__FieldTag::__base_score),
                            "exploitabilityScore" => Ok(__FieldTag::__exploitability_score),
                            "exploitability_score" => Ok(__FieldTag::__exploitability_score),
                            "impactScore" => Ok(__FieldTag::__impact_score),
                            "impact_score" => Ok(__FieldTag::__impact_score),
                            "attackVector" => Ok(__FieldTag::__attack_vector),
                            "attack_vector" => Ok(__FieldTag::__attack_vector),
                            "attackComplexity" => Ok(__FieldTag::__attack_complexity),
                            "attack_complexity" => Ok(__FieldTag::__attack_complexity),
                            "authentication" => Ok(__FieldTag::__authentication),
                            "privilegesRequired" => Ok(__FieldTag::__privileges_required),
                            "privileges_required" => Ok(__FieldTag::__privileges_required),
                            "userInteraction" => Ok(__FieldTag::__user_interaction),
                            "user_interaction" => Ok(__FieldTag::__user_interaction),
                            "scope" => Ok(__FieldTag::__scope),
                            "confidentialityImpact" => Ok(__FieldTag::__confidentiality_impact),
                            "confidentiality_impact" => Ok(__FieldTag::__confidentiality_impact),
                            "integrityImpact" => Ok(__FieldTag::__integrity_impact),
                            "integrity_impact" => Ok(__FieldTag::__integrity_impact),
                            "availabilityImpact" => Ok(__FieldTag::__availability_impact),
                            "availability_impact" => Ok(__FieldTag::__availability_impact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Cvss;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cvss")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_score => {
                            if !fields.insert(__FieldTag::__base_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.base_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__exploitability_score => {
                            if !fields.insert(__FieldTag::__exploitability_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exploitability_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exploitability_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__impact_score => {
                            if !fields.insert(__FieldTag::__impact_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for impact_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.impact_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__attack_vector => {
                            if !fields.insert(__FieldTag::__attack_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_vector",
                                ));
                            }
                            result.attack_vector = map.next_value::<std::option::Option<crate::model::cvss::AttackVector>>()?.unwrap_or_default();
                        }
                        __FieldTag::__attack_complexity => {
                            if !fields.insert(__FieldTag::__attack_complexity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_complexity",
                                ));
                            }
                            result.attack_complexity = map.next_value::<std::option::Option<crate::model::cvss::AttackComplexity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__authentication => {
                            if !fields.insert(__FieldTag::__authentication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authentication",
                                ));
                            }
                            result.authentication = map.next_value::<std::option::Option<crate::model::cvss::Authentication>>()?.unwrap_or_default();
                        }
                        __FieldTag::__privileges_required => {
                            if !fields.insert(__FieldTag::__privileges_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privileges_required",
                                ));
                            }
                            result.privileges_required = map.next_value::<std::option::Option<crate::model::cvss::PrivilegesRequired>>()?.unwrap_or_default();
                        }
                        __FieldTag::__user_interaction => {
                            if !fields.insert(__FieldTag::__user_interaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_interaction",
                                ));
                            }
                            result.user_interaction = map.next_value::<std::option::Option<crate::model::cvss::UserInteraction>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<crate::model::cvss::Scope>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidentiality_impact => {
                            if !fields.insert(__FieldTag::__confidentiality_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidentiality_impact",
                                ));
                            }
                            result.confidentiality_impact = map
                                .next_value::<std::option::Option<crate::model::cvss::Impact>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__integrity_impact => {
                            if !fields.insert(__FieldTag::__integrity_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integrity_impact",
                                ));
                            }
                            result.integrity_impact = map
                                .next_value::<std::option::Option<crate::model::cvss::Impact>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__availability_impact => {
                            if !fields.insert(__FieldTag::__availability_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability_impact",
                                ));
                            }
                            result.availability_impact = map
                                .next_value::<std::option::Option<crate::model::cvss::Impact>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeploymentNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeploymentNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeploymentNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeploymentNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeploymentOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_email,
            __deploy_time,
            __undeploy_time,
            __config,
            __address,
            __resource_uri,
            __platform,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeploymentOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userEmail" => Ok(__FieldTag::__user_email),
                            "user_email" => Ok(__FieldTag::__user_email),
                            "deployTime" => Ok(__FieldTag::__deploy_time),
                            "deploy_time" => Ok(__FieldTag::__deploy_time),
                            "undeployTime" => Ok(__FieldTag::__undeploy_time),
                            "undeploy_time" => Ok(__FieldTag::__undeploy_time),
                            "config" => Ok(__FieldTag::__config),
                            "address" => Ok(__FieldTag::__address),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "platform" => Ok(__FieldTag::__platform),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeploymentOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeploymentOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_email => {
                            if !fields.insert(__FieldTag::__user_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_email",
                                ));
                            }
                            result.user_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_time => {
                            if !fields.insert(__FieldTag::__deploy_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_time",
                                ));
                            }
                            result.deploy_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__undeploy_time => {
                            if !fields.insert(__FieldTag::__undeploy_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for undeploy_time",
                                ));
                            }
                            result.undeploy_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__address => {
                            if !fields.insert(__FieldTag::__address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for address",
                                ));
                            }
                            result.address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__platform => {
                            if !fields.insert(__FieldTag::__platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for platform",
                                ));
                            }
                            result.platform =
                                map.next_value::<std::option::Option<
                                    crate::model::deployment_occurrence::Platform,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DiscoveryNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analysis_kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analysisKind" => Ok(__FieldTag::__analysis_kind),
                            "analysis_kind" => Ok(__FieldTag::__analysis_kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DiscoveryNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analysis_kind => {
                            if !fields.insert(__FieldTag::__analysis_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_kind",
                                ));
                            }
                            result.analysis_kind = map
                                .next_value::<std::option::Option<crate::model::NoteKind>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DiscoveryOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __continuous_analysis,
            __analysis_status,
            __analysis_completed,
            __analysis_error,
            __analysis_status_error,
            __cpe,
            __last_scan_time,
            __archive_time,
            __sbom_status,
            __vulnerability_attestation,
            __files,
            __last_vulnerability_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "continuousAnalysis" => Ok(__FieldTag::__continuous_analysis),
                            "continuous_analysis" => Ok(__FieldTag::__continuous_analysis),
                            "analysisStatus" => Ok(__FieldTag::__analysis_status),
                            "analysis_status" => Ok(__FieldTag::__analysis_status),
                            "analysisCompleted" => Ok(__FieldTag::__analysis_completed),
                            "analysis_completed" => Ok(__FieldTag::__analysis_completed),
                            "analysisError" => Ok(__FieldTag::__analysis_error),
                            "analysis_error" => Ok(__FieldTag::__analysis_error),
                            "analysisStatusError" => Ok(__FieldTag::__analysis_status_error),
                            "analysis_status_error" => Ok(__FieldTag::__analysis_status_error),
                            "cpe" => Ok(__FieldTag::__cpe),
                            "lastScanTime" => Ok(__FieldTag::__last_scan_time),
                            "last_scan_time" => Ok(__FieldTag::__last_scan_time),
                            "archiveTime" => Ok(__FieldTag::__archive_time),
                            "archive_time" => Ok(__FieldTag::__archive_time),
                            "sbomStatus" => Ok(__FieldTag::__sbom_status),
                            "sbom_status" => Ok(__FieldTag::__sbom_status),
                            "vulnerabilityAttestation" => {
                                Ok(__FieldTag::__vulnerability_attestation)
                            }
                            "vulnerability_attestation" => {
                                Ok(__FieldTag::__vulnerability_attestation)
                            }
                            "files" => Ok(__FieldTag::__files),
                            "lastVulnerabilityUpdateTime" => {
                                Ok(__FieldTag::__last_vulnerability_update_time)
                            }
                            "last_vulnerability_update_time" => {
                                Ok(__FieldTag::__last_vulnerability_update_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DiscoveryOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__continuous_analysis => {
                            if !fields.insert(__FieldTag::__continuous_analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continuous_analysis",
                                ));
                            }
                            result.continuous_analysis = map
                                .next_value::<std::option::Option<
                                    crate::model::discovery_occurrence::ContinuousAnalysis,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__analysis_status => {
                            if !fields.insert(__FieldTag::__analysis_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_status",
                                ));
                            }
                            result.analysis_status = map
                                .next_value::<std::option::Option<
                                    crate::model::discovery_occurrence::AnalysisStatus,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__analysis_completed => {
                            if !fields.insert(__FieldTag::__analysis_completed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_completed",
                                ));
                            }
                            result.analysis_completed = map.next_value::<std::option::Option<
                                crate::model::discovery_occurrence::AnalysisCompleted,
                            >>()?;
                        }
                        __FieldTag::__analysis_error => {
                            if !fields.insert(__FieldTag::__analysis_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_error",
                                ));
                            }
                            result.analysis_error = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__analysis_status_error => {
                            if !fields.insert(__FieldTag::__analysis_status_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_status_error",
                                ));
                            }
                            result.analysis_status_error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__cpe => {
                            if !fields.insert(__FieldTag::__cpe) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe",
                                ));
                            }
                            result.cpe = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_scan_time => {
                            if !fields.insert(__FieldTag::__last_scan_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_scan_time",
                                ));
                            }
                            result.last_scan_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__archive_time => {
                            if !fields.insert(__FieldTag::__archive_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_time",
                                ));
                            }
                            result.archive_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__sbom_status => {
                            if !fields.insert(__FieldTag::__sbom_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sbom_status",
                                ));
                            }
                            result.sbom_status = map.next_value::<std::option::Option<
                                crate::model::discovery_occurrence::SBOMStatus,
                            >>()?;
                        }
                        __FieldTag::__vulnerability_attestation => {
                            if !fields.insert(__FieldTag::__vulnerability_attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability_attestation",
                                ));
                            }
                            result.vulnerability_attestation = map
                                .next_value::<std::option::Option<
                                    crate::model::discovery_occurrence::VulnerabilityAttestation,
                                >>()?;
                        }
                        __FieldTag::__files => {
                            if !fields.insert(__FieldTag::__files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for files",
                                ));
                            }
                            result.files = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::discovery_occurrence::File>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_vulnerability_update_time => {
                            if !fields.insert(__FieldTag::__last_vulnerability_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_vulnerability_update_time",
                                ));
                            }
                            result.last_vulnerability_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::discovery_occurrence::AnalysisCompleted {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analysis_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalysisCompleted")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analysisType" => Ok(__FieldTag::__analysis_type),
                            "analysis_type" => Ok(__FieldTag::__analysis_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::discovery_occurrence::AnalysisCompleted;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalysisCompleted")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analysis_type => {
                            if !fields.insert(__FieldTag::__analysis_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_type",
                                ));
                            }
                            result.analysis_type = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::discovery_occurrence::SBOMStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sbom_state,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SBOMStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sbomState" => Ok(__FieldTag::__sbom_state),
                            "sbom_state" => Ok(__FieldTag::__sbom_state),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::discovery_occurrence::SBOMStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SBOMStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sbom_state => {
                            if !fields.insert(__FieldTag::__sbom_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sbom_state",
                                ));
                            }
                            result.sbom_state = map
                                .next_value::<std::option::Option<
                                    crate::model::discovery_occurrence::sbom_status::SBOMState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::discovery_occurrence::VulnerabilityAttestation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __last_attempt_time,
            __state,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerabilityAttestation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lastAttemptTime" => Ok(__FieldTag::__last_attempt_time),
                            "last_attempt_time" => Ok(__FieldTag::__last_attempt_time),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::discovery_occurrence::VulnerabilityAttestation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerabilityAttestation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__last_attempt_time => {
                            if !fields.insert(__FieldTag::__last_attempt_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_attempt_time",
                                ));
                            }
                            result.last_attempt_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::discovery_occurrence::vulnerability_attestation::VulnerabilityAttestationState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::discovery_occurrence::File {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __digest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for File")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "digest" => Ok(__FieldTag::__digest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::discovery_occurrence::File;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct File")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DSSEAttestationNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DSSEAttestationNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hint" => Ok(__FieldTag::__hint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DSSEAttestationNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DSSEAttestationNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hint => {
                            if !fields.insert(__FieldTag::__hint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hint",
                                ));
                            }
                            result.hint = map.next_value::<std::option::Option<
                                crate::model::dsse_attestation_note::DSSEHint,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::dsse_attestation_note::DSSEHint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __human_readable_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DSSEHint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "humanReadableName" => Ok(__FieldTag::__human_readable_name),
                            "human_readable_name" => Ok(__FieldTag::__human_readable_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::dsse_attestation_note::DSSEHint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DSSEHint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__human_readable_name => {
                            if !fields.insert(__FieldTag::__human_readable_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for human_readable_name",
                                ));
                            }
                            result.human_readable_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DSSEAttestationOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __envelope,
            __statement,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DSSEAttestationOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "envelope" => Ok(__FieldTag::__envelope),
                            "statement" => Ok(__FieldTag::__statement),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DSSEAttestationOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DSSEAttestationOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__envelope => {
                            if !fields.insert(__FieldTag::__envelope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for envelope",
                                ));
                            }
                            result.envelope =
                                map.next_value::<std::option::Option<crate::model::Envelope>>()?;
                        }
                        __FieldTag::__statement => {
                            if !fields.insert(__FieldTag::__statement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statement",
                                ));
                            }
                            if result.decoded_payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `decoded_payload`, a oneof with full ID .grafeas.v1.DSSEAttestationOccurrence.statement, latest field was statement",
                                ));
                            }
                            result.decoded_payload = std::option::Option::Some(
                                crate::model::dsse_attestation_occurrence::DecodedPayload::Statement(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InTotoStatement>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Occurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __resource_uri,
            __note_name,
            __kind,
            __remediation,
            __create_time,
            __update_time,
            __vulnerability,
            __build,
            __image,
            __package,
            __deployment,
            __discovery,
            __attestation,
            __upgrade,
            __compliance,
            __dsse_attestation,
            __sbom_reference,
            __secret,
            __envelope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Occurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "noteName" => Ok(__FieldTag::__note_name),
                            "note_name" => Ok(__FieldTag::__note_name),
                            "kind" => Ok(__FieldTag::__kind),
                            "remediation" => Ok(__FieldTag::__remediation),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "vulnerability" => Ok(__FieldTag::__vulnerability),
                            "build" => Ok(__FieldTag::__build),
                            "image" => Ok(__FieldTag::__image),
                            "package" => Ok(__FieldTag::__package),
                            "deployment" => Ok(__FieldTag::__deployment),
                            "discovery" => Ok(__FieldTag::__discovery),
                            "attestation" => Ok(__FieldTag::__attestation),
                            "upgrade" => Ok(__FieldTag::__upgrade),
                            "compliance" => Ok(__FieldTag::__compliance),
                            "dsseAttestation" => Ok(__FieldTag::__dsse_attestation),
                            "dsse_attestation" => Ok(__FieldTag::__dsse_attestation),
                            "sbomReference" => Ok(__FieldTag::__sbom_reference),
                            "sbom_reference" => Ok(__FieldTag::__sbom_reference),
                            "secret" => Ok(__FieldTag::__secret),
                            "envelope" => Ok(__FieldTag::__envelope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Occurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Occurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__note_name => {
                            if !fields.insert(__FieldTag::__note_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note_name",
                                ));
                            }
                            result.note_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<crate::model::NoteKind>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remediation => {
                            if !fields.insert(__FieldTag::__remediation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remediation",
                                ));
                            }
                            result.remediation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__vulnerability => {
                            if !fields.insert(__FieldTag::__vulnerability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.vulnerability, latest field was vulnerability",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Vulnerability(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VulnerabilityOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.build, latest field was build",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Build(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BuildOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.image, latest field was image",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Image(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ImageOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__package => {
                            if !fields.insert(__FieldTag::__package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.package, latest field was package",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Package(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PackageOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__deployment => {
                            if !fields.insert(__FieldTag::__deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.deployment, latest field was deployment",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Deployment(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeploymentOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__discovery => {
                            if !fields.insert(__FieldTag::__discovery) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.discovery, latest field was discovery",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Discovery(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DiscoveryOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__attestation => {
                            if !fields.insert(__FieldTag::__attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attestation",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.attestation, latest field was attestation",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Attestation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AttestationOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__upgrade => {
                            if !fields.insert(__FieldTag::__upgrade) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.upgrade, latest field was upgrade",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Upgrade(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UpgradeOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__compliance => {
                            if !fields.insert(__FieldTag::__compliance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.compliance, latest field was compliance",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Compliance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ComplianceOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dsse_attestation => {
                            if !fields.insert(__FieldTag::__dsse_attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dsse_attestation",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.dsse_attestation, latest field was dsseAttestation",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::DsseAttestation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DSSEAttestationOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sbom_reference => {
                            if !fields.insert(__FieldTag::__sbom_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sbom_reference",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.sbom_reference, latest field was sbomReference",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::SbomReference(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SBOMReferenceOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .grafeas.v1.Occurrence.secret, latest field was secret",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::occurrence::Details::Secret(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SecretOccurrence>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__envelope => {
                            if !fields.insert(__FieldTag::__envelope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for envelope",
                                ));
                            }
                            result.envelope =
                                map.next_value::<std::option::Option<crate::model::Envelope>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Note {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __short_description,
            __long_description,
            __kind,
            __related_url,
            __expiration_time,
            __create_time,
            __update_time,
            __related_note_names,
            __vulnerability,
            __build,
            __image,
            __package,
            __deployment,
            __discovery,
            __attestation,
            __upgrade,
            __compliance,
            __dsse_attestation,
            __vulnerability_assessment,
            __sbom_reference,
            __secret,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Note")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "shortDescription" => Ok(__FieldTag::__short_description),
                            "short_description" => Ok(__FieldTag::__short_description),
                            "longDescription" => Ok(__FieldTag::__long_description),
                            "long_description" => Ok(__FieldTag::__long_description),
                            "kind" => Ok(__FieldTag::__kind),
                            "relatedUrl" => Ok(__FieldTag::__related_url),
                            "related_url" => Ok(__FieldTag::__related_url),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "relatedNoteNames" => Ok(__FieldTag::__related_note_names),
                            "related_note_names" => Ok(__FieldTag::__related_note_names),
                            "vulnerability" => Ok(__FieldTag::__vulnerability),
                            "build" => Ok(__FieldTag::__build),
                            "image" => Ok(__FieldTag::__image),
                            "package" => Ok(__FieldTag::__package),
                            "deployment" => Ok(__FieldTag::__deployment),
                            "discovery" => Ok(__FieldTag::__discovery),
                            "attestation" => Ok(__FieldTag::__attestation),
                            "upgrade" => Ok(__FieldTag::__upgrade),
                            "compliance" => Ok(__FieldTag::__compliance),
                            "dsseAttestation" => Ok(__FieldTag::__dsse_attestation),
                            "dsse_attestation" => Ok(__FieldTag::__dsse_attestation),
                            "vulnerabilityAssessment" => Ok(__FieldTag::__vulnerability_assessment),
                            "vulnerability_assessment" => {
                                Ok(__FieldTag::__vulnerability_assessment)
                            }
                            "sbomReference" => Ok(__FieldTag::__sbom_reference),
                            "sbom_reference" => Ok(__FieldTag::__sbom_reference),
                            "secret" => Ok(__FieldTag::__secret),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Note;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Note")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__short_description => {
                            if !fields.insert(__FieldTag::__short_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for short_description",
                                ));
                            }
                            result.short_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__long_description => {
                            if !fields.insert(__FieldTag::__long_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_description",
                                ));
                            }
                            result.long_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<crate::model::NoteKind>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__related_url => {
                            if !fields.insert(__FieldTag::__related_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_url",
                                ));
                            }
                            result.related_url = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RelatedUrl>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            result.expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__related_note_names => {
                            if !fields.insert(__FieldTag::__related_note_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_note_names",
                                ));
                            }
                            result.related_note_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__vulnerability => {
                            if !fields.insert(__FieldTag::__vulnerability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.vulnerability, latest field was vulnerability",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Vulnerability(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VulnerabilityNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.build, latest field was build",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Build(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BuildNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.image, latest field was image",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Image(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ImageNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__package => {
                            if !fields.insert(__FieldTag::__package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.package, latest field was package",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Package(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PackageNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__deployment => {
                            if !fields.insert(__FieldTag::__deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.deployment, latest field was deployment",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Deployment(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeploymentNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__discovery => {
                            if !fields.insert(__FieldTag::__discovery) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.discovery, latest field was discovery",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Discovery(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DiscoveryNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__attestation => {
                            if !fields.insert(__FieldTag::__attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attestation",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.attestation, latest field was attestation",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Attestation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AttestationNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__upgrade => {
                            if !fields.insert(__FieldTag::__upgrade) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.upgrade, latest field was upgrade",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Upgrade(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UpgradeNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__compliance => {
                            if !fields.insert(__FieldTag::__compliance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.compliance, latest field was compliance",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Compliance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ComplianceNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__dsse_attestation => {
                            if !fields.insert(__FieldTag::__dsse_attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dsse_attestation",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.dsse_attestation, latest field was dsseAttestation",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::note::Type::DsseAttestation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DSSEAttestationNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vulnerability_assessment => {
                            if !fields.insert(__FieldTag::__vulnerability_assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability_assessment",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.vulnerability_assessment, latest field was vulnerabilityAssessment",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::note::Type::VulnerabilityAssessment(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VulnerabilityAssessmentNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sbom_reference => {
                            if !fields.insert(__FieldTag::__sbom_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sbom_reference",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.sbom_reference, latest field was sbomReference",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::SbomReference(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SBOMReferenceNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .grafeas.v1.Note.secret, latest field was secret",
                                ));
                            }
                            result.r#type =
                                std::option::Option::Some(crate::model::note::Type::Secret(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SecretNote>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetOccurrenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOccurrenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetOccurrenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOccurrenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListOccurrencesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            __return_partial_success,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOccurrencesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "returnPartialSuccess" => Ok(__FieldTag::__return_partial_success),
                            "return_partial_success" => Ok(__FieldTag::__return_partial_success),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListOccurrencesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOccurrencesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__return_partial_success => {
                            if !fields.insert(__FieldTag::__return_partial_success) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_partial_success",
                                ));
                            }
                            result.return_partial_success = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListOccurrencesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __occurrences,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOccurrencesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "occurrences" => Ok(__FieldTag::__occurrences),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListOccurrencesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOccurrencesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__occurrences => {
                            if !fields.insert(__FieldTag::__occurrences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrences",
                                ));
                            }
                            result.occurrences = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Occurrence>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteOccurrenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteOccurrenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteOccurrenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteOccurrenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateOccurrenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __occurrence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateOccurrenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "occurrence" => Ok(__FieldTag::__occurrence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateOccurrenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateOccurrenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__occurrence => {
                            if !fields.insert(__FieldTag::__occurrence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrence",
                                ));
                            }
                            result.occurrence =
                                map.next_value::<std::option::Option<crate::model::Occurrence>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateOccurrenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __occurrence,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateOccurrenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "occurrence" => Ok(__FieldTag::__occurrence),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateOccurrenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateOccurrenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__occurrence => {
                            if !fields.insert(__FieldTag::__occurrence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrence",
                                ));
                            }
                            result.occurrence =
                                map.next_value::<std::option::Option<crate::model::Occurrence>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetNoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetNoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetNoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetOccurrenceNoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOccurrenceNoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetOccurrenceNoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOccurrenceNoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListNotesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            __return_partial_success,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNotesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "returnPartialSuccess" => Ok(__FieldTag::__return_partial_success),
                            "return_partial_success" => Ok(__FieldTag::__return_partial_success),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListNotesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNotesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__return_partial_success => {
                            if !fields.insert(__FieldTag::__return_partial_success) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_partial_success",
                                ));
                            }
                            result.return_partial_success = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListNotesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __notes,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNotesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "notes" => Ok(__FieldTag::__notes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListNotesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNotesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__notes => {
                            if !fields.insert(__FieldTag::__notes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notes",
                                ));
                            }
                            result.notes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Note>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteNoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteNoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteNoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteNoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateNoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __note_id,
            __note,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateNoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "noteId" => Ok(__FieldTag::__note_id),
                            "note_id" => Ok(__FieldTag::__note_id),
                            "note" => Ok(__FieldTag::__note),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateNoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateNoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__note_id => {
                            if !fields.insert(__FieldTag::__note_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note_id",
                                ));
                            }
                            result.note_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__note => {
                            if !fields.insert(__FieldTag::__note) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note",
                                ));
                            }
                            result.note =
                                map.next_value::<std::option::Option<crate::model::Note>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateNoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __note,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateNoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "note" => Ok(__FieldTag::__note),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateNoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateNoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__note => {
                            if !fields.insert(__FieldTag::__note) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note",
                                ));
                            }
                            result.note =
                                map.next_value::<std::option::Option<crate::model::Note>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListNoteOccurrencesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNoteOccurrencesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListNoteOccurrencesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNoteOccurrencesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListNoteOccurrencesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __occurrences,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNoteOccurrencesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "occurrences" => Ok(__FieldTag::__occurrences),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListNoteOccurrencesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNoteOccurrencesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__occurrences => {
                            if !fields.insert(__FieldTag::__occurrences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrences",
                                ));
                            }
                            result.occurrences = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Occurrence>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchCreateNotesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __notes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateNotesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "notes" => Ok(__FieldTag::__notes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchCreateNotesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateNotesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__notes => {
                            if !fields.insert(__FieldTag::__notes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notes",
                                ));
                            }
                            result.notes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::Note,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchCreateNotesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __notes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateNotesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "notes" => Ok(__FieldTag::__notes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchCreateNotesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateNotesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__notes => {
                            if !fields.insert(__FieldTag::__notes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notes",
                                ));
                            }
                            result.notes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Note>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchCreateOccurrencesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __occurrences,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateOccurrencesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "occurrences" => Ok(__FieldTag::__occurrences),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchCreateOccurrencesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateOccurrencesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__occurrences => {
                            if !fields.insert(__FieldTag::__occurrences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrences",
                                ));
                            }
                            result.occurrences = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Occurrence>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchCreateOccurrencesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __occurrences,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateOccurrencesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "occurrences" => Ok(__FieldTag::__occurrences),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchCreateOccurrencesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateOccurrencesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__occurrences => {
                            if !fields.insert(__FieldTag::__occurrences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for occurrences",
                                ));
                            }
                            result.occurrences = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Occurrence>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Layer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __directive,
            __arguments,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Layer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "directive" => Ok(__FieldTag::__directive),
                            "arguments" => Ok(__FieldTag::__arguments),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Layer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Layer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__directive => {
                            if !fields.insert(__FieldTag::__directive) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directive",
                                ));
                            }
                            result.directive = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__arguments => {
                            if !fields.insert(__FieldTag::__arguments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arguments",
                                ));
                            }
                            result.arguments = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Fingerprint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __v1_name,
            __v2_blob,
            __v2_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fingerprint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "v1Name" => Ok(__FieldTag::__v1_name),
                            "v1_name" => Ok(__FieldTag::__v1_name),
                            "v2Blob" => Ok(__FieldTag::__v2_blob),
                            "v2_blob" => Ok(__FieldTag::__v2_blob),
                            "v2Name" => Ok(__FieldTag::__v2_name),
                            "v2_name" => Ok(__FieldTag::__v2_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Fingerprint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fingerprint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__v1_name => {
                            if !fields.insert(__FieldTag::__v1_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for v1_name",
                                ));
                            }
                            result.v1_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__v2_blob => {
                            if !fields.insert(__FieldTag::__v2_blob) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for v2_blob",
                                ));
                            }
                            result.v2_blob = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__v2_name => {
                            if !fields.insert(__FieldTag::__v2_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for v2_name",
                                ));
                            }
                            result.v2_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ImageNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_url,
            __fingerprint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceUrl" => Ok(__FieldTag::__resource_url),
                            "resource_url" => Ok(__FieldTag::__resource_url),
                            "fingerprint" => Ok(__FieldTag::__fingerprint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ImageNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_url => {
                            if !fields.insert(__FieldTag::__resource_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_url",
                                ));
                            }
                            result.resource_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fingerprint => {
                            if !fields.insert(__FieldTag::__fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fingerprint",
                                ));
                            }
                            result.fingerprint =
                                map.next_value::<std::option::Option<crate::model::Fingerprint>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ImageOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fingerprint,
            __distance,
            __layer_info,
            __base_resource_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fingerprint" => Ok(__FieldTag::__fingerprint),
                            "distance" => Ok(__FieldTag::__distance),
                            "layerInfo" => Ok(__FieldTag::__layer_info),
                            "layer_info" => Ok(__FieldTag::__layer_info),
                            "baseResourceUrl" => Ok(__FieldTag::__base_resource_url),
                            "base_resource_url" => Ok(__FieldTag::__base_resource_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ImageOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fingerprint => {
                            if !fields.insert(__FieldTag::__fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fingerprint",
                                ));
                            }
                            result.fingerprint =
                                map.next_value::<std::option::Option<crate::model::Fingerprint>>()?;
                        }
                        __FieldTag::__distance => {
                            if !fields.insert(__FieldTag::__distance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distance",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.distance = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__layer_info => {
                            if !fields.insert(__FieldTag::__layer_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for layer_info",
                                ));
                            }
                            result.layer_info = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Layer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__base_resource_url => {
                            if !fields.insert(__FieldTag::__base_resource_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_resource_url",
                                ));
                            }
                            result.base_resource_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Recipe {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __defined_in_material,
            __entry_point,
            __arguments,
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Recipe")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "definedInMaterial" => Ok(__FieldTag::__defined_in_material),
                            "defined_in_material" => Ok(__FieldTag::__defined_in_material),
                            "entryPoint" => Ok(__FieldTag::__entry_point),
                            "entry_point" => Ok(__FieldTag::__entry_point),
                            "arguments" => Ok(__FieldTag::__arguments),
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Recipe;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Recipe")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__defined_in_material => {
                            if !fields.insert(__FieldTag::__defined_in_material) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for defined_in_material",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.defined_in_material =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__entry_point => {
                            if !fields.insert(__FieldTag::__entry_point) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_point",
                                ));
                            }
                            result.entry_point = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__arguments => {
                            if !fields.insert(__FieldTag::__arguments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arguments",
                                ));
                            }
                            result.arguments = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Any>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Any>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Completeness {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __arguments,
            __environment,
            __materials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Completeness")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "arguments" => Ok(__FieldTag::__arguments),
                            "environment" => Ok(__FieldTag::__environment),
                            "materials" => Ok(__FieldTag::__materials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Completeness;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Completeness")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__arguments => {
                            if !fields.insert(__FieldTag::__arguments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arguments",
                                ));
                            }
                            result.arguments = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__materials => {
                            if !fields.insert(__FieldTag::__materials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materials",
                                ));
                            }
                            result.materials = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Metadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build_invocation_id,
            __build_started_on,
            __build_finished_on,
            __completeness,
            __reproducible,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Metadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buildInvocationId" => Ok(__FieldTag::__build_invocation_id),
                            "build_invocation_id" => Ok(__FieldTag::__build_invocation_id),
                            "buildStartedOn" => Ok(__FieldTag::__build_started_on),
                            "build_started_on" => Ok(__FieldTag::__build_started_on),
                            "buildFinishedOn" => Ok(__FieldTag::__build_finished_on),
                            "build_finished_on" => Ok(__FieldTag::__build_finished_on),
                            "completeness" => Ok(__FieldTag::__completeness),
                            "reproducible" => Ok(__FieldTag::__reproducible),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Metadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Metadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build_invocation_id => {
                            if !fields.insert(__FieldTag::__build_invocation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_invocation_id",
                                ));
                            }
                            result.build_invocation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build_started_on => {
                            if !fields.insert(__FieldTag::__build_started_on) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_started_on",
                                ));
                            }
                            result.build_started_on =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__build_finished_on => {
                            if !fields.insert(__FieldTag::__build_finished_on) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_finished_on",
                                ));
                            }
                            result.build_finished_on =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completeness => {
                            if !fields.insert(__FieldTag::__completeness) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completeness",
                                ));
                            }
                            result.completeness = map
                                .next_value::<std::option::Option<crate::model::Completeness>>()?;
                        }
                        __FieldTag::__reproducible => {
                            if !fields.insert(__FieldTag::__reproducible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reproducible",
                                ));
                            }
                            result.reproducible = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BuilderConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuilderConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BuilderConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuilderConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InTotoProvenance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __builder_config,
            __recipe,
            __metadata,
            __materials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InTotoProvenance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "builderConfig" => Ok(__FieldTag::__builder_config),
                            "builder_config" => Ok(__FieldTag::__builder_config),
                            "recipe" => Ok(__FieldTag::__recipe),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "materials" => Ok(__FieldTag::__materials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InTotoProvenance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InTotoProvenance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__builder_config => {
                            if !fields.insert(__FieldTag::__builder_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder_config",
                                ));
                            }
                            result.builder_config = map
                                .next_value::<std::option::Option<crate::model::BuilderConfig>>()?;
                        }
                        __FieldTag::__recipe => {
                            if !fields.insert(__FieldTag::__recipe) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recipe",
                                ));
                            }
                            result.recipe =
                                map.next_value::<std::option::Option<crate::model::Recipe>>()?;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata =
                                map.next_value::<std::option::Option<crate::model::Metadata>>()?;
                        }
                        __FieldTag::__materials => {
                            if !fields.insert(__FieldTag::__materials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materials",
                                ));
                            }
                            result.materials = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InTotoStatement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __subject,
            __predicate_type,
            __provenance,
            __slsa_provenance,
            __slsa_provenance_zero_two,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InTotoStatement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "_type" => Ok(__FieldTag::__type),
                            "type" => Ok(__FieldTag::__type),
                            "subject" => Ok(__FieldTag::__subject),
                            "predicateType" => Ok(__FieldTag::__predicate_type),
                            "predicate_type" => Ok(__FieldTag::__predicate_type),
                            "provenance" => Ok(__FieldTag::__provenance),
                            "slsaProvenance" => Ok(__FieldTag::__slsa_provenance),
                            "slsa_provenance" => Ok(__FieldTag::__slsa_provenance),
                            "slsaProvenanceZeroTwo" => Ok(__FieldTag::__slsa_provenance_zero_two),
                            "slsa_provenance_zero_two" => {
                                Ok(__FieldTag::__slsa_provenance_zero_two)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InTotoStatement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InTotoStatement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Subject>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__predicate_type => {
                            if !fields.insert(__FieldTag::__predicate_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicate_type",
                                ));
                            }
                            result.predicate_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__provenance => {
                            if !fields.insert(__FieldTag::__provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provenance",
                                ));
                            }
                            if result.predicate.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `predicate`, a oneof with full ID .grafeas.v1.InTotoStatement.provenance, latest field was provenance",
                                ));
                            }
                            result.predicate = std::option::Option::Some(
                                crate::model::in_toto_statement::Predicate::Provenance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InTotoProvenance>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__slsa_provenance => {
                            if !fields.insert(__FieldTag::__slsa_provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slsa_provenance",
                                ));
                            }
                            if result.predicate.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `predicate`, a oneof with full ID .grafeas.v1.InTotoStatement.slsa_provenance, latest field was slsaProvenance",
                                ));
                            }
                            result.predicate = std::option::Option::Some(
                                crate::model::in_toto_statement::Predicate::SlsaProvenance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SlsaProvenance>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__slsa_provenance_zero_two => {
                            if !fields.insert(__FieldTag::__slsa_provenance_zero_two) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slsa_provenance_zero_two",
                                ));
                            }
                            if result.predicate.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `predicate`, a oneof with full ID .grafeas.v1.InTotoStatement.slsa_provenance_zero_two, latest field was slsaProvenanceZeroTwo",
                                ));
                            }
                            result.predicate = std::option::Option::Some(
                                crate::model::in_toto_statement::Predicate::SlsaProvenanceZeroTwo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SlsaProvenanceZeroTwo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Subject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __digest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Subject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "digest" => Ok(__FieldTag::__digest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Subject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Subject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InTotoSlsaProvenanceV1 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __subject,
            __predicate_type,
            __predicate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InTotoSlsaProvenanceV1")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "_type" => Ok(__FieldTag::__type),
                            "type" => Ok(__FieldTag::__type),
                            "subject" => Ok(__FieldTag::__subject),
                            "predicateType" => Ok(__FieldTag::__predicate_type),
                            "predicate_type" => Ok(__FieldTag::__predicate_type),
                            "predicate" => Ok(__FieldTag::__predicate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InTotoSlsaProvenanceV1;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InTotoSlsaProvenanceV1")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Subject>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__predicate_type => {
                            if !fields.insert(__FieldTag::__predicate_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicate_type",
                                ));
                            }
                            result.predicate_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__predicate => {
                            if !fields.insert(__FieldTag::__predicate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicate",
                                ));
                            }
                            result.predicate = map.next_value::<std::option::Option<
                                crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::in_toto_slsa_provenance_v_1::SlsaProvenanceV1 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build_definition,
            __run_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaProvenanceV1")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buildDefinition" => Ok(__FieldTag::__build_definition),
                            "build_definition" => Ok(__FieldTag::__build_definition),
                            "runDetails" => Ok(__FieldTag::__run_details),
                            "run_details" => Ok(__FieldTag::__run_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::in_toto_slsa_provenance_v_1::SlsaProvenanceV1;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaProvenanceV1")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build_definition => {
                            if !fields.insert(__FieldTag::__build_definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_definition",
                                ));
                            }
                            result.build_definition = map.next_value::<std::option::Option<
                                crate::model::in_toto_slsa_provenance_v_1::BuildDefinition,
                            >>()?;
                        }
                        __FieldTag::__run_details => {
                            if !fields.insert(__FieldTag::__run_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_details",
                                ));
                            }
                            result.run_details = map.next_value::<std::option::Option<
                                crate::model::in_toto_slsa_provenance_v_1::RunDetails,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::in_toto_slsa_provenance_v_1::BuildDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build_type,
            __external_parameters,
            __internal_parameters,
            __resolved_dependencies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buildType" => Ok(__FieldTag::__build_type),
                            "build_type" => Ok(__FieldTag::__build_type),
                            "externalParameters" => Ok(__FieldTag::__external_parameters),
                            "external_parameters" => Ok(__FieldTag::__external_parameters),
                            "internalParameters" => Ok(__FieldTag::__internal_parameters),
                            "internal_parameters" => Ok(__FieldTag::__internal_parameters),
                            "resolvedDependencies" => Ok(__FieldTag::__resolved_dependencies),
                            "resolved_dependencies" => Ok(__FieldTag::__resolved_dependencies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::in_toto_slsa_provenance_v_1::BuildDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build_type => {
                            if !fields.insert(__FieldTag::__build_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_type",
                                ));
                            }
                            result.build_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_parameters => {
                            if !fields.insert(__FieldTag::__external_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_parameters",
                                ));
                            }
                            result.external_parameters =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__internal_parameters => {
                            if !fields.insert(__FieldTag::__internal_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_parameters",
                                ));
                            }
                            result.internal_parameters =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__resolved_dependencies => {
                            if !fields.insert(__FieldTag::__resolved_dependencies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_dependencies",
                                ));
                            }
                            result.resolved_dependencies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::in_toto_slsa_provenance_v_1::ResourceDescriptor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uri,
            __digest,
            __content,
            __download_location,
            __media_type,
            __annotations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceDescriptor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uri" => Ok(__FieldTag::__uri),
                            "digest" => Ok(__FieldTag::__digest),
                            "content" => Ok(__FieldTag::__content),
                            "downloadLocation" => Ok(__FieldTag::__download_location),
                            "download_location" => Ok(__FieldTag::__download_location),
                            "mediaType" => Ok(__FieldTag::__media_type),
                            "media_type" => Ok(__FieldTag::__media_type),
                            "annotations" => Ok(__FieldTag::__annotations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::in_toto_slsa_provenance_v_1::ResourceDescriptor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceDescriptor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.content = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__download_location => {
                            if !fields.insert(__FieldTag::__download_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for download_location",
                                ));
                            }
                            result.download_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__media_type => {
                            if !fields.insert(__FieldTag::__media_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for media_type",
                                ));
                            }
                            result.media_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Value>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::in_toto_slsa_provenance_v_1::RunDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __builder,
            __metadata,
            __byproducts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "builder" => Ok(__FieldTag::__builder),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "byproducts" => Ok(__FieldTag::__byproducts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::in_toto_slsa_provenance_v_1::RunDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__builder => {
                            if !fields.insert(__FieldTag::__builder) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder",
                                ));
                            }
                            result.builder = map.next_value::<std::option::Option<
                                crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder,
                            >>()?;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<
                                crate::model::in_toto_slsa_provenance_v_1::BuildMetadata,
                            >>()?;
                        }
                        __FieldTag::__byproducts => {
                            if !fields.insert(__FieldTag::__byproducts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for byproducts",
                                ));
                            }
                            result.byproducts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::in_toto_slsa_provenance_v_1::ProvenanceBuilder {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __version,
            __builder_dependencies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProvenanceBuilder")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "version" => Ok(__FieldTag::__version),
                            "builderDependencies" => Ok(__FieldTag::__builder_dependencies),
                            "builder_dependencies" => Ok(__FieldTag::__builder_dependencies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::in_toto_slsa_provenance_v_1::ProvenanceBuilder;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProvenanceBuilder")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__builder_dependencies => {
                            if !fields.insert(__FieldTag::__builder_dependencies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder_dependencies",
                                ));
                            }
                            result.builder_dependencies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::in_toto_slsa_provenance_v_1::BuildMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __invocation_id,
            __started_on,
            __finished_on,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "invocationId" => Ok(__FieldTag::__invocation_id),
                            "invocation_id" => Ok(__FieldTag::__invocation_id),
                            "startedOn" => Ok(__FieldTag::__started_on),
                            "started_on" => Ok(__FieldTag::__started_on),
                            "finishedOn" => Ok(__FieldTag::__finished_on),
                            "finished_on" => Ok(__FieldTag::__finished_on),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::in_toto_slsa_provenance_v_1::BuildMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__invocation_id => {
                            if !fields.insert(__FieldTag::__invocation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invocation_id",
                                ));
                            }
                            result.invocation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__started_on => {
                            if !fields.insert(__FieldTag::__started_on) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for started_on",
                                ));
                            }
                            result.started_on =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finished_on => {
                            if !fields.insert(__FieldTag::__finished_on) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finished_on",
                                ));
                            }
                            result.finished_on =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Distribution {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpe_uri,
            __architecture,
            __latest_version,
            __maintainer,
            __url,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Distribution")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "architecture" => Ok(__FieldTag::__architecture),
                            "latestVersion" => Ok(__FieldTag::__latest_version),
                            "latest_version" => Ok(__FieldTag::__latest_version),
                            "maintainer" => Ok(__FieldTag::__maintainer),
                            "url" => Ok(__FieldTag::__url),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Distribution;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Distribution")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<crate::model::Architecture>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_version => {
                            if !fields.insert(__FieldTag::__latest_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_version",
                                ));
                            }
                            result.latest_version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__maintainer => {
                            if !fields.insert(__FieldTag::__maintainer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintainer",
                                ));
                            }
                            result.maintainer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Location {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpe_uri,
            __version,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Location")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "version" => Ok(__FieldTag::__version),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Location;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Location")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PackageNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __distribution,
            __package_type,
            __cpe_uri,
            __architecture,
            __version,
            __maintainer,
            __url,
            __description,
            __license,
            __digest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PackageNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "distribution" => Ok(__FieldTag::__distribution),
                            "packageType" => Ok(__FieldTag::__package_type),
                            "package_type" => Ok(__FieldTag::__package_type),
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "architecture" => Ok(__FieldTag::__architecture),
                            "version" => Ok(__FieldTag::__version),
                            "maintainer" => Ok(__FieldTag::__maintainer),
                            "url" => Ok(__FieldTag::__url),
                            "description" => Ok(__FieldTag::__description),
                            "license" => Ok(__FieldTag::__license),
                            "digest" => Ok(__FieldTag::__digest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PackageNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PackageNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__distribution => {
                            if !fields.insert(__FieldTag::__distribution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution",
                                ));
                            }
                            result.distribution = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Distribution>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__package_type => {
                            if !fields.insert(__FieldTag::__package_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_type",
                                ));
                            }
                            result.package_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<crate::model::Architecture>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__maintainer => {
                            if !fields.insert(__FieldTag::__maintainer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintainer",
                                ));
                            }
                            result.maintainer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license => {
                            if !fields.insert(__FieldTag::__license) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license",
                                ));
                            }
                            result.license =
                                map.next_value::<std::option::Option<crate::model::License>>()?;
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Digest>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PackageOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __location,
            __package_type,
            __cpe_uri,
            __architecture,
            __license,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PackageOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "location" => Ok(__FieldTag::__location),
                            "packageType" => Ok(__FieldTag::__package_type),
                            "package_type" => Ok(__FieldTag::__package_type),
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "architecture" => Ok(__FieldTag::__architecture),
                            "license" => Ok(__FieldTag::__license),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PackageOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PackageOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Location>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__package_type => {
                            if !fields.insert(__FieldTag::__package_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_type",
                                ));
                            }
                            result.package_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<crate::model::Architecture>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license => {
                            if !fields.insert(__FieldTag::__license) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license",
                                ));
                            }
                            result.license =
                                map.next_value::<std::option::Option<crate::model::License>>()?;
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Version {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __epoch,
            __name,
            __revision,
            __inclusive,
            __kind,
            __full_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Version")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "epoch" => Ok(__FieldTag::__epoch),
                            "name" => Ok(__FieldTag::__name),
                            "revision" => Ok(__FieldTag::__revision),
                            "inclusive" => Ok(__FieldTag::__inclusive),
                            "kind" => Ok(__FieldTag::__kind),
                            "fullName" => Ok(__FieldTag::__full_name),
                            "full_name" => Ok(__FieldTag::__full_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Version;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Version")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__epoch => {
                            if !fields.insert(__FieldTag::__epoch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for epoch",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.epoch = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inclusive => {
                            if !fields.insert(__FieldTag::__inclusive) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inclusive",
                                ));
                            }
                            result.inclusive = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map.next_value::<std::option::Option<crate::model::version::VersionKind>>()?.unwrap_or_default();
                        }
                        __FieldTag::__full_name => {
                            if !fields.insert(__FieldTag::__full_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_name",
                                ));
                            }
                            result.full_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BuildProvenance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __project_id,
            __commands,
            __built_artifacts,
            __create_time,
            __start_time,
            __end_time,
            __creator,
            __logs_uri,
            __source_provenance,
            __trigger_id,
            __build_options,
            __builder_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildProvenance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "commands" => Ok(__FieldTag::__commands),
                            "builtArtifacts" => Ok(__FieldTag::__built_artifacts),
                            "built_artifacts" => Ok(__FieldTag::__built_artifacts),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "creator" => Ok(__FieldTag::__creator),
                            "logsUri" => Ok(__FieldTag::__logs_uri),
                            "logs_uri" => Ok(__FieldTag::__logs_uri),
                            "sourceProvenance" => Ok(__FieldTag::__source_provenance),
                            "source_provenance" => Ok(__FieldTag::__source_provenance),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            "buildOptions" => Ok(__FieldTag::__build_options),
                            "build_options" => Ok(__FieldTag::__build_options),
                            "builderVersion" => Ok(__FieldTag::__builder_version),
                            "builder_version" => Ok(__FieldTag::__builder_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BuildProvenance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildProvenance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__commands => {
                            if !fields.insert(__FieldTag::__commands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commands",
                                ));
                            }
                            result.commands = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Command>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__built_artifacts => {
                            if !fields.insert(__FieldTag::__built_artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for built_artifacts",
                                ));
                            }
                            result.built_artifacts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Artifact>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__creator => {
                            if !fields.insert(__FieldTag::__creator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creator",
                                ));
                            }
                            result.creator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logs_uri => {
                            if !fields.insert(__FieldTag::__logs_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logs_uri",
                                ));
                            }
                            result.logs_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_provenance => {
                            if !fields.insert(__FieldTag::__source_provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_provenance",
                                ));
                            }
                            result.source_provenance =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build_options => {
                            if !fields.insert(__FieldTag::__build_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_options",
                                ));
                            }
                            result.build_options = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__builder_version => {
                            if !fields.insert(__FieldTag::__builder_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder_version",
                                ));
                            }
                            result.builder_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Source {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __artifact_storage_source_uri,
            __file_hashes,
            __context,
            __additional_contexts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Source")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "artifactStorageSourceUri" => {
                                Ok(__FieldTag::__artifact_storage_source_uri)
                            }
                            "artifact_storage_source_uri" => {
                                Ok(__FieldTag::__artifact_storage_source_uri)
                            }
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            "context" => Ok(__FieldTag::__context),
                            "additionalContexts" => Ok(__FieldTag::__additional_contexts),
                            "additional_contexts" => Ok(__FieldTag::__additional_contexts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Source;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Source")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__artifact_storage_source_uri => {
                            if !fields.insert(__FieldTag::__artifact_storage_source_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_storage_source_uri",
                                ));
                            }
                            result.artifact_storage_source_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::FileHashes,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context => {
                            if !fields.insert(__FieldTag::__context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context",
                                ));
                            }
                            result.context = map
                                .next_value::<std::option::Option<crate::model::SourceContext>>()?;
                        }
                        __FieldTag::__additional_contexts => {
                            if !fields.insert(__FieldTag::__additional_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_contexts",
                                ));
                            }
                            result.additional_contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SourceContext>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FileHashes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_hash,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileHashes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileHash" => Ok(__FieldTag::__file_hash),
                            "file_hash" => Ok(__FieldTag::__file_hash),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FileHashes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileHashes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_hash => {
                            if !fields.insert(__FieldTag::__file_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hash",
                                ));
                            }
                            result.file_hash = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Hash>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Hash {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Hash")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Hash;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Hash")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Command {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __env,
            __args,
            __dir,
            __id,
            __wait_for,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Command")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "env" => Ok(__FieldTag::__env),
                            "args" => Ok(__FieldTag::__args),
                            "dir" => Ok(__FieldTag::__dir),
                            "id" => Ok(__FieldTag::__id),
                            "waitFor" => Ok(__FieldTag::__wait_for),
                            "wait_for" => Ok(__FieldTag::__wait_for),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Command;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Command")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env => {
                            if !fields.insert(__FieldTag::__env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env",
                                ));
                            }
                            result.env = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dir => {
                            if !fields.insert(__FieldTag::__dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dir",
                                ));
                            }
                            result.dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__wait_for => {
                            if !fields.insert(__FieldTag::__wait_for) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait_for",
                                ));
                            }
                            result.wait_for = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Artifact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __checksum,
            __id,
            __names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Artifact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "checksum" => Ok(__FieldTag::__checksum),
                            "id" => Ok(__FieldTag::__id),
                            "names" => Ok(__FieldTag::__names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Artifact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Artifact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__checksum => {
                            if !fields.insert(__FieldTag::__checksum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for checksum",
                                ));
                            }
                            result.checksum = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SourceContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_repo,
            __gerrit,
            __git,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudRepo" => Ok(__FieldTag::__cloud_repo),
                            "cloud_repo" => Ok(__FieldTag::__cloud_repo),
                            "gerrit" => Ok(__FieldTag::__gerrit),
                            "git" => Ok(__FieldTag::__git),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SourceContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_repo => {
                            if !fields.insert(__FieldTag::__cloud_repo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_repo",
                                ));
                            }
                            if result.context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `context`, a oneof with full ID .grafeas.v1.SourceContext.cloud_repo, latest field was cloudRepo",
                                ));
                            }
                            result.context = std::option::Option::Some(
                                crate::model::source_context::Context::CloudRepo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudRepoSourceContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gerrit => {
                            if !fields.insert(__FieldTag::__gerrit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gerrit",
                                ));
                            }
                            if result.context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `context`, a oneof with full ID .grafeas.v1.SourceContext.gerrit, latest field was gerrit",
                                ));
                            }
                            result.context = std::option::Option::Some(
                                crate::model::source_context::Context::Gerrit(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GerritSourceContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__git => {
                            if !fields.insert(__FieldTag::__git) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git",
                                ));
                            }
                            if result.context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `context`, a oneof with full ID .grafeas.v1.SourceContext.git, latest field was git",
                                ));
                            }
                            result.context = std::option::Option::Some(
                                crate::model::source_context::Context::Git(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GitSourceContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AliasContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AliasContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AliasContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AliasContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map.next_value::<std::option::Option<crate::model::alias_context::Kind>>()?.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudRepoSourceContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __repo_id,
            __revision_id,
            __alias_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRepoSourceContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "repoId" => Ok(__FieldTag::__repo_id),
                            "repo_id" => Ok(__FieldTag::__repo_id),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "aliasContext" => Ok(__FieldTag::__alias_context),
                            "alias_context" => Ok(__FieldTag::__alias_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudRepoSourceContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRepoSourceContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__repo_id => {
                            if !fields.insert(__FieldTag::__repo_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_id",
                                ));
                            }
                            result.repo_id =
                                map.next_value::<std::option::Option<crate::model::RepoId>>()?;
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .grafeas.v1.CloudRepoSourceContext.revision_id, latest field was revisionId",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::cloud_repo_source_context::Revision::RevisionId(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__alias_context => {
                            if !fields.insert(__FieldTag::__alias_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alias_context",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .grafeas.v1.CloudRepoSourceContext.alias_context, latest field was aliasContext",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::cloud_repo_source_context::Revision::AliasContext(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AliasContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GerritSourceContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host_uri,
            __gerrit_project,
            __revision_id,
            __alias_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GerritSourceContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostUri" => Ok(__FieldTag::__host_uri),
                            "host_uri" => Ok(__FieldTag::__host_uri),
                            "gerritProject" => Ok(__FieldTag::__gerrit_project),
                            "gerrit_project" => Ok(__FieldTag::__gerrit_project),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "aliasContext" => Ok(__FieldTag::__alias_context),
                            "alias_context" => Ok(__FieldTag::__alias_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GerritSourceContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GerritSourceContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host_uri => {
                            if !fields.insert(__FieldTag::__host_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_uri",
                                ));
                            }
                            result.host_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gerrit_project => {
                            if !fields.insert(__FieldTag::__gerrit_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gerrit_project",
                                ));
                            }
                            result.gerrit_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .grafeas.v1.GerritSourceContext.revision_id, latest field was revisionId",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::gerrit_source_context::Revision::RevisionId(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__alias_context => {
                            if !fields.insert(__FieldTag::__alias_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alias_context",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .grafeas.v1.GerritSourceContext.alias_context, latest field was aliasContext",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::gerrit_source_context::Revision::AliasContext(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AliasContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GitSourceContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __revision_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitSourceContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GitSourceContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitSourceContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RepoId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_repo_id,
            __uid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepoId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectRepoId" => Ok(__FieldTag::__project_repo_id),
                            "project_repo_id" => Ok(__FieldTag::__project_repo_id),
                            "uid" => Ok(__FieldTag::__uid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RepoId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepoId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_repo_id => {
                            if !fields.insert(__FieldTag::__project_repo_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_repo_id",
                                ));
                            }
                            if result.id.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `id`, a oneof with full ID .grafeas.v1.RepoId.project_repo_id, latest field was projectRepoId",
                                ));
                            }
                            result.id = std::option::Option::Some(
                                crate::model::repo_id::Id::ProjectRepoId(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ProjectRepoId>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            if result.id.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `id`, a oneof with full ID .grafeas.v1.RepoId.uid, latest field was uid",
                                ));
                            }
                            result.id = std::option::Option::Some(crate::model::repo_id::Id::Uid(
                                map.next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default(),
                            ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ProjectRepoId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __repo_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProjectRepoId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "repoName" => Ok(__FieldTag::__repo_name),
                            "repo_name" => Ok(__FieldTag::__repo_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ProjectRepoId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProjectRepoId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repo_name => {
                            if !fields.insert(__FieldTag::__repo_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_name",
                                ));
                            }
                            result.repo_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Risk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cisa_kev,
            __epss,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Risk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cisaKev" => Ok(__FieldTag::__cisa_kev),
                            "cisa_kev" => Ok(__FieldTag::__cisa_kev),
                            "epss" => Ok(__FieldTag::__epss),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Risk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Risk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cisa_kev => {
                            if !fields.insert(__FieldTag::__cisa_kev) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cisa_kev",
                                ));
                            }
                            result.cisa_kev = map.next_value::<std::option::Option<
                                crate::model::CISAKnownExploitedVulnerabilities,
                            >>()?;
                        }
                        __FieldTag::__epss => {
                            if !fields.insert(__FieldTag::__epss) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for epss",
                                ));
                            }
                            result.epss =
                                map.next_value::<std::option::Option<
                                    crate::model::ExploitPredictionScoringSystem,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CISAKnownExploitedVulnerabilities {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __known_ransomware_campaign_use,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CISAKnownExploitedVulnerabilities")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "knownRansomwareCampaignUse" => {
                                Ok(__FieldTag::__known_ransomware_campaign_use)
                            }
                            "known_ransomware_campaign_use" => {
                                Ok(__FieldTag::__known_ransomware_campaign_use)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CISAKnownExploitedVulnerabilities;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CISAKnownExploitedVulnerabilities")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__known_ransomware_campaign_use => {
                            if !fields.insert(__FieldTag::__known_ransomware_campaign_use) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for known_ransomware_campaign_use",
                                ));
                            }
                            result.known_ransomware_campaign_use = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExploitPredictionScoringSystem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __percentile,
            __score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExploitPredictionScoringSystem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "percentile" => Ok(__FieldTag::__percentile),
                            "score" => Ok(__FieldTag::__score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExploitPredictionScoringSystem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExploitPredictionScoringSystem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__percentile => {
                            if !fields.insert(__FieldTag::__percentile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percentile",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.percentile = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SBOMReferenceNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __format,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SBOMReferenceNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "format" => Ok(__FieldTag::__format),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SBOMReferenceNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SBOMReferenceNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SBOMReferenceOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __payload,
            __payload_type,
            __signatures,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SBOMReferenceOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "payload" => Ok(__FieldTag::__payload),
                            "payloadType" => Ok(__FieldTag::__payload_type),
                            "payload_type" => Ok(__FieldTag::__payload_type),
                            "signatures" => Ok(__FieldTag::__signatures),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SBOMReferenceOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SBOMReferenceOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            result.payload = map.next_value::<std::option::Option<crate::model::SbomReferenceIntotoPayload>>()?
                                ;
                        }
                        __FieldTag::__payload_type => {
                            if !fields.insert(__FieldTag::__payload_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload_type",
                                ));
                            }
                            result.payload_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__signatures => {
                            if !fields.insert(__FieldTag::__signatures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signatures",
                                ));
                            }
                            result.signatures =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EnvelopeSignature>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SbomReferenceIntotoPayload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __predicate_type,
            __subject,
            __predicate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SbomReferenceIntotoPayload")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "_type" => Ok(__FieldTag::__type),
                            "type" => Ok(__FieldTag::__type),
                            "predicateType" => Ok(__FieldTag::__predicate_type),
                            "predicate_type" => Ok(__FieldTag::__predicate_type),
                            "subject" => Ok(__FieldTag::__subject),
                            "predicate" => Ok(__FieldTag::__predicate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SbomReferenceIntotoPayload;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SbomReferenceIntotoPayload")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__predicate_type => {
                            if !fields.insert(__FieldTag::__predicate_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicate_type",
                                ));
                            }
                            result.predicate_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Subject>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__predicate => {
                            if !fields.insert(__FieldTag::__predicate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicate",
                                ));
                            }
                            result.predicate = map.next_value::<std::option::Option<crate::model::SbomReferenceIntotoPredicate>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SbomReferenceIntotoPredicate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __referrer_id,
            __location,
            __mime_type,
            __digest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SbomReferenceIntotoPredicate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "referrerId" => Ok(__FieldTag::__referrer_id),
                            "referrer_id" => Ok(__FieldTag::__referrer_id),
                            "location" => Ok(__FieldTag::__location),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "digest" => Ok(__FieldTag::__digest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SbomReferenceIntotoPredicate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SbomReferenceIntotoPredicate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__referrer_id => {
                            if !fields.insert(__FieldTag::__referrer_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referrer_id",
                                ));
                            }
                            result.referrer_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SecretNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SecretNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SecretOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __locations,
            __statuses,
            __data,
            __digest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "locations" => Ok(__FieldTag::__locations),
                            "statuses" => Ok(__FieldTag::__statuses),
                            "data" => Ok(__FieldTag::__data),
                            "digest" => Ok(__FieldTag::__digest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SecretOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<crate::model::SecretKind>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SecretLocation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__statuses => {
                            if !fields.insert(__FieldTag::__statuses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statuses",
                                ));
                            }
                            result.statuses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SecretStatus>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            result.data = map.next_value::<std::option::Option<wkt::Any>>()?;
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest =
                                map.next_value::<std::option::Option<crate::model::Digest>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SecretLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileLocation" => Ok(__FieldTag::__file_location),
                            "file_location" => Ok(__FieldTag::__file_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SecretLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_location => {
                            if !fields.insert(__FieldTag::__file_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_location",
                                ));
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .grafeas.v1.SecretLocation.file_location, latest field was fileLocation",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::secret_location::Location::FileLocation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FileLocation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SecretStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __status,
            __update_time,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "status" => Ok(__FieldTag::__status),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SecretStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::secret_status::Status>>()?.unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SlsaProvenance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __builder,
            __recipe,
            __metadata,
            __materials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaProvenance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "builder" => Ok(__FieldTag::__builder),
                            "recipe" => Ok(__FieldTag::__recipe),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "materials" => Ok(__FieldTag::__materials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SlsaProvenance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaProvenance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__builder => {
                            if !fields.insert(__FieldTag::__builder) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder",
                                ));
                            }
                            result.builder = map.next_value::<std::option::Option<crate::model::slsa_provenance::SlsaBuilder>>()?
                                ;
                        }
                        __FieldTag::__recipe => {
                            if !fields.insert(__FieldTag::__recipe) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recipe",
                                ));
                            }
                            result.recipe = map.next_value::<std::option::Option<crate::model::slsa_provenance::SlsaRecipe>>()?
                                ;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata =
                                map.next_value::<std::option::Option<
                                    crate::model::slsa_provenance::SlsaMetadata,
                                >>()?;
                        }
                        __FieldTag::__materials => {
                            if !fields.insert(__FieldTag::__materials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materials",
                                ));
                            }
                            result.materials = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::slsa_provenance::Material>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::slsa_provenance::SlsaRecipe {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __defined_in_material,
            __entry_point,
            __arguments,
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaRecipe")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "definedInMaterial" => Ok(__FieldTag::__defined_in_material),
                            "defined_in_material" => Ok(__FieldTag::__defined_in_material),
                            "entryPoint" => Ok(__FieldTag::__entry_point),
                            "entry_point" => Ok(__FieldTag::__entry_point),
                            "arguments" => Ok(__FieldTag::__arguments),
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::slsa_provenance::SlsaRecipe;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaRecipe")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__defined_in_material => {
                            if !fields.insert(__FieldTag::__defined_in_material) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for defined_in_material",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.defined_in_material =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__entry_point => {
                            if !fields.insert(__FieldTag::__entry_point) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_point",
                                ));
                            }
                            result.entry_point = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__arguments => {
                            if !fields.insert(__FieldTag::__arguments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arguments",
                                ));
                            }
                            result.arguments = map.next_value::<std::option::Option<wkt::Any>>()?;
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment =
                                map.next_value::<std::option::Option<wkt::Any>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::slsa_provenance::SlsaCompleteness {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __arguments,
            __environment,
            __materials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaCompleteness")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "arguments" => Ok(__FieldTag::__arguments),
                            "environment" => Ok(__FieldTag::__environment),
                            "materials" => Ok(__FieldTag::__materials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::slsa_provenance::SlsaCompleteness;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaCompleteness")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__arguments => {
                            if !fields.insert(__FieldTag::__arguments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arguments",
                                ));
                            }
                            result.arguments = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__materials => {
                            if !fields.insert(__FieldTag::__materials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materials",
                                ));
                            }
                            result.materials = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::slsa_provenance::SlsaMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build_invocation_id,
            __build_started_on,
            __build_finished_on,
            __completeness,
            __reproducible,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buildInvocationId" => Ok(__FieldTag::__build_invocation_id),
                            "build_invocation_id" => Ok(__FieldTag::__build_invocation_id),
                            "buildStartedOn" => Ok(__FieldTag::__build_started_on),
                            "build_started_on" => Ok(__FieldTag::__build_started_on),
                            "buildFinishedOn" => Ok(__FieldTag::__build_finished_on),
                            "build_finished_on" => Ok(__FieldTag::__build_finished_on),
                            "completeness" => Ok(__FieldTag::__completeness),
                            "reproducible" => Ok(__FieldTag::__reproducible),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::slsa_provenance::SlsaMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build_invocation_id => {
                            if !fields.insert(__FieldTag::__build_invocation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_invocation_id",
                                ));
                            }
                            result.build_invocation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build_started_on => {
                            if !fields.insert(__FieldTag::__build_started_on) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_started_on",
                                ));
                            }
                            result.build_started_on =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__build_finished_on => {
                            if !fields.insert(__FieldTag::__build_finished_on) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_finished_on",
                                ));
                            }
                            result.build_finished_on =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completeness => {
                            if !fields.insert(__FieldTag::__completeness) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completeness",
                                ));
                            }
                            result.completeness = map.next_value::<std::option::Option<
                                crate::model::slsa_provenance::SlsaCompleteness,
                            >>()?;
                        }
                        __FieldTag::__reproducible => {
                            if !fields.insert(__FieldTag::__reproducible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reproducible",
                                ));
                            }
                            result.reproducible = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::slsa_provenance::SlsaBuilder {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaBuilder")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::slsa_provenance::SlsaBuilder;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaBuilder")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::slsa_provenance::Material {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __digest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Material")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "digest" => Ok(__FieldTag::__digest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::slsa_provenance::Material;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Material")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SlsaProvenanceZeroTwo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __builder,
            __build_type,
            __invocation,
            __build_config,
            __metadata,
            __materials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaProvenanceZeroTwo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "builder" => Ok(__FieldTag::__builder),
                            "buildType" => Ok(__FieldTag::__build_type),
                            "build_type" => Ok(__FieldTag::__build_type),
                            "invocation" => Ok(__FieldTag::__invocation),
                            "buildConfig" => Ok(__FieldTag::__build_config),
                            "build_config" => Ok(__FieldTag::__build_config),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "materials" => Ok(__FieldTag::__materials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SlsaProvenanceZeroTwo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaProvenanceZeroTwo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__builder => {
                            if !fields.insert(__FieldTag::__builder) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builder",
                                ));
                            }
                            result.builder = map.next_value::<std::option::Option<
                                crate::model::slsa_provenance_zero_two::SlsaBuilder,
                            >>()?;
                        }
                        __FieldTag::__build_type => {
                            if !fields.insert(__FieldTag::__build_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_type",
                                ));
                            }
                            result.build_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invocation => {
                            if !fields.insert(__FieldTag::__invocation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invocation",
                                ));
                            }
                            result.invocation = map.next_value::<std::option::Option<
                                crate::model::slsa_provenance_zero_two::SlsaInvocation,
                            >>()?;
                        }
                        __FieldTag::__build_config => {
                            if !fields.insert(__FieldTag::__build_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_config",
                                ));
                            }
                            result.build_config =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<
                                crate::model::slsa_provenance_zero_two::SlsaMetadata,
                            >>()?;
                        }
                        __FieldTag::__materials => {
                            if !fields.insert(__FieldTag::__materials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materials",
                                ));
                            }
                            result.materials = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::slsa_provenance_zero_two::SlsaMaterial,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::slsa_provenance_zero_two::SlsaBuilder {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaBuilder")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::slsa_provenance_zero_two::SlsaBuilder;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaBuilder")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::slsa_provenance_zero_two::SlsaMaterial {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __digest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaMaterial")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "digest" => Ok(__FieldTag::__digest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::slsa_provenance_zero_two::SlsaMaterial;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaMaterial")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::slsa_provenance_zero_two::SlsaInvocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config_source,
            __parameters,
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaInvocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "configSource" => Ok(__FieldTag::__config_source),
                            "config_source" => Ok(__FieldTag::__config_source),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::slsa_provenance_zero_two::SlsaInvocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaInvocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config_source => {
                            if !fields.insert(__FieldTag::__config_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_source",
                                ));
                            }
                            result.config_source = map.next_value::<std::option::Option<
                                crate::model::slsa_provenance_zero_two::SlsaConfigSource,
                            >>()?;
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::slsa_provenance_zero_two::SlsaConfigSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __digest,
            __entry_point,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaConfigSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "digest" => Ok(__FieldTag::__digest),
                            "entryPoint" => Ok(__FieldTag::__entry_point),
                            "entry_point" => Ok(__FieldTag::__entry_point),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::slsa_provenance_zero_two::SlsaConfigSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaConfigSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_point => {
                            if !fields.insert(__FieldTag::__entry_point) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_point",
                                ));
                            }
                            result.entry_point = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::slsa_provenance_zero_two::SlsaMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build_invocation_id,
            __build_started_on,
            __build_finished_on,
            __completeness,
            __reproducible,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buildInvocationId" => Ok(__FieldTag::__build_invocation_id),
                            "build_invocation_id" => Ok(__FieldTag::__build_invocation_id),
                            "buildStartedOn" => Ok(__FieldTag::__build_started_on),
                            "build_started_on" => Ok(__FieldTag::__build_started_on),
                            "buildFinishedOn" => Ok(__FieldTag::__build_finished_on),
                            "build_finished_on" => Ok(__FieldTag::__build_finished_on),
                            "completeness" => Ok(__FieldTag::__completeness),
                            "reproducible" => Ok(__FieldTag::__reproducible),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::slsa_provenance_zero_two::SlsaMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build_invocation_id => {
                            if !fields.insert(__FieldTag::__build_invocation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_invocation_id",
                                ));
                            }
                            result.build_invocation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build_started_on => {
                            if !fields.insert(__FieldTag::__build_started_on) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_started_on",
                                ));
                            }
                            result.build_started_on =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__build_finished_on => {
                            if !fields.insert(__FieldTag::__build_finished_on) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_finished_on",
                                ));
                            }
                            result.build_finished_on =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completeness => {
                            if !fields.insert(__FieldTag::__completeness) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completeness",
                                ));
                            }
                            result.completeness = map.next_value::<std::option::Option<
                                crate::model::slsa_provenance_zero_two::SlsaCompleteness,
                            >>()?;
                        }
                        __FieldTag::__reproducible => {
                            if !fields.insert(__FieldTag::__reproducible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reproducible",
                                ));
                            }
                            result.reproducible = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::slsa_provenance_zero_two::SlsaCompleteness {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parameters,
            __environment,
            __materials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SlsaCompleteness")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parameters" => Ok(__FieldTag::__parameters),
                            "environment" => Ok(__FieldTag::__environment),
                            "materials" => Ok(__FieldTag::__materials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::slsa_provenance_zero_two::SlsaCompleteness;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SlsaCompleteness")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__materials => {
                            if !fields.insert(__FieldTag::__materials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materials",
                                ));
                            }
                            result.materials = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpgradeNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __package,
            __version,
            __distributions,
            __windows_update,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "package" => Ok(__FieldTag::__package),
                            "version" => Ok(__FieldTag::__version),
                            "distributions" => Ok(__FieldTag::__distributions),
                            "windowsUpdate" => Ok(__FieldTag::__windows_update),
                            "windows_update" => Ok(__FieldTag::__windows_update),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpgradeNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__package => {
                            if !fields.insert(__FieldTag::__package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package",
                                ));
                            }
                            result.package = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__distributions => {
                            if !fields.insert(__FieldTag::__distributions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distributions",
                                ));
                            }
                            result.distributions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UpgradeDistribution>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__windows_update => {
                            if !fields.insert(__FieldTag::__windows_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_update",
                                ));
                            }
                            result.windows_update = map
                                .next_value::<std::option::Option<crate::model::WindowsUpdate>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpgradeDistribution {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpe_uri,
            __classification,
            __severity,
            __cve,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeDistribution")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "classification" => Ok(__FieldTag::__classification),
                            "severity" => Ok(__FieldTag::__severity),
                            "cve" => Ok(__FieldTag::__cve),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpgradeDistribution;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeDistribution")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__classification => {
                            if !fields.insert(__FieldTag::__classification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for classification",
                                ));
                            }
                            result.classification = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cve => {
                            if !fields.insert(__FieldTag::__cve) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cve",
                                ));
                            }
                            result.cve = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WindowsUpdate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __identity,
            __title,
            __description,
            __categories,
            __kb_article_ids,
            __support_url,
            __last_published_timestamp,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsUpdate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "identity" => Ok(__FieldTag::__identity),
                            "title" => Ok(__FieldTag::__title),
                            "description" => Ok(__FieldTag::__description),
                            "categories" => Ok(__FieldTag::__categories),
                            "kbArticleIds" => Ok(__FieldTag::__kb_article_ids),
                            "kb_article_ids" => Ok(__FieldTag::__kb_article_ids),
                            "supportUrl" => Ok(__FieldTag::__support_url),
                            "support_url" => Ok(__FieldTag::__support_url),
                            "lastPublishedTimestamp" => Ok(__FieldTag::__last_published_timestamp),
                            "last_published_timestamp" => {
                                Ok(__FieldTag::__last_published_timestamp)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WindowsUpdate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsUpdate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__identity => {
                            if !fields.insert(__FieldTag::__identity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity",
                                ));
                            }
                            result.identity = map.next_value::<std::option::Option<crate::model::windows_update::Identity>>()?
                                ;
                        }
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__categories => {
                            if !fields.insert(__FieldTag::__categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categories",
                                ));
                            }
                            result.categories = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::windows_update::Category>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kb_article_ids => {
                            if !fields.insert(__FieldTag::__kb_article_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kb_article_ids",
                                ));
                            }
                            result.kb_article_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__support_url => {
                            if !fields.insert(__FieldTag::__support_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for support_url",
                                ));
                            }
                            result.support_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_published_timestamp => {
                            if !fields.insert(__FieldTag::__last_published_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_published_timestamp",
                                ));
                            }
                            result.last_published_timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::windows_update::Identity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_id,
            __revision,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Identity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateId" => Ok(__FieldTag::__update_id),
                            "update_id" => Ok(__FieldTag::__update_id),
                            "revision" => Ok(__FieldTag::__revision),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::windows_update::Identity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Identity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_id => {
                            if !fields.insert(__FieldTag::__update_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_id",
                                ));
                            }
                            result.update_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.revision = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::windows_update::Category {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __category_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Category")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "categoryId" => Ok(__FieldTag::__category_id),
                            "category_id" => Ok(__FieldTag::__category_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::windows_update::Category;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Category")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__category_id => {
                            if !fields.insert(__FieldTag::__category_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category_id",
                                ));
                            }
                            result.category_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpgradeOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __package,
            __parsed_version,
            __distribution,
            __windows_update,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "package" => Ok(__FieldTag::__package),
                            "parsedVersion" => Ok(__FieldTag::__parsed_version),
                            "parsed_version" => Ok(__FieldTag::__parsed_version),
                            "distribution" => Ok(__FieldTag::__distribution),
                            "windowsUpdate" => Ok(__FieldTag::__windows_update),
                            "windows_update" => Ok(__FieldTag::__windows_update),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpgradeOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__package => {
                            if !fields.insert(__FieldTag::__package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package",
                                ));
                            }
                            result.package = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parsed_version => {
                            if !fields.insert(__FieldTag::__parsed_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parsed_version",
                                ));
                            }
                            result.parsed_version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__distribution => {
                            if !fields.insert(__FieldTag::__distribution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution",
                                ));
                            }
                            result.distribution = map.next_value::<std::option::Option<crate::model::UpgradeDistribution>>()?
                                ;
                        }
                        __FieldTag::__windows_update => {
                            if !fields.insert(__FieldTag::__windows_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_update",
                                ));
                            }
                            result.windows_update = map
                                .next_value::<std::option::Option<crate::model::WindowsUpdate>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VulnerabilityAssessmentNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __short_description,
            __long_description,
            __language_code,
            __publisher,
            __product,
            __assessment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerabilityAssessmentNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "shortDescription" => Ok(__FieldTag::__short_description),
                            "short_description" => Ok(__FieldTag::__short_description),
                            "longDescription" => Ok(__FieldTag::__long_description),
                            "long_description" => Ok(__FieldTag::__long_description),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "publisher" => Ok(__FieldTag::__publisher),
                            "product" => Ok(__FieldTag::__product),
                            "assessment" => Ok(__FieldTag::__assessment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VulnerabilityAssessmentNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerabilityAssessmentNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__short_description => {
                            if !fields.insert(__FieldTag::__short_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for short_description",
                                ));
                            }
                            result.short_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__long_description => {
                            if !fields.insert(__FieldTag::__long_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_description",
                                ));
                            }
                            result.long_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__publisher => {
                            if !fields.insert(__FieldTag::__publisher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publisher",
                                ));
                            }
                            result.publisher = map.next_value::<std::option::Option<
                                crate::model::vulnerability_assessment_note::Publisher,
                            >>()?;
                        }
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product = map.next_value::<std::option::Option<
                                crate::model::vulnerability_assessment_note::Product,
                            >>()?;
                        }
                        __FieldTag::__assessment => {
                            if !fields.insert(__FieldTag::__assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assessment",
                                ));
                            }
                            result.assessment = map.next_value::<std::option::Option<
                                crate::model::vulnerability_assessment_note::Assessment,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vulnerability_assessment_note::Publisher {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __issuing_authority,
            __publisher_namespace,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Publisher")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "issuingAuthority" => Ok(__FieldTag::__issuing_authority),
                            "issuing_authority" => Ok(__FieldTag::__issuing_authority),
                            "publisherNamespace" => Ok(__FieldTag::__publisher_namespace),
                            "publisher_namespace" => Ok(__FieldTag::__publisher_namespace),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_assessment_note::Publisher;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Publisher")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__issuing_authority => {
                            if !fields.insert(__FieldTag::__issuing_authority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuing_authority",
                                ));
                            }
                            result.issuing_authority = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__publisher_namespace => {
                            if !fields.insert(__FieldTag::__publisher_namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publisher_namespace",
                                ));
                            }
                            result.publisher_namespace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vulnerability_assessment_note::Product {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __generic_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Product")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "genericUri" => Ok(__FieldTag::__generic_uri),
                            "generic_uri" => Ok(__FieldTag::__generic_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_assessment_note::Product;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Product")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generic_uri => {
                            if !fields.insert(__FieldTag::__generic_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generic_uri",
                                ));
                            }
                            if result.identifier.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `identifier`, a oneof with full ID .grafeas.v1.VulnerabilityAssessmentNote.Product.generic_uri, latest field was genericUri",
                                ));
                            }
                            result.identifier = std::option::Option::Some(
                                crate::model::vulnerability_assessment_note::product::Identifier::GenericUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vulnerability_assessment_note::Assessment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cve,
            __vulnerability_id,
            __short_description,
            __long_description,
            __related_uris,
            __state,
            __impacts,
            __justification,
            __remediations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Assessment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cve" => Ok(__FieldTag::__cve),
                            "vulnerabilityId" => Ok(__FieldTag::__vulnerability_id),
                            "vulnerability_id" => Ok(__FieldTag::__vulnerability_id),
                            "shortDescription" => Ok(__FieldTag::__short_description),
                            "short_description" => Ok(__FieldTag::__short_description),
                            "longDescription" => Ok(__FieldTag::__long_description),
                            "long_description" => Ok(__FieldTag::__long_description),
                            "relatedUris" => Ok(__FieldTag::__related_uris),
                            "related_uris" => Ok(__FieldTag::__related_uris),
                            "state" => Ok(__FieldTag::__state),
                            "impacts" => Ok(__FieldTag::__impacts),
                            "justification" => Ok(__FieldTag::__justification),
                            "remediations" => Ok(__FieldTag::__remediations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_assessment_note::Assessment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Assessment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cve => {
                            if !fields.insert(__FieldTag::__cve) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cve",
                                ));
                            }
                            result.cve = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vulnerability_id => {
                            if !fields.insert(__FieldTag::__vulnerability_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability_id",
                                ));
                            }
                            result.vulnerability_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__short_description => {
                            if !fields.insert(__FieldTag::__short_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for short_description",
                                ));
                            }
                            result.short_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__long_description => {
                            if !fields.insert(__FieldTag::__long_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_description",
                                ));
                            }
                            result.long_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__related_uris => {
                            if !fields.insert(__FieldTag::__related_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_uris",
                                ));
                            }
                            result.related_uris = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RelatedUrl>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::vulnerability_assessment_note::assessment::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__impacts => {
                            if !fields.insert(__FieldTag::__impacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for impacts",
                                ));
                            }
                            result.impacts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__justification => {
                            if !fields.insert(__FieldTag::__justification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for justification",
                                ));
                            }
                            result.justification = map.next_value::<std::option::Option<crate::model::vulnerability_assessment_note::assessment::Justification>>()?
                                ;
                        }
                        __FieldTag::__remediations => {
                            if !fields.insert(__FieldTag::__remediations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remediations",
                                ));
                            }
                            result.remediations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::vulnerability_assessment_note::assessment::Remediation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::vulnerability_assessment_note::assessment::Justification
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __justification_type,
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Justification")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "justificationType" => Ok(__FieldTag::__justification_type),
                            "justification_type" => Ok(__FieldTag::__justification_type),
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_assessment_note::assessment::Justification;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Justification")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__justification_type => {
                            if !fields.insert(__FieldTag::__justification_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for justification_type",
                                ));
                            }
                            result.justification_type = map.next_value::<std::option::Option<crate::model::vulnerability_assessment_note::assessment::justification::JustificationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::vulnerability_assessment_note::assessment::Remediation
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __remediation_type,
            __details,
            __remediation_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Remediation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "remediationType" => Ok(__FieldTag::__remediation_type),
                            "remediation_type" => Ok(__FieldTag::__remediation_type),
                            "details" => Ok(__FieldTag::__details),
                            "remediationUri" => Ok(__FieldTag::__remediation_uri),
                            "remediation_uri" => Ok(__FieldTag::__remediation_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_assessment_note::assessment::Remediation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Remediation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__remediation_type => {
                            if !fields.insert(__FieldTag::__remediation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remediation_type",
                                ));
                            }
                            result.remediation_type = map.next_value::<std::option::Option<crate::model::vulnerability_assessment_note::assessment::remediation::RemediationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remediation_uri => {
                            if !fields.insert(__FieldTag::__remediation_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remediation_uri",
                                ));
                            }
                            result.remediation_uri =
                                map.next_value::<std::option::Option<crate::model::RelatedUrl>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VulnerabilityNote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cvss_score,
            __severity,
            __details,
            __cvss_v3,
            __windows_details,
            __source_update_time,
            __cvss_version,
            __cvss_v2,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerabilityNote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cvssScore" => Ok(__FieldTag::__cvss_score),
                            "cvss_score" => Ok(__FieldTag::__cvss_score),
                            "severity" => Ok(__FieldTag::__severity),
                            "details" => Ok(__FieldTag::__details),
                            "cvssV3" => Ok(__FieldTag::__cvss_v3),
                            "cvss_v3" => Ok(__FieldTag::__cvss_v3),
                            "windowsDetails" => Ok(__FieldTag::__windows_details),
                            "windows_details" => Ok(__FieldTag::__windows_details),
                            "sourceUpdateTime" => Ok(__FieldTag::__source_update_time),
                            "source_update_time" => Ok(__FieldTag::__source_update_time),
                            "cvssVersion" => Ok(__FieldTag::__cvss_version),
                            "cvss_version" => Ok(__FieldTag::__cvss_version),
                            "cvssV2" => Ok(__FieldTag::__cvss_v2),
                            "cvss_v2" => Ok(__FieldTag::__cvss_v2),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VulnerabilityNote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerabilityNote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cvss_score => {
                            if !fields.insert(__FieldTag::__cvss_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cvss_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::vulnerability_note::Detail>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cvss_v3 => {
                            if !fields.insert(__FieldTag::__cvss_v3) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_v3",
                                ));
                            }
                            result.cvss_v3 =
                                map.next_value::<std::option::Option<crate::model::CVSSv3>>()?;
                        }
                        __FieldTag::__windows_details => {
                            if !fields.insert(__FieldTag::__windows_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_details",
                                ));
                            }
                            result.windows_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::vulnerability_note::WindowsDetail>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_update_time => {
                            if !fields.insert(__FieldTag::__source_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_update_time",
                                ));
                            }
                            result.source_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cvss_version => {
                            if !fields.insert(__FieldTag::__cvss_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_version",
                                ));
                            }
                            result.cvss_version = map
                                .next_value::<std::option::Option<crate::model::CVSSVersion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cvss_v2 => {
                            if !fields.insert(__FieldTag::__cvss_v2) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_v2",
                                ));
                            }
                            result.cvss_v2 =
                                map.next_value::<std::option::Option<crate::model::Cvss>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vulnerability_note::Detail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __severity_name,
            __description,
            __package_type,
            __affected_cpe_uri,
            __affected_package,
            __affected_version_start,
            __affected_version_end,
            __fixed_cpe_uri,
            __fixed_package,
            __fixed_version,
            __is_obsolete,
            __source_update_time,
            __source,
            __vendor,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Detail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "severityName" => Ok(__FieldTag::__severity_name),
                            "severity_name" => Ok(__FieldTag::__severity_name),
                            "description" => Ok(__FieldTag::__description),
                            "packageType" => Ok(__FieldTag::__package_type),
                            "package_type" => Ok(__FieldTag::__package_type),
                            "affectedCpeUri" => Ok(__FieldTag::__affected_cpe_uri),
                            "affected_cpe_uri" => Ok(__FieldTag::__affected_cpe_uri),
                            "affectedPackage" => Ok(__FieldTag::__affected_package),
                            "affected_package" => Ok(__FieldTag::__affected_package),
                            "affectedVersionStart" => Ok(__FieldTag::__affected_version_start),
                            "affected_version_start" => Ok(__FieldTag::__affected_version_start),
                            "affectedVersionEnd" => Ok(__FieldTag::__affected_version_end),
                            "affected_version_end" => Ok(__FieldTag::__affected_version_end),
                            "fixedCpeUri" => Ok(__FieldTag::__fixed_cpe_uri),
                            "fixed_cpe_uri" => Ok(__FieldTag::__fixed_cpe_uri),
                            "fixedPackage" => Ok(__FieldTag::__fixed_package),
                            "fixed_package" => Ok(__FieldTag::__fixed_package),
                            "fixedVersion" => Ok(__FieldTag::__fixed_version),
                            "fixed_version" => Ok(__FieldTag::__fixed_version),
                            "isObsolete" => Ok(__FieldTag::__is_obsolete),
                            "is_obsolete" => Ok(__FieldTag::__is_obsolete),
                            "sourceUpdateTime" => Ok(__FieldTag::__source_update_time),
                            "source_update_time" => Ok(__FieldTag::__source_update_time),
                            "source" => Ok(__FieldTag::__source),
                            "vendor" => Ok(__FieldTag::__vendor),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_note::Detail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Detail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__severity_name => {
                            if !fields.insert(__FieldTag::__severity_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity_name",
                                ));
                            }
                            result.severity_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__package_type => {
                            if !fields.insert(__FieldTag::__package_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_type",
                                ));
                            }
                            result.package_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__affected_cpe_uri => {
                            if !fields.insert(__FieldTag::__affected_cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for affected_cpe_uri",
                                ));
                            }
                            result.affected_cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__affected_package => {
                            if !fields.insert(__FieldTag::__affected_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for affected_package",
                                ));
                            }
                            result.affected_package = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__affected_version_start => {
                            if !fields.insert(__FieldTag::__affected_version_start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for affected_version_start",
                                ));
                            }
                            result.affected_version_start =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__affected_version_end => {
                            if !fields.insert(__FieldTag::__affected_version_end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for affected_version_end",
                                ));
                            }
                            result.affected_version_end =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__fixed_cpe_uri => {
                            if !fields.insert(__FieldTag::__fixed_cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed_cpe_uri",
                                ));
                            }
                            result.fixed_cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fixed_package => {
                            if !fields.insert(__FieldTag::__fixed_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed_package",
                                ));
                            }
                            result.fixed_package = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fixed_version => {
                            if !fields.insert(__FieldTag::__fixed_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed_version",
                                ));
                            }
                            result.fixed_version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__is_obsolete => {
                            if !fields.insert(__FieldTag::__is_obsolete) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_obsolete",
                                ));
                            }
                            result.is_obsolete = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_update_time => {
                            if !fields.insert(__FieldTag::__source_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_update_time",
                                ));
                            }
                            result.source_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vendor => {
                            if !fields.insert(__FieldTag::__vendor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vendor",
                                ));
                            }
                            result.vendor = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vulnerability_note::WindowsDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpe_uri,
            __name,
            __description,
            __fixing_kbs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "fixingKbs" => Ok(__FieldTag::__fixing_kbs),
                            "fixing_kbs" => Ok(__FieldTag::__fixing_kbs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_note::WindowsDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fixing_kbs => {
                            if !fields.insert(__FieldTag::__fixing_kbs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixing_kbs",
                                ));
                            }
                            result.fixing_kbs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::vulnerability_note::windows_detail::KnowledgeBase>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vulnerability_note::windows_detail::KnowledgeBase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeBase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "url" => Ok(__FieldTag::__url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_note::windows_detail::KnowledgeBase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeBase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VulnerabilityOccurrence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __severity,
            __cvss_score,
            __cvssv3,
            __package_issue,
            __short_description,
            __long_description,
            __related_urls,
            __effective_severity,
            __fix_available,
            __cvss_version,
            __cvss_v2,
            __vex_assessment,
            __extra_details,
            __risk,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerabilityOccurrence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "severity" => Ok(__FieldTag::__severity),
                            "cvssScore" => Ok(__FieldTag::__cvss_score),
                            "cvss_score" => Ok(__FieldTag::__cvss_score),
                            "cvssv3" => Ok(__FieldTag::__cvssv3),
                            "packageIssue" => Ok(__FieldTag::__package_issue),
                            "package_issue" => Ok(__FieldTag::__package_issue),
                            "shortDescription" => Ok(__FieldTag::__short_description),
                            "short_description" => Ok(__FieldTag::__short_description),
                            "longDescription" => Ok(__FieldTag::__long_description),
                            "long_description" => Ok(__FieldTag::__long_description),
                            "relatedUrls" => Ok(__FieldTag::__related_urls),
                            "related_urls" => Ok(__FieldTag::__related_urls),
                            "effectiveSeverity" => Ok(__FieldTag::__effective_severity),
                            "effective_severity" => Ok(__FieldTag::__effective_severity),
                            "fixAvailable" => Ok(__FieldTag::__fix_available),
                            "fix_available" => Ok(__FieldTag::__fix_available),
                            "cvssVersion" => Ok(__FieldTag::__cvss_version),
                            "cvss_version" => Ok(__FieldTag::__cvss_version),
                            "cvssV2" => Ok(__FieldTag::__cvss_v2),
                            "cvss_v2" => Ok(__FieldTag::__cvss_v2),
                            "vexAssessment" => Ok(__FieldTag::__vex_assessment),
                            "vex_assessment" => Ok(__FieldTag::__vex_assessment),
                            "extraDetails" => Ok(__FieldTag::__extra_details),
                            "extra_details" => Ok(__FieldTag::__extra_details),
                            "risk" => Ok(__FieldTag::__risk),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VulnerabilityOccurrence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerabilityOccurrence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cvss_score => {
                            if !fields.insert(__FieldTag::__cvss_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cvss_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cvssv3 => {
                            if !fields.insert(__FieldTag::__cvssv3) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvssv3",
                                ));
                            }
                            result.cvssv3 =
                                map.next_value::<std::option::Option<crate::model::Cvss>>()?;
                        }
                        __FieldTag::__package_issue => {
                            if !fields.insert(__FieldTag::__package_issue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_issue",
                                ));
                            }
                            result.package_issue = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::vulnerability_occurrence::PackageIssue,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__short_description => {
                            if !fields.insert(__FieldTag::__short_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for short_description",
                                ));
                            }
                            result.short_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__long_description => {
                            if !fields.insert(__FieldTag::__long_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_description",
                                ));
                            }
                            result.long_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__related_urls => {
                            if !fields.insert(__FieldTag::__related_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_urls",
                                ));
                            }
                            result.related_urls = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RelatedUrl>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__effective_severity => {
                            if !fields.insert(__FieldTag::__effective_severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effective_severity",
                                ));
                            }
                            result.effective_severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fix_available => {
                            if !fields.insert(__FieldTag::__fix_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fix_available",
                                ));
                            }
                            result.fix_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cvss_version => {
                            if !fields.insert(__FieldTag::__cvss_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_version",
                                ));
                            }
                            result.cvss_version = map
                                .next_value::<std::option::Option<crate::model::CVSSVersion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cvss_v2 => {
                            if !fields.insert(__FieldTag::__cvss_v2) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_v2",
                                ));
                            }
                            result.cvss_v2 =
                                map.next_value::<std::option::Option<crate::model::Cvss>>()?;
                        }
                        __FieldTag::__vex_assessment => {
                            if !fields.insert(__FieldTag::__vex_assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vex_assessment",
                                ));
                            }
                            result.vex_assessment = map.next_value::<std::option::Option<
                                crate::model::vulnerability_occurrence::VexAssessment,
                            >>()?;
                        }
                        __FieldTag::__extra_details => {
                            if !fields.insert(__FieldTag::__extra_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extra_details",
                                ));
                            }
                            result.extra_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__risk => {
                            if !fields.insert(__FieldTag::__risk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for risk",
                                ));
                            }
                            result.risk =
                                map.next_value::<std::option::Option<crate::model::Risk>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vulnerability_occurrence::PackageIssue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __affected_cpe_uri,
            __affected_package,
            __affected_version,
            __fixed_cpe_uri,
            __fixed_package,
            __fixed_version,
            __fix_available,
            __package_type,
            __effective_severity,
            __file_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PackageIssue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "affectedCpeUri" => Ok(__FieldTag::__affected_cpe_uri),
                            "affected_cpe_uri" => Ok(__FieldTag::__affected_cpe_uri),
                            "affectedPackage" => Ok(__FieldTag::__affected_package),
                            "affected_package" => Ok(__FieldTag::__affected_package),
                            "affectedVersion" => Ok(__FieldTag::__affected_version),
                            "affected_version" => Ok(__FieldTag::__affected_version),
                            "fixedCpeUri" => Ok(__FieldTag::__fixed_cpe_uri),
                            "fixed_cpe_uri" => Ok(__FieldTag::__fixed_cpe_uri),
                            "fixedPackage" => Ok(__FieldTag::__fixed_package),
                            "fixed_package" => Ok(__FieldTag::__fixed_package),
                            "fixedVersion" => Ok(__FieldTag::__fixed_version),
                            "fixed_version" => Ok(__FieldTag::__fixed_version),
                            "fixAvailable" => Ok(__FieldTag::__fix_available),
                            "fix_available" => Ok(__FieldTag::__fix_available),
                            "packageType" => Ok(__FieldTag::__package_type),
                            "package_type" => Ok(__FieldTag::__package_type),
                            "effectiveSeverity" => Ok(__FieldTag::__effective_severity),
                            "effective_severity" => Ok(__FieldTag::__effective_severity),
                            "fileLocation" => Ok(__FieldTag::__file_location),
                            "file_location" => Ok(__FieldTag::__file_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_occurrence::PackageIssue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PackageIssue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__affected_cpe_uri => {
                            if !fields.insert(__FieldTag::__affected_cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for affected_cpe_uri",
                                ));
                            }
                            result.affected_cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__affected_package => {
                            if !fields.insert(__FieldTag::__affected_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for affected_package",
                                ));
                            }
                            result.affected_package = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__affected_version => {
                            if !fields.insert(__FieldTag::__affected_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for affected_version",
                                ));
                            }
                            result.affected_version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__fixed_cpe_uri => {
                            if !fields.insert(__FieldTag::__fixed_cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed_cpe_uri",
                                ));
                            }
                            result.fixed_cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fixed_package => {
                            if !fields.insert(__FieldTag::__fixed_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed_package",
                                ));
                            }
                            result.fixed_package = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fixed_version => {
                            if !fields.insert(__FieldTag::__fixed_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed_version",
                                ));
                            }
                            result.fixed_version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__fix_available => {
                            if !fields.insert(__FieldTag::__fix_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fix_available",
                                ));
                            }
                            result.fix_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__package_type => {
                            if !fields.insert(__FieldTag::__package_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_type",
                                ));
                            }
                            result.package_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__effective_severity => {
                            if !fields.insert(__FieldTag::__effective_severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effective_severity",
                                ));
                            }
                            result.effective_severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_location => {
                            if !fields.insert(__FieldTag::__file_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_location",
                                ));
                            }
                            result.file_location = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FileLocation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vulnerability_occurrence::VexAssessment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cve,
            __vulnerability_id,
            __related_uris,
            __note_name,
            __state,
            __impacts,
            __remediations,
            __justification,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VexAssessment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cve" => Ok(__FieldTag::__cve),
                            "vulnerabilityId" => Ok(__FieldTag::__vulnerability_id),
                            "vulnerability_id" => Ok(__FieldTag::__vulnerability_id),
                            "relatedUris" => Ok(__FieldTag::__related_uris),
                            "related_uris" => Ok(__FieldTag::__related_uris),
                            "noteName" => Ok(__FieldTag::__note_name),
                            "note_name" => Ok(__FieldTag::__note_name),
                            "state" => Ok(__FieldTag::__state),
                            "impacts" => Ok(__FieldTag::__impacts),
                            "remediations" => Ok(__FieldTag::__remediations),
                            "justification" => Ok(__FieldTag::__justification),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_occurrence::VexAssessment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VexAssessment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cve => {
                            if !fields.insert(__FieldTag::__cve) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cve",
                                ));
                            }
                            result.cve = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vulnerability_id => {
                            if !fields.insert(__FieldTag::__vulnerability_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability_id",
                                ));
                            }
                            result.vulnerability_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__related_uris => {
                            if !fields.insert(__FieldTag::__related_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_uris",
                                ));
                            }
                            result.related_uris = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RelatedUrl>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__note_name => {
                            if !fields.insert(__FieldTag::__note_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note_name",
                                ));
                            }
                            result.note_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::vulnerability_assessment_note::assessment::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__impacts => {
                            if !fields.insert(__FieldTag::__impacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for impacts",
                                ));
                            }
                            result.impacts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__remediations => {
                            if !fields.insert(__FieldTag::__remediations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remediations",
                                ));
                            }
                            result.remediations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::vulnerability_assessment_note::assessment::Remediation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__justification => {
                            if !fields.insert(__FieldTag::__justification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for justification",
                                ));
                            }
                            result.justification = map.next_value::<std::option::Option<crate::model::vulnerability_assessment_note::assessment::Justification>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
