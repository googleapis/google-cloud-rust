// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate std;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// Note kind that represents a logical attestation "role" or "authority". For
/// example, an organization might have one `Authority` for "QA" and one for
/// "build". This note is intended to act strictly as a grouping mechanism for
/// the attached occurrences (Attestations). This grouping mechanism also
/// provides a security boundary, since IAM ACLs gate the ability for a principle
/// to attach an occurrence to a given note. It also provides a single point of
/// lookup to find all attached attestation occurrences, even if they don't all
/// live in the same project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttestationNote {

    /// Hint hints at the purpose of the attestation authority.
    pub hint: std::option::Option<crate::model::attestation_note::Hint>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttestationNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hint][crate::model::AttestationNote::hint].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::AttestationNote;
    /// use google_cloud_grafeas_v1::model::attestation_note::Hint;
    /// let x = AttestationNote::new().set_hint(Hint::default()/* use setters */);
    /// ```
    pub fn set_hint<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::attestation_note::Hint>
    {
        self.hint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hint][crate::model::AttestationNote::hint].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::AttestationNote;
    /// use google_cloud_grafeas_v1::model::attestation_note::Hint;
    /// let x = AttestationNote::new().set_or_clear_hint(Some(Hint::default()/* use setters */));
    /// let x = AttestationNote::new().set_or_clear_hint(None::<Hint>);
    /// ```
    pub fn set_or_clear_hint<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::attestation_note::Hint>
    {
        self.hint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AttestationNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.AttestationNote"
    }
}

/// Defines additional types related to [AttestationNote].
pub mod attestation_note {
    #[allow(unused_imports)]
    use super::*;


    /// This submessage provides human-readable hints about the purpose of the
    /// authority. Because the name of a note acts as its resource reference, it is
    /// important to disambiguate the canonical name of the Note (which might be a
    /// UUID for security purposes) from "readable" names more suitable for debug
    /// output. Note that these hints should not be used to look up authorities in
    /// security sensitive contexts, such as when looking up attestations to
    /// verify.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Hint {

        /// Required. The human readable name of this attestation authority, for
        /// example "qa".
        pub human_readable_name: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Hint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [human_readable_name][crate::model::attestation_note::Hint::human_readable_name].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::attestation_note::Hint;
        /// let x = Hint::new().set_human_readable_name("example");
        /// ```
        pub fn set_human_readable_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.human_readable_name = v.into();
            self
        }
    }

    impl wkt::message::Message for Hint {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.AttestationNote.Hint"
        }
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Jwt {

    /// The compact encoding of a JWS, which is always three base64 encoded strings
    /// joined by periods. For details, see:
    /// <https://tools.ietf.org/html/rfc7515.html#section-3.1>
    pub compact_jwt: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Jwt {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [compact_jwt][crate::model::Jwt::compact_jwt].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Jwt;
    /// let x = Jwt::new().set_compact_jwt("example");
    /// ```
    pub fn set_compact_jwt<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compact_jwt = v.into();
        self
    }
}

impl wkt::message::Message for Jwt {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Jwt"
    }
}

/// Occurrence that represents a single "attestation". The authenticity of an
/// attestation can be verified using the attached signature. If the verifier
/// trusts the public key of the signer, then verifying the signature is
/// sufficient to establish trust. In this circumstance, the authority to which
/// this attestation is attached is primarily useful for lookup (how to find
/// this attestation if you already know the authority and artifact to be
/// verified) and intent (for which authority this attestation was intended to
/// sign.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttestationOccurrence {

    /// Required. The serialized payload that is verified by one or more
    /// `signatures`.
    pub serialized_payload: ::bytes::Bytes,

    /// One or more signatures over `serialized_payload`.  Verifier implementations
    /// should consider this attestation message verified if at least one
    /// `signature` verifies `serialized_payload`.  See `Signature` in common.proto
    /// for more details on signature structure and verification.
    pub signatures: std::vec::Vec<crate::model::Signature>,

    /// One or more JWTs encoding a self-contained attestation.
    /// Each JWT encodes the payload that it verifies within the JWT itself.
    /// Verifier implementation SHOULD ignore the `serialized_payload` field
    /// when verifying these JWTs.
    /// If only JWTs are present on this AttestationOccurrence, then the
    /// `serialized_payload` SHOULD be left empty.
    /// Each JWT SHOULD encode a claim specific to the `resource_uri` of this
    /// Occurrence, but this is not validated by Grafeas metadata API
    /// implementations.  The JWT itself is opaque to Grafeas.
    pub jwts: std::vec::Vec<crate::model::Jwt>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttestationOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serialized_payload][crate::model::AttestationOccurrence::serialized_payload].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::AttestationOccurrence;
    /// let x = AttestationOccurrence::new().set_serialized_payload(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_serialized_payload<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.serialized_payload = v.into();
        self
    }

    /// Sets the value of [signatures][crate::model::AttestationOccurrence::signatures].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::AttestationOccurrence;
    /// use google_cloud_grafeas_v1::model::Signature;
    /// let x = AttestationOccurrence::new()
    ///     .set_signatures([
    ///         Signature::default()/* use setters */,
    ///         Signature::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Signature>
    {
        use std::iter::Iterator;
        self.signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jwts][crate::model::AttestationOccurrence::jwts].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::AttestationOccurrence;
    /// use google_cloud_grafeas_v1::model::Jwt;
    /// let x = AttestationOccurrence::new()
    ///     .set_jwts([
    ///         Jwt::default()/* use setters */,
    ///         Jwt::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_jwts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Jwt>
    {
        use std::iter::Iterator;
        self.jwts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AttestationOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.AttestationOccurrence"
    }
}

/// Note holding the version of the provider's builder and the signature of the
/// provenance message in the build details occurrence.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildNote {

    /// Required. Immutable. Version of the builder which produced this build.
    pub builder_version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder_version][crate::model::BuildNote::builder_version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildNote;
    /// let x = BuildNote::new().set_builder_version("example");
    /// ```
    pub fn set_builder_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.builder_version = v.into();
        self
    }
}

impl wkt::message::Message for BuildNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuildNote"
    }
}

/// Details of a build occurrence.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildOccurrence {

    /// The actual provenance for the build.
    pub provenance: std::option::Option<crate::model::BuildProvenance>,

    /// Serialized JSON representation of the provenance, used in generating the
    /// build signature in the corresponding build note. After verifying the
    /// signature, `provenance_bytes` can be unmarshalled and compared to the
    /// provenance to confirm that it is unchanged. A base64-encoded string
    /// representation of the provenance bytes is used for the signature in order
    /// to interoperate with openssl which expects this format for signature
    /// verification.
    ///
    /// The serialized form is captured both to avoid ambiguity in how the
    /// provenance is marshalled to json as well to prevent incompatibilities with
    /// future changes.
    pub provenance_bytes: std::string::String,

    /// Deprecated. See InTotoStatement for the replacement.
    /// In-toto Provenance representation as defined in spec.
    pub intoto_provenance: std::option::Option<crate::model::InTotoProvenance>,

    /// In-toto Statement representation as defined in spec.
    /// The intoto_statement can contain any type of provenance. The serialized
    /// payload of the statement can be stored and signed in the Occurrence's
    /// envelope.
    pub intoto_statement: std::option::Option<crate::model::InTotoStatement>,

    /// In-Toto Slsa Provenance V1 represents a slsa provenance meeting the slsa
    /// spec, wrapped in an in-toto statement. This allows for direct
    /// jsonification of a to-spec in-toto slsa statement with a to-spec
    /// slsa provenance.
    pub in_toto_slsa_provenance_v1: std::option::Option<crate::model::InTotoSlsaProvenanceV1>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provenance][crate::model::BuildOccurrence::provenance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildOccurrence;
    /// use google_cloud_grafeas_v1::model::BuildProvenance;
    /// let x = BuildOccurrence::new().set_provenance(BuildProvenance::default()/* use setters */);
    /// ```
    pub fn set_provenance<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::BuildProvenance>
    {
        self.provenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provenance][crate::model::BuildOccurrence::provenance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildOccurrence;
    /// use google_cloud_grafeas_v1::model::BuildProvenance;
    /// let x = BuildOccurrence::new().set_or_clear_provenance(Some(BuildProvenance::default()/* use setters */));
    /// let x = BuildOccurrence::new().set_or_clear_provenance(None::<BuildProvenance>);
    /// ```
    pub fn set_or_clear_provenance<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::BuildProvenance>
    {
        self.provenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provenance_bytes][crate::model::BuildOccurrence::provenance_bytes].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildOccurrence;
    /// let x = BuildOccurrence::new().set_provenance_bytes("example");
    /// ```
    pub fn set_provenance_bytes<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.provenance_bytes = v.into();
        self
    }

    /// Sets the value of [intoto_provenance][crate::model::BuildOccurrence::intoto_provenance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildOccurrence;
    /// use google_cloud_grafeas_v1::model::InTotoProvenance;
    /// let x = BuildOccurrence::new().set_intoto_provenance(InTotoProvenance::default()/* use setters */);
    /// ```
    pub fn set_intoto_provenance<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::InTotoProvenance>
    {
        self.intoto_provenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intoto_provenance][crate::model::BuildOccurrence::intoto_provenance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildOccurrence;
    /// use google_cloud_grafeas_v1::model::InTotoProvenance;
    /// let x = BuildOccurrence::new().set_or_clear_intoto_provenance(Some(InTotoProvenance::default()/* use setters */));
    /// let x = BuildOccurrence::new().set_or_clear_intoto_provenance(None::<InTotoProvenance>);
    /// ```
    pub fn set_or_clear_intoto_provenance<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::InTotoProvenance>
    {
        self.intoto_provenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [intoto_statement][crate::model::BuildOccurrence::intoto_statement].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildOccurrence;
    /// use google_cloud_grafeas_v1::model::InTotoStatement;
    /// let x = BuildOccurrence::new().set_intoto_statement(InTotoStatement::default()/* use setters */);
    /// ```
    pub fn set_intoto_statement<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::InTotoStatement>
    {
        self.intoto_statement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intoto_statement][crate::model::BuildOccurrence::intoto_statement].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildOccurrence;
    /// use google_cloud_grafeas_v1::model::InTotoStatement;
    /// let x = BuildOccurrence::new().set_or_clear_intoto_statement(Some(InTotoStatement::default()/* use setters */));
    /// let x = BuildOccurrence::new().set_or_clear_intoto_statement(None::<InTotoStatement>);
    /// ```
    pub fn set_or_clear_intoto_statement<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::InTotoStatement>
    {
        self.intoto_statement = v.map(|x| x.into());
        self
    }

    /// Sets the value of [in_toto_slsa_provenance_v1][crate::model::BuildOccurrence::in_toto_slsa_provenance_v1].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildOccurrence;
    /// use google_cloud_grafeas_v1::model::InTotoSlsaProvenanceV1;
    /// let x = BuildOccurrence::new().set_in_toto_slsa_provenance_v1(InTotoSlsaProvenanceV1::default()/* use setters */);
    /// ```
    pub fn set_in_toto_slsa_provenance_v1<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::InTotoSlsaProvenanceV1>
    {
        self.in_toto_slsa_provenance_v1 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [in_toto_slsa_provenance_v1][crate::model::BuildOccurrence::in_toto_slsa_provenance_v1].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildOccurrence;
    /// use google_cloud_grafeas_v1::model::InTotoSlsaProvenanceV1;
    /// let x = BuildOccurrence::new().set_or_clear_in_toto_slsa_provenance_v1(Some(InTotoSlsaProvenanceV1::default()/* use setters */));
    /// let x = BuildOccurrence::new().set_or_clear_in_toto_slsa_provenance_v1(None::<InTotoSlsaProvenanceV1>);
    /// ```
    pub fn set_or_clear_in_toto_slsa_provenance_v1<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::InTotoSlsaProvenanceV1>
    {
        self.in_toto_slsa_provenance_v1 = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BuildOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuildOccurrence"
    }
}

/// Metadata for any related URL information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RelatedUrl {

    /// Specific URL associated with the resource.
    pub url: std::string::String,

    /// Label to describe usage of the URL.
    pub label: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedUrl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::RelatedUrl::url].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::RelatedUrl;
    /// let x = RelatedUrl::new().set_url("example");
    /// ```
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [label][crate::model::RelatedUrl::label].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::RelatedUrl;
    /// let x = RelatedUrl::new().set_label("example");
    /// ```
    pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label = v.into();
        self
    }
}

impl wkt::message::Message for RelatedUrl {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.RelatedUrl"
    }
}

/// Verifiers (e.g. Kritis implementations) MUST verify signatures
/// with respect to the trust anchors defined in policy (e.g. a Kritis policy).
/// Typically this means that the verifier has been configured with a map from
/// `public_key_id` to public key material (and any required parameters, e.g.
/// signing algorithm).
///
/// In particular, verification implementations MUST NOT treat the signature
/// `public_key_id` as anything more than a key lookup hint. The `public_key_id`
/// DOES NOT validate or authenticate a public key; it only provides a mechanism
/// for quickly selecting a public key ALREADY CONFIGURED on the verifier through
/// a trusted channel. Verification implementations MUST reject signatures in any
/// of the following circumstances:
///
/// * The `public_key_id` is not recognized by the verifier.
/// * The public key that `public_key_id` refers to does not verify the
///   signature with respect to the payload.
///
/// The `signature` contents SHOULD NOT be "attached" (where the payload is
/// included with the serialized `signature` bytes). Verifiers MUST ignore any
/// "attached" payload and only verify signatures with respect to explicitly
/// provided payload (e.g. a `payload` field on the proto message that holds
/// this Signature, or the canonical serialization of the proto message that
/// holds this signature).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Signature {

    /// The content of the signature, an opaque bytestring.
    /// The payload that this signature verifies MUST be unambiguously provided
    /// with the Signature during verification. A wrapper message might provide
    /// the payload explicitly. Alternatively, a message might have a canonical
    /// serialization that can always be unambiguously computed to derive the
    /// payload.
    pub signature: ::bytes::Bytes,

    /// The identifier for the public key that verifies this signature.
    ///
    /// * The `public_key_id` is required.
    /// * The `public_key_id` SHOULD be an RFC3986 conformant URI.
    /// * When possible, the `public_key_id` SHOULD be an immutable reference,
    ///   such as a cryptographic digest.
    ///
    /// Examples of valid `public_key_id`s:
    ///
    /// OpenPGP V4 public key fingerprint:
    ///
    /// * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA"
    ///   See <https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr> for more
    ///   details on this scheme.
    ///
    /// RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
    /// serialization):
    ///
    /// * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU"
    /// * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
    pub public_key_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Signature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [signature][crate::model::Signature::signature].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Signature;
    /// let x = Signature::new().set_signature(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_signature<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.signature = v.into();
        self
    }

    /// Sets the value of [public_key_id][crate::model::Signature::public_key_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Signature;
    /// let x = Signature::new().set_public_key_id("example");
    /// ```
    pub fn set_public_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key_id = v.into();
        self
    }
}

impl wkt::message::Message for Signature {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Signature"
    }
}

/// MUST match
/// <https://github.com/secure-systems-lab/dsse/blob/master/envelope.proto>. An
/// authenticated message of arbitrary type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Envelope {

    pub payload: ::bytes::Bytes,

    pub payload_type: std::string::String,

    pub signatures: std::vec::Vec<crate::model::EnvelopeSignature>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Envelope {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload][crate::model::Envelope::payload].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Envelope;
    /// let x = Envelope::new().set_payload(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_payload<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [payload_type][crate::model::Envelope::payload_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Envelope;
    /// let x = Envelope::new().set_payload_type("example");
    /// ```
    pub fn set_payload_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload_type = v.into();
        self
    }

    /// Sets the value of [signatures][crate::model::Envelope::signatures].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Envelope;
    /// use google_cloud_grafeas_v1::model::EnvelopeSignature;
    /// let x = Envelope::new()
    ///     .set_signatures([
    ///         EnvelopeSignature::default()/* use setters */,
    ///         EnvelopeSignature::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvelopeSignature>
    {
        use std::iter::Iterator;
        self.signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Envelope {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Envelope"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnvelopeSignature {

    pub sig: ::bytes::Bytes,

    pub keyid: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnvelopeSignature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sig][crate::model::EnvelopeSignature::sig].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::EnvelopeSignature;
    /// let x = EnvelopeSignature::new().set_sig(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_sig<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.sig = v.into();
        self
    }

    /// Sets the value of [keyid][crate::model::EnvelopeSignature::keyid].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::EnvelopeSignature;
    /// let x = EnvelopeSignature::new().set_keyid("example");
    /// ```
    pub fn set_keyid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.keyid = v.into();
        self
    }
}

impl wkt::message::Message for EnvelopeSignature {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.EnvelopeSignature"
    }
}

/// Indicates the location at which a package was found.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FileLocation {

    /// For jars that are contained inside .war files, this filepath
    /// can indicate the path to war file combined with the path to jar file.
    pub file_path: std::string::String,

    /// Each package found in a file should have its own layer metadata (that is,
    /// information from the origin layer of the package).
    pub layer_details: std::option::Option<crate::model::LayerDetails>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_path][crate::model::FileLocation::file_path].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::FileLocation;
    /// let x = FileLocation::new().set_file_path("example");
    /// ```
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }

    /// Sets the value of [layer_details][crate::model::FileLocation::layer_details].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::FileLocation;
    /// use google_cloud_grafeas_v1::model::LayerDetails;
    /// let x = FileLocation::new().set_layer_details(LayerDetails::default()/* use setters */);
    /// ```
    pub fn set_layer_details<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::LayerDetails>
    {
        self.layer_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [layer_details][crate::model::FileLocation::layer_details].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::FileLocation;
    /// use google_cloud_grafeas_v1::model::LayerDetails;
    /// let x = FileLocation::new().set_or_clear_layer_details(Some(LayerDetails::default()/* use setters */));
    /// let x = FileLocation::new().set_or_clear_layer_details(None::<LayerDetails>);
    /// ```
    pub fn set_or_clear_layer_details<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::LayerDetails>
    {
        self.layer_details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FileLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.FileLocation"
    }
}

/// BaseImage describes a base image of a container image.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BaseImage {

    /// The name of the base image.
    pub name: std::string::String,

    /// The repository name in which the base image is from.
    pub repository: std::string::String,

    /// The number of layers that the base image is composed of.
    pub layer_count: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BaseImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BaseImage::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BaseImage;
    /// let x = BaseImage::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::BaseImage::repository].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BaseImage;
    /// let x = BaseImage::new().set_repository("example");
    /// ```
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [layer_count][crate::model::BaseImage::layer_count].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BaseImage;
    /// let x = BaseImage::new().set_layer_count(42);
    /// ```
    pub fn set_layer_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.layer_count = v.into();
        self
    }
}

impl wkt::message::Message for BaseImage {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BaseImage"
    }
}

/// Details about the layer a package was found in.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LayerDetails {

    /// The index of the layer in the container image.
    pub index: i32,

    /// The diff ID (typically a sha256 hash) of the layer in the container image.
    pub diff_id: std::string::String,

    /// The layer chain ID (sha256 hash) of the layer in the container image.
    /// <https://github.com/opencontainers/image-spec/blob/main/config.md#layer-chainid>
    pub chain_id: std::string::String,

    /// The layer build command that was used to build the layer. This may not be
    /// found in all layers depending on how the container image is built.
    pub command: std::string::String,

    /// The base images the layer is found within.
    pub base_images: std::vec::Vec<crate::model::BaseImage>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LayerDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::LayerDetails::index].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::LayerDetails;
    /// let x = LayerDetails::new().set_index(42);
    /// ```
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [diff_id][crate::model::LayerDetails::diff_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::LayerDetails;
    /// let x = LayerDetails::new().set_diff_id("example");
    /// ```
    pub fn set_diff_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.diff_id = v.into();
        self
    }

    /// Sets the value of [chain_id][crate::model::LayerDetails::chain_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::LayerDetails;
    /// let x = LayerDetails::new().set_chain_id("example");
    /// ```
    pub fn set_chain_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.chain_id = v.into();
        self
    }

    /// Sets the value of [command][crate::model::LayerDetails::command].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::LayerDetails;
    /// let x = LayerDetails::new().set_command("example");
    /// ```
    pub fn set_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command = v.into();
        self
    }

    /// Sets the value of [base_images][crate::model::LayerDetails::base_images].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::LayerDetails;
    /// use google_cloud_grafeas_v1::model::BaseImage;
    /// let x = LayerDetails::new()
    ///     .set_base_images([
    ///         BaseImage::default()/* use setters */,
    ///         BaseImage::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_base_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BaseImage>
    {
        use std::iter::Iterator;
        self.base_images = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LayerDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.LayerDetails"
    }
}

/// License information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct License {

    /// Often a single license can be used to represent the licensing terms.
    /// Sometimes it is necessary to include a choice of one or more licenses
    /// or some combination of license identifiers.
    /// Examples: "LGPL-2.1-only OR MIT", "LGPL-2.1-only AND MIT",
    /// "GPL-2.0-or-later WITH Bison-exception-2.2".
    pub expression: std::string::String,

    /// Comments
    pub comments: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl License {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expression][crate::model::License::expression].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::License;
    /// let x = License::new().set_expression("example");
    /// ```
    pub fn set_expression<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.expression = v.into();
        self
    }

    /// Sets the value of [comments][crate::model::License::comments].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::License;
    /// let x = License::new().set_comments("example");
    /// ```
    pub fn set_comments<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comments = v.into();
        self
    }
}

impl wkt::message::Message for License {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.License"
    }
}

/// Digest information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Digest {

    /// `SHA1`, `SHA512` etc.
    pub algo: std::string::String,

    /// Value of the digest.
    pub digest_bytes: ::bytes::Bytes,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Digest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [algo][crate::model::Digest::algo].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Digest;
    /// let x = Digest::new().set_algo("example");
    /// ```
    pub fn set_algo<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.algo = v.into();
        self
    }

    /// Sets the value of [digest_bytes][crate::model::Digest::digest_bytes].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Digest;
    /// let x = Digest::new().set_digest_bytes(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_digest_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.digest_bytes = v.into();
        self
    }
}

impl wkt::message::Message for Digest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Digest"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComplianceNote {

    /// The title that identifies this compliance check.
    pub title: std::string::String,

    /// A description about this compliance check.
    pub description: std::string::String,

    /// The OS and config versions the benchmark applies to.
    pub version: std::vec::Vec<crate::model::ComplianceVersion>,

    /// A rationale for the existence of this compliance check.
    pub rationale: std::string::String,

    /// A description of remediation steps if the compliance check fails.
    pub remediation: std::string::String,

    /// Serialized scan instructions with a predefined format.
    pub scan_instructions: ::bytes::Bytes,

    pub compliance_type: std::option::Option<crate::model::compliance_note::ComplianceType>,

    /// Potential impact of the suggested remediation
    pub potential_impact: std::option::Option<crate::model::compliance_note::PotentialImpact>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::ComplianceNote::title].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceNote;
    /// let x = ComplianceNote::new().set_title("example");
    /// ```
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ComplianceNote::description].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceNote;
    /// let x = ComplianceNote::new().set_description("example");
    /// ```
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [version][crate::model::ComplianceNote::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceNote;
    /// use google_cloud_grafeas_v1::model::ComplianceVersion;
    /// let x = ComplianceNote::new()
    ///     .set_version([
    ///         ComplianceVersion::default()/* use setters */,
    ///         ComplianceVersion::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_version<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ComplianceVersion>
    {
        use std::iter::Iterator;
        self.version = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rationale][crate::model::ComplianceNote::rationale].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceNote;
    /// let x = ComplianceNote::new().set_rationale("example");
    /// ```
    pub fn set_rationale<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rationale = v.into();
        self
    }

    /// Sets the value of [remediation][crate::model::ComplianceNote::remediation].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceNote;
    /// let x = ComplianceNote::new().set_remediation("example");
    /// ```
    pub fn set_remediation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remediation = v.into();
        self
    }

    /// Sets the value of [scan_instructions][crate::model::ComplianceNote::scan_instructions].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceNote;
    /// let x = ComplianceNote::new().set_scan_instructions(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_scan_instructions<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.scan_instructions = v.into();
        self
    }

    /// Sets the value of [compliance_type][crate::model::ComplianceNote::compliance_type].
    ///
    /// Note that all the setters affecting `compliance_type` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceNote;
    /// use google_cloud_grafeas_v1::model::compliance_note::CisBenchmark;
    /// let x = ComplianceNote::new().set_compliance_type(Some(
    ///     google_cloud_grafeas_v1::model::compliance_note::ComplianceType::CisBenchmark(CisBenchmark::default().into())));
    /// ```
    pub fn set_compliance_type<T: std::convert::Into<std::option::Option<crate::model::compliance_note::ComplianceType>>>(mut self, v: T) -> Self
    {
        self.compliance_type = v.into();
        self
    }

    /// The value of [compliance_type][crate::model::ComplianceNote::compliance_type]
    /// if it holds a `CisBenchmark`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cis_benchmark(&self) -> std::option::Option<&std::boxed::Box<crate::model::compliance_note::CisBenchmark>> {
        #[allow(unreachable_patterns)]
        self.compliance_type.as_ref().and_then(|v| match v {
            crate::model::compliance_note::ComplianceType::CisBenchmark(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compliance_type][crate::model::ComplianceNote::compliance_type]
    /// to hold a `CisBenchmark`.
    ///
    /// Note that all the setters affecting `compliance_type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceNote;
    /// use google_cloud_grafeas_v1::model::compliance_note::CisBenchmark;
    /// let x = ComplianceNote::new().set_cis_benchmark(CisBenchmark::default()/* use setters */);
    /// assert!(x.cis_benchmark().is_some());
    /// ```
    pub fn set_cis_benchmark<T: std::convert::Into<std::boxed::Box<crate::model::compliance_note::CisBenchmark>>>(mut self, v: T) -> Self {
        self.compliance_type = std::option::Option::Some(
            crate::model::compliance_note::ComplianceType::CisBenchmark(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [potential_impact][crate::model::ComplianceNote::potential_impact].
    ///
    /// Note that all the setters affecting `potential_impact` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceNote;
    /// use google_cloud_grafeas_v1::model::compliance_note::PotentialImpact;
    /// let x = ComplianceNote::new().set_potential_impact(Some(PotentialImpact::Impact("example".to_string())));
    /// ```
    pub fn set_potential_impact<T: std::convert::Into<std::option::Option<crate::model::compliance_note::PotentialImpact>>>(mut self, v: T) -> Self
    {
        self.potential_impact = v.into();
        self
    }

    /// The value of [potential_impact][crate::model::ComplianceNote::potential_impact]
    /// if it holds a `Impact`, `None` if the field is not set or
    /// holds a different branch.
    pub fn impact(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.potential_impact.as_ref().and_then(|v| match v {
            crate::model::compliance_note::PotentialImpact::Impact(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [potential_impact][crate::model::ComplianceNote::potential_impact]
    /// to hold a `Impact`.
    ///
    /// Note that all the setters affecting `potential_impact` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceNote;
    /// let x = ComplianceNote::new().set_impact("example");
    /// assert!(x.impact().is_some());
    /// ```
    pub fn set_impact<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.potential_impact = std::option::Option::Some(
            crate::model::compliance_note::PotentialImpact::Impact(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for ComplianceNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ComplianceNote"
    }
}

/// Defines additional types related to [ComplianceNote].
pub mod compliance_note {
    #[allow(unused_imports)]
    use super::*;


    /// A compliance check that is a CIS benchmark.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CisBenchmark {

        pub profile_level: i32,

        pub severity: crate::model::Severity,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CisBenchmark {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [profile_level][crate::model::compliance_note::CisBenchmark::profile_level].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::compliance_note::CisBenchmark;
        /// let x = CisBenchmark::new().set_profile_level(42);
        /// ```
        pub fn set_profile_level<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.profile_level = v.into();
            self
        }

        /// Sets the value of [severity][crate::model::compliance_note::CisBenchmark::severity].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::compliance_note::CisBenchmark;
        /// use google_cloud_grafeas_v1::model::Severity;
        /// let x0 = CisBenchmark::new().set_severity(Severity::Minimal);
        /// let x1 = CisBenchmark::new().set_severity(Severity::Low);
        /// let x2 = CisBenchmark::new().set_severity(Severity::Medium);
        /// ```
        pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
            self.severity = v.into();
            self
        }
    }

    impl wkt::message::Message for CisBenchmark {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.ComplianceNote.CisBenchmark"
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ComplianceType {
        CisBenchmark(std::boxed::Box<crate::model::compliance_note::CisBenchmark>),
    }

    /// Potential impact of the suggested remediation
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PotentialImpact {
        Impact(std::string::String),
    }
}

/// Describes the CIS benchmark version that is applicable to a given OS and
/// os version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComplianceVersion {

    /// The CPE URI (<https://cpe.mitre.org/specification/>) this benchmark is
    /// applicable to.
    pub cpe_uri: std::string::String,

    /// The name of the document that defines this benchmark, e.g. "CIS
    /// Container-Optimized OS".
    pub benchmark_document: std::string::String,

    /// The version of the benchmark. This is set to the version of the OS-specific
    /// CIS document the benchmark is defined in.
    pub version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::ComplianceVersion::cpe_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceVersion;
    /// let x = ComplianceVersion::new().set_cpe_uri("example");
    /// ```
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [benchmark_document][crate::model::ComplianceVersion::benchmark_document].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceVersion;
    /// let x = ComplianceVersion::new().set_benchmark_document("example");
    /// ```
    pub fn set_benchmark_document<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.benchmark_document = v.into();
        self
    }

    /// Sets the value of [version][crate::model::ComplianceVersion::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceVersion;
    /// let x = ComplianceVersion::new().set_version("example");
    /// ```
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for ComplianceVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ComplianceVersion"
    }
}

/// An indication that the compliance checks in the associated ComplianceNote
/// were not satisfied for particular resources or a specified reason.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComplianceOccurrence {

    pub non_compliant_files: std::vec::Vec<crate::model::NonCompliantFile>,

    pub non_compliance_reason: std::string::String,

    /// The OS and config version the benchmark was run on.
    pub version: std::option::Option<crate::model::ComplianceVersion>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [non_compliant_files][crate::model::ComplianceOccurrence::non_compliant_files].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceOccurrence;
    /// use google_cloud_grafeas_v1::model::NonCompliantFile;
    /// let x = ComplianceOccurrence::new()
    ///     .set_non_compliant_files([
    ///         NonCompliantFile::default()/* use setters */,
    ///         NonCompliantFile::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_non_compliant_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NonCompliantFile>
    {
        use std::iter::Iterator;
        self.non_compliant_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [non_compliance_reason][crate::model::ComplianceOccurrence::non_compliance_reason].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceOccurrence;
    /// let x = ComplianceOccurrence::new().set_non_compliance_reason("example");
    /// ```
    pub fn set_non_compliance_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.non_compliance_reason = v.into();
        self
    }

    /// Sets the value of [version][crate::model::ComplianceOccurrence::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceOccurrence;
    /// use google_cloud_grafeas_v1::model::ComplianceVersion;
    /// let x = ComplianceOccurrence::new().set_version(ComplianceVersion::default()/* use setters */);
    /// ```
    pub fn set_version<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::ComplianceVersion>
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::ComplianceOccurrence::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ComplianceOccurrence;
    /// use google_cloud_grafeas_v1::model::ComplianceVersion;
    /// let x = ComplianceOccurrence::new().set_or_clear_version(Some(ComplianceVersion::default()/* use setters */));
    /// let x = ComplianceOccurrence::new().set_or_clear_version(None::<ComplianceVersion>);
    /// ```
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::ComplianceVersion>
    {
        self.version = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComplianceOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ComplianceOccurrence"
    }
}

/// Details about files that caused a compliance check to fail.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NonCompliantFile {

    /// Empty if `display_command` is set.
    pub path: std::string::String,

    /// Command to display the non-compliant files.
    pub display_command: std::string::String,

    /// Explains why a file is non compliant for a CIS check.
    pub reason: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NonCompliantFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::NonCompliantFile::path].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::NonCompliantFile;
    /// let x = NonCompliantFile::new().set_path("example");
    /// ```
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [display_command][crate::model::NonCompliantFile::display_command].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::NonCompliantFile;
    /// let x = NonCompliantFile::new().set_display_command("example");
    /// ```
    pub fn set_display_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_command = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::NonCompliantFile::reason].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::NonCompliantFile;
    /// let x = NonCompliantFile::new().set_reason("example");
    /// ```
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for NonCompliantFile {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.NonCompliantFile"
    }
}

/// Common Vulnerability Scoring System version 3.
/// For details, see <https://www.first.org/cvss/specification-document>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CVSSv3 {

    /// The base score is a function of the base metric scores.
    pub base_score: f32,

    pub exploitability_score: f32,

    pub impact_score: f32,

    /// Base Metrics
    /// Represents the intrinsic characteristics of a vulnerability that are
    /// constant over time and across user environments.
    pub attack_vector: crate::model::cvs_sv_3::AttackVector,

    pub attack_complexity: crate::model::cvs_sv_3::AttackComplexity,

    pub privileges_required: crate::model::cvs_sv_3::PrivilegesRequired,

    pub user_interaction: crate::model::cvs_sv_3::UserInteraction,

    pub scope: crate::model::cvs_sv_3::Scope,

    pub confidentiality_impact: crate::model::cvs_sv_3::Impact,

    pub integrity_impact: crate::model::cvs_sv_3::Impact,

    pub availability_impact: crate::model::cvs_sv_3::Impact,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CVSSv3 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_score][crate::model::CVSSv3::base_score].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CVSSv3;
    /// let x = CVSSv3::new().set_base_score(42.0);
    /// ```
    pub fn set_base_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.base_score = v.into();
        self
    }

    /// Sets the value of [exploitability_score][crate::model::CVSSv3::exploitability_score].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CVSSv3;
    /// let x = CVSSv3::new().set_exploitability_score(42.0);
    /// ```
    pub fn set_exploitability_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.exploitability_score = v.into();
        self
    }

    /// Sets the value of [impact_score][crate::model::CVSSv3::impact_score].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CVSSv3;
    /// let x = CVSSv3::new().set_impact_score(42.0);
    /// ```
    pub fn set_impact_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.impact_score = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::CVSSv3::attack_vector].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CVSSv3;
    /// use google_cloud_grafeas_v1::model::cvs_sv_3::AttackVector;
    /// let x0 = CVSSv3::new().set_attack_vector(AttackVector::Network);
    /// let x1 = CVSSv3::new().set_attack_vector(AttackVector::Adjacent);
    /// let x2 = CVSSv3::new().set_attack_vector(AttackVector::Local);
    /// ```
    pub fn set_attack_vector<T: std::convert::Into<crate::model::cvs_sv_3::AttackVector>>(mut self, v: T) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [attack_complexity][crate::model::CVSSv3::attack_complexity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CVSSv3;
    /// use google_cloud_grafeas_v1::model::cvs_sv_3::AttackComplexity;
    /// let x0 = CVSSv3::new().set_attack_complexity(AttackComplexity::Low);
    /// let x1 = CVSSv3::new().set_attack_complexity(AttackComplexity::High);
    /// ```
    pub fn set_attack_complexity<T: std::convert::Into<crate::model::cvs_sv_3::AttackComplexity>>(mut self, v: T) -> Self {
        self.attack_complexity = v.into();
        self
    }

    /// Sets the value of [privileges_required][crate::model::CVSSv3::privileges_required].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CVSSv3;
    /// use google_cloud_grafeas_v1::model::cvs_sv_3::PrivilegesRequired;
    /// let x0 = CVSSv3::new().set_privileges_required(PrivilegesRequired::None);
    /// let x1 = CVSSv3::new().set_privileges_required(PrivilegesRequired::Low);
    /// let x2 = CVSSv3::new().set_privileges_required(PrivilegesRequired::High);
    /// ```
    pub fn set_privileges_required<T: std::convert::Into<crate::model::cvs_sv_3::PrivilegesRequired>>(mut self, v: T) -> Self {
        self.privileges_required = v.into();
        self
    }

    /// Sets the value of [user_interaction][crate::model::CVSSv3::user_interaction].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CVSSv3;
    /// use google_cloud_grafeas_v1::model::cvs_sv_3::UserInteraction;
    /// let x0 = CVSSv3::new().set_user_interaction(UserInteraction::None);
    /// let x1 = CVSSv3::new().set_user_interaction(UserInteraction::Required);
    /// ```
    pub fn set_user_interaction<T: std::convert::Into<crate::model::cvs_sv_3::UserInteraction>>(mut self, v: T) -> Self {
        self.user_interaction = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::CVSSv3::scope].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CVSSv3;
    /// use google_cloud_grafeas_v1::model::cvs_sv_3::Scope;
    /// let x0 = CVSSv3::new().set_scope(Scope::Unchanged);
    /// let x1 = CVSSv3::new().set_scope(Scope::Changed);
    /// ```
    pub fn set_scope<T: std::convert::Into<crate::model::cvs_sv_3::Scope>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [confidentiality_impact][crate::model::CVSSv3::confidentiality_impact].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CVSSv3;
    /// use google_cloud_grafeas_v1::model::cvs_sv_3::Impact;
    /// let x0 = CVSSv3::new().set_confidentiality_impact(Impact::High);
    /// let x1 = CVSSv3::new().set_confidentiality_impact(Impact::Low);
    /// let x2 = CVSSv3::new().set_confidentiality_impact(Impact::None);
    /// ```
    pub fn set_confidentiality_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(mut self, v: T) -> Self {
        self.confidentiality_impact = v.into();
        self
    }

    /// Sets the value of [integrity_impact][crate::model::CVSSv3::integrity_impact].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CVSSv3;
    /// use google_cloud_grafeas_v1::model::cvs_sv_3::Impact;
    /// let x0 = CVSSv3::new().set_integrity_impact(Impact::High);
    /// let x1 = CVSSv3::new().set_integrity_impact(Impact::Low);
    /// let x2 = CVSSv3::new().set_integrity_impact(Impact::None);
    /// ```
    pub fn set_integrity_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(mut self, v: T) -> Self {
        self.integrity_impact = v.into();
        self
    }

    /// Sets the value of [availability_impact][crate::model::CVSSv3::availability_impact].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CVSSv3;
    /// use google_cloud_grafeas_v1::model::cvs_sv_3::Impact;
    /// let x0 = CVSSv3::new().set_availability_impact(Impact::High);
    /// let x1 = CVSSv3::new().set_availability_impact(Impact::Low);
    /// let x2 = CVSSv3::new().set_availability_impact(Impact::None);
    /// ```
    pub fn set_availability_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(mut self, v: T) -> Self {
        self.availability_impact = v.into();
        self
    }
}

impl wkt::message::Message for CVSSv3 {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CVSSv3"
    }
}

/// Defines additional types related to [CVSSv3].
pub mod cvs_sv_3 {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackVector {
        Unspecified,
        Network,
        Adjacent,
        Local,
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackVector::value] or
        /// [AttackVector::name].
        UnknownValue(attack_vector::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_vector {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackVector {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::Adjacent => std::option::Option::Some(2),
                Self::Local => std::option::Option::Some(3),
                Self::Physical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_VECTOR_UNSPECIFIED"),
                Self::Network => std::option::Option::Some("ATTACK_VECTOR_NETWORK"),
                Self::Adjacent => std::option::Option::Some("ATTACK_VECTOR_ADJACENT"),
                Self::Local => std::option::Option::Some("ATTACK_VECTOR_LOCAL"),
                Self::Physical => std::option::Option::Some("ATTACK_VECTOR_PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackVector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Network,
                2 => Self::Adjacent,
                3 => Self::Local,
                4 => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for AttackVector {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_VECTOR_NETWORK" => Self::Network,
                "ATTACK_VECTOR_ADJACENT" => Self::Adjacent,
                "ATTACK_VECTOR_LOCAL" => Self::Local,
                "ATTACK_VECTOR_PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for AttackVector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Network => serializer.serialize_i32(1),
                Self::Adjacent => serializer.serialize_i32(2),
                Self::Local => serializer.serialize_i32(3),
                Self::Physical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackVector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackVector>::new(
                ".grafeas.v1.CVSSv3.AttackVector"))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackComplexity {
        Unspecified,
        Low,
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackComplexity::value] or
        /// [AttackComplexity::name].
        UnknownValue(attack_complexity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_complexity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackComplexity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_COMPLEXITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("ATTACK_COMPLEXITY_LOW"),
                Self::High => std::option::Option::Some("ATTACK_COMPLEXITY_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackComplexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackComplexity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackComplexity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for AttackComplexity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_COMPLEXITY_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_COMPLEXITY_LOW" => Self::Low,
                "ATTACK_COMPLEXITY_HIGH" => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for AttackComplexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackComplexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackComplexity>::new(
                ".grafeas.v1.CVSSv3.AttackComplexity"))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivilegesRequired {
        Unspecified,
        None,
        Low,
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivilegesRequired::value] or
        /// [PrivilegesRequired::name].
        UnknownValue(privileges_required::UnknownValue),
    }

    #[doc(hidden)]
    pub mod privileges_required {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrivilegesRequired {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIVILEGES_REQUIRED_UNSPECIFIED"),
                Self::None => std::option::Option::Some("PRIVILEGES_REQUIRED_NONE"),
                Self::Low => std::option::Option::Some("PRIVILEGES_REQUIRED_LOW"),
                Self::High => std::option::Option::Some("PRIVILEGES_REQUIRED_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrivilegesRequired {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrivilegesRequired {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrivilegesRequired {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Low,
                3 => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for PrivilegesRequired {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIVILEGES_REQUIRED_UNSPECIFIED" => Self::Unspecified,
                "PRIVILEGES_REQUIRED_NONE" => Self::None,
                "PRIVILEGES_REQUIRED_LOW" => Self::Low,
                "PRIVILEGES_REQUIRED_HIGH" => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for PrivilegesRequired {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrivilegesRequired {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrivilegesRequired>::new(
                ".grafeas.v1.CVSSv3.PrivilegesRequired"))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserInteraction {
        Unspecified,
        None,
        Required,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserInteraction::value] or
        /// [UserInteraction::name].
        UnknownValue(user_interaction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_interaction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserInteraction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Required => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_INTERACTION_UNSPECIFIED"),
                Self::None => std::option::Option::Some("USER_INTERACTION_NONE"),
                Self::Required => std::option::Option::Some("USER_INTERACTION_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserInteraction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserInteraction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserInteraction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for UserInteraction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_INTERACTION_UNSPECIFIED" => Self::Unspecified,
                "USER_INTERACTION_NONE" => Self::None,
                "USER_INTERACTION_REQUIRED" => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for UserInteraction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Required => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserInteraction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserInteraction>::new(
                ".grafeas.v1.CVSSv3.UserInteraction"))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        Unspecified,
        Unchanged,
        Changed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unchanged => std::option::Option::Some(1),
                Self::Changed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Unchanged => std::option::Option::Some("SCOPE_UNCHANGED"),
                Self::Changed => std::option::Option::Some("SCOPE_CHANGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unchanged,
                2 => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "SCOPE_UNCHANGED" => Self::Unchanged,
                "SCOPE_CHANGED" => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unchanged => serializer.serialize_i32(1),
                Self::Changed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".grafeas.v1.CVSSv3.Scope"))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Impact {
        Unspecified,
        High,
        Low,
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Impact::value] or
        /// [Impact::name].
        UnknownValue(impact::UnknownValue),
    }

    #[doc(hidden)]
    pub mod impact {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Impact {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPACT_UNSPECIFIED"),
                Self::High => std::option::Option::Some("IMPACT_HIGH"),
                Self::Low => std::option::Option::Some("IMPACT_LOW"),
                Self::None => std::option::Option::Some("IMPACT_NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Impact {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Impact {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Impact {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Low,
                3 => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Impact {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPACT_UNSPECIFIED" => Self::Unspecified,
                "IMPACT_HIGH" => Self::High,
                "IMPACT_LOW" => Self::Low,
                "IMPACT_NONE" => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Impact {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Impact {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Impact>::new(
                ".grafeas.v1.CVSSv3.Impact"))
        }
    }
}

/// Common Vulnerability Scoring System.
/// For details, see <https://www.first.org/cvss/specification-document>
/// This is a message we will try to use for storing various versions of CVSS
/// rather than making a separate proto for storing a specific version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Cvss {

    /// The base score is a function of the base metric scores.
    pub base_score: f32,

    pub exploitability_score: f32,

    pub impact_score: f32,

    /// Base Metrics
    /// Represents the intrinsic characteristics of a vulnerability that are
    /// constant over time and across user environments.
    pub attack_vector: crate::model::cvss::AttackVector,

    pub attack_complexity: crate::model::cvss::AttackComplexity,

    pub authentication: crate::model::cvss::Authentication,

    pub privileges_required: crate::model::cvss::PrivilegesRequired,

    pub user_interaction: crate::model::cvss::UserInteraction,

    pub scope: crate::model::cvss::Scope,

    pub confidentiality_impact: crate::model::cvss::Impact,

    pub integrity_impact: crate::model::cvss::Impact,

    pub availability_impact: crate::model::cvss::Impact,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cvss {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_score][crate::model::Cvss::base_score].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// let x = Cvss::new().set_base_score(42.0);
    /// ```
    pub fn set_base_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.base_score = v.into();
        self
    }

    /// Sets the value of [exploitability_score][crate::model::Cvss::exploitability_score].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// let x = Cvss::new().set_exploitability_score(42.0);
    /// ```
    pub fn set_exploitability_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.exploitability_score = v.into();
        self
    }

    /// Sets the value of [impact_score][crate::model::Cvss::impact_score].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// let x = Cvss::new().set_impact_score(42.0);
    /// ```
    pub fn set_impact_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.impact_score = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::Cvss::attack_vector].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// use google_cloud_grafeas_v1::model::cvss::AttackVector;
    /// let x0 = Cvss::new().set_attack_vector(AttackVector::Network);
    /// let x1 = Cvss::new().set_attack_vector(AttackVector::Adjacent);
    /// let x2 = Cvss::new().set_attack_vector(AttackVector::Local);
    /// ```
    pub fn set_attack_vector<T: std::convert::Into<crate::model::cvss::AttackVector>>(mut self, v: T) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [attack_complexity][crate::model::Cvss::attack_complexity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// use google_cloud_grafeas_v1::model::cvss::AttackComplexity;
    /// let x0 = Cvss::new().set_attack_complexity(AttackComplexity::Low);
    /// let x1 = Cvss::new().set_attack_complexity(AttackComplexity::High);
    /// let x2 = Cvss::new().set_attack_complexity(AttackComplexity::Medium);
    /// ```
    pub fn set_attack_complexity<T: std::convert::Into<crate::model::cvss::AttackComplexity>>(mut self, v: T) -> Self {
        self.attack_complexity = v.into();
        self
    }

    /// Sets the value of [authentication][crate::model::Cvss::authentication].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// use google_cloud_grafeas_v1::model::cvss::Authentication;
    /// let x0 = Cvss::new().set_authentication(Authentication::Multiple);
    /// let x1 = Cvss::new().set_authentication(Authentication::Single);
    /// let x2 = Cvss::new().set_authentication(Authentication::None);
    /// ```
    pub fn set_authentication<T: std::convert::Into<crate::model::cvss::Authentication>>(mut self, v: T) -> Self {
        self.authentication = v.into();
        self
    }

    /// Sets the value of [privileges_required][crate::model::Cvss::privileges_required].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// use google_cloud_grafeas_v1::model::cvss::PrivilegesRequired;
    /// let x0 = Cvss::new().set_privileges_required(PrivilegesRequired::None);
    /// let x1 = Cvss::new().set_privileges_required(PrivilegesRequired::Low);
    /// let x2 = Cvss::new().set_privileges_required(PrivilegesRequired::High);
    /// ```
    pub fn set_privileges_required<T: std::convert::Into<crate::model::cvss::PrivilegesRequired>>(mut self, v: T) -> Self {
        self.privileges_required = v.into();
        self
    }

    /// Sets the value of [user_interaction][crate::model::Cvss::user_interaction].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// use google_cloud_grafeas_v1::model::cvss::UserInteraction;
    /// let x0 = Cvss::new().set_user_interaction(UserInteraction::None);
    /// let x1 = Cvss::new().set_user_interaction(UserInteraction::Required);
    /// ```
    pub fn set_user_interaction<T: std::convert::Into<crate::model::cvss::UserInteraction>>(mut self, v: T) -> Self {
        self.user_interaction = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::Cvss::scope].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// use google_cloud_grafeas_v1::model::cvss::Scope;
    /// let x0 = Cvss::new().set_scope(Scope::Unchanged);
    /// let x1 = Cvss::new().set_scope(Scope::Changed);
    /// ```
    pub fn set_scope<T: std::convert::Into<crate::model::cvss::Scope>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [confidentiality_impact][crate::model::Cvss::confidentiality_impact].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// use google_cloud_grafeas_v1::model::cvss::Impact;
    /// let x0 = Cvss::new().set_confidentiality_impact(Impact::High);
    /// let x1 = Cvss::new().set_confidentiality_impact(Impact::Low);
    /// let x2 = Cvss::new().set_confidentiality_impact(Impact::None);
    /// ```
    pub fn set_confidentiality_impact<T: std::convert::Into<crate::model::cvss::Impact>>(mut self, v: T) -> Self {
        self.confidentiality_impact = v.into();
        self
    }

    /// Sets the value of [integrity_impact][crate::model::Cvss::integrity_impact].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// use google_cloud_grafeas_v1::model::cvss::Impact;
    /// let x0 = Cvss::new().set_integrity_impact(Impact::High);
    /// let x1 = Cvss::new().set_integrity_impact(Impact::Low);
    /// let x2 = Cvss::new().set_integrity_impact(Impact::None);
    /// ```
    pub fn set_integrity_impact<T: std::convert::Into<crate::model::cvss::Impact>>(mut self, v: T) -> Self {
        self.integrity_impact = v.into();
        self
    }

    /// Sets the value of [availability_impact][crate::model::Cvss::availability_impact].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Cvss;
    /// use google_cloud_grafeas_v1::model::cvss::Impact;
    /// let x0 = Cvss::new().set_availability_impact(Impact::High);
    /// let x1 = Cvss::new().set_availability_impact(Impact::Low);
    /// let x2 = Cvss::new().set_availability_impact(Impact::None);
    /// ```
    pub fn set_availability_impact<T: std::convert::Into<crate::model::cvss::Impact>>(mut self, v: T) -> Self {
        self.availability_impact = v.into();
        self
    }
}

impl wkt::message::Message for Cvss {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CVSS"
    }
}

/// Defines additional types related to [Cvss].
pub mod cvss {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackVector {
        Unspecified,
        Network,
        Adjacent,
        Local,
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackVector::value] or
        /// [AttackVector::name].
        UnknownValue(attack_vector::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_vector {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackVector {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::Adjacent => std::option::Option::Some(2),
                Self::Local => std::option::Option::Some(3),
                Self::Physical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_VECTOR_UNSPECIFIED"),
                Self::Network => std::option::Option::Some("ATTACK_VECTOR_NETWORK"),
                Self::Adjacent => std::option::Option::Some("ATTACK_VECTOR_ADJACENT"),
                Self::Local => std::option::Option::Some("ATTACK_VECTOR_LOCAL"),
                Self::Physical => std::option::Option::Some("ATTACK_VECTOR_PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackVector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Network,
                2 => Self::Adjacent,
                3 => Self::Local,
                4 => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for AttackVector {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_VECTOR_NETWORK" => Self::Network,
                "ATTACK_VECTOR_ADJACENT" => Self::Adjacent,
                "ATTACK_VECTOR_LOCAL" => Self::Local,
                "ATTACK_VECTOR_PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for AttackVector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Network => serializer.serialize_i32(1),
                Self::Adjacent => serializer.serialize_i32(2),
                Self::Local => serializer.serialize_i32(3),
                Self::Physical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackVector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackVector>::new(
                ".grafeas.v1.CVSS.AttackVector"))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackComplexity {
        Unspecified,
        Low,
        High,
        Medium,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackComplexity::value] or
        /// [AttackComplexity::name].
        UnknownValue(attack_complexity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_complexity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackComplexity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_COMPLEXITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("ATTACK_COMPLEXITY_LOW"),
                Self::High => std::option::Option::Some("ATTACK_COMPLEXITY_HIGH"),
                Self::Medium => std::option::Option::Some("ATTACK_COMPLEXITY_MEDIUM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackComplexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackComplexity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackComplexity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::High,
                3 => Self::Medium,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for AttackComplexity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_COMPLEXITY_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_COMPLEXITY_LOW" => Self::Low,
                "ATTACK_COMPLEXITY_HIGH" => Self::High,
                "ATTACK_COMPLEXITY_MEDIUM" => Self::Medium,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for AttackComplexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackComplexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackComplexity>::new(
                ".grafeas.v1.CVSS.AttackComplexity"))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Authentication {
        Unspecified,
        Multiple,
        Single,
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Authentication::value] or
        /// [Authentication::name].
        UnknownValue(authentication::UnknownValue),
    }

    #[doc(hidden)]
    pub mod authentication {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Authentication {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Multiple => std::option::Option::Some(1),
                Self::Single => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTHENTICATION_UNSPECIFIED"),
                Self::Multiple => std::option::Option::Some("AUTHENTICATION_MULTIPLE"),
                Self::Single => std::option::Option::Some("AUTHENTICATION_SINGLE"),
                Self::None => std::option::Option::Some("AUTHENTICATION_NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Authentication {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Authentication {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Authentication {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Multiple,
                2 => Self::Single,
                3 => Self::None,
                _ => Self::UnknownValue(authentication::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Authentication {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTHENTICATION_UNSPECIFIED" => Self::Unspecified,
                "AUTHENTICATION_MULTIPLE" => Self::Multiple,
                "AUTHENTICATION_SINGLE" => Self::Single,
                "AUTHENTICATION_NONE" => Self::None,
                _ => Self::UnknownValue(authentication::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Authentication {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Multiple => serializer.serialize_i32(1),
                Self::Single => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Authentication {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Authentication>::new(
                ".grafeas.v1.CVSS.Authentication"))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivilegesRequired {
        Unspecified,
        None,
        Low,
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivilegesRequired::value] or
        /// [PrivilegesRequired::name].
        UnknownValue(privileges_required::UnknownValue),
    }

    #[doc(hidden)]
    pub mod privileges_required {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrivilegesRequired {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIVILEGES_REQUIRED_UNSPECIFIED"),
                Self::None => std::option::Option::Some("PRIVILEGES_REQUIRED_NONE"),
                Self::Low => std::option::Option::Some("PRIVILEGES_REQUIRED_LOW"),
                Self::High => std::option::Option::Some("PRIVILEGES_REQUIRED_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrivilegesRequired {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrivilegesRequired {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrivilegesRequired {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Low,
                3 => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for PrivilegesRequired {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIVILEGES_REQUIRED_UNSPECIFIED" => Self::Unspecified,
                "PRIVILEGES_REQUIRED_NONE" => Self::None,
                "PRIVILEGES_REQUIRED_LOW" => Self::Low,
                "PRIVILEGES_REQUIRED_HIGH" => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for PrivilegesRequired {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrivilegesRequired {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrivilegesRequired>::new(
                ".grafeas.v1.CVSS.PrivilegesRequired"))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserInteraction {
        Unspecified,
        None,
        Required,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserInteraction::value] or
        /// [UserInteraction::name].
        UnknownValue(user_interaction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_interaction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserInteraction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Required => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_INTERACTION_UNSPECIFIED"),
                Self::None => std::option::Option::Some("USER_INTERACTION_NONE"),
                Self::Required => std::option::Option::Some("USER_INTERACTION_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserInteraction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserInteraction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserInteraction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for UserInteraction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_INTERACTION_UNSPECIFIED" => Self::Unspecified,
                "USER_INTERACTION_NONE" => Self::None,
                "USER_INTERACTION_REQUIRED" => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for UserInteraction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Required => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserInteraction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserInteraction>::new(
                ".grafeas.v1.CVSS.UserInteraction"))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        Unspecified,
        Unchanged,
        Changed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unchanged => std::option::Option::Some(1),
                Self::Changed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Unchanged => std::option::Option::Some("SCOPE_UNCHANGED"),
                Self::Changed => std::option::Option::Some("SCOPE_CHANGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unchanged,
                2 => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "SCOPE_UNCHANGED" => Self::Unchanged,
                "SCOPE_CHANGED" => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unchanged => serializer.serialize_i32(1),
                Self::Changed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".grafeas.v1.CVSS.Scope"))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Impact {
        Unspecified,
        High,
        Low,
        None,
        Partial,
        Complete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Impact::value] or
        /// [Impact::name].
        UnknownValue(impact::UnknownValue),
    }

    #[doc(hidden)]
    pub mod impact {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Impact {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::Partial => std::option::Option::Some(4),
                Self::Complete => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPACT_UNSPECIFIED"),
                Self::High => std::option::Option::Some("IMPACT_HIGH"),
                Self::Low => std::option::Option::Some("IMPACT_LOW"),
                Self::None => std::option::Option::Some("IMPACT_NONE"),
                Self::Partial => std::option::Option::Some("IMPACT_PARTIAL"),
                Self::Complete => std::option::Option::Some("IMPACT_COMPLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Impact {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Impact {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Impact {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Low,
                3 => Self::None,
                4 => Self::Partial,
                5 => Self::Complete,
                _ => Self::UnknownValue(impact::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Impact {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPACT_UNSPECIFIED" => Self::Unspecified,
                "IMPACT_HIGH" => Self::High,
                "IMPACT_LOW" => Self::Low,
                "IMPACT_NONE" => Self::None,
                "IMPACT_PARTIAL" => Self::Partial,
                "IMPACT_COMPLETE" => Self::Complete,
                _ => Self::UnknownValue(impact::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Impact {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::Partial => serializer.serialize_i32(4),
                Self::Complete => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Impact {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Impact>::new(
                ".grafeas.v1.CVSS.Impact"))
        }
    }
}

/// An artifact that can be deployed in some runtime.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeploymentNote {

    /// Required. Resource URI for the artifact being deployed.
    pub resource_uri: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeploymentNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_uri][crate::model::DeploymentNote::resource_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeploymentNote;
    /// let x = DeploymentNote::new().set_resource_uri(["a", "b", "c"]);
    /// ```
    pub fn set_resource_uri<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.resource_uri = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DeploymentNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeploymentNote"
    }
}

/// The period during which some deployable was active in a runtime.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeploymentOccurrence {

    /// Identity of the user that triggered this deployment.
    pub user_email: std::string::String,

    /// Required. Beginning of the lifetime of this deployment.
    pub deploy_time: std::option::Option<wkt::Timestamp>,

    /// End of the lifetime of this deployment.
    pub undeploy_time: std::option::Option<wkt::Timestamp>,

    /// Configuration used to create this deployment.
    pub config: std::string::String,

    /// Address of the runtime element hosting this deployment.
    pub address: std::string::String,

    /// Output only. Resource URI for the artifact being deployed taken from
    /// the deployable field with the same name.
    pub resource_uri: std::vec::Vec<std::string::String>,

    /// Platform hosting this deployment.
    pub platform: crate::model::deployment_occurrence::Platform,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeploymentOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_email][crate::model::DeploymentOccurrence::user_email].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeploymentOccurrence;
    /// let x = DeploymentOccurrence::new().set_user_email("example");
    /// ```
    pub fn set_user_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_email = v.into();
        self
    }

    /// Sets the value of [deploy_time][crate::model::DeploymentOccurrence::deploy_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeploymentOccurrence;
    /// use wkt::Timestamp;
    /// let x = DeploymentOccurrence::new().set_deploy_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_deploy_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.deploy_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_time][crate::model::DeploymentOccurrence::deploy_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeploymentOccurrence;
    /// use wkt::Timestamp;
    /// let x = DeploymentOccurrence::new().set_or_clear_deploy_time(Some(Timestamp::default()/* use setters */));
    /// let x = DeploymentOccurrence::new().set_or_clear_deploy_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_deploy_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.deploy_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [undeploy_time][crate::model::DeploymentOccurrence::undeploy_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeploymentOccurrence;
    /// use wkt::Timestamp;
    /// let x = DeploymentOccurrence::new().set_undeploy_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_undeploy_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.undeploy_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [undeploy_time][crate::model::DeploymentOccurrence::undeploy_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeploymentOccurrence;
    /// use wkt::Timestamp;
    /// let x = DeploymentOccurrence::new().set_or_clear_undeploy_time(Some(Timestamp::default()/* use setters */));
    /// let x = DeploymentOccurrence::new().set_or_clear_undeploy_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_undeploy_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.undeploy_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config][crate::model::DeploymentOccurrence::config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeploymentOccurrence;
    /// let x = DeploymentOccurrence::new().set_config("example");
    /// ```
    pub fn set_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [address][crate::model::DeploymentOccurrence::address].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeploymentOccurrence;
    /// let x = DeploymentOccurrence::new().set_address("example");
    /// ```
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::DeploymentOccurrence::resource_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeploymentOccurrence;
    /// let x = DeploymentOccurrence::new().set_resource_uri(["a", "b", "c"]);
    /// ```
    pub fn set_resource_uri<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.resource_uri = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [platform][crate::model::DeploymentOccurrence::platform].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeploymentOccurrence;
    /// use google_cloud_grafeas_v1::model::deployment_occurrence::Platform;
    /// let x0 = DeploymentOccurrence::new().set_platform(Platform::Gke);
    /// let x1 = DeploymentOccurrence::new().set_platform(Platform::Flex);
    /// let x2 = DeploymentOccurrence::new().set_platform(Platform::Custom);
    /// ```
    pub fn set_platform<T: std::convert::Into<crate::model::deployment_occurrence::Platform>>(mut self, v: T) -> Self {
        self.platform = v.into();
        self
    }
}

impl wkt::message::Message for DeploymentOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeploymentOccurrence"
    }
}

/// Defines additional types related to [DeploymentOccurrence].
pub mod deployment_occurrence {
    #[allow(unused_imports)]
    use super::*;


    /// Types of platforms.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Platform {
        /// Unknown.
        Unspecified,
        /// Google Container Engine.
        Gke,
        /// Google App Engine: Flexible Environment.
        Flex,
        /// Custom user-defined platform.
        Custom,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Platform::value] or
        /// [Platform::name].
        UnknownValue(platform::UnknownValue),
    }

    #[doc(hidden)]
    pub mod platform {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Platform {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gke => std::option::Option::Some(1),
                Self::Flex => std::option::Option::Some(2),
                Self::Custom => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PLATFORM_UNSPECIFIED"),
                Self::Gke => std::option::Option::Some("GKE"),
                Self::Flex => std::option::Option::Some("FLEX"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Platform {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Platform {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Platform {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gke,
                2 => Self::Flex,
                3 => Self::Custom,
                _ => Self::UnknownValue(platform::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Platform {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PLATFORM_UNSPECIFIED" => Self::Unspecified,
                "GKE" => Self::Gke,
                "FLEX" => Self::Flex,
                "CUSTOM" => Self::Custom,
                _ => Self::UnknownValue(platform::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Platform {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gke => serializer.serialize_i32(1),
                Self::Flex => serializer.serialize_i32(2),
                Self::Custom => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Platform {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Platform>::new(
                ".grafeas.v1.DeploymentOccurrence.Platform"))
        }
    }
}

/// A note that indicates a type of analysis a provider would perform. This note
/// exists in a provider's project. A `Discovery` occurrence is created in a
/// consumer's project at the start of analysis.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryNote {

    /// Required. Immutable. The kind of analysis that is handled by this
    /// discovery.
    pub analysis_kind: crate::model::NoteKind,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analysis_kind][crate::model::DiscoveryNote::analysis_kind].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryNote;
    /// use google_cloud_grafeas_v1::model::NoteKind;
    /// let x0 = DiscoveryNote::new().set_analysis_kind(NoteKind::Vulnerability);
    /// let x1 = DiscoveryNote::new().set_analysis_kind(NoteKind::Build);
    /// let x2 = DiscoveryNote::new().set_analysis_kind(NoteKind::Image);
    /// ```
    pub fn set_analysis_kind<T: std::convert::Into<crate::model::NoteKind>>(mut self, v: T) -> Self {
        self.analysis_kind = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DiscoveryNote"
    }
}

/// Provides information about the analysis status of a discovered resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryOccurrence {

    /// Whether the resource is continuously analyzed.
    pub continuous_analysis: crate::model::discovery_occurrence::ContinuousAnalysis,

    /// The status of discovery for the resource.
    pub analysis_status: crate::model::discovery_occurrence::AnalysisStatus,

    pub analysis_completed: std::option::Option<crate::model::discovery_occurrence::AnalysisCompleted>,

    /// Indicates any errors encountered during analysis of a resource. There
    /// could be 0 or more of these errors.
    pub analysis_error: std::vec::Vec<rpc::model::Status>,

    /// When an error is encountered this will contain a LocalizedMessage under
    /// details to show to the user. The LocalizedMessage is output only and
    /// populated by the API.
    pub analysis_status_error: std::option::Option<rpc::model::Status>,

    /// The CPE of the resource being scanned.
    pub cpe: std::string::String,

    /// The last time this resource was scanned.
    pub last_scan_time: std::option::Option<wkt::Timestamp>,

    /// The time occurrences related to this discovery occurrence were archived.
    pub archive_time: std::option::Option<wkt::Timestamp>,

    /// The status of an SBOM generation.
    pub sbom_status: std::option::Option<crate::model::discovery_occurrence::SBOMStatus>,

    /// The status of an vulnerability attestation generation.
    pub vulnerability_attestation: std::option::Option<crate::model::discovery_occurrence::VulnerabilityAttestation>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continuous_analysis][crate::model::DiscoveryOccurrence::continuous_analysis].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use google_cloud_grafeas_v1::model::discovery_occurrence::ContinuousAnalysis;
    /// let x0 = DiscoveryOccurrence::new().set_continuous_analysis(ContinuousAnalysis::Active);
    /// let x1 = DiscoveryOccurrence::new().set_continuous_analysis(ContinuousAnalysis::Inactive);
    /// ```
    pub fn set_continuous_analysis<T: std::convert::Into<crate::model::discovery_occurrence::ContinuousAnalysis>>(mut self, v: T) -> Self {
        self.continuous_analysis = v.into();
        self
    }

    /// Sets the value of [analysis_status][crate::model::DiscoveryOccurrence::analysis_status].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use google_cloud_grafeas_v1::model::discovery_occurrence::AnalysisStatus;
    /// let x0 = DiscoveryOccurrence::new().set_analysis_status(AnalysisStatus::Pending);
    /// let x1 = DiscoveryOccurrence::new().set_analysis_status(AnalysisStatus::Scanning);
    /// let x2 = DiscoveryOccurrence::new().set_analysis_status(AnalysisStatus::FinishedSuccess);
    /// ```
    pub fn set_analysis_status<T: std::convert::Into<crate::model::discovery_occurrence::AnalysisStatus>>(mut self, v: T) -> Self {
        self.analysis_status = v.into();
        self
    }

    /// Sets the value of [analysis_completed][crate::model::DiscoveryOccurrence::analysis_completed].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use google_cloud_grafeas_v1::model::discovery_occurrence::AnalysisCompleted;
    /// let x = DiscoveryOccurrence::new().set_analysis_completed(AnalysisCompleted::default()/* use setters */);
    /// ```
    pub fn set_analysis_completed<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::discovery_occurrence::AnalysisCompleted>
    {
        self.analysis_completed = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_completed][crate::model::DiscoveryOccurrence::analysis_completed].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use google_cloud_grafeas_v1::model::discovery_occurrence::AnalysisCompleted;
    /// let x = DiscoveryOccurrence::new().set_or_clear_analysis_completed(Some(AnalysisCompleted::default()/* use setters */));
    /// let x = DiscoveryOccurrence::new().set_or_clear_analysis_completed(None::<AnalysisCompleted>);
    /// ```
    pub fn set_or_clear_analysis_completed<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::discovery_occurrence::AnalysisCompleted>
    {
        self.analysis_completed = v.map(|x| x.into());
        self
    }

    /// Sets the value of [analysis_error][crate::model::DiscoveryOccurrence::analysis_error].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use rpc::model::Status;
    /// let x = DiscoveryOccurrence::new()
    ///     .set_analysis_error([
    ///         Status::default()/* use setters */,
    ///         Status::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_analysis_error<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>
    {
        use std::iter::Iterator;
        self.analysis_error = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [analysis_status_error][crate::model::DiscoveryOccurrence::analysis_status_error].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use rpc::model::Status;
    /// let x = DiscoveryOccurrence::new().set_analysis_status_error(Status::default()/* use setters */);
    /// ```
    pub fn set_analysis_status_error<T>(mut self, v: T) -> Self
    where T: std::convert::Into<rpc::model::Status>
    {
        self.analysis_status_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_status_error][crate::model::DiscoveryOccurrence::analysis_status_error].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use rpc::model::Status;
    /// let x = DiscoveryOccurrence::new().set_or_clear_analysis_status_error(Some(Status::default()/* use setters */));
    /// let x = DiscoveryOccurrence::new().set_or_clear_analysis_status_error(None::<Status>);
    /// ```
    pub fn set_or_clear_analysis_status_error<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<rpc::model::Status>
    {
        self.analysis_status_error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpe][crate::model::DiscoveryOccurrence::cpe].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// let x = DiscoveryOccurrence::new().set_cpe("example");
    /// ```
    pub fn set_cpe<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe = v.into();
        self
    }

    /// Sets the value of [last_scan_time][crate::model::DiscoveryOccurrence::last_scan_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use wkt::Timestamp;
    /// let x = DiscoveryOccurrence::new().set_last_scan_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_last_scan_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.last_scan_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_scan_time][crate::model::DiscoveryOccurrence::last_scan_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use wkt::Timestamp;
    /// let x = DiscoveryOccurrence::new().set_or_clear_last_scan_time(Some(Timestamp::default()/* use setters */));
    /// let x = DiscoveryOccurrence::new().set_or_clear_last_scan_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_last_scan_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.last_scan_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [archive_time][crate::model::DiscoveryOccurrence::archive_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use wkt::Timestamp;
    /// let x = DiscoveryOccurrence::new().set_archive_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_archive_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.archive_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [archive_time][crate::model::DiscoveryOccurrence::archive_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use wkt::Timestamp;
    /// let x = DiscoveryOccurrence::new().set_or_clear_archive_time(Some(Timestamp::default()/* use setters */));
    /// let x = DiscoveryOccurrence::new().set_or_clear_archive_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_archive_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.archive_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sbom_status][crate::model::DiscoveryOccurrence::sbom_status].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use google_cloud_grafeas_v1::model::discovery_occurrence::SBOMStatus;
    /// let x = DiscoveryOccurrence::new().set_sbom_status(SBOMStatus::default()/* use setters */);
    /// ```
    pub fn set_sbom_status<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::discovery_occurrence::SBOMStatus>
    {
        self.sbom_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sbom_status][crate::model::DiscoveryOccurrence::sbom_status].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use google_cloud_grafeas_v1::model::discovery_occurrence::SBOMStatus;
    /// let x = DiscoveryOccurrence::new().set_or_clear_sbom_status(Some(SBOMStatus::default()/* use setters */));
    /// let x = DiscoveryOccurrence::new().set_or_clear_sbom_status(None::<SBOMStatus>);
    /// ```
    pub fn set_or_clear_sbom_status<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::discovery_occurrence::SBOMStatus>
    {
        self.sbom_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vulnerability_attestation][crate::model::DiscoveryOccurrence::vulnerability_attestation].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use google_cloud_grafeas_v1::model::discovery_occurrence::VulnerabilityAttestation;
    /// let x = DiscoveryOccurrence::new().set_vulnerability_attestation(VulnerabilityAttestation::default()/* use setters */);
    /// ```
    pub fn set_vulnerability_attestation<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::discovery_occurrence::VulnerabilityAttestation>
    {
        self.vulnerability_attestation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vulnerability_attestation][crate::model::DiscoveryOccurrence::vulnerability_attestation].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// use google_cloud_grafeas_v1::model::discovery_occurrence::VulnerabilityAttestation;
    /// let x = DiscoveryOccurrence::new().set_or_clear_vulnerability_attestation(Some(VulnerabilityAttestation::default()/* use setters */));
    /// let x = DiscoveryOccurrence::new().set_or_clear_vulnerability_attestation(None::<VulnerabilityAttestation>);
    /// ```
    pub fn set_or_clear_vulnerability_attestation<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::discovery_occurrence::VulnerabilityAttestation>
    {
        self.vulnerability_attestation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiscoveryOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DiscoveryOccurrence"
    }
}

/// Defines additional types related to [DiscoveryOccurrence].
pub mod discovery_occurrence {
    #[allow(unused_imports)]
    use super::*;


    /// Indicates which analysis completed successfully. Multiple types of
    /// analysis can be performed on a single resource.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnalysisCompleted {

        pub analysis_type: std::vec::Vec<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnalysisCompleted {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [analysis_type][crate::model::discovery_occurrence::AnalysisCompleted::analysis_type].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::discovery_occurrence::AnalysisCompleted;
        /// let x = AnalysisCompleted::new().set_analysis_type(["a", "b", "c"]);
        /// ```
        pub fn set_analysis_type<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>
        {
            use std::iter::Iterator;
            self.analysis_type = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AnalysisCompleted {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DiscoveryOccurrence.AnalysisCompleted"
        }
    }

    /// The status of an SBOM generation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SBOMStatus {

        /// The progress of the SBOM generation.
        pub sbom_state: crate::model::discovery_occurrence::sbom_status::SBOMState,

        /// If there was an error generating an SBOM, this will indicate what that
        /// error was.
        pub error: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SBOMStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sbom_state][crate::model::discovery_occurrence::SBOMStatus::sbom_state].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::discovery_occurrence::SBOMStatus;
        /// use google_cloud_grafeas_v1::model::discovery_occurrence::sbom_status::SBOMState;
        /// let x0 = SBOMStatus::new().set_sbom_state(SBOMState::Pending);
        /// let x1 = SBOMStatus::new().set_sbom_state(SBOMState::Complete);
        /// ```
        pub fn set_sbom_state<T: std::convert::Into<crate::model::discovery_occurrence::sbom_status::SBOMState>>(mut self, v: T) -> Self {
            self.sbom_state = v.into();
            self
        }

        /// Sets the value of [error][crate::model::discovery_occurrence::SBOMStatus::error].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::discovery_occurrence::SBOMStatus;
        /// let x = SBOMStatus::new().set_error("example");
        /// ```
        pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for SBOMStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DiscoveryOccurrence.SBOMStatus"
        }
    }

    /// Defines additional types related to [SBOMStatus].
    pub mod sbom_status {
        #[allow(unused_imports)]
        use super::*;


        /// An enum indicating the progress of the SBOM generation.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SBOMState {
            /// Default unknown state.
            Unspecified,
            /// SBOM scanning is pending.
            Pending,
            /// SBOM scanning has completed.
            Complete,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SBOMState::value] or
            /// [SBOMState::name].
            UnknownValue(sbom_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod sbom_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SBOMState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Pending => std::option::Option::Some(1),
                    Self::Complete => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SBOM_STATE_UNSPECIFIED"),
                    Self::Pending => std::option::Option::Some("PENDING"),
                    Self::Complete => std::option::Option::Some("COMPLETE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SBOMState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SBOMState {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SBOMState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Pending,
                    2 => Self::Complete,
                    _ => Self::UnknownValue(sbom_state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for SBOMState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SBOM_STATE_UNSPECIFIED" => Self::Unspecified,
                    "PENDING" => Self::Pending,
                    "COMPLETE" => Self::Complete,
                    _ => Self::UnknownValue(sbom_state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for SBOMState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Pending => serializer.serialize_i32(1),
                    Self::Complete => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SBOMState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SBOMState>::new(
                    ".grafeas.v1.DiscoveryOccurrence.SBOMStatus.SBOMState"))
            }
        }
    }

    /// The status of an vulnerability attestation generation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VulnerabilityAttestation {

        /// The last time we attempted to generate an attestation.
        pub last_attempt_time: std::option::Option<wkt::Timestamp>,

        /// The success/failure state of the latest attestation attempt.
        pub state: crate::model::discovery_occurrence::vulnerability_attestation::VulnerabilityAttestationState,

        /// If failure, the error reason for why the attestation generation failed.
        pub error: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VulnerabilityAttestation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [last_attempt_time][crate::model::discovery_occurrence::VulnerabilityAttestation::last_attempt_time].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::discovery_occurrence::VulnerabilityAttestation;
        /// use wkt::Timestamp;
        /// let x = VulnerabilityAttestation::new().set_last_attempt_time(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_last_attempt_time<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.last_attempt_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_attempt_time][crate::model::discovery_occurrence::VulnerabilityAttestation::last_attempt_time].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::discovery_occurrence::VulnerabilityAttestation;
        /// use wkt::Timestamp;
        /// let x = VulnerabilityAttestation::new().set_or_clear_last_attempt_time(Some(Timestamp::default()/* use setters */));
        /// let x = VulnerabilityAttestation::new().set_or_clear_last_attempt_time(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_last_attempt_time<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.last_attempt_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [state][crate::model::discovery_occurrence::VulnerabilityAttestation::state].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::discovery_occurrence::VulnerabilityAttestation;
        /// use google_cloud_grafeas_v1::model::discovery_occurrence::vulnerability_attestation::VulnerabilityAttestationState;
        /// let x0 = VulnerabilityAttestation::new().set_state(VulnerabilityAttestationState::Success);
        /// let x1 = VulnerabilityAttestation::new().set_state(VulnerabilityAttestationState::Failure);
        /// ```
        pub fn set_state<T: std::convert::Into<crate::model::discovery_occurrence::vulnerability_attestation::VulnerabilityAttestationState>>(mut self, v: T) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [error][crate::model::discovery_occurrence::VulnerabilityAttestation::error].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::discovery_occurrence::VulnerabilityAttestation;
        /// let x = VulnerabilityAttestation::new().set_error("example");
        /// ```
        pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for VulnerabilityAttestation {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DiscoveryOccurrence.VulnerabilityAttestation"
        }
    }

    /// Defines additional types related to [VulnerabilityAttestation].
    pub mod vulnerability_attestation {
        #[allow(unused_imports)]
        use super::*;


        /// An enum indicating the state of the attestation generation.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum VulnerabilityAttestationState {
            /// Default unknown state.
            Unspecified,
            /// Attestation was successfully generated and stored.
            Success,
            /// Attestation was unsuccessfully generated and stored.
            Failure,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [VulnerabilityAttestationState::value] or
            /// [VulnerabilityAttestationState::name].
            UnknownValue(vulnerability_attestation_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod vulnerability_attestation_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl VulnerabilityAttestationState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Success => std::option::Option::Some(1),
                    Self::Failure => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("VULNERABILITY_ATTESTATION_STATE_UNSPECIFIED"),
                    Self::Success => std::option::Option::Some("SUCCESS"),
                    Self::Failure => std::option::Option::Some("FAILURE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for VulnerabilityAttestationState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for VulnerabilityAttestationState {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for VulnerabilityAttestationState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Success,
                    2 => Self::Failure,
                    _ => Self::UnknownValue(vulnerability_attestation_state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for VulnerabilityAttestationState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "VULNERABILITY_ATTESTATION_STATE_UNSPECIFIED" => Self::Unspecified,
                    "SUCCESS" => Self::Success,
                    "FAILURE" => Self::Failure,
                    _ => Self::UnknownValue(vulnerability_attestation_state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for VulnerabilityAttestationState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Success => serializer.serialize_i32(1),
                    Self::Failure => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for VulnerabilityAttestationState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<VulnerabilityAttestationState>::new(
                    ".grafeas.v1.DiscoveryOccurrence.VulnerabilityAttestation.VulnerabilityAttestationState"))
            }
        }
    }

    /// Whether the resource is continuously analyzed.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ContinuousAnalysis {
        /// Unknown.
        Unspecified,
        /// The resource is continuously analyzed.
        Active,
        /// The resource is ignored for continuous analysis.
        Inactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ContinuousAnalysis::value] or
        /// [ContinuousAnalysis::name].
        UnknownValue(continuous_analysis::UnknownValue),
    }

    #[doc(hidden)]
    pub mod continuous_analysis {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ContinuousAnalysis {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Inactive => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONTINUOUS_ANALYSIS_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ContinuousAnalysis {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ContinuousAnalysis {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ContinuousAnalysis {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Inactive,
                _ => Self::UnknownValue(continuous_analysis::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ContinuousAnalysis {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONTINUOUS_ANALYSIS_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "INACTIVE" => Self::Inactive,
                _ => Self::UnknownValue(continuous_analysis::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ContinuousAnalysis {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Inactive => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ContinuousAnalysis {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContinuousAnalysis>::new(
                ".grafeas.v1.DiscoveryOccurrence.ContinuousAnalysis"))
        }
    }

    /// Analysis status for a resource. Currently for initial analysis only (not
    /// updated in continuous analysis).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AnalysisStatus {
        /// Unknown.
        Unspecified,
        /// Resource is known but no action has been taken yet.
        Pending,
        /// Resource is being analyzed.
        Scanning,
        /// Analysis has finished successfully.
        FinishedSuccess,
        /// Analysis has completed.
        Complete,
        /// Analysis has finished unsuccessfully, the analysis itself is in a bad
        /// state.
        FinishedFailed,
        /// The resource is known not to be supported.
        FinishedUnsupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AnalysisStatus::value] or
        /// [AnalysisStatus::name].
        UnknownValue(analysis_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod analysis_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AnalysisStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Scanning => std::option::Option::Some(2),
                Self::FinishedSuccess => std::option::Option::Some(3),
                Self::Complete => std::option::Option::Some(3),
                Self::FinishedFailed => std::option::Option::Some(4),
                Self::FinishedUnsupported => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANALYSIS_STATUS_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Scanning => std::option::Option::Some("SCANNING"),
                Self::FinishedSuccess => std::option::Option::Some("FINISHED_SUCCESS"),
                Self::Complete => std::option::Option::Some("COMPLETE"),
                Self::FinishedFailed => std::option::Option::Some("FINISHED_FAILED"),
                Self::FinishedUnsupported => std::option::Option::Some("FINISHED_UNSUPPORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AnalysisStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AnalysisStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AnalysisStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Scanning,
                3 => Self::Complete,
                4 => Self::FinishedFailed,
                5 => Self::FinishedUnsupported,
                _ => Self::UnknownValue(analysis_status::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for AnalysisStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANALYSIS_STATUS_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "SCANNING" => Self::Scanning,
                "FINISHED_SUCCESS" => Self::FinishedSuccess,
                "COMPLETE" => Self::Complete,
                "FINISHED_FAILED" => Self::FinishedFailed,
                "FINISHED_UNSUPPORTED" => Self::FinishedUnsupported,
                _ => Self::UnknownValue(analysis_status::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for AnalysisStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Scanning => serializer.serialize_i32(2),
                Self::FinishedSuccess => serializer.serialize_i32(3),
                Self::Complete => serializer.serialize_i32(3),
                Self::FinishedFailed => serializer.serialize_i32(4),
                Self::FinishedUnsupported => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AnalysisStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AnalysisStatus>::new(
                ".grafeas.v1.DiscoveryOccurrence.AnalysisStatus"))
        }
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DSSEAttestationNote {

    /// DSSEHint hints at the purpose of the attestation authority.
    pub hint: std::option::Option<crate::model::dsse_attestation_note::DSSEHint>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DSSEAttestationNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hint][crate::model::DSSEAttestationNote::hint].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DSSEAttestationNote;
    /// use google_cloud_grafeas_v1::model::dsse_attestation_note::DSSEHint;
    /// let x = DSSEAttestationNote::new().set_hint(DSSEHint::default()/* use setters */);
    /// ```
    pub fn set_hint<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::dsse_attestation_note::DSSEHint>
    {
        self.hint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hint][crate::model::DSSEAttestationNote::hint].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DSSEAttestationNote;
    /// use google_cloud_grafeas_v1::model::dsse_attestation_note::DSSEHint;
    /// let x = DSSEAttestationNote::new().set_or_clear_hint(Some(DSSEHint::default()/* use setters */));
    /// let x = DSSEAttestationNote::new().set_or_clear_hint(None::<DSSEHint>);
    /// ```
    pub fn set_or_clear_hint<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::dsse_attestation_note::DSSEHint>
    {
        self.hint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DSSEAttestationNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DSSEAttestationNote"
    }
}

/// Defines additional types related to [DSSEAttestationNote].
pub mod dsse_attestation_note {
    #[allow(unused_imports)]
    use super::*;


    /// This submessage provides human-readable hints about the purpose of the
    /// authority. Because the name of a note acts as its resource reference, it is
    /// important to disambiguate the canonical name of the Note (which might be a
    /// UUID for security purposes) from "readable" names more suitable for debug
    /// output. Note that these hints should not be used to look up authorities in
    /// security sensitive contexts, such as when looking up attestations to
    /// verify.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DSSEHint {

        /// Required. The human readable name of this attestation authority, for
        /// example "cloudbuild-prod".
        pub human_readable_name: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DSSEHint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [human_readable_name][crate::model::dsse_attestation_note::DSSEHint::human_readable_name].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::dsse_attestation_note::DSSEHint;
        /// let x = DSSEHint::new().set_human_readable_name("example");
        /// ```
        pub fn set_human_readable_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.human_readable_name = v.into();
            self
        }
    }

    impl wkt::message::Message for DSSEHint {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.DSSEAttestationNote.DSSEHint"
        }
    }
}

/// Deprecated. Prefer to use a regular Occurrence, and populate the
/// Envelope at the top level of the Occurrence.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DSSEAttestationOccurrence {

    /// If doing something security critical, make sure to verify the signatures in
    /// this metadata.
    pub envelope: std::option::Option<crate::model::Envelope>,

    pub decoded_payload: std::option::Option<crate::model::dsse_attestation_occurrence::DecodedPayload>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DSSEAttestationOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [envelope][crate::model::DSSEAttestationOccurrence::envelope].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DSSEAttestationOccurrence;
    /// use google_cloud_grafeas_v1::model::Envelope;
    /// let x = DSSEAttestationOccurrence::new().set_envelope(Envelope::default()/* use setters */);
    /// ```
    pub fn set_envelope<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Envelope>
    {
        self.envelope = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [envelope][crate::model::DSSEAttestationOccurrence::envelope].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DSSEAttestationOccurrence;
    /// use google_cloud_grafeas_v1::model::Envelope;
    /// let x = DSSEAttestationOccurrence::new().set_or_clear_envelope(Some(Envelope::default()/* use setters */));
    /// let x = DSSEAttestationOccurrence::new().set_or_clear_envelope(None::<Envelope>);
    /// ```
    pub fn set_or_clear_envelope<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Envelope>
    {
        self.envelope = v.map(|x| x.into());
        self
    }

    /// Sets the value of [decoded_payload][crate::model::DSSEAttestationOccurrence::decoded_payload].
    ///
    /// Note that all the setters affecting `decoded_payload` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DSSEAttestationOccurrence;
    /// use google_cloud_grafeas_v1::model::InTotoStatement;
    /// let x = DSSEAttestationOccurrence::new().set_decoded_payload(Some(
    ///     google_cloud_grafeas_v1::model::dsse_attestation_occurrence::DecodedPayload::Statement(InTotoStatement::default().into())));
    /// ```
    pub fn set_decoded_payload<T: std::convert::Into<std::option::Option<crate::model::dsse_attestation_occurrence::DecodedPayload>>>(mut self, v: T) -> Self
    {
        self.decoded_payload = v.into();
        self
    }

    /// The value of [decoded_payload][crate::model::DSSEAttestationOccurrence::decoded_payload]
    /// if it holds a `Statement`, `None` if the field is not set or
    /// holds a different branch.
    pub fn statement(&self) -> std::option::Option<&std::boxed::Box<crate::model::InTotoStatement>> {
        #[allow(unreachable_patterns)]
        self.decoded_payload.as_ref().and_then(|v| match v {
            crate::model::dsse_attestation_occurrence::DecodedPayload::Statement(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [decoded_payload][crate::model::DSSEAttestationOccurrence::decoded_payload]
    /// to hold a `Statement`.
    ///
    /// Note that all the setters affecting `decoded_payload` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DSSEAttestationOccurrence;
    /// use google_cloud_grafeas_v1::model::InTotoStatement;
    /// let x = DSSEAttestationOccurrence::new().set_statement(InTotoStatement::default()/* use setters */);
    /// assert!(x.statement().is_some());
    /// ```
    pub fn set_statement<T: std::convert::Into<std::boxed::Box<crate::model::InTotoStatement>>>(mut self, v: T) -> Self {
        self.decoded_payload = std::option::Option::Some(
            crate::model::dsse_attestation_occurrence::DecodedPayload::Statement(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for DSSEAttestationOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DSSEAttestationOccurrence"
    }
}

/// Defines additional types related to [DSSEAttestationOccurrence].
pub mod dsse_attestation_occurrence {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DecodedPayload {
        Statement(std::boxed::Box<crate::model::InTotoStatement>),
    }
}

/// An instance of an analysis type that has been found on a resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Occurrence {

    /// Output only. The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    pub name: std::string::String,

    /// Required. Immutable. A URI that represents the resource for which the
    /// occurrence applies. For example,
    /// `<https://gcr.io/project/image@sha256:123abc>` for a Docker image.
    pub resource_uri: std::string::String,

    /// Required. Immutable. The analysis note associated with this occurrence, in
    /// the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
    /// used as a filter in list requests.
    pub note_name: std::string::String,

    /// Output only. This explicitly denotes which of the occurrence details are
    /// specified. This field can be used as a filter in list requests.
    pub kind: crate::model::NoteKind,

    /// A description of actions that can be taken to remedy the note.
    pub remediation: std::string::String,

    /// Output only. The time this occurrence was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this occurrence was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// <https://github.com/secure-systems-lab/dsse>
    pub envelope: std::option::Option<crate::model::Envelope>,

    /// Required. Immutable. Describes the details of the note kind found on this
    /// resource.
    pub details: std::option::Option<crate::model::occurrence::Details>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Occurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Occurrence::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = Occurrence::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::Occurrence::resource_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = Occurrence::new().set_resource_uri("example");
    /// ```
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [note_name][crate::model::Occurrence::note_name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = Occurrence::new().set_note_name("example");
    /// ```
    pub fn set_note_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Occurrence::kind].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::NoteKind;
    /// let x0 = Occurrence::new().set_kind(NoteKind::Vulnerability);
    /// let x1 = Occurrence::new().set_kind(NoteKind::Build);
    /// let x2 = Occurrence::new().set_kind(NoteKind::Image);
    /// ```
    pub fn set_kind<T: std::convert::Into<crate::model::NoteKind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [remediation][crate::model::Occurrence::remediation].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = Occurrence::new().set_remediation("example");
    /// ```
    pub fn set_remediation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remediation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Occurrence::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use wkt::Timestamp;
    /// let x = Occurrence::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Occurrence::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use wkt::Timestamp;
    /// let x = Occurrence::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = Occurrence::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Occurrence::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use wkt::Timestamp;
    /// let x = Occurrence::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Occurrence::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use wkt::Timestamp;
    /// let x = Occurrence::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = Occurrence::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [envelope][crate::model::Occurrence::envelope].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::Envelope;
    /// let x = Occurrence::new().set_envelope(Envelope::default()/* use setters */);
    /// ```
    pub fn set_envelope<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Envelope>
    {
        self.envelope = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [envelope][crate::model::Occurrence::envelope].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::Envelope;
    /// let x = Occurrence::new().set_or_clear_envelope(Some(Envelope::default()/* use setters */));
    /// let x = Occurrence::new().set_or_clear_envelope(None::<Envelope>);
    /// ```
    pub fn set_or_clear_envelope<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Envelope>
    {
        self.envelope = v.map(|x| x.into());
        self
    }

    /// Sets the value of [details][crate::model::Occurrence::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// let x = Occurrence::new().set_details(Some(
    ///     google_cloud_grafeas_v1::model::occurrence::Details::Vulnerability(VulnerabilityOccurrence::default().into())));
    /// ```
    pub fn set_details<T: std::convert::Into<std::option::Option<crate::model::occurrence::Details>>>(mut self, v: T) -> Self
    {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Vulnerability`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vulnerability(&self) -> std::option::Option<&std::boxed::Box<crate::model::VulnerabilityOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Vulnerability(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Vulnerability`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// let x = Occurrence::new().set_vulnerability(VulnerabilityOccurrence::default()/* use setters */);
    /// assert!(x.vulnerability().is_some());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_vulnerability<T: std::convert::Into<std::boxed::Box<crate::model::VulnerabilityOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::Vulnerability(
                v.into()
            )
        );
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Build`, `None` if the field is not set or
    /// holds a different branch.
    pub fn build(&self) -> std::option::Option<&std::boxed::Box<crate::model::BuildOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Build(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Build`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::BuildOccurrence;
    /// let x = Occurrence::new().set_build(BuildOccurrence::default()/* use setters */);
    /// assert!(x.build().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_build<T: std::convert::Into<std::boxed::Box<crate::model::BuildOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::Build(
                v.into()
            )
        );
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Image`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image(&self) -> std::option::Option<&std::boxed::Box<crate::model::ImageOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Image(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Image`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::ImageOccurrence;
    /// let x = Occurrence::new().set_image(ImageOccurrence::default()/* use setters */);
    /// assert!(x.image().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_image<T: std::convert::Into<std::boxed::Box<crate::model::ImageOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::Image(
                v.into()
            )
        );
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Package`, `None` if the field is not set or
    /// holds a different branch.
    pub fn package(&self) -> std::option::Option<&std::boxed::Box<crate::model::PackageOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Package(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Package`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::PackageOccurrence;
    /// let x = Occurrence::new().set_package(PackageOccurrence::default()/* use setters */);
    /// assert!(x.package().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_package<T: std::convert::Into<std::boxed::Box<crate::model::PackageOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::Package(
                v.into()
            )
        );
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Deployment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deployment(&self) -> std::option::Option<&std::boxed::Box<crate::model::DeploymentOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Deployment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Deployment`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::DeploymentOccurrence;
    /// let x = Occurrence::new().set_deployment(DeploymentOccurrence::default()/* use setters */);
    /// assert!(x.deployment().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_deployment<T: std::convert::Into<std::boxed::Box<crate::model::DeploymentOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::Deployment(
                v.into()
            )
        );
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Discovery`, `None` if the field is not set or
    /// holds a different branch.
    pub fn discovery(&self) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Discovery(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Discovery`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::DiscoveryOccurrence;
    /// let x = Occurrence::new().set_discovery(DiscoveryOccurrence::default()/* use setters */);
    /// assert!(x.discovery().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_discovery<T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::Discovery(
                v.into()
            )
        );
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Attestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn attestation(&self) -> std::option::Option<&std::boxed::Box<crate::model::AttestationOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Attestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Attestation`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::AttestationOccurrence;
    /// let x = Occurrence::new().set_attestation(AttestationOccurrence::default()/* use setters */);
    /// assert!(x.attestation().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_attestation<T: std::convert::Into<std::boxed::Box<crate::model::AttestationOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::Attestation(
                v.into()
            )
        );
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Upgrade`, `None` if the field is not set or
    /// holds a different branch.
    pub fn upgrade(&self) -> std::option::Option<&std::boxed::Box<crate::model::UpgradeOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Upgrade(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Upgrade`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::UpgradeOccurrence;
    /// let x = Occurrence::new().set_upgrade(UpgradeOccurrence::default()/* use setters */);
    /// assert!(x.upgrade().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_upgrade<T: std::convert::Into<std::boxed::Box<crate::model::UpgradeOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::Upgrade(
                v.into()
            )
        );
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Compliance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compliance(&self) -> std::option::Option<&std::boxed::Box<crate::model::ComplianceOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Compliance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Compliance`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::ComplianceOccurrence;
    /// let x = Occurrence::new().set_compliance(ComplianceOccurrence::default()/* use setters */);
    /// assert!(x.compliance().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_compliance<T: std::convert::Into<std::boxed::Box<crate::model::ComplianceOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::Compliance(
                v.into()
            )
        );
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `DsseAttestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dsse_attestation(&self) -> std::option::Option<&std::boxed::Box<crate::model::DSSEAttestationOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::DsseAttestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `DsseAttestation`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::DSSEAttestationOccurrence;
    /// let x = Occurrence::new().set_dsse_attestation(DSSEAttestationOccurrence::default()/* use setters */);
    /// assert!(x.dsse_attestation().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_dsse_attestation<T: std::convert::Into<std::boxed::Box<crate::model::DSSEAttestationOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::DsseAttestation(
                v.into()
            )
        );
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `SbomReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sbom_reference(&self) -> std::option::Option<&std::boxed::Box<crate::model::SBOMReferenceOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::SbomReference(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `SbomReference`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::SBOMReferenceOccurrence;
    /// let x = Occurrence::new().set_sbom_reference(SBOMReferenceOccurrence::default()/* use setters */);
    /// assert!(x.sbom_reference().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_sbom_reference<T: std::convert::Into<std::boxed::Box<crate::model::SBOMReferenceOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::SbomReference(
                v.into()
            )
        );
        self
    }

    /// The value of [details][crate::model::Occurrence::details]
    /// if it holds a `Secret`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret(&self) -> std::option::Option<&std::boxed::Box<crate::model::SecretOccurrence>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::occurrence::Details::Secret(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Occurrence::details]
    /// to hold a `Secret`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Occurrence;
    /// use google_cloud_grafeas_v1::model::SecretOccurrence;
    /// let x = Occurrence::new().set_secret(SecretOccurrence::default()/* use setters */);
    /// assert!(x.secret().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// ```
    pub fn set_secret<T: std::convert::Into<std::boxed::Box<crate::model::SecretOccurrence>>>(mut self, v: T) -> Self {
        self.details = std::option::Option::Some(
            crate::model::occurrence::Details::Secret(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for Occurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Occurrence"
    }
}

/// Defines additional types related to [Occurrence].
pub mod occurrence {
    #[allow(unused_imports)]
    use super::*;


    /// Required. Immutable. Describes the details of the note kind found on this
    /// resource.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Details {
        /// Describes a security vulnerability.
        Vulnerability(std::boxed::Box<crate::model::VulnerabilityOccurrence>),
        /// Describes a verifiable build.
        Build(std::boxed::Box<crate::model::BuildOccurrence>),
        /// Describes how this resource derives from the basis in the associated
        /// note.
        Image(std::boxed::Box<crate::model::ImageOccurrence>),
        /// Describes the installation of a package on the linked resource.
        Package(std::boxed::Box<crate::model::PackageOccurrence>),
        /// Describes the deployment of an artifact on a runtime.
        Deployment(std::boxed::Box<crate::model::DeploymentOccurrence>),
        /// Describes when a resource was discovered.
        Discovery(std::boxed::Box<crate::model::DiscoveryOccurrence>),
        /// Describes an attestation of an artifact.
        Attestation(std::boxed::Box<crate::model::AttestationOccurrence>),
        /// Describes an available package upgrade on the linked resource.
        Upgrade(std::boxed::Box<crate::model::UpgradeOccurrence>),
        /// Describes a compliance violation on a linked resource.
        Compliance(std::boxed::Box<crate::model::ComplianceOccurrence>),
        /// Describes an attestation of an artifact using dsse.
        DsseAttestation(std::boxed::Box<crate::model::DSSEAttestationOccurrence>),
        /// Describes a specific SBOM reference occurrences.
        SbomReference(std::boxed::Box<crate::model::SBOMReferenceOccurrence>),
        /// Describes a secret.
        Secret(std::boxed::Box<crate::model::SecretOccurrence>),
    }
}

/// A type of analysis that can be done for a resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Note {

    /// Output only. The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    pub name: std::string::String,

    /// A one sentence description of this note.
    pub short_description: std::string::String,

    /// A detailed description of this note.
    pub long_description: std::string::String,

    /// Output only. The type of analysis. This field can be used as a filter in
    /// list requests.
    pub kind: crate::model::NoteKind,

    /// URLs associated with this note.
    pub related_url: std::vec::Vec<crate::model::RelatedUrl>,

    /// Time of expiration for this note. Empty if note does not expire.
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this note was created. This field can be used as a
    /// filter in list requests.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this note was last updated. This field can be used as
    /// a filter in list requests.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Other notes related to this note.
    pub related_note_names: std::vec::Vec<std::string::String>,

    /// Required. Immutable. The type of analysis this note represents.
    pub r#type: std::option::Option<crate::model::note::Type>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Note {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Note::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// let x = Note::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [short_description][crate::model::Note::short_description].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// let x = Note::new().set_short_description("example");
    /// ```
    pub fn set_short_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.short_description = v.into();
        self
    }

    /// Sets the value of [long_description][crate::model::Note::long_description].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// let x = Note::new().set_long_description("example");
    /// ```
    pub fn set_long_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.long_description = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Note::kind].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::NoteKind;
    /// let x0 = Note::new().set_kind(NoteKind::Vulnerability);
    /// let x1 = Note::new().set_kind(NoteKind::Build);
    /// let x2 = Note::new().set_kind(NoteKind::Image);
    /// ```
    pub fn set_kind<T: std::convert::Into<crate::model::NoteKind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [related_url][crate::model::Note::related_url].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::RelatedUrl;
    /// let x = Note::new()
    ///     .set_related_url([
    ///         RelatedUrl::default()/* use setters */,
    ///         RelatedUrl::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_related_url<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedUrl>
    {
        use std::iter::Iterator;
        self.related_url = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [expiration_time][crate::model::Note::expiration_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use wkt::Timestamp;
    /// let x = Note::new().set_expiration_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::Note::expiration_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use wkt::Timestamp;
    /// let x = Note::new().set_or_clear_expiration_time(Some(Timestamp::default()/* use setters */));
    /// let x = Note::new().set_or_clear_expiration_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Note::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use wkt::Timestamp;
    /// let x = Note::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Note::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use wkt::Timestamp;
    /// let x = Note::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = Note::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Note::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use wkt::Timestamp;
    /// let x = Note::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Note::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use wkt::Timestamp;
    /// let x = Note::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = Note::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [related_note_names][crate::model::Note::related_note_names].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// let x = Note::new().set_related_note_names(["a", "b", "c"]);
    /// ```
    pub fn set_related_note_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.related_note_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [r#type][crate::model::Note::type].
    ///
    /// Note that all the setters affecting `r#type` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// let x = Note::new().set_type(Some(
    ///     google_cloud_grafeas_v1::model::note::Type::Vulnerability(VulnerabilityNote::default().into())));
    /// ```
    pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::note::Type>>>(mut self, v: T) -> Self
    {
        self.r#type = v.into();
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Vulnerability`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vulnerability(&self) -> std::option::Option<&std::boxed::Box<crate::model::VulnerabilityNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Vulnerability(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Vulnerability`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// let x = Note::new().set_vulnerability(VulnerabilityNote::default()/* use setters */);
    /// assert!(x.vulnerability().is_some());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_vulnerability<T: std::convert::Into<std::boxed::Box<crate::model::VulnerabilityNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::Vulnerability(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Build`, `None` if the field is not set or
    /// holds a different branch.
    pub fn build(&self) -> std::option::Option<&std::boxed::Box<crate::model::BuildNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Build(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Build`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::BuildNote;
    /// let x = Note::new().set_build(BuildNote::default()/* use setters */);
    /// assert!(x.build().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_build<T: std::convert::Into<std::boxed::Box<crate::model::BuildNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::Build(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Image`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image(&self) -> std::option::Option<&std::boxed::Box<crate::model::ImageNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Image(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Image`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::ImageNote;
    /// let x = Note::new().set_image(ImageNote::default()/* use setters */);
    /// assert!(x.image().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_image<T: std::convert::Into<std::boxed::Box<crate::model::ImageNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::Image(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Package`, `None` if the field is not set or
    /// holds a different branch.
    pub fn package(&self) -> std::option::Option<&std::boxed::Box<crate::model::PackageNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Package(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Package`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::PackageNote;
    /// let x = Note::new().set_package(PackageNote::default()/* use setters */);
    /// assert!(x.package().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_package<T: std::convert::Into<std::boxed::Box<crate::model::PackageNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::Package(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Deployment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deployment(&self) -> std::option::Option<&std::boxed::Box<crate::model::DeploymentNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Deployment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Deployment`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::DeploymentNote;
    /// let x = Note::new().set_deployment(DeploymentNote::default()/* use setters */);
    /// assert!(x.deployment().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_deployment<T: std::convert::Into<std::boxed::Box<crate::model::DeploymentNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::Deployment(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Discovery`, `None` if the field is not set or
    /// holds a different branch.
    pub fn discovery(&self) -> std::option::Option<&std::boxed::Box<crate::model::DiscoveryNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Discovery(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Discovery`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::DiscoveryNote;
    /// let x = Note::new().set_discovery(DiscoveryNote::default()/* use setters */);
    /// assert!(x.discovery().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_discovery<T: std::convert::Into<std::boxed::Box<crate::model::DiscoveryNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::Discovery(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Attestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn attestation(&self) -> std::option::Option<&std::boxed::Box<crate::model::AttestationNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Attestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Attestation`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::AttestationNote;
    /// let x = Note::new().set_attestation(AttestationNote::default()/* use setters */);
    /// assert!(x.attestation().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_attestation<T: std::convert::Into<std::boxed::Box<crate::model::AttestationNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::Attestation(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Upgrade`, `None` if the field is not set or
    /// holds a different branch.
    pub fn upgrade(&self) -> std::option::Option<&std::boxed::Box<crate::model::UpgradeNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Upgrade(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Upgrade`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::UpgradeNote;
    /// let x = Note::new().set_upgrade(UpgradeNote::default()/* use setters */);
    /// assert!(x.upgrade().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_upgrade<T: std::convert::Into<std::boxed::Box<crate::model::UpgradeNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::Upgrade(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Compliance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compliance(&self) -> std::option::Option<&std::boxed::Box<crate::model::ComplianceNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Compliance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Compliance`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::ComplianceNote;
    /// let x = Note::new().set_compliance(ComplianceNote::default()/* use setters */);
    /// assert!(x.compliance().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_compliance<T: std::convert::Into<std::boxed::Box<crate::model::ComplianceNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::Compliance(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `DsseAttestation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dsse_attestation(&self) -> std::option::Option<&std::boxed::Box<crate::model::DSSEAttestationNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::DsseAttestation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `DsseAttestation`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::DSSEAttestationNote;
    /// let x = Note::new().set_dsse_attestation(DSSEAttestationNote::default()/* use setters */);
    /// assert!(x.dsse_attestation().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_dsse_attestation<T: std::convert::Into<std::boxed::Box<crate::model::DSSEAttestationNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::DsseAttestation(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `VulnerabilityAssessment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vulnerability_assessment(&self) -> std::option::Option<&std::boxed::Box<crate::model::VulnerabilityAssessmentNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::VulnerabilityAssessment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `VulnerabilityAssessment`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::VulnerabilityAssessmentNote;
    /// let x = Note::new().set_vulnerability_assessment(VulnerabilityAssessmentNote::default()/* use setters */);
    /// assert!(x.vulnerability_assessment().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_vulnerability_assessment<T: std::convert::Into<std::boxed::Box<crate::model::VulnerabilityAssessmentNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::VulnerabilityAssessment(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `SbomReference`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sbom_reference(&self) -> std::option::Option<&std::boxed::Box<crate::model::SBOMReferenceNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::SbomReference(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `SbomReference`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::SBOMReferenceNote;
    /// let x = Note::new().set_sbom_reference(SBOMReferenceNote::default()/* use setters */);
    /// assert!(x.sbom_reference().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.secret().is_none());
    /// ```
    pub fn set_sbom_reference<T: std::convert::Into<std::boxed::Box<crate::model::SBOMReferenceNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::SbomReference(
                v.into()
            )
        );
        self
    }

    /// The value of [r#type][crate::model::Note::r#type]
    /// if it holds a `Secret`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret(&self) -> std::option::Option<&std::boxed::Box<crate::model::SecretNote>> {
        #[allow(unreachable_patterns)]
        self.r#type.as_ref().and_then(|v| match v {
            crate::model::note::Type::Secret(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [r#type][crate::model::Note::r#type]
    /// to hold a `Secret`.
    ///
    /// Note that all the setters affecting `r#type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Note;
    /// use google_cloud_grafeas_v1::model::SecretNote;
    /// let x = Note::new().set_secret(SecretNote::default()/* use setters */);
    /// assert!(x.secret().is_some());
    /// assert!(x.vulnerability().is_none());
    /// assert!(x.build().is_none());
    /// assert!(x.image().is_none());
    /// assert!(x.package().is_none());
    /// assert!(x.deployment().is_none());
    /// assert!(x.discovery().is_none());
    /// assert!(x.attestation().is_none());
    /// assert!(x.upgrade().is_none());
    /// assert!(x.compliance().is_none());
    /// assert!(x.dsse_attestation().is_none());
    /// assert!(x.vulnerability_assessment().is_none());
    /// assert!(x.sbom_reference().is_none());
    /// ```
    pub fn set_secret<T: std::convert::Into<std::boxed::Box<crate::model::SecretNote>>>(mut self, v: T) -> Self {
        self.r#type = std::option::Option::Some(
            crate::model::note::Type::Secret(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for Note {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Note"
    }
}

/// Defines additional types related to [Note].
pub mod note {
    #[allow(unused_imports)]
    use super::*;


    /// Required. Immutable. The type of analysis this note represents.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// A note describing a package vulnerability.
        Vulnerability(std::boxed::Box<crate::model::VulnerabilityNote>),
        /// A note describing build provenance for a verifiable build.
        Build(std::boxed::Box<crate::model::BuildNote>),
        /// A note describing a base image.
        Image(std::boxed::Box<crate::model::ImageNote>),
        /// A note describing a package hosted by various package managers.
        Package(std::boxed::Box<crate::model::PackageNote>),
        /// A note describing something that can be deployed.
        Deployment(std::boxed::Box<crate::model::DeploymentNote>),
        /// A note describing the initial analysis of a resource.
        Discovery(std::boxed::Box<crate::model::DiscoveryNote>),
        /// A note describing an attestation role.
        Attestation(std::boxed::Box<crate::model::AttestationNote>),
        /// A note describing available package upgrades.
        Upgrade(std::boxed::Box<crate::model::UpgradeNote>),
        /// A note describing a compliance check.
        Compliance(std::boxed::Box<crate::model::ComplianceNote>),
        /// A note describing a dsse attestation note.
        DsseAttestation(std::boxed::Box<crate::model::DSSEAttestationNote>),
        /// A note describing a vulnerability assessment.
        VulnerabilityAssessment(std::boxed::Box<crate::model::VulnerabilityAssessmentNote>),
        /// A note describing an SBOM reference.
        SbomReference(std::boxed::Box<crate::model::SBOMReferenceNote>),
        /// A note describing a secret.
        Secret(std::boxed::Box<crate::model::SecretNote>),
    }
}

/// Request to get an occurrence.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOccurrenceRequest {

    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOccurrenceRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::GetOccurrenceRequest;
    /// let x = GetOccurrenceRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GetOccurrenceRequest"
    }
}

/// Request to list occurrences.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOccurrencesRequest {

    /// The name of the project to list occurrences for in the form of
    /// `projects/[PROJECT_ID]`.
    pub parent: std::string::String,

    /// The filter expression.
    pub filter: std::string::String,

    /// Number of occurrences to return in the list. Must be positive. Max allowed
    /// page size is 1000. If not specified, page size defaults to 20.
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOccurrencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOccurrencesRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListOccurrencesRequest;
    /// let x = ListOccurrencesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOccurrencesRequest::filter].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListOccurrencesRequest;
    /// let x = ListOccurrencesRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOccurrencesRequest::page_size].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListOccurrencesRequest;
    /// let x = ListOccurrencesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOccurrencesRequest::page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListOccurrencesRequest;
    /// let x = ListOccurrencesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOccurrencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListOccurrencesRequest"
    }
}

/// Response for listing occurrences.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOccurrencesResponse {

    /// The occurrences requested.
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    /// The next pagination token in the list response. It should be used as
    /// `page_token` for the following request. An empty value means no more
    /// results.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOccurrencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [occurrences][crate::model::ListOccurrencesResponse::occurrences].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListOccurrencesResponse;
    /// use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = ListOccurrencesResponse::new()
    ///     .set_occurrences([
    ///         Occurrence::default()/* use setters */,
    ///         Occurrence::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOccurrencesResponse::next_page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListOccurrencesResponse;
    /// let x = ListOccurrencesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOccurrencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListOccurrencesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOccurrencesResponse {
    type PageItem = crate::model::Occurrence;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.occurrences
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to delete an occurrence.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteOccurrenceRequest {

    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteOccurrenceRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeleteOccurrenceRequest;
    /// let x = DeleteOccurrenceRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeleteOccurrenceRequest"
    }
}

/// Request to create a new occurrence.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateOccurrenceRequest {

    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the occurrence is to be created.
    pub parent: std::string::String,

    /// The occurrence to create.
    pub occurrence: std::option::Option<crate::model::Occurrence>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateOccurrenceRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CreateOccurrenceRequest;
    /// let x = CreateOccurrenceRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [occurrence][crate::model::CreateOccurrenceRequest::occurrence].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CreateOccurrenceRequest;
    /// use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = CreateOccurrenceRequest::new().set_occurrence(Occurrence::default()/* use setters */);
    /// ```
    pub fn set_occurrence<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Occurrence>
    {
        self.occurrence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [occurrence][crate::model::CreateOccurrenceRequest::occurrence].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CreateOccurrenceRequest;
    /// use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = CreateOccurrenceRequest::new().set_or_clear_occurrence(Some(Occurrence::default()/* use setters */));
    /// let x = CreateOccurrenceRequest::new().set_or_clear_occurrence(None::<Occurrence>);
    /// ```
    pub fn set_or_clear_occurrence<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Occurrence>
    {
        self.occurrence = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CreateOccurrenceRequest"
    }
}

/// Request to update an occurrence.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateOccurrenceRequest {

    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    pub name: std::string::String,

    /// The updated occurrence.
    pub occurrence: std::option::Option<crate::model::Occurrence>,

    /// The fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateOccurrenceRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpdateOccurrenceRequest;
    /// let x = UpdateOccurrenceRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [occurrence][crate::model::UpdateOccurrenceRequest::occurrence].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpdateOccurrenceRequest;
    /// use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = UpdateOccurrenceRequest::new().set_occurrence(Occurrence::default()/* use setters */);
    /// ```
    pub fn set_occurrence<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Occurrence>
    {
        self.occurrence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [occurrence][crate::model::UpdateOccurrenceRequest::occurrence].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpdateOccurrenceRequest;
    /// use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = UpdateOccurrenceRequest::new().set_or_clear_occurrence(Some(Occurrence::default()/* use setters */));
    /// let x = UpdateOccurrenceRequest::new().set_or_clear_occurrence(None::<Occurrence>);
    /// ```
    pub fn set_or_clear_occurrence<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Occurrence>
    {
        self.occurrence = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateOccurrenceRequest::update_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpdateOccurrenceRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateOccurrenceRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateOccurrenceRequest::update_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpdateOccurrenceRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateOccurrenceRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateOccurrenceRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpdateOccurrenceRequest"
    }
}

/// Request to get a note.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNoteRequest {

    /// The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNoteRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::GetNoteRequest;
    /// let x = GetNoteRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GetNoteRequest"
    }
}

/// Request to get the note to which the specified occurrence is attached.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOccurrenceNoteRequest {

    /// The name of the occurrence in the form of
    /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOccurrenceNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOccurrenceNoteRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::GetOccurrenceNoteRequest;
    /// let x = GetOccurrenceNoteRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOccurrenceNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GetOccurrenceNoteRequest"
    }
}

/// Request to list notes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNotesRequest {

    /// The name of the project to list notes for in the form of
    /// `projects/[PROJECT_ID]`.
    pub parent: std::string::String,

    /// The filter expression.
    pub filter: std::string::String,

    /// Number of notes to return in the list. Must be positive. Max allowed page
    /// size is 1000. If not specified, page size defaults to 20.
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNotesRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNotesRequest;
    /// let x = ListNotesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNotesRequest::filter].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNotesRequest;
    /// let x = ListNotesRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotesRequest::page_size].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNotesRequest;
    /// let x = ListNotesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotesRequest::page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNotesRequest;
    /// let x = ListNotesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNotesRequest"
    }
}

/// Response for listing notes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNotesResponse {

    /// The notes requested.
    pub notes: std::vec::Vec<crate::model::Note>,

    /// The next pagination token in the list response. It should be used as
    /// `page_token` for the following request. An empty value means no more
    /// results.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notes][crate::model::ListNotesResponse::notes].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNotesResponse;
    /// use google_cloud_grafeas_v1::model::Note;
    /// let x = ListNotesResponse::new()
    ///     .set_notes([
    ///         Note::default()/* use setters */,
    ///         Note::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_notes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Note>
    {
        use std::iter::Iterator;
        self.notes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNotesResponse::next_page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNotesResponse;
    /// let x = ListNotesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNotesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNotesResponse {
    type PageItem = crate::model::Note;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to delete a note.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteNoteRequest {

    /// The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNoteRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::DeleteNoteRequest;
    /// let x = DeleteNoteRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.DeleteNoteRequest"
    }
}

/// Request to create a new note.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateNoteRequest {

    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the note is to be created.
    pub parent: std::string::String,

    /// The ID to use for this note.
    pub note_id: std::string::String,

    /// The note to create.
    pub note: std::option::Option<crate::model::Note>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNoteRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CreateNoteRequest;
    /// let x = CreateNoteRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [note_id][crate::model::CreateNoteRequest::note_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CreateNoteRequest;
    /// let x = CreateNoteRequest::new().set_note_id("example");
    /// ```
    pub fn set_note_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note_id = v.into();
        self
    }

    /// Sets the value of [note][crate::model::CreateNoteRequest::note].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CreateNoteRequest;
    /// use google_cloud_grafeas_v1::model::Note;
    /// let x = CreateNoteRequest::new().set_note(Note::default()/* use setters */);
    /// ```
    pub fn set_note<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Note>
    {
        self.note = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [note][crate::model::CreateNoteRequest::note].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CreateNoteRequest;
    /// use google_cloud_grafeas_v1::model::Note;
    /// let x = CreateNoteRequest::new().set_or_clear_note(Some(Note::default()/* use setters */));
    /// let x = CreateNoteRequest::new().set_or_clear_note(None::<Note>);
    /// ```
    pub fn set_or_clear_note<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Note>
    {
        self.note = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CreateNoteRequest"
    }
}

/// Request to update a note.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateNoteRequest {

    /// The name of the note in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    pub name: std::string::String,

    /// The updated note.
    pub note: std::option::Option<crate::model::Note>,

    /// The fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateNoteRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpdateNoteRequest;
    /// let x = UpdateNoteRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [note][crate::model::UpdateNoteRequest::note].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpdateNoteRequest;
    /// use google_cloud_grafeas_v1::model::Note;
    /// let x = UpdateNoteRequest::new().set_note(Note::default()/* use setters */);
    /// ```
    pub fn set_note<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Note>
    {
        self.note = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [note][crate::model::UpdateNoteRequest::note].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpdateNoteRequest;
    /// use google_cloud_grafeas_v1::model::Note;
    /// let x = UpdateNoteRequest::new().set_or_clear_note(Some(Note::default()/* use setters */));
    /// let x = UpdateNoteRequest::new().set_or_clear_note(None::<Note>);
    /// ```
    pub fn set_or_clear_note<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Note>
    {
        self.note = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNoteRequest::update_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpdateNoteRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateNoteRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNoteRequest::update_mask].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpdateNoteRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateNoteRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateNoteRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateNoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpdateNoteRequest"
    }
}

/// Request to list occurrences for a note.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNoteOccurrencesRequest {

    /// The name of the note to list occurrences for in the form of
    /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    pub name: std::string::String,

    /// The filter expression.
    pub filter: std::string::String,

    /// Number of occurrences to return in the list.
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNoteOccurrencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListNoteOccurrencesRequest::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNoteOccurrencesRequest;
    /// let x = ListNoteOccurrencesRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNoteOccurrencesRequest::filter].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNoteOccurrencesRequest;
    /// let x = ListNoteOccurrencesRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNoteOccurrencesRequest::page_size].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNoteOccurrencesRequest;
    /// let x = ListNoteOccurrencesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNoteOccurrencesRequest::page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNoteOccurrencesRequest;
    /// let x = ListNoteOccurrencesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNoteOccurrencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNoteOccurrencesRequest"
    }
}

/// Response for listing occurrences for a note.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNoteOccurrencesResponse {

    /// The occurrences attached to the specified note.
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    /// Token to provide to skip to a particular spot in the list.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNoteOccurrencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [occurrences][crate::model::ListNoteOccurrencesResponse::occurrences].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNoteOccurrencesResponse;
    /// use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = ListNoteOccurrencesResponse::new()
    ///     .set_occurrences([
    ///         Occurrence::default()/* use setters */,
    ///         Occurrence::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNoteOccurrencesResponse::next_page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ListNoteOccurrencesResponse;
    /// let x = ListNoteOccurrencesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNoteOccurrencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ListNoteOccurrencesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNoteOccurrencesResponse {
    type PageItem = crate::model::Occurrence;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.occurrences
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to create notes in batch.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateNotesRequest {

    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the notes are to be created.
    pub parent: std::string::String,

    /// The notes to create. Max allowed length is 1000.
    pub notes: std::collections::HashMap<std::string::String,crate::model::Note>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateNotesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateNotesRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BatchCreateNotesRequest;
    /// let x = BatchCreateNotesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [notes][crate::model::BatchCreateNotesRequest::notes].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BatchCreateNotesRequest;
    /// use google_cloud_grafeas_v1::model::Note;
    /// let x = BatchCreateNotesRequest::new().set_notes([
    ///     ("key0", Note::default()/* use setters */),
    ///     ("key1", Note::default()/* use (different) setters */),
    /// ]);
    /// ```
    pub fn set_notes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Note>,
    {
        use std::iter::Iterator;
        self.notes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateNotesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateNotesRequest"
    }
}

/// Response for creating notes in batch.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateNotesResponse {

    /// The notes that were created.
    pub notes: std::vec::Vec<crate::model::Note>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateNotesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notes][crate::model::BatchCreateNotesResponse::notes].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BatchCreateNotesResponse;
    /// use google_cloud_grafeas_v1::model::Note;
    /// let x = BatchCreateNotesResponse::new()
    ///     .set_notes([
    ///         Note::default()/* use setters */,
    ///         Note::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_notes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Note>
    {
        use std::iter::Iterator;
        self.notes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateNotesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateNotesResponse"
    }
}

/// Request to create occurrences in batch.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateOccurrencesRequest {

    /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
    /// the occurrences are to be created.
    pub parent: std::string::String,

    /// The occurrences to create. Max allowed length is 1000.
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateOccurrencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateOccurrencesRequest::parent].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BatchCreateOccurrencesRequest;
    /// let x = BatchCreateOccurrencesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [occurrences][crate::model::BatchCreateOccurrencesRequest::occurrences].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BatchCreateOccurrencesRequest;
    /// use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = BatchCreateOccurrencesRequest::new()
    ///     .set_occurrences([
    ///         Occurrence::default()/* use setters */,
    ///         Occurrence::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateOccurrencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateOccurrencesRequest"
    }
}

/// Response for creating occurrences in batch.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateOccurrencesResponse {

    /// The occurrences that were created.
    pub occurrences: std::vec::Vec<crate::model::Occurrence>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateOccurrencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [occurrences][crate::model::BatchCreateOccurrencesResponse::occurrences].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BatchCreateOccurrencesResponse;
    /// use google_cloud_grafeas_v1::model::Occurrence;
    /// let x = BatchCreateOccurrencesResponse::new()
    ///     .set_occurrences([
    ///         Occurrence::default()/* use setters */,
    ///         Occurrence::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_occurrences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Occurrence>
    {
        use std::iter::Iterator;
        self.occurrences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateOccurrencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BatchCreateOccurrencesResponse"
    }
}

/// Layer holds metadata specific to a layer of a Docker image.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Layer {

    /// Required. The recovered Dockerfile directive used to construct this layer.
    /// See <https://docs.docker.com/engine/reference/builder/> for more information.
    pub directive: std::string::String,

    /// The recovered arguments to the Dockerfile directive.
    pub arguments: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Layer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [directive][crate::model::Layer::directive].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Layer;
    /// let x = Layer::new().set_directive("example");
    /// ```
    pub fn set_directive<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.directive = v.into();
        self
    }

    /// Sets the value of [arguments][crate::model::Layer::arguments].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Layer;
    /// let x = Layer::new().set_arguments("example");
    /// ```
    pub fn set_arguments<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.arguments = v.into();
        self
    }
}

impl wkt::message::Message for Layer {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Layer"
    }
}

/// A set of properties that uniquely identify a given Docker image.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Fingerprint {

    /// Required. The layer ID of the final layer in the Docker image's v1
    /// representation.
    pub v1_name: std::string::String,

    /// Required. The ordered list of v2 blobs that represent a given image.
    pub v2_blob: std::vec::Vec<std::string::String>,

    /// Output only. The name of the image's v2 blobs computed via:
    /// [bottom] := v2_blob[bottom]
    /// [N] := sha256(v2_blob[N] + " " + v2_name[N+1])
    /// Only the name of the final blob is kept.
    pub v2_name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Fingerprint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [v1_name][crate::model::Fingerprint::v1_name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Fingerprint;
    /// let x = Fingerprint::new().set_v1_name("example");
    /// ```
    pub fn set_v1_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.v1_name = v.into();
        self
    }

    /// Sets the value of [v2_blob][crate::model::Fingerprint::v2_blob].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Fingerprint;
    /// let x = Fingerprint::new().set_v2_blob(["a", "b", "c"]);
    /// ```
    pub fn set_v2_blob<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.v2_blob = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [v2_name][crate::model::Fingerprint::v2_name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Fingerprint;
    /// let x = Fingerprint::new().set_v2_name("example");
    /// ```
    pub fn set_v2_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.v2_name = v.into();
        self
    }
}

impl wkt::message::Message for Fingerprint {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Fingerprint"
    }
}

/// Basis describes the base image portion (Note) of the DockerImage
/// relationship. Linked occurrences are derived from this or an equivalent image
/// via:
/// FROM <Basis.resource_url>
/// Or an equivalent reference, e.g., a tag of the resource_url.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageNote {

    /// Required. Immutable. The resource_url for the resource representing the
    /// basis of associated occurrence images.
    pub resource_url: std::string::String,

    /// Required. Immutable. The fingerprint of the base image.
    pub fingerprint: std::option::Option<crate::model::Fingerprint>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_url][crate::model::ImageNote::resource_url].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ImageNote;
    /// let x = ImageNote::new().set_resource_url("example");
    /// ```
    pub fn set_resource_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_url = v.into();
        self
    }

    /// Sets the value of [fingerprint][crate::model::ImageNote::fingerprint].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ImageNote;
    /// use google_cloud_grafeas_v1::model::Fingerprint;
    /// let x = ImageNote::new().set_fingerprint(Fingerprint::default()/* use setters */);
    /// ```
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Fingerprint>
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::ImageNote::fingerprint].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ImageNote;
    /// use google_cloud_grafeas_v1::model::Fingerprint;
    /// let x = ImageNote::new().set_or_clear_fingerprint(Some(Fingerprint::default()/* use setters */));
    /// let x = ImageNote::new().set_or_clear_fingerprint(None::<Fingerprint>);
    /// ```
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Fingerprint>
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImageNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ImageNote"
    }
}

/// Details of the derived image portion of the DockerImage relationship. This
/// image would be produced from a Dockerfile with FROM <DockerImage.Basis in
/// attached Note>.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageOccurrence {

    /// Required. The fingerprint of the derived image.
    pub fingerprint: std::option::Option<crate::model::Fingerprint>,

    /// Output only. The number of layers by which this image differs from the
    /// associated image basis.
    pub distance: i32,

    /// This contains layer-specific metadata, if populated it has length
    /// "distance" and is ordered with [distance] being the layer immediately
    /// following the base image and [1] being the final layer.
    pub layer_info: std::vec::Vec<crate::model::Layer>,

    /// Output only. This contains the base image URL for the derived image
    /// occurrence.
    pub base_resource_url: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::ImageOccurrence::fingerprint].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ImageOccurrence;
    /// use google_cloud_grafeas_v1::model::Fingerprint;
    /// let x = ImageOccurrence::new().set_fingerprint(Fingerprint::default()/* use setters */);
    /// ```
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Fingerprint>
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::ImageOccurrence::fingerprint].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ImageOccurrence;
    /// use google_cloud_grafeas_v1::model::Fingerprint;
    /// let x = ImageOccurrence::new().set_or_clear_fingerprint(Some(Fingerprint::default()/* use setters */));
    /// let x = ImageOccurrence::new().set_or_clear_fingerprint(None::<Fingerprint>);
    /// ```
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Fingerprint>
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [distance][crate::model::ImageOccurrence::distance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ImageOccurrence;
    /// let x = ImageOccurrence::new().set_distance(42);
    /// ```
    pub fn set_distance<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.distance = v.into();
        self
    }

    /// Sets the value of [layer_info][crate::model::ImageOccurrence::layer_info].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ImageOccurrence;
    /// use google_cloud_grafeas_v1::model::Layer;
    /// let x = ImageOccurrence::new()
    ///     .set_layer_info([
    ///         Layer::default()/* use setters */,
    ///         Layer::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_layer_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Layer>
    {
        use std::iter::Iterator;
        self.layer_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [base_resource_url][crate::model::ImageOccurrence::base_resource_url].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ImageOccurrence;
    /// let x = ImageOccurrence::new().set_base_resource_url("example");
    /// ```
    pub fn set_base_resource_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_resource_url = v.into();
        self
    }
}

impl wkt::message::Message for ImageOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ImageOccurrence"
    }
}

/// Steps taken to build the artifact.
/// For a TaskRun, typically each container corresponds to one step in the
/// recipe.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Recipe {

    /// URI indicating what type of recipe was performed. It determines the meaning
    /// of recipe.entryPoint, recipe.arguments, recipe.environment, and materials.
    pub r#type: std::string::String,

    /// Index in materials containing the recipe steps that are not implied by
    /// recipe.type. For example, if the recipe type were "make", then this would
    /// point to the source containing the Makefile, not the make program itself.
    /// Set to -1 if the recipe doesn't come from a material, as zero is default
    /// unset value for int64.
    pub defined_in_material: i64,

    /// String identifying the entry point into the build.
    /// This is often a path to a configuration file and/or a target label within
    /// that file. The syntax and meaning are defined by recipe.type. For example,
    /// if the recipe type were "make", then this would reference the directory in
    /// which to run make as well as which target to use.
    pub entry_point: std::string::String,

    /// Collection of all external inputs that influenced the build on top of
    /// recipe.definedInMaterial and recipe.entryPoint. For example, if the recipe
    /// type were "make", then this might be the flags passed to make aside from
    /// the target, which is captured in recipe.entryPoint. Since the arguments
    /// field can greatly vary in structure, depending on the builder and recipe
    /// type, this is of form "Any".
    pub arguments: std::vec::Vec<wkt::Any>,

    /// Any other builder-controlled inputs necessary for correctly evaluating the
    /// recipe. Usually only needed for reproducing the build but not evaluated as
    /// part of policy. Since the environment field can greatly vary in structure,
    /// depending on the builder and recipe type, this is of form "Any".
    pub environment: std::vec::Vec<wkt::Any>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Recipe {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Recipe::type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Recipe;
    /// let x = Recipe::new().set_type("example");
    /// ```
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [defined_in_material][crate::model::Recipe::defined_in_material].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Recipe;
    /// let x = Recipe::new().set_defined_in_material(42);
    /// ```
    pub fn set_defined_in_material<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.defined_in_material = v.into();
        self
    }

    /// Sets the value of [entry_point][crate::model::Recipe::entry_point].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Recipe;
    /// let x = Recipe::new().set_entry_point("example");
    /// ```
    pub fn set_entry_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_point = v.into();
        self
    }

    /// Sets the value of [arguments][crate::model::Recipe::arguments].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Recipe;
    /// use wkt::Any;
    /// let x = Recipe::new()
    ///     .set_arguments([
    ///         Any::default()/* use setters */,
    ///         Any::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_arguments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>
    {
        use std::iter::Iterator;
        self.arguments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [environment][crate::model::Recipe::environment].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Recipe;
    /// use wkt::Any;
    /// let x = Recipe::new()
    ///     .set_environment([
    ///         Any::default()/* use setters */,
    ///         Any::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_environment<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>
    {
        use std::iter::Iterator;
        self.environment = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Recipe {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Recipe"
    }
}

/// Indicates that the builder claims certain fields in this message to be
/// complete.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Completeness {

    /// If true, the builder claims that recipe.arguments is complete, meaning that
    /// all external inputs are properly captured in the recipe.
    pub arguments: bool,

    /// If true, the builder claims that recipe.environment is claimed to be
    /// complete.
    pub environment: bool,

    /// If true, the builder claims that materials are complete, usually through
    /// some controls to prevent network access. Sometimes called "hermetic".
    pub materials: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Completeness {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [arguments][crate::model::Completeness::arguments].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Completeness;
    /// let x = Completeness::new().set_arguments(true);
    /// ```
    pub fn set_arguments<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.arguments = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::Completeness::environment].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Completeness;
    /// let x = Completeness::new().set_environment(true);
    /// ```
    pub fn set_environment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [materials][crate::model::Completeness::materials].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Completeness;
    /// let x = Completeness::new().set_materials(true);
    /// ```
    pub fn set_materials<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.materials = v.into();
        self
    }
}

impl wkt::message::Message for Completeness {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Completeness"
    }
}

/// Other properties of the build.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Metadata {

    /// Identifies the particular build invocation, which can be useful for finding
    /// associated logs or other ad-hoc analysis. The value SHOULD be globally
    /// unique, per in-toto Provenance spec.
    pub build_invocation_id: std::string::String,

    /// The timestamp of when the build started.
    pub build_started_on: std::option::Option<wkt::Timestamp>,

    /// The timestamp of when the build completed.
    pub build_finished_on: std::option::Option<wkt::Timestamp>,

    /// Indicates that the builder claims certain fields in this message to be
    /// complete.
    pub completeness: std::option::Option<crate::model::Completeness>,

    /// If true, the builder claims that running the recipe on materials will
    /// produce bit-for-bit identical output.
    pub reproducible: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Metadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build_invocation_id][crate::model::Metadata::build_invocation_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Metadata;
    /// let x = Metadata::new().set_build_invocation_id("example");
    /// ```
    pub fn set_build_invocation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build_invocation_id = v.into();
        self
    }

    /// Sets the value of [build_started_on][crate::model::Metadata::build_started_on].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Metadata;
    /// use wkt::Timestamp;
    /// let x = Metadata::new().set_build_started_on(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_build_started_on<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.build_started_on = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_started_on][crate::model::Metadata::build_started_on].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Metadata;
    /// use wkt::Timestamp;
    /// let x = Metadata::new().set_or_clear_build_started_on(Some(Timestamp::default()/* use setters */));
    /// let x = Metadata::new().set_or_clear_build_started_on(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_build_started_on<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.build_started_on = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_finished_on][crate::model::Metadata::build_finished_on].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Metadata;
    /// use wkt::Timestamp;
    /// let x = Metadata::new().set_build_finished_on(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_build_finished_on<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.build_finished_on = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_finished_on][crate::model::Metadata::build_finished_on].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Metadata;
    /// use wkt::Timestamp;
    /// let x = Metadata::new().set_or_clear_build_finished_on(Some(Timestamp::default()/* use setters */));
    /// let x = Metadata::new().set_or_clear_build_finished_on(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_build_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.build_finished_on = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completeness][crate::model::Metadata::completeness].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Metadata;
    /// use google_cloud_grafeas_v1::model::Completeness;
    /// let x = Metadata::new().set_completeness(Completeness::default()/* use setters */);
    /// ```
    pub fn set_completeness<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Completeness>
    {
        self.completeness = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completeness][crate::model::Metadata::completeness].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Metadata;
    /// use google_cloud_grafeas_v1::model::Completeness;
    /// let x = Metadata::new().set_or_clear_completeness(Some(Completeness::default()/* use setters */));
    /// let x = Metadata::new().set_or_clear_completeness(None::<Completeness>);
    /// ```
    pub fn set_or_clear_completeness<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Completeness>
    {
        self.completeness = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reproducible][crate::model::Metadata::reproducible].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Metadata;
    /// let x = Metadata::new().set_reproducible(true);
    /// ```
    pub fn set_reproducible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reproducible = v.into();
        self
    }
}

impl wkt::message::Message for Metadata {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Metadata"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BuilderConfig {

    pub id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuilderConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::BuilderConfig::id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuilderConfig;
    /// let x = BuilderConfig::new().set_id("example");
    /// ```
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for BuilderConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuilderConfig"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InTotoProvenance {

    pub builder_config: std::option::Option<crate::model::BuilderConfig>,

    /// Identifies the configuration used for the build.
    /// When combined with materials, this SHOULD fully describe the build,
    /// such that re-running this recipe results in bit-for-bit identical output
    /// (if the build is reproducible).
    pub recipe: std::option::Option<crate::model::Recipe>,

    pub metadata: std::option::Option<crate::model::Metadata>,

    /// The collection of artifacts that influenced the build including sources,
    /// dependencies, build tools, base images, and so on. This is considered to be
    /// incomplete unless metadata.completeness.materials is true. Unset or null is
    /// equivalent to empty.
    pub materials: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InTotoProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder_config][crate::model::InTotoProvenance::builder_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoProvenance;
    /// use google_cloud_grafeas_v1::model::BuilderConfig;
    /// let x = InTotoProvenance::new().set_builder_config(BuilderConfig::default()/* use setters */);
    /// ```
    pub fn set_builder_config<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::BuilderConfig>
    {
        self.builder_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [builder_config][crate::model::InTotoProvenance::builder_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoProvenance;
    /// use google_cloud_grafeas_v1::model::BuilderConfig;
    /// let x = InTotoProvenance::new().set_or_clear_builder_config(Some(BuilderConfig::default()/* use setters */));
    /// let x = InTotoProvenance::new().set_or_clear_builder_config(None::<BuilderConfig>);
    /// ```
    pub fn set_or_clear_builder_config<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::BuilderConfig>
    {
        self.builder_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recipe][crate::model::InTotoProvenance::recipe].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoProvenance;
    /// use google_cloud_grafeas_v1::model::Recipe;
    /// let x = InTotoProvenance::new().set_recipe(Recipe::default()/* use setters */);
    /// ```
    pub fn set_recipe<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Recipe>
    {
        self.recipe = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recipe][crate::model::InTotoProvenance::recipe].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoProvenance;
    /// use google_cloud_grafeas_v1::model::Recipe;
    /// let x = InTotoProvenance::new().set_or_clear_recipe(Some(Recipe::default()/* use setters */));
    /// let x = InTotoProvenance::new().set_or_clear_recipe(None::<Recipe>);
    /// ```
    pub fn set_or_clear_recipe<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Recipe>
    {
        self.recipe = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::InTotoProvenance::metadata].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoProvenance;
    /// use google_cloud_grafeas_v1::model::Metadata;
    /// let x = InTotoProvenance::new().set_metadata(Metadata::default()/* use setters */);
    /// ```
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Metadata>
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::InTotoProvenance::metadata].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoProvenance;
    /// use google_cloud_grafeas_v1::model::Metadata;
    /// let x = InTotoProvenance::new().set_or_clear_metadata(Some(Metadata::default()/* use setters */));
    /// let x = InTotoProvenance::new().set_or_clear_metadata(None::<Metadata>);
    /// ```
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Metadata>
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [materials][crate::model::InTotoProvenance::materials].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoProvenance;
    /// let x = InTotoProvenance::new().set_materials(["a", "b", "c"]);
    /// ```
    pub fn set_materials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.materials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InTotoProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.InTotoProvenance"
    }
}

/// Spec defined at
/// <https://github.com/in-toto/attestation/tree/main/spec#statement> The
/// serialized InTotoStatement will be stored as Envelope.payload.
/// Envelope.payloadType is always "application/vnd.in-toto+json".
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InTotoStatement {

    /// Always `<https://in-toto.io/Statement/v0.1>`.
    pub r#type: std::string::String,

    pub subject: std::vec::Vec<crate::model::Subject>,

    /// `<https://slsa.dev/provenance/v0.1>` for SlsaProvenance.
    pub predicate_type: std::string::String,

    pub predicate: std::option::Option<crate::model::in_toto_statement::Predicate>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InTotoStatement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::InTotoStatement::type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoStatement;
    /// let x = InTotoStatement::new().set_type("example");
    /// ```
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::InTotoStatement::subject].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoStatement;
    /// use google_cloud_grafeas_v1::model::Subject;
    /// let x = InTotoStatement::new()
    ///     .set_subject([
    ///         Subject::default()/* use setters */,
    ///         Subject::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_subject<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subject>
    {
        use std::iter::Iterator;
        self.subject = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [predicate_type][crate::model::InTotoStatement::predicate_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoStatement;
    /// let x = InTotoStatement::new().set_predicate_type("example");
    /// ```
    pub fn set_predicate_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predicate_type = v.into();
        self
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate].
    ///
    /// Note that all the setters affecting `predicate` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoStatement;
    /// use google_cloud_grafeas_v1::model::InTotoProvenance;
    /// let x = InTotoStatement::new().set_predicate(Some(
    ///     google_cloud_grafeas_v1::model::in_toto_statement::Predicate::Provenance(InTotoProvenance::default().into())));
    /// ```
    pub fn set_predicate<T: std::convert::Into<std::option::Option<crate::model::in_toto_statement::Predicate>>>(mut self, v: T) -> Self
    {
        self.predicate = v.into();
        self
    }

    /// The value of [predicate][crate::model::InTotoStatement::predicate]
    /// if it holds a `Provenance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn provenance(&self) -> std::option::Option<&std::boxed::Box<crate::model::InTotoProvenance>> {
        #[allow(unreachable_patterns)]
        self.predicate.as_ref().and_then(|v| match v {
            crate::model::in_toto_statement::Predicate::Provenance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate]
    /// to hold a `Provenance`.
    ///
    /// Note that all the setters affecting `predicate` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoStatement;
    /// use google_cloud_grafeas_v1::model::InTotoProvenance;
    /// let x = InTotoStatement::new().set_provenance(InTotoProvenance::default()/* use setters */);
    /// assert!(x.provenance().is_some());
    /// assert!(x.slsa_provenance().is_none());
    /// assert!(x.slsa_provenance_zero_two().is_none());
    /// ```
    pub fn set_provenance<T: std::convert::Into<std::boxed::Box<crate::model::InTotoProvenance>>>(mut self, v: T) -> Self {
        self.predicate = std::option::Option::Some(
            crate::model::in_toto_statement::Predicate::Provenance(
                v.into()
            )
        );
        self
    }

    /// The value of [predicate][crate::model::InTotoStatement::predicate]
    /// if it holds a `SlsaProvenance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn slsa_provenance(&self) -> std::option::Option<&std::boxed::Box<crate::model::SlsaProvenance>> {
        #[allow(unreachable_patterns)]
        self.predicate.as_ref().and_then(|v| match v {
            crate::model::in_toto_statement::Predicate::SlsaProvenance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate]
    /// to hold a `SlsaProvenance`.
    ///
    /// Note that all the setters affecting `predicate` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoStatement;
    /// use google_cloud_grafeas_v1::model::SlsaProvenance;
    /// let x = InTotoStatement::new().set_slsa_provenance(SlsaProvenance::default()/* use setters */);
    /// assert!(x.slsa_provenance().is_some());
    /// assert!(x.provenance().is_none());
    /// assert!(x.slsa_provenance_zero_two().is_none());
    /// ```
    pub fn set_slsa_provenance<T: std::convert::Into<std::boxed::Box<crate::model::SlsaProvenance>>>(mut self, v: T) -> Self {
        self.predicate = std::option::Option::Some(
            crate::model::in_toto_statement::Predicate::SlsaProvenance(
                v.into()
            )
        );
        self
    }

    /// The value of [predicate][crate::model::InTotoStatement::predicate]
    /// if it holds a `SlsaProvenanceZeroTwo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn slsa_provenance_zero_two(&self) -> std::option::Option<&std::boxed::Box<crate::model::SlsaProvenanceZeroTwo>> {
        #[allow(unreachable_patterns)]
        self.predicate.as_ref().and_then(|v| match v {
            crate::model::in_toto_statement::Predicate::SlsaProvenanceZeroTwo(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [predicate][crate::model::InTotoStatement::predicate]
    /// to hold a `SlsaProvenanceZeroTwo`.
    ///
    /// Note that all the setters affecting `predicate` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoStatement;
    /// use google_cloud_grafeas_v1::model::SlsaProvenanceZeroTwo;
    /// let x = InTotoStatement::new().set_slsa_provenance_zero_two(SlsaProvenanceZeroTwo::default()/* use setters */);
    /// assert!(x.slsa_provenance_zero_two().is_some());
    /// assert!(x.provenance().is_none());
    /// assert!(x.slsa_provenance().is_none());
    /// ```
    pub fn set_slsa_provenance_zero_two<T: std::convert::Into<std::boxed::Box<crate::model::SlsaProvenanceZeroTwo>>>(mut self, v: T) -> Self {
        self.predicate = std::option::Option::Some(
            crate::model::in_toto_statement::Predicate::SlsaProvenanceZeroTwo(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for InTotoStatement {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.InTotoStatement"
    }
}

/// Defines additional types related to [InTotoStatement].
pub mod in_toto_statement {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Predicate {
        Provenance(std::boxed::Box<crate::model::InTotoProvenance>),
        SlsaProvenance(std::boxed::Box<crate::model::SlsaProvenance>),
        SlsaProvenanceZeroTwo(std::boxed::Box<crate::model::SlsaProvenanceZeroTwo>),
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Subject {

    pub name: std::string::String,

    /// `"<ALGORITHM>": "<HEX_VALUE>"`
    /// Algorithms can be e.g. sha256, sha512
    /// See
    /// <https://github.com/in-toto/attestation/blob/main/spec/field_types.md#DigestSet>
    pub digest: std::collections::HashMap<std::string::String,std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Subject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Subject::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Subject;
    /// let x = Subject::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [digest][crate::model::Subject::digest].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Subject;
    /// let x = Subject::new().set_digest([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_digest<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Subject {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Subject"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InTotoSlsaProvenanceV1 {

    /// InToto spec defined at
    /// <https://github.com/in-toto/attestation/tree/main/spec#statement>
    pub r#type: std::string::String,

    pub subject: std::vec::Vec<crate::model::Subject>,

    pub predicate_type: std::string::String,

    pub predicate: std::option::Option<crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InTotoSlsaProvenanceV1 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::InTotoSlsaProvenanceV1::type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoSlsaProvenanceV1;
    /// let x = InTotoSlsaProvenanceV1::new().set_type("example");
    /// ```
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::InTotoSlsaProvenanceV1::subject].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoSlsaProvenanceV1;
    /// use google_cloud_grafeas_v1::model::Subject;
    /// let x = InTotoSlsaProvenanceV1::new()
    ///     .set_subject([
    ///         Subject::default()/* use setters */,
    ///         Subject::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_subject<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subject>
    {
        use std::iter::Iterator;
        self.subject = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [predicate_type][crate::model::InTotoSlsaProvenanceV1::predicate_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoSlsaProvenanceV1;
    /// let x = InTotoSlsaProvenanceV1::new().set_predicate_type("example");
    /// ```
    pub fn set_predicate_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predicate_type = v.into();
        self
    }

    /// Sets the value of [predicate][crate::model::InTotoSlsaProvenanceV1::predicate].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoSlsaProvenanceV1;
    /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1;
    /// let x = InTotoSlsaProvenanceV1::new().set_predicate(SlsaProvenanceV1::default()/* use setters */);
    /// ```
    pub fn set_predicate<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1>
    {
        self.predicate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predicate][crate::model::InTotoSlsaProvenanceV1::predicate].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::InTotoSlsaProvenanceV1;
    /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1;
    /// let x = InTotoSlsaProvenanceV1::new().set_or_clear_predicate(Some(SlsaProvenanceV1::default()/* use setters */));
    /// let x = InTotoSlsaProvenanceV1::new().set_or_clear_predicate(None::<SlsaProvenanceV1>);
    /// ```
    pub fn set_or_clear_predicate<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1>
    {
        self.predicate = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InTotoSlsaProvenanceV1 {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1"
    }
}

/// Defines additional types related to [InTotoSlsaProvenanceV1].
pub mod in_toto_slsa_provenance_v_1 {
    #[allow(unused_imports)]
    use super::*;


    /// Keep in sync with schema at
    /// <https://github.com/slsa-framework/slsa/blob/main/docs/provenance/schema/v1/provenance.proto>
    /// Builder renamed to ProvenanceBuilder because of Java conflicts.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaProvenanceV1 {

        pub build_definition: std::option::Option<crate::model::in_toto_slsa_provenance_v_1::BuildDefinition>,

        pub run_details: std::option::Option<crate::model::in_toto_slsa_provenance_v_1::RunDetails>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaProvenanceV1 {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_definition][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::build_definition].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1;
        /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildDefinition;
        /// let x = SlsaProvenanceV1::new().set_build_definition(BuildDefinition::default()/* use setters */);
        /// ```
        pub fn set_build_definition<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildDefinition>
        {
            self.build_definition = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_definition][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::build_definition].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1;
        /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildDefinition;
        /// let x = SlsaProvenanceV1::new().set_or_clear_build_definition(Some(BuildDefinition::default()/* use setters */));
        /// let x = SlsaProvenanceV1::new().set_or_clear_build_definition(None::<BuildDefinition>);
        /// ```
        pub fn set_or_clear_build_definition<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildDefinition>
        {
            self.build_definition = v.map(|x| x.into());
            self
        }

        /// Sets the value of [run_details][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::run_details].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1;
        /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::RunDetails;
        /// let x = SlsaProvenanceV1::new().set_run_details(RunDetails::default()/* use setters */);
        /// ```
        pub fn set_run_details<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::RunDetails>
        {
            self.run_details = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [run_details][crate::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1::run_details].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::SlsaProvenanceV1;
        /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::RunDetails;
        /// let x = SlsaProvenanceV1::new().set_or_clear_run_details(Some(RunDetails::default()/* use setters */));
        /// let x = SlsaProvenanceV1::new().set_or_clear_run_details(None::<RunDetails>);
        /// ```
        pub fn set_or_clear_run_details<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::RunDetails>
        {
            self.run_details = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SlsaProvenanceV1 {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.SlsaProvenanceV1"
        }
    }

    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BuildDefinition {

        pub build_type: std::string::String,

        pub external_parameters: std::option::Option<wkt::Struct>,

        pub internal_parameters: std::option::Option<wkt::Struct>,

        pub resolved_dependencies: std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BuildDefinition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_type][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::build_type].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildDefinition;
        /// let x = BuildDefinition::new().set_build_type("example");
        /// ```
        pub fn set_build_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.build_type = v.into();
            self
        }

        /// Sets the value of [external_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::external_parameters].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildDefinition;
        /// use wkt::Struct;
        /// let x = BuildDefinition::new().set_external_parameters(Struct::default()/* use setters */);
        /// ```
        pub fn set_external_parameters<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Struct>
        {
            self.external_parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [external_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::external_parameters].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildDefinition;
        /// use wkt::Struct;
        /// let x = BuildDefinition::new().set_or_clear_external_parameters(Some(Struct::default()/* use setters */));
        /// let x = BuildDefinition::new().set_or_clear_external_parameters(None::<Struct>);
        /// ```
        pub fn set_or_clear_external_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Struct>
        {
            self.external_parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [internal_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::internal_parameters].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildDefinition;
        /// use wkt::Struct;
        /// let x = BuildDefinition::new().set_internal_parameters(Struct::default()/* use setters */);
        /// ```
        pub fn set_internal_parameters<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Struct>
        {
            self.internal_parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [internal_parameters][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::internal_parameters].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildDefinition;
        /// use wkt::Struct;
        /// let x = BuildDefinition::new().set_or_clear_internal_parameters(Some(Struct::default()/* use setters */));
        /// let x = BuildDefinition::new().set_or_clear_internal_parameters(None::<Struct>);
        /// ```
        pub fn set_or_clear_internal_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Struct>
        {
            self.internal_parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resolved_dependencies][crate::model::in_toto_slsa_provenance_v_1::BuildDefinition::resolved_dependencies].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildDefinition;
        /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ResourceDescriptor;
        /// let x = BuildDefinition::new()
        ///     .set_resolved_dependencies([
        ///         ResourceDescriptor::default()/* use setters */,
        ///         ResourceDescriptor::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_resolved_dependencies<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>
        {
            use std::iter::Iterator;
            self.resolved_dependencies = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for BuildDefinition {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.BuildDefinition"
        }
    }

    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourceDescriptor {

        pub name: std::string::String,

        pub uri: std::string::String,

        pub digest: std::collections::HashMap<std::string::String,std::string::String>,

        pub content: ::bytes::Bytes,

        pub download_location: std::string::String,

        pub media_type: std::string::String,

        pub annotations: std::collections::HashMap<std::string::String,wkt::Value>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceDescriptor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::name].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ResourceDescriptor;
        /// let x = ResourceDescriptor::new().set_name("example");
        /// ```
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [uri][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::uri].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ResourceDescriptor;
        /// let x = ResourceDescriptor::new().set_uri("example");
        /// ```
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::digest].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ResourceDescriptor;
        /// let x = ResourceDescriptor::new().set_digest([
        ///     ("key0", "abc"),
        ///     ("key1", "xyz"),
        /// ]);
        /// ```
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [content][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::content].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ResourceDescriptor;
        /// let x = ResourceDescriptor::new().set_content(bytes::Bytes::from_static(b"example"));
        /// ```
        pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }

        /// Sets the value of [download_location][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::download_location].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ResourceDescriptor;
        /// let x = ResourceDescriptor::new().set_download_location("example");
        /// ```
        pub fn set_download_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.download_location = v.into();
            self
        }

        /// Sets the value of [media_type][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::media_type].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ResourceDescriptor;
        /// let x = ResourceDescriptor::new().set_media_type("example");
        /// ```
        pub fn set_media_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.media_type = v.into();
            self
        }

        /// Sets the value of [annotations][crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor::annotations].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ResourceDescriptor;
        /// use wkt::Value;
        /// let x = ResourceDescriptor::new().set_annotations([
        ///     ("key0", Value::default()/* use setters */),
        ///     ("key1", Value::default()/* use (different) setters */),
        /// ]);
        /// ```
        pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for ResourceDescriptor {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.ResourceDescriptor"
        }
    }

    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RunDetails {

        pub builder: std::option::Option<crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder>,

        pub metadata: std::option::Option<crate::model::in_toto_slsa_provenance_v_1::BuildMetadata>,

        pub byproducts: std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RunDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [builder][crate::model::in_toto_slsa_provenance_v_1::RunDetails::builder].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::RunDetails;
        /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder;
        /// let x = RunDetails::new().set_builder(ProvenanceBuilder::default()/* use setters */);
        /// ```
        pub fn set_builder<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder>
        {
            self.builder = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [builder][crate::model::in_toto_slsa_provenance_v_1::RunDetails::builder].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::RunDetails;
        /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder;
        /// let x = RunDetails::new().set_or_clear_builder(Some(ProvenanceBuilder::default()/* use setters */));
        /// let x = RunDetails::new().set_or_clear_builder(None::<ProvenanceBuilder>);
        /// ```
        pub fn set_or_clear_builder<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder>
        {
            self.builder = v.map(|x| x.into());
            self
        }

        /// Sets the value of [metadata][crate::model::in_toto_slsa_provenance_v_1::RunDetails::metadata].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::RunDetails;
        /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildMetadata;
        /// let x = RunDetails::new().set_metadata(BuildMetadata::default()/* use setters */);
        /// ```
        pub fn set_metadata<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildMetadata>
        {
            self.metadata = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [metadata][crate::model::in_toto_slsa_provenance_v_1::RunDetails::metadata].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::RunDetails;
        /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildMetadata;
        /// let x = RunDetails::new().set_or_clear_metadata(Some(BuildMetadata::default()/* use setters */));
        /// let x = RunDetails::new().set_or_clear_metadata(None::<BuildMetadata>);
        /// ```
        pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::BuildMetadata>
        {
            self.metadata = v.map(|x| x.into());
            self
        }

        /// Sets the value of [byproducts][crate::model::in_toto_slsa_provenance_v_1::RunDetails::byproducts].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::RunDetails;
        /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ResourceDescriptor;
        /// let x = RunDetails::new()
        ///     .set_byproducts([
        ///         ResourceDescriptor::default()/* use setters */,
        ///         ResourceDescriptor::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_byproducts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>
        {
            use std::iter::Iterator;
            self.byproducts = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for RunDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.RunDetails"
        }
    }

    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ProvenanceBuilder {

        pub id: std::string::String,

        pub version: std::collections::HashMap<std::string::String,std::string::String>,

        pub builder_dependencies: std::vec::Vec<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ProvenanceBuilder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder::id].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder;
        /// let x = ProvenanceBuilder::new().set_id("example");
        /// ```
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [version][crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder::version].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder;
        /// let x = ProvenanceBuilder::new().set_version([
        ///     ("key0", "abc"),
        ///     ("key1", "xyz"),
        /// ]);
        /// ```
        pub fn set_version<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.version = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [builder_dependencies][crate::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder::builder_dependencies].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ProvenanceBuilder;
        /// use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::ResourceDescriptor;
        /// let x = ProvenanceBuilder::new()
        ///     .set_builder_dependencies([
        ///         ResourceDescriptor::default()/* use setters */,
        ///         ResourceDescriptor::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_builder_dependencies<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::in_toto_slsa_provenance_v_1::ResourceDescriptor>
        {
            use std::iter::Iterator;
            self.builder_dependencies = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ProvenanceBuilder {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.ProvenanceBuilder"
        }
    }

    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BuildMetadata {

        pub invocation_id: std::string::String,

        pub started_on: std::option::Option<wkt::Timestamp>,

        pub finished_on: std::option::Option<wkt::Timestamp>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BuildMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [invocation_id][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::invocation_id].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildMetadata;
        /// let x = BuildMetadata::new().set_invocation_id("example");
        /// ```
        pub fn set_invocation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.invocation_id = v.into();
            self
        }

        /// Sets the value of [started_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::started_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildMetadata;
        /// use wkt::Timestamp;
        /// let x = BuildMetadata::new().set_started_on(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_started_on<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.started_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [started_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::started_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildMetadata;
        /// use wkt::Timestamp;
        /// let x = BuildMetadata::new().set_or_clear_started_on(Some(Timestamp::default()/* use setters */));
        /// let x = BuildMetadata::new().set_or_clear_started_on(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_started_on<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.started_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [finished_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::finished_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildMetadata;
        /// use wkt::Timestamp;
        /// let x = BuildMetadata::new().set_finished_on(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_finished_on<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.finished_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [finished_on][crate::model::in_toto_slsa_provenance_v_1::BuildMetadata::finished_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::in_toto_slsa_provenance_v_1::BuildMetadata;
        /// use wkt::Timestamp;
        /// let x = BuildMetadata::new().set_or_clear_finished_on(Some(Timestamp::default()/* use setters */));
        /// let x = BuildMetadata::new().set_or_clear_finished_on(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.finished_on = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for BuildMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.InTotoSlsaProvenanceV1.BuildMetadata"
        }
    }
}

/// This represents a particular channel of distribution for a given package.
/// E.g., Debian's jessie-backports dpkg mirror.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Distribution {

    /// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/)
    /// denoting the package manager version distributing a package.
    pub cpe_uri: std::string::String,

    /// The CPU architecture for which packages in this distribution channel were
    /// built.
    pub architecture: crate::model::Architecture,

    /// The latest available version of this package in this distribution channel.
    pub latest_version: std::option::Option<crate::model::Version>,

    /// A freeform string denoting the maintainer of this package.
    pub maintainer: std::string::String,

    /// The distribution channel-specific homepage for this package.
    pub url: std::string::String,

    /// The distribution channel-specific description of this package.
    pub description: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Distribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::Distribution::cpe_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Distribution;
    /// let x = Distribution::new().set_cpe_uri("example");
    /// ```
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::Distribution::architecture].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Distribution;
    /// use google_cloud_grafeas_v1::model::Architecture;
    /// let x0 = Distribution::new().set_architecture(Architecture::X86);
    /// let x1 = Distribution::new().set_architecture(Architecture::X64);
    /// ```
    pub fn set_architecture<T: std::convert::Into<crate::model::Architecture>>(mut self, v: T) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [latest_version][crate::model::Distribution::latest_version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Distribution;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = Distribution::new().set_latest_version(Version::default()/* use setters */);
    /// ```
    pub fn set_latest_version<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.latest_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_version][crate::model::Distribution::latest_version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Distribution;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = Distribution::new().set_or_clear_latest_version(Some(Version::default()/* use setters */));
    /// let x = Distribution::new().set_or_clear_latest_version(None::<Version>);
    /// ```
    pub fn set_or_clear_latest_version<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.latest_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintainer][crate::model::Distribution::maintainer].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Distribution;
    /// let x = Distribution::new().set_maintainer("example");
    /// ```
    pub fn set_maintainer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.maintainer = v.into();
        self
    }

    /// Sets the value of [url][crate::model::Distribution::url].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Distribution;
    /// let x = Distribution::new().set_url("example");
    /// ```
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Distribution::description].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Distribution;
    /// let x = Distribution::new().set_description("example");
    /// ```
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for Distribution {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Distribution"
    }
}

/// An occurrence of a particular package installation found within a system's
/// filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Location {

    /// Deprecated.
    /// The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
    pub cpe_uri: std::string::String,

    /// Deprecated.
    /// The version installed at this location.
    pub version: std::option::Option<crate::model::Version>,

    /// The path from which we gathered that this package/version is installed.
    pub path: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Location {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::Location::cpe_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Location;
    /// let x = Location::new().set_cpe_uri("example");
    /// ```
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Location::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Location;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = Location::new().set_version(Version::default()/* use setters */);
    /// ```
    pub fn set_version<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::Location::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Location;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = Location::new().set_or_clear_version(Some(Version::default()/* use setters */));
    /// let x = Location::new().set_or_clear_version(None::<Version>);
    /// ```
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [path][crate::model::Location::path].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Location;
    /// let x = Location::new().set_path("example");
    /// ```
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for Location {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Location"
    }
}

/// PackageNote represents a particular package version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PackageNote {

    /// The name of the package.
    pub name: std::string::String,

    /// Deprecated.
    /// The various channels by which a package is distributed.
    pub distribution: std::vec::Vec<crate::model::Distribution>,

    /// The type of package; whether native or non native (e.g., ruby gems,
    /// node.js packages, etc.).
    pub package_type: std::string::String,

    /// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/)
    /// denoting the package manager version distributing a package.
    /// The cpe_uri will be blank for language packages.
    pub cpe_uri: std::string::String,

    /// The CPU architecture for which packages in this distribution channel were
    /// built. Architecture will be blank for language packages.
    pub architecture: crate::model::Architecture,

    /// The version of the package.
    pub version: std::option::Option<crate::model::Version>,

    /// A freeform text denoting the maintainer of this package.
    pub maintainer: std::string::String,

    /// The homepage for this package.
    pub url: std::string::String,

    /// The description of this package.
    pub description: std::string::String,

    /// Licenses that have been declared by the authors of the package.
    pub license: std::option::Option<crate::model::License>,

    /// Hash value, typically a file digest, that allows unique
    /// identification a specific package.
    pub digest: std::vec::Vec<crate::model::Digest>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PackageNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PackageNote::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// let x = PackageNote::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [distribution][crate::model::PackageNote::distribution].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// use google_cloud_grafeas_v1::model::Distribution;
    /// let x = PackageNote::new()
    ///     .set_distribution([
    ///         Distribution::default()/* use setters */,
    ///         Distribution::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_distribution<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Distribution>
    {
        use std::iter::Iterator;
        self.distribution = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [package_type][crate::model::PackageNote::package_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// let x = PackageNote::new().set_package_type("example");
    /// ```
    pub fn set_package_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_type = v.into();
        self
    }

    /// Sets the value of [cpe_uri][crate::model::PackageNote::cpe_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// let x = PackageNote::new().set_cpe_uri("example");
    /// ```
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::PackageNote::architecture].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// use google_cloud_grafeas_v1::model::Architecture;
    /// let x0 = PackageNote::new().set_architecture(Architecture::X86);
    /// let x1 = PackageNote::new().set_architecture(Architecture::X64);
    /// ```
    pub fn set_architecture<T: std::convert::Into<crate::model::Architecture>>(mut self, v: T) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [version][crate::model::PackageNote::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = PackageNote::new().set_version(Version::default()/* use setters */);
    /// ```
    pub fn set_version<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::PackageNote::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = PackageNote::new().set_or_clear_version(Some(Version::default()/* use setters */));
    /// let x = PackageNote::new().set_or_clear_version(None::<Version>);
    /// ```
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintainer][crate::model::PackageNote::maintainer].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// let x = PackageNote::new().set_maintainer("example");
    /// ```
    pub fn set_maintainer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.maintainer = v.into();
        self
    }

    /// Sets the value of [url][crate::model::PackageNote::url].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// let x = PackageNote::new().set_url("example");
    /// ```
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PackageNote::description].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// let x = PackageNote::new().set_description("example");
    /// ```
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [license][crate::model::PackageNote::license].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// use google_cloud_grafeas_v1::model::License;
    /// let x = PackageNote::new().set_license(License::default()/* use setters */);
    /// ```
    pub fn set_license<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::License>
    {
        self.license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [license][crate::model::PackageNote::license].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// use google_cloud_grafeas_v1::model::License;
    /// let x = PackageNote::new().set_or_clear_license(Some(License::default()/* use setters */));
    /// let x = PackageNote::new().set_or_clear_license(None::<License>);
    /// ```
    pub fn set_or_clear_license<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::License>
    {
        self.license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [digest][crate::model::PackageNote::digest].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageNote;
    /// use google_cloud_grafeas_v1::model::Digest;
    /// let x = PackageNote::new()
    ///     .set_digest([
    ///         Digest::default()/* use setters */,
    ///         Digest::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_digest<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Digest>
    {
        use std::iter::Iterator;
        self.digest = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PackageNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.PackageNote"
    }
}

/// Details on how a particular software package was installed on a system.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PackageOccurrence {

    /// The name of the installed package.
    pub name: std::string::String,

    /// All of the places within the filesystem versions of this package
    /// have been found.
    pub location: std::vec::Vec<crate::model::Location>,

    /// The type of package; whether native or non native (e.g., ruby gems,
    /// node.js packages, etc.).
    pub package_type: std::string::String,

    /// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/)
    /// denoting the package manager version distributing a package.
    /// The cpe_uri will be blank for language packages.
    pub cpe_uri: std::string::String,

    /// The CPU architecture for which packages in this distribution channel were
    /// built. Architecture will be blank for language packages.
    pub architecture: crate::model::Architecture,

    /// Licenses that have been declared by the authors of the package.
    pub license: std::option::Option<crate::model::License>,

    /// The version of the package.
    pub version: std::option::Option<crate::model::Version>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PackageOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PackageOccurrence::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageOccurrence;
    /// let x = PackageOccurrence::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [location][crate::model::PackageOccurrence::location].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageOccurrence;
    /// use google_cloud_grafeas_v1::model::Location;
    /// let x = PackageOccurrence::new()
    ///     .set_location([
    ///         Location::default()/* use setters */,
    ///         Location::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_location<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Location>
    {
        use std::iter::Iterator;
        self.location = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [package_type][crate::model::PackageOccurrence::package_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageOccurrence;
    /// let x = PackageOccurrence::new().set_package_type("example");
    /// ```
    pub fn set_package_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_type = v.into();
        self
    }

    /// Sets the value of [cpe_uri][crate::model::PackageOccurrence::cpe_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageOccurrence;
    /// let x = PackageOccurrence::new().set_cpe_uri("example");
    /// ```
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::PackageOccurrence::architecture].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageOccurrence;
    /// use google_cloud_grafeas_v1::model::Architecture;
    /// let x0 = PackageOccurrence::new().set_architecture(Architecture::X86);
    /// let x1 = PackageOccurrence::new().set_architecture(Architecture::X64);
    /// ```
    pub fn set_architecture<T: std::convert::Into<crate::model::Architecture>>(mut self, v: T) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [license][crate::model::PackageOccurrence::license].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageOccurrence;
    /// use google_cloud_grafeas_v1::model::License;
    /// let x = PackageOccurrence::new().set_license(License::default()/* use setters */);
    /// ```
    pub fn set_license<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::License>
    {
        self.license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [license][crate::model::PackageOccurrence::license].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageOccurrence;
    /// use google_cloud_grafeas_v1::model::License;
    /// let x = PackageOccurrence::new().set_or_clear_license(Some(License::default()/* use setters */));
    /// let x = PackageOccurrence::new().set_or_clear_license(None::<License>);
    /// ```
    pub fn set_or_clear_license<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::License>
    {
        self.license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version][crate::model::PackageOccurrence::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageOccurrence;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = PackageOccurrence::new().set_version(Version::default()/* use setters */);
    /// ```
    pub fn set_version<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::PackageOccurrence::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::PackageOccurrence;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = PackageOccurrence::new().set_or_clear_version(Some(Version::default()/* use setters */));
    /// let x = PackageOccurrence::new().set_or_clear_version(None::<Version>);
    /// ```
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.version = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PackageOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.PackageOccurrence"
    }
}

/// Version contains structured information about the version of a package.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Version {

    /// Used to correct mistakes in the version numbering scheme.
    pub epoch: i32,

    /// Required only when version kind is NORMAL. The main part of the version
    /// name.
    pub name: std::string::String,

    /// The iteration of the package build from the above version.
    pub revision: std::string::String,

    /// Whether this version is specifying part of an inclusive range. Grafeas
    /// does not have the capability to specify version ranges; instead we have
    /// fields that specify start version and end versions. At times this is
    /// insufficient - we also need to specify whether the version is included in
    /// the range or is excluded from the range. This boolean is expected to be set
    /// to true when the version is included in a range.
    pub inclusive: bool,

    /// Required. Distinguishes between sentinel MIN/MAX versions and normal
    /// versions.
    pub kind: crate::model::version::VersionKind,

    /// Human readable version string. This string is of the form
    /// \<epoch\>:\<name\>-\<revision\> and is only set when kind is NORMAL.
    pub full_name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [epoch][crate::model::Version::epoch].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Version;
    /// let x = Version::new().set_epoch(42);
    /// ```
    pub fn set_epoch<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.epoch = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Version::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Version;
    /// let x = Version::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::Version::revision].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Version;
    /// let x = Version::new().set_revision("example");
    /// ```
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [inclusive][crate::model::Version::inclusive].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Version;
    /// let x = Version::new().set_inclusive(true);
    /// ```
    pub fn set_inclusive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.inclusive = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Version::kind].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Version;
    /// use google_cloud_grafeas_v1::model::version::VersionKind;
    /// let x0 = Version::new().set_kind(VersionKind::Normal);
    /// let x1 = Version::new().set_kind(VersionKind::Minimum);
    /// let x2 = Version::new().set_kind(VersionKind::Maximum);
    /// ```
    pub fn set_kind<T: std::convert::Into<crate::model::version::VersionKind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [full_name][crate::model::Version::full_name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Version;
    /// let x = Version::new().set_full_name("example");
    /// ```
    pub fn set_full_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_name = v.into();
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Version"
    }
}

/// Defines additional types related to [Version].
pub mod version {
    #[allow(unused_imports)]
    use super::*;


    /// Whether this is an ordinary package version or a sentinel MIN/MAX version.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VersionKind {
        /// Unknown.
        Unspecified,
        /// A standard package version.
        Normal,
        /// A special version representing negative infinity.
        Minimum,
        /// A special version representing positive infinity.
        Maximum,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VersionKind::value] or
        /// [VersionKind::name].
        UnknownValue(version_kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod version_kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VersionKind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Normal => std::option::Option::Some(1),
                Self::Minimum => std::option::Option::Some(2),
                Self::Maximum => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VERSION_KIND_UNSPECIFIED"),
                Self::Normal => std::option::Option::Some("NORMAL"),
                Self::Minimum => std::option::Option::Some("MINIMUM"),
                Self::Maximum => std::option::Option::Some("MAXIMUM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VersionKind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VersionKind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VersionKind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Normal,
                2 => Self::Minimum,
                3 => Self::Maximum,
                _ => Self::UnknownValue(version_kind::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for VersionKind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VERSION_KIND_UNSPECIFIED" => Self::Unspecified,
                "NORMAL" => Self::Normal,
                "MINIMUM" => Self::Minimum,
                "MAXIMUM" => Self::Maximum,
                _ => Self::UnknownValue(version_kind::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for VersionKind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Normal => serializer.serialize_i32(1),
                Self::Minimum => serializer.serialize_i32(2),
                Self::Maximum => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VersionKind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VersionKind>::new(
                ".grafeas.v1.Version.VersionKind"))
        }
    }
}

/// Provenance of a build. Contains all information needed to verify the full
/// details about the build from source to completion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildProvenance {

    /// Required. Unique identifier of the build.
    pub id: std::string::String,

    /// ID of the project.
    pub project_id: std::string::String,

    /// Commands requested by the build.
    pub commands: std::vec::Vec<crate::model::Command>,

    /// Output of the build.
    pub built_artifacts: std::vec::Vec<crate::model::Artifact>,

    /// Time at which the build was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time at which execution of the build was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Time at which execution of the build was finished.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// E-mail address of the user who initiated this build. Note that this was the
    /// user's e-mail address at the time the build was initiated; this address may
    /// not represent the same end-user for all time.
    pub creator: std::string::String,

    /// URI where any logs for this provenance were written.
    pub logs_uri: std::string::String,

    /// Details of the Source input to the build.
    pub source_provenance: std::option::Option<crate::model::Source>,

    /// Trigger identifier if the build was triggered automatically; empty if not.
    pub trigger_id: std::string::String,

    /// Special options applied to this build. This is a catch-all field where
    /// build providers can enter any desired additional details.
    pub build_options: std::collections::HashMap<std::string::String,std::string::String>,

    /// Version string of the builder at the time this build was executed.
    pub builder_version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::BuildProvenance::id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// let x = BuildProvenance::new().set_id("example");
    /// ```
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::BuildProvenance::project_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// let x = BuildProvenance::new().set_project_id("example");
    /// ```
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [commands][crate::model::BuildProvenance::commands].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// use google_cloud_grafeas_v1::model::Command;
    /// let x = BuildProvenance::new()
    ///     .set_commands([
    ///         Command::default()/* use setters */,
    ///         Command::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_commands<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Command>
    {
        use std::iter::Iterator;
        self.commands = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [built_artifacts][crate::model::BuildProvenance::built_artifacts].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// use google_cloud_grafeas_v1::model::Artifact;
    /// let x = BuildProvenance::new()
    ///     .set_built_artifacts([
    ///         Artifact::default()/* use setters */,
    ///         Artifact::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_built_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Artifact>
    {
        use std::iter::Iterator;
        self.built_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::BuildProvenance::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// use wkt::Timestamp;
    /// let x = BuildProvenance::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BuildProvenance::create_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// use wkt::Timestamp;
    /// let x = BuildProvenance::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = BuildProvenance::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::BuildProvenance::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// use wkt::Timestamp;
    /// let x = BuildProvenance::new().set_start_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::BuildProvenance::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// use wkt::Timestamp;
    /// let x = BuildProvenance::new().set_or_clear_start_time(Some(Timestamp::default()/* use setters */));
    /// let x = BuildProvenance::new().set_or_clear_start_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BuildProvenance::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// use wkt::Timestamp;
    /// let x = BuildProvenance::new().set_end_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BuildProvenance::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// use wkt::Timestamp;
    /// let x = BuildProvenance::new().set_or_clear_end_time(Some(Timestamp::default()/* use setters */));
    /// let x = BuildProvenance::new().set_or_clear_end_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::BuildProvenance::creator].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// let x = BuildProvenance::new().set_creator("example");
    /// ```
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [logs_uri][crate::model::BuildProvenance::logs_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// let x = BuildProvenance::new().set_logs_uri("example");
    /// ```
    pub fn set_logs_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.logs_uri = v.into();
        self
    }

    /// Sets the value of [source_provenance][crate::model::BuildProvenance::source_provenance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// use google_cloud_grafeas_v1::model::Source;
    /// let x = BuildProvenance::new().set_source_provenance(Source::default()/* use setters */);
    /// ```
    pub fn set_source_provenance<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Source>
    {
        self.source_provenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_provenance][crate::model::BuildProvenance::source_provenance].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// use google_cloud_grafeas_v1::model::Source;
    /// let x = BuildProvenance::new().set_or_clear_source_provenance(Some(Source::default()/* use setters */));
    /// let x = BuildProvenance::new().set_or_clear_source_provenance(None::<Source>);
    /// ```
    pub fn set_or_clear_source_provenance<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Source>
    {
        self.source_provenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trigger_id][crate::model::BuildProvenance::trigger_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// let x = BuildProvenance::new().set_trigger_id("example");
    /// ```
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [build_options][crate::model::BuildProvenance::build_options].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// let x = BuildProvenance::new().set_build_options([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_build_options<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.build_options = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [builder_version][crate::model::BuildProvenance::builder_version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::BuildProvenance;
    /// let x = BuildProvenance::new().set_builder_version("example");
    /// ```
    pub fn set_builder_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.builder_version = v.into();
        self
    }
}

impl wkt::message::Message for BuildProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.BuildProvenance"
    }
}

/// Source describes the location of the source used for the build.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Source {

    /// If provided, the input binary artifacts for the build came from this
    /// location.
    pub artifact_storage_source_uri: std::string::String,

    /// Hash(es) of the build source, which can be used to verify that the original
    /// source integrity was maintained in the build.
    ///
    /// The keys to this map are file paths used as build source and the values
    /// contain the hash values for those files.
    ///
    /// If the build source came in a single package such as a gzipped tarfile
    /// (.tar.gz), the FileHash will be for the single path to that file.
    pub file_hashes: std::collections::HashMap<std::string::String,crate::model::FileHashes>,

    /// If provided, the source code used for the build came from this location.
    pub context: std::option::Option<crate::model::SourceContext>,

    /// If provided, some of the source code used for the build may be found in
    /// these locations, in the case where the source repository had multiple
    /// remotes or submodules. This list will not include the context specified in
    /// the context field.
    pub additional_contexts: std::vec::Vec<crate::model::SourceContext>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact_storage_source_uri][crate::model::Source::artifact_storage_source_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Source;
    /// let x = Source::new().set_artifact_storage_source_uri("example");
    /// ```
    pub fn set_artifact_storage_source_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_storage_source_uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::Source::file_hashes].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Source;
    /// use google_cloud_grafeas_v1::model::FileHashes;
    /// let x = Source::new().set_file_hashes([
    ///     ("key0", FileHashes::default()/* use setters */),
    ///     ("key1", FileHashes::default()/* use (different) setters */),
    /// ]);
    /// ```
    pub fn set_file_hashes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FileHashes>,
    {
        use std::iter::Iterator;
        self.file_hashes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [context][crate::model::Source::context].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Source;
    /// use google_cloud_grafeas_v1::model::SourceContext;
    /// let x = Source::new().set_context(SourceContext::default()/* use setters */);
    /// ```
    pub fn set_context<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::SourceContext>
    {
        self.context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [context][crate::model::Source::context].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Source;
    /// use google_cloud_grafeas_v1::model::SourceContext;
    /// let x = Source::new().set_or_clear_context(Some(SourceContext::default()/* use setters */));
    /// let x = Source::new().set_or_clear_context(None::<SourceContext>);
    /// ```
    pub fn set_or_clear_context<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::SourceContext>
    {
        self.context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_contexts][crate::model::Source::additional_contexts].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Source;
    /// use google_cloud_grafeas_v1::model::SourceContext;
    /// let x = Source::new()
    ///     .set_additional_contexts([
    ///         SourceContext::default()/* use setters */,
    ///         SourceContext::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_additional_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SourceContext>
    {
        use std::iter::Iterator;
        self.additional_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Source"
    }
}

/// Container message for hashes of byte content of files, used in source
/// messages to verify integrity of source input to the build.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FileHashes {

    /// Required. Collection of file hashes.
    pub file_hash: std::vec::Vec<crate::model::Hash>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileHashes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_hash][crate::model::FileHashes::file_hash].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::FileHashes;
    /// use google_cloud_grafeas_v1::model::Hash;
    /// let x = FileHashes::new()
    ///     .set_file_hash([
    ///         Hash::default()/* use setters */,
    ///         Hash::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_file_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Hash>
    {
        use std::iter::Iterator;
        self.file_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileHashes {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.FileHashes"
    }
}

/// Container message for hash values.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Hash {

    /// Required. The type of hash that was performed, e.g. "SHA-256".
    pub r#type: std::string::String,

    /// Required. The hash value.
    pub value: ::bytes::Bytes,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Hash {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Hash::type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Hash;
    /// let x = Hash::new().set_type("example");
    /// ```
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Hash::value].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Hash;
    /// let x = Hash::new().set_value(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Hash {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Hash"
    }
}

/// Command describes a step performed as part of the build pipeline.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Command {

    /// Required. Name of the command, as presented on the command line, or if the
    /// command is packaged as a Docker container, as presented to `docker pull`.
    pub name: std::string::String,

    /// Environment variables set before running this command.
    pub env: std::vec::Vec<std::string::String>,

    /// Command-line arguments used when executing this command.
    pub args: std::vec::Vec<std::string::String>,

    /// Working directory (relative to project source root) used when running this
    /// command.
    pub dir: std::string::String,

    /// Optional unique identifier for this command, used in wait_for to reference
    /// this command as a dependency.
    pub id: std::string::String,

    /// The ID(s) of the command(s) that this command depends on.
    pub wait_for: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Command {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Command::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Command;
    /// let x = Command::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [env][crate::model::Command::env].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Command;
    /// let x = Command::new().set_env(["a", "b", "c"]);
    /// ```
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::Command::args].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Command;
    /// let x = Command::new().set_args(["a", "b", "c"]);
    /// ```
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dir][crate::model::Command::dir].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Command;
    /// let x = Command::new().set_dir("example");
    /// ```
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Command::id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Command;
    /// let x = Command::new().set_id("example");
    /// ```
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [wait_for][crate::model::Command::wait_for].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Command;
    /// let x = Command::new().set_wait_for(["a", "b", "c"]);
    /// ```
    pub fn set_wait_for<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.wait_for = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Command {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Command"
    }
}

/// Artifact describes a build product.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Artifact {

    /// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
    /// container.
    pub checksum: std::string::String,

    /// Artifact ID, if any; for container images, this will be a URL by digest
    /// like `gcr.io/projectID/imagename@sha256:123456`.
    pub id: std::string::String,

    /// Related artifact names. This may be the path to a binary or jar file, or in
    /// the case of a container build, the name used to push the container image to
    /// Google Container Registry, as presented to `docker push`. Note that a
    /// single Artifact ID can have multiple names, for example if two tags are
    /// applied to one image.
    pub names: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Artifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [checksum][crate::model::Artifact::checksum].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Artifact;
    /// let x = Artifact::new().set_checksum("example");
    /// ```
    pub fn set_checksum<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.checksum = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Artifact::id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Artifact;
    /// let x = Artifact::new().set_id("example");
    /// ```
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [names][crate::model::Artifact::names].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::Artifact;
    /// let x = Artifact::new().set_names(["a", "b", "c"]);
    /// ```
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Artifact {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.Artifact"
    }
}

/// A SourceContext is a reference to a tree of files. A SourceContext together
/// with a path point to a unique revision of a single file or directory.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceContext {

    /// Labels with user defined metadata.
    pub labels: std::collections::HashMap<std::string::String,std::string::String>,

    /// A SourceContext can refer any one of the following types of repositories.
    pub context: std::option::Option<crate::model::source_context::Context>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::SourceContext::labels].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SourceContext;
    /// let x = SourceContext::new().set_labels([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [context][crate::model::SourceContext::context].
    ///
    /// Note that all the setters affecting `context` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SourceContext;
    /// use google_cloud_grafeas_v1::model::CloudRepoSourceContext;
    /// let x = SourceContext::new().set_context(Some(
    ///     google_cloud_grafeas_v1::model::source_context::Context::CloudRepo(CloudRepoSourceContext::default().into())));
    /// ```
    pub fn set_context<T: std::convert::Into<std::option::Option<crate::model::source_context::Context>>>(mut self, v: T) -> Self
    {
        self.context = v.into();
        self
    }

    /// The value of [context][crate::model::SourceContext::context]
    /// if it holds a `CloudRepo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_repo(&self) -> std::option::Option<&std::boxed::Box<crate::model::CloudRepoSourceContext>> {
        #[allow(unreachable_patterns)]
        self.context.as_ref().and_then(|v| match v {
            crate::model::source_context::Context::CloudRepo(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [context][crate::model::SourceContext::context]
    /// to hold a `CloudRepo`.
    ///
    /// Note that all the setters affecting `context` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SourceContext;
    /// use google_cloud_grafeas_v1::model::CloudRepoSourceContext;
    /// let x = SourceContext::new().set_cloud_repo(CloudRepoSourceContext::default()/* use setters */);
    /// assert!(x.cloud_repo().is_some());
    /// assert!(x.gerrit().is_none());
    /// assert!(x.git().is_none());
    /// ```
    pub fn set_cloud_repo<T: std::convert::Into<std::boxed::Box<crate::model::CloudRepoSourceContext>>>(mut self, v: T) -> Self {
        self.context = std::option::Option::Some(
            crate::model::source_context::Context::CloudRepo(
                v.into()
            )
        );
        self
    }

    /// The value of [context][crate::model::SourceContext::context]
    /// if it holds a `Gerrit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gerrit(&self) -> std::option::Option<&std::boxed::Box<crate::model::GerritSourceContext>> {
        #[allow(unreachable_patterns)]
        self.context.as_ref().and_then(|v| match v {
            crate::model::source_context::Context::Gerrit(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [context][crate::model::SourceContext::context]
    /// to hold a `Gerrit`.
    ///
    /// Note that all the setters affecting `context` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SourceContext;
    /// use google_cloud_grafeas_v1::model::GerritSourceContext;
    /// let x = SourceContext::new().set_gerrit(GerritSourceContext::default()/* use setters */);
    /// assert!(x.gerrit().is_some());
    /// assert!(x.cloud_repo().is_none());
    /// assert!(x.git().is_none());
    /// ```
    pub fn set_gerrit<T: std::convert::Into<std::boxed::Box<crate::model::GerritSourceContext>>>(mut self, v: T) -> Self {
        self.context = std::option::Option::Some(
            crate::model::source_context::Context::Gerrit(
                v.into()
            )
        );
        self
    }

    /// The value of [context][crate::model::SourceContext::context]
    /// if it holds a `Git`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git(&self) -> std::option::Option<&std::boxed::Box<crate::model::GitSourceContext>> {
        #[allow(unreachable_patterns)]
        self.context.as_ref().and_then(|v| match v {
            crate::model::source_context::Context::Git(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [context][crate::model::SourceContext::context]
    /// to hold a `Git`.
    ///
    /// Note that all the setters affecting `context` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SourceContext;
    /// use google_cloud_grafeas_v1::model::GitSourceContext;
    /// let x = SourceContext::new().set_git(GitSourceContext::default()/* use setters */);
    /// assert!(x.git().is_some());
    /// assert!(x.cloud_repo().is_none());
    /// assert!(x.gerrit().is_none());
    /// ```
    pub fn set_git<T: std::convert::Into<std::boxed::Box<crate::model::GitSourceContext>>>(mut self, v: T) -> Self {
        self.context = std::option::Option::Some(
            crate::model::source_context::Context::Git(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for SourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SourceContext"
    }
}

/// Defines additional types related to [SourceContext].
pub mod source_context {
    #[allow(unused_imports)]
    use super::*;


    /// A SourceContext can refer any one of the following types of repositories.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Context {
        /// A SourceContext referring to a revision in a Google Cloud Source Repo.
        CloudRepo(std::boxed::Box<crate::model::CloudRepoSourceContext>),
        /// A SourceContext referring to a Gerrit project.
        Gerrit(std::boxed::Box<crate::model::GerritSourceContext>),
        /// A SourceContext referring to any third party Git repo (e.g., GitHub).
        Git(std::boxed::Box<crate::model::GitSourceContext>),
    }
}

/// An alias to a repo revision.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AliasContext {

    /// The alias kind.
    pub kind: crate::model::alias_context::Kind,

    /// The alias name.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AliasContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::AliasContext::kind].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::AliasContext;
    /// use google_cloud_grafeas_v1::model::alias_context::Kind;
    /// let x0 = AliasContext::new().set_kind(Kind::Fixed);
    /// let x1 = AliasContext::new().set_kind(Kind::Movable);
    /// let x2 = AliasContext::new().set_kind(Kind::Other);
    /// ```
    pub fn set_kind<T: std::convert::Into<crate::model::alias_context::Kind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AliasContext::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::AliasContext;
    /// let x = AliasContext::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AliasContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.AliasContext"
    }
}

/// Defines additional types related to [AliasContext].
pub mod alias_context {
    #[allow(unused_imports)]
    use super::*;


    /// The type of an alias.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// Unknown.
        Unspecified,
        /// Git tag.
        Fixed,
        /// Git branch.
        Movable,
        /// Used to specify non-standard aliases. For example, if a Git repo has a
        /// ref named "refs/foo/bar".
        Other,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Kind::value] or
        /// [Kind::name].
        UnknownValue(kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Kind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Fixed => std::option::Option::Some(1),
                Self::Movable => std::option::Option::Some(2),
                Self::Other => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KIND_UNSPECIFIED"),
                Self::Fixed => std::option::Option::Some("FIXED"),
                Self::Movable => std::option::Option::Some("MOVABLE"),
                Self::Other => std::option::Option::Some("OTHER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Kind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Kind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Kind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Fixed,
                2 => Self::Movable,
                4 => Self::Other,
                _ => Self::UnknownValue(kind::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Kind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KIND_UNSPECIFIED" => Self::Unspecified,
                "FIXED" => Self::Fixed,
                "MOVABLE" => Self::Movable,
                "OTHER" => Self::Other,
                _ => Self::UnknownValue(kind::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Kind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Fixed => serializer.serialize_i32(1),
                Self::Movable => serializer.serialize_i32(2),
                Self::Other => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Kind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Kind>::new(
                ".grafeas.v1.AliasContext.Kind"))
        }
    }
}

/// A CloudRepoSourceContext denotes a particular revision in a Google Cloud
/// Source Repo.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudRepoSourceContext {

    /// The ID of the repo.
    pub repo_id: std::option::Option<crate::model::RepoId>,

    /// A revision in a Cloud Repo can be identified by either its revision ID or
    /// its alias.
    pub revision: std::option::Option<crate::model::cloud_repo_source_context::Revision>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRepoSourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repo_id][crate::model::CloudRepoSourceContext::repo_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CloudRepoSourceContext;
    /// use google_cloud_grafeas_v1::model::RepoId;
    /// let x = CloudRepoSourceContext::new().set_repo_id(RepoId::default()/* use setters */);
    /// ```
    pub fn set_repo_id<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::RepoId>
    {
        self.repo_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repo_id][crate::model::CloudRepoSourceContext::repo_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CloudRepoSourceContext;
    /// use google_cloud_grafeas_v1::model::RepoId;
    /// let x = CloudRepoSourceContext::new().set_or_clear_repo_id(Some(RepoId::default()/* use setters */));
    /// let x = CloudRepoSourceContext::new().set_or_clear_repo_id(None::<RepoId>);
    /// ```
    pub fn set_or_clear_repo_id<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::RepoId>
    {
        self.repo_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [revision][crate::model::CloudRepoSourceContext::revision].
    ///
    /// Note that all the setters affecting `revision` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CloudRepoSourceContext;
    /// use google_cloud_grafeas_v1::model::cloud_repo_source_context::Revision;
    /// let x = CloudRepoSourceContext::new().set_revision(Some(Revision::RevisionId("example".to_string())));
    /// ```
    pub fn set_revision<T: std::convert::Into<std::option::Option<crate::model::cloud_repo_source_context::Revision>>>(mut self, v: T) -> Self
    {
        self.revision = v.into();
        self
    }

    /// The value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// if it holds a `RevisionId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn revision_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::cloud_repo_source_context::Revision::RevisionId(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// to hold a `RevisionId`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CloudRepoSourceContext;
    /// let x = CloudRepoSourceContext::new().set_revision_id("example");
    /// assert!(x.revision_id().is_some());
    /// assert!(x.alias_context().is_none());
    /// ```
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::cloud_repo_source_context::Revision::RevisionId(
                v.into()
            )
        );
        self
    }

    /// The value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// if it holds a `AliasContext`, `None` if the field is not set or
    /// holds a different branch.
    pub fn alias_context(&self) -> std::option::Option<&std::boxed::Box<crate::model::AliasContext>> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::cloud_repo_source_context::Revision::AliasContext(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::CloudRepoSourceContext::revision]
    /// to hold a `AliasContext`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::CloudRepoSourceContext;
    /// use google_cloud_grafeas_v1::model::AliasContext;
    /// let x = CloudRepoSourceContext::new().set_alias_context(AliasContext::default()/* use setters */);
    /// assert!(x.alias_context().is_some());
    /// assert!(x.revision_id().is_none());
    /// ```
    pub fn set_alias_context<T: std::convert::Into<std::boxed::Box<crate::model::AliasContext>>>(mut self, v: T) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::cloud_repo_source_context::Revision::AliasContext(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for CloudRepoSourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.CloudRepoSourceContext"
    }
}

/// Defines additional types related to [CloudRepoSourceContext].
pub mod cloud_repo_source_context {
    #[allow(unused_imports)]
    use super::*;


    /// A revision in a Cloud Repo can be identified by either its revision ID or
    /// its alias.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Revision {
        /// A revision ID.
        RevisionId(std::string::String),
        /// An alias, which may be a branch or tag.
        AliasContext(std::boxed::Box<crate::model::AliasContext>),
    }
}

/// A SourceContext referring to a Gerrit project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GerritSourceContext {

    /// The URI of a running Gerrit instance.
    pub host_uri: std::string::String,

    /// The full project name within the host. Projects may be nested, so
    /// "project/subproject" is a valid project name. The "repo name" is the
    /// hostURI/project.
    pub gerrit_project: std::string::String,

    /// A revision in a Gerrit project can be identified by either its revision ID
    /// or its alias.
    pub revision: std::option::Option<crate::model::gerrit_source_context::Revision>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GerritSourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_uri][crate::model::GerritSourceContext::host_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::GerritSourceContext;
    /// let x = GerritSourceContext::new().set_host_uri("example");
    /// ```
    pub fn set_host_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_uri = v.into();
        self
    }

    /// Sets the value of [gerrit_project][crate::model::GerritSourceContext::gerrit_project].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::GerritSourceContext;
    /// let x = GerritSourceContext::new().set_gerrit_project("example");
    /// ```
    pub fn set_gerrit_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gerrit_project = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::GerritSourceContext::revision].
    ///
    /// Note that all the setters affecting `revision` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::GerritSourceContext;
    /// use google_cloud_grafeas_v1::model::gerrit_source_context::Revision;
    /// let x = GerritSourceContext::new().set_revision(Some(Revision::RevisionId("example".to_string())));
    /// ```
    pub fn set_revision<T: std::convert::Into<std::option::Option<crate::model::gerrit_source_context::Revision>>>(mut self, v: T) -> Self
    {
        self.revision = v.into();
        self
    }

    /// The value of [revision][crate::model::GerritSourceContext::revision]
    /// if it holds a `RevisionId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn revision_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::gerrit_source_context::Revision::RevisionId(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::GerritSourceContext::revision]
    /// to hold a `RevisionId`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::GerritSourceContext;
    /// let x = GerritSourceContext::new().set_revision_id("example");
    /// assert!(x.revision_id().is_some());
    /// assert!(x.alias_context().is_none());
    /// ```
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::gerrit_source_context::Revision::RevisionId(
                v.into()
            )
        );
        self
    }

    /// The value of [revision][crate::model::GerritSourceContext::revision]
    /// if it holds a `AliasContext`, `None` if the field is not set or
    /// holds a different branch.
    pub fn alias_context(&self) -> std::option::Option<&std::boxed::Box<crate::model::AliasContext>> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::gerrit_source_context::Revision::AliasContext(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::GerritSourceContext::revision]
    /// to hold a `AliasContext`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::GerritSourceContext;
    /// use google_cloud_grafeas_v1::model::AliasContext;
    /// let x = GerritSourceContext::new().set_alias_context(AliasContext::default()/* use setters */);
    /// assert!(x.alias_context().is_some());
    /// assert!(x.revision_id().is_none());
    /// ```
    pub fn set_alias_context<T: std::convert::Into<std::boxed::Box<crate::model::AliasContext>>>(mut self, v: T) -> Self {
        self.revision = std::option::Option::Some(
            crate::model::gerrit_source_context::Revision::AliasContext(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for GerritSourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GerritSourceContext"
    }
}

/// Defines additional types related to [GerritSourceContext].
pub mod gerrit_source_context {
    #[allow(unused_imports)]
    use super::*;


    /// A revision in a Gerrit project can be identified by either its revision ID
    /// or its alias.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Revision {
        /// A revision (commit) ID.
        RevisionId(std::string::String),
        /// An alias, which may be a branch or tag.
        AliasContext(std::boxed::Box<crate::model::AliasContext>),
    }
}

/// A GitSourceContext denotes a particular revision in a third party Git
/// repository (e.g., GitHub).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GitSourceContext {

    /// Git repository URL.
    pub url: std::string::String,

    /// Git commit hash.
    pub revision_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitSourceContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::GitSourceContext::url].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::GitSourceContext;
    /// let x = GitSourceContext::new().set_url("example");
    /// ```
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::GitSourceContext::revision_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::GitSourceContext;
    /// let x = GitSourceContext::new().set_revision_id("example");
    /// ```
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }
}

impl wkt::message::Message for GitSourceContext {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.GitSourceContext"
    }
}

/// A unique identifier for a Cloud Repo.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RepoId {

    /// A cloud repo can be identified by either its project ID and repository name
    /// combination, or its globally unique identifier.
    pub id: std::option::Option<crate::model::repo_id::Id>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepoId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::RepoId::id].
    ///
    /// Note that all the setters affecting `id` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::RepoId;
    /// use google_cloud_grafeas_v1::model::repo_id::Id;
    /// let x = RepoId::new().set_id(Some(Id::Uid("example".to_string())));
    /// ```
    pub fn set_id<T: std::convert::Into<std::option::Option<crate::model::repo_id::Id>>>(mut self, v: T) -> Self
    {
        self.id = v.into();
        self
    }

    /// The value of [id][crate::model::RepoId::id]
    /// if it holds a `ProjectRepoId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn project_repo_id(&self) -> std::option::Option<&std::boxed::Box<crate::model::ProjectRepoId>> {
        #[allow(unreachable_patterns)]
        self.id.as_ref().and_then(|v| match v {
            crate::model::repo_id::Id::ProjectRepoId(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id][crate::model::RepoId::id]
    /// to hold a `ProjectRepoId`.
    ///
    /// Note that all the setters affecting `id` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::RepoId;
    /// use google_cloud_grafeas_v1::model::ProjectRepoId;
    /// let x = RepoId::new().set_project_repo_id(ProjectRepoId::default()/* use setters */);
    /// assert!(x.project_repo_id().is_some());
    /// assert!(x.uid().is_none());
    /// ```
    pub fn set_project_repo_id<T: std::convert::Into<std::boxed::Box<crate::model::ProjectRepoId>>>(mut self, v: T) -> Self {
        self.id = std::option::Option::Some(
            crate::model::repo_id::Id::ProjectRepoId(
                v.into()
            )
        );
        self
    }

    /// The value of [id][crate::model::RepoId::id]
    /// if it holds a `Uid`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uid(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id.as_ref().and_then(|v| match v {
            crate::model::repo_id::Id::Uid(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id][crate::model::RepoId::id]
    /// to hold a `Uid`.
    ///
    /// Note that all the setters affecting `id` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::RepoId;
    /// let x = RepoId::new().set_uid("example");
    /// assert!(x.uid().is_some());
    /// assert!(x.project_repo_id().is_none());
    /// ```
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = std::option::Option::Some(
            crate::model::repo_id::Id::Uid(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for RepoId {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.RepoId"
    }
}

/// Defines additional types related to [RepoId].
pub mod repo_id {
    #[allow(unused_imports)]
    use super::*;


    /// A cloud repo can be identified by either its project ID and repository name
    /// combination, or its globally unique identifier.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Id {
        /// A combination of a project ID and a repo name.
        ProjectRepoId(std::boxed::Box<crate::model::ProjectRepoId>),
        /// A server-assigned, globally unique identifier.
        Uid(std::string::String),
    }
}

/// Selects a repo using a Google Cloud Platform project ID (e.g.,
/// winged-cargo-31) and a repo name within that project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProjectRepoId {

    /// The ID of the project.
    pub project_id: std::string::String,

    /// The name of the repo. Leave empty for the default repo.
    pub repo_name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProjectRepoId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ProjectRepoId::project_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ProjectRepoId;
    /// let x = ProjectRepoId::new().set_project_id("example");
    /// ```
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [repo_name][crate::model::ProjectRepoId::repo_name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::ProjectRepoId;
    /// let x = ProjectRepoId::new().set_repo_name("example");
    /// ```
    pub fn set_repo_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repo_name = v.into();
        self
    }
}

impl wkt::message::Message for ProjectRepoId {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.ProjectRepoId"
    }
}

/// The note representing an SBOM reference.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SBOMReferenceNote {

    /// The format that SBOM takes. E.g. may be spdx, cyclonedx, etc...
    pub format: std::string::String,

    /// The version of the format that the SBOM takes. E.g. if the format
    /// is spdx, the version may be 2.3.
    pub version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SBOMReferenceNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [format][crate::model::SBOMReferenceNote::format].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SBOMReferenceNote;
    /// let x = SBOMReferenceNote::new().set_format("example");
    /// ```
    pub fn set_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SBOMReferenceNote::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SBOMReferenceNote;
    /// let x = SBOMReferenceNote::new().set_version("example");
    /// ```
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for SBOMReferenceNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SBOMReferenceNote"
    }
}

/// The occurrence representing an SBOM reference as applied to a specific
/// resource. The occurrence follows the DSSE specification. See
/// <https://github.com/secure-systems-lab/dsse/blob/master/envelope.md> for more
/// details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SBOMReferenceOccurrence {

    /// The actual payload that contains the SBOM reference data.
    pub payload: std::option::Option<crate::model::SbomReferenceIntotoPayload>,

    /// The kind of payload that SbomReferenceIntotoPayload takes. Since it's in
    /// the intoto format, this value is expected to be
    /// 'application/vnd.in-toto+json'.
    pub payload_type: std::string::String,

    /// The signatures over the payload.
    pub signatures: std::vec::Vec<crate::model::EnvelopeSignature>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SBOMReferenceOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload][crate::model::SBOMReferenceOccurrence::payload].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SBOMReferenceOccurrence;
    /// use google_cloud_grafeas_v1::model::SbomReferenceIntotoPayload;
    /// let x = SBOMReferenceOccurrence::new().set_payload(SbomReferenceIntotoPayload::default()/* use setters */);
    /// ```
    pub fn set_payload<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::SbomReferenceIntotoPayload>
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::SBOMReferenceOccurrence::payload].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SBOMReferenceOccurrence;
    /// use google_cloud_grafeas_v1::model::SbomReferenceIntotoPayload;
    /// let x = SBOMReferenceOccurrence::new().set_or_clear_payload(Some(SbomReferenceIntotoPayload::default()/* use setters */));
    /// let x = SBOMReferenceOccurrence::new().set_or_clear_payload(None::<SbomReferenceIntotoPayload>);
    /// ```
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::SbomReferenceIntotoPayload>
    {
        self.payload = v.map(|x| x.into());
        self
    }

    /// Sets the value of [payload_type][crate::model::SBOMReferenceOccurrence::payload_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SBOMReferenceOccurrence;
    /// let x = SBOMReferenceOccurrence::new().set_payload_type("example");
    /// ```
    pub fn set_payload_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload_type = v.into();
        self
    }

    /// Sets the value of [signatures][crate::model::SBOMReferenceOccurrence::signatures].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SBOMReferenceOccurrence;
    /// use google_cloud_grafeas_v1::model::EnvelopeSignature;
    /// let x = SBOMReferenceOccurrence::new()
    ///     .set_signatures([
    ///         EnvelopeSignature::default()/* use setters */,
    ///         EnvelopeSignature::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvelopeSignature>
    {
        use std::iter::Iterator;
        self.signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SBOMReferenceOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SBOMReferenceOccurrence"
    }
}

/// The actual payload that contains the SBOM Reference data.
/// The payload follows the intoto statement specification. See
/// <https://github.com/in-toto/attestation/blob/main/spec/v1.0/statement.md>
/// for more details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SbomReferenceIntotoPayload {

    /// Identifier for the schema of the Statement.
    pub r#type: std::string::String,

    /// URI identifying the type of the Predicate.
    pub predicate_type: std::string::String,

    /// Set of software artifacts that the attestation applies to. Each element
    /// represents a single software artifact.
    pub subject: std::vec::Vec<crate::model::Subject>,

    /// Additional parameters of the Predicate. Includes the actual data about the
    /// SBOM.
    pub predicate: std::option::Option<crate::model::SbomReferenceIntotoPredicate>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SbomReferenceIntotoPayload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::SbomReferenceIntotoPayload::type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SbomReferenceIntotoPayload;
    /// let x = SbomReferenceIntotoPayload::new().set_type("example");
    /// ```
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [predicate_type][crate::model::SbomReferenceIntotoPayload::predicate_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SbomReferenceIntotoPayload;
    /// let x = SbomReferenceIntotoPayload::new().set_predicate_type("example");
    /// ```
    pub fn set_predicate_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predicate_type = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::SbomReferenceIntotoPayload::subject].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SbomReferenceIntotoPayload;
    /// use google_cloud_grafeas_v1::model::Subject;
    /// let x = SbomReferenceIntotoPayload::new()
    ///     .set_subject([
    ///         Subject::default()/* use setters */,
    ///         Subject::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_subject<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subject>
    {
        use std::iter::Iterator;
        self.subject = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [predicate][crate::model::SbomReferenceIntotoPayload::predicate].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SbomReferenceIntotoPayload;
    /// use google_cloud_grafeas_v1::model::SbomReferenceIntotoPredicate;
    /// let x = SbomReferenceIntotoPayload::new().set_predicate(SbomReferenceIntotoPredicate::default()/* use setters */);
    /// ```
    pub fn set_predicate<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::SbomReferenceIntotoPredicate>
    {
        self.predicate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predicate][crate::model::SbomReferenceIntotoPayload::predicate].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SbomReferenceIntotoPayload;
    /// use google_cloud_grafeas_v1::model::SbomReferenceIntotoPredicate;
    /// let x = SbomReferenceIntotoPayload::new().set_or_clear_predicate(Some(SbomReferenceIntotoPredicate::default()/* use setters */));
    /// let x = SbomReferenceIntotoPayload::new().set_or_clear_predicate(None::<SbomReferenceIntotoPredicate>);
    /// ```
    pub fn set_or_clear_predicate<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::SbomReferenceIntotoPredicate>
    {
        self.predicate = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SbomReferenceIntotoPayload {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SbomReferenceIntotoPayload"
    }
}

/// A predicate which describes the SBOM being referenced.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SbomReferenceIntotoPredicate {

    /// The person or system referring this predicate to the consumer.
    pub referrer_id: std::string::String,

    /// The location of the SBOM.
    pub location: std::string::String,

    /// The mime type of the SBOM.
    pub mime_type: std::string::String,

    /// A map of algorithm to digest of the contents of the SBOM.
    pub digest: std::collections::HashMap<std::string::String,std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SbomReferenceIntotoPredicate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [referrer_id][crate::model::SbomReferenceIntotoPredicate::referrer_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SbomReferenceIntotoPredicate;
    /// let x = SbomReferenceIntotoPredicate::new().set_referrer_id("example");
    /// ```
    pub fn set_referrer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.referrer_id = v.into();
        self
    }

    /// Sets the value of [location][crate::model::SbomReferenceIntotoPredicate::location].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SbomReferenceIntotoPredicate;
    /// let x = SbomReferenceIntotoPredicate::new().set_location("example");
    /// ```
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::SbomReferenceIntotoPredicate::mime_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SbomReferenceIntotoPredicate;
    /// let x = SbomReferenceIntotoPredicate::new().set_mime_type("example");
    /// ```
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [digest][crate::model::SbomReferenceIntotoPredicate::digest].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SbomReferenceIntotoPredicate;
    /// let x = SbomReferenceIntotoPredicate::new().set_digest([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_digest<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SbomReferenceIntotoPredicate {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SbomReferenceIntotoPredicate"
    }
}

/// The note representing a secret.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretNote {

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SecretNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretNote"
    }
}

/// The occurrence provides details of a secret.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretOccurrence {

    /// Type of secret.
    pub kind: crate::model::SecretKind,

    /// Locations where the secret is detected.
    pub locations: std::vec::Vec<crate::model::SecretLocation>,

    /// Status of the secret.
    pub statuses: std::vec::Vec<crate::model::SecretStatus>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SecretOccurrence::kind].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SecretOccurrence;
    /// use google_cloud_grafeas_v1::model::SecretKind;
    /// let x0 = SecretOccurrence::new().set_kind(SecretKind::Unknown);
    /// let x1 = SecretOccurrence::new().set_kind(SecretKind::GcpServiceAccountKey);
    /// ```
    pub fn set_kind<T: std::convert::Into<crate::model::SecretKind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::SecretOccurrence::locations].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SecretOccurrence;
    /// use google_cloud_grafeas_v1::model::SecretLocation;
    /// let x = SecretOccurrence::new()
    ///     .set_locations([
    ///         SecretLocation::default()/* use setters */,
    ///         SecretLocation::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretLocation>
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [statuses][crate::model::SecretOccurrence::statuses].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SecretOccurrence;
    /// use google_cloud_grafeas_v1::model::SecretStatus;
    /// let x = SecretOccurrence::new()
    ///     .set_statuses([
    ///         SecretStatus::default()/* use setters */,
    ///         SecretStatus::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_statuses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretStatus>
    {
        use std::iter::Iterator;
        self.statuses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SecretOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretOccurrence"
    }
}

/// The location of the secret.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretLocation {

    /// The detailed location of the secret.
    pub location: std::option::Option<crate::model::secret_location::Location>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::SecretLocation::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SecretLocation;
    /// use google_cloud_grafeas_v1::model::FileLocation;
    /// let x = SecretLocation::new().set_location(Some(
    ///     google_cloud_grafeas_v1::model::secret_location::Location::FileLocation(FileLocation::default().into())));
    /// ```
    pub fn set_location<T: std::convert::Into<std::option::Option<crate::model::secret_location::Location>>>(mut self, v: T) -> Self
    {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::SecretLocation::location]
    /// if it holds a `FileLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn file_location(&self) -> std::option::Option<&std::boxed::Box<crate::model::FileLocation>> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::secret_location::Location::FileLocation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::SecretLocation::location]
    /// to hold a `FileLocation`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SecretLocation;
    /// use google_cloud_grafeas_v1::model::FileLocation;
    /// let x = SecretLocation::new().set_file_location(FileLocation::default()/* use setters */);
    /// assert!(x.file_location().is_some());
    /// ```
    pub fn set_file_location<T: std::convert::Into<std::boxed::Box<crate::model::FileLocation>>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::secret_location::Location::FileLocation(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for SecretLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretLocation"
    }
}

/// Defines additional types related to [SecretLocation].
pub mod secret_location {
    #[allow(unused_imports)]
    use super::*;


    /// The detailed location of the secret.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Location {
        /// The secret is found from a file.
        FileLocation(std::boxed::Box<crate::model::FileLocation>),
    }
}

/// The status of the secret with a timestamp.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretStatus {

    /// The status of the secret.
    pub status: crate::model::secret_status::Status,

    /// The time the secret status was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional message about the status code.
    pub message: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::SecretStatus::status].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SecretStatus;
    /// use google_cloud_grafeas_v1::model::secret_status::Status;
    /// let x0 = SecretStatus::new().set_status(Status::Unknown);
    /// let x1 = SecretStatus::new().set_status(Status::Valid);
    /// let x2 = SecretStatus::new().set_status(Status::Invalid);
    /// ```
    pub fn set_status<T: std::convert::Into<crate::model::secret_status::Status>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::SecretStatus::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SecretStatus;
    /// use wkt::Timestamp;
    /// let x = SecretStatus::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::SecretStatus::update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SecretStatus;
    /// use wkt::Timestamp;
    /// let x = SecretStatus::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = SecretStatus::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message][crate::model::SecretStatus::message].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SecretStatus;
    /// let x = SecretStatus::new().set_message("example");
    /// ```
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for SecretStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SecretStatus"
    }
}

/// Defines additional types related to [SecretStatus].
pub mod secret_status {
    #[allow(unused_imports)]
    use super::*;


    /// The status of the secret.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Unspecified
        Unspecified,
        /// The status of the secret is unknown.
        Unknown,
        /// The secret is valid.
        Valid,
        /// The secret is invalid.
        Invalid,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::Valid => std::option::Option::Some(2),
                Self::Invalid => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Valid => std::option::Option::Some("VALID"),
                Self::Invalid => std::option::Option::Some("INVALID"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unknown,
                2 => Self::Valid,
                3 => Self::Invalid,
                _ => Self::UnknownValue(status::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN" => Self::Unknown,
                "VALID" => Self::Valid,
                "INVALID" => Self::Invalid,
                _ => Self::UnknownValue(status::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::Valid => serializer.serialize_i32(2),
                Self::Invalid => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".grafeas.v1.SecretStatus.Status"))
        }
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SlsaProvenance {

    pub builder: std::option::Option<crate::model::slsa_provenance::SlsaBuilder>,

    /// Identifies the configuration used for the build.
    /// When combined with materials, this SHOULD fully describe the build,
    /// such that re-running this recipe results in bit-for-bit identical output
    /// (if the build is reproducible).
    pub recipe: std::option::Option<crate::model::slsa_provenance::SlsaRecipe>,

    pub metadata: std::option::Option<crate::model::slsa_provenance::SlsaMetadata>,

    /// The collection of artifacts that influenced the build including sources,
    /// dependencies, build tools, base images, and so on. This is considered to be
    /// incomplete unless metadata.completeness.materials is true. Unset or null is
    /// equivalent to empty.
    pub materials: std::vec::Vec<crate::model::slsa_provenance::Material>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SlsaProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder][crate::model::SlsaProvenance::builder].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenance;
    /// use google_cloud_grafeas_v1::model::slsa_provenance::SlsaBuilder;
    /// let x = SlsaProvenance::new().set_builder(SlsaBuilder::default()/* use setters */);
    /// ```
    pub fn set_builder<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance::SlsaBuilder>
    {
        self.builder = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [builder][crate::model::SlsaProvenance::builder].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenance;
    /// use google_cloud_grafeas_v1::model::slsa_provenance::SlsaBuilder;
    /// let x = SlsaProvenance::new().set_or_clear_builder(Some(SlsaBuilder::default()/* use setters */));
    /// let x = SlsaProvenance::new().set_or_clear_builder(None::<SlsaBuilder>);
    /// ```
    pub fn set_or_clear_builder<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance::SlsaBuilder>
    {
        self.builder = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recipe][crate::model::SlsaProvenance::recipe].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenance;
    /// use google_cloud_grafeas_v1::model::slsa_provenance::SlsaRecipe;
    /// let x = SlsaProvenance::new().set_recipe(SlsaRecipe::default()/* use setters */);
    /// ```
    pub fn set_recipe<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance::SlsaRecipe>
    {
        self.recipe = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recipe][crate::model::SlsaProvenance::recipe].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenance;
    /// use google_cloud_grafeas_v1::model::slsa_provenance::SlsaRecipe;
    /// let x = SlsaProvenance::new().set_or_clear_recipe(Some(SlsaRecipe::default()/* use setters */));
    /// let x = SlsaProvenance::new().set_or_clear_recipe(None::<SlsaRecipe>);
    /// ```
    pub fn set_or_clear_recipe<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance::SlsaRecipe>
    {
        self.recipe = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::SlsaProvenance::metadata].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenance;
    /// use google_cloud_grafeas_v1::model::slsa_provenance::SlsaMetadata;
    /// let x = SlsaProvenance::new().set_metadata(SlsaMetadata::default()/* use setters */);
    /// ```
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance::SlsaMetadata>
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::SlsaProvenance::metadata].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenance;
    /// use google_cloud_grafeas_v1::model::slsa_provenance::SlsaMetadata;
    /// let x = SlsaProvenance::new().set_or_clear_metadata(Some(SlsaMetadata::default()/* use setters */));
    /// let x = SlsaProvenance::new().set_or_clear_metadata(None::<SlsaMetadata>);
    /// ```
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance::SlsaMetadata>
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [materials][crate::model::SlsaProvenance::materials].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenance;
    /// use google_cloud_grafeas_v1::model::slsa_provenance::Material;
    /// let x = SlsaProvenance::new()
    ///     .set_materials([
    ///         Material::default()/* use setters */,
    ///         Material::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_materials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::slsa_provenance::Material>
    {
        use std::iter::Iterator;
        self.materials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SlsaProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SlsaProvenance"
    }
}

/// Defines additional types related to [SlsaProvenance].
pub mod slsa_provenance {
    #[allow(unused_imports)]
    use super::*;


    /// Steps taken to build the artifact.
    /// For a TaskRun, typically each container corresponds to one step in the
    /// recipe.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaRecipe {

        /// URI indicating what type of recipe was performed. It determines the
        /// meaning of recipe.entryPoint, recipe.arguments, recipe.environment, and
        /// materials.
        pub r#type: std::string::String,

        /// Index in materials containing the recipe steps that are not implied by
        /// recipe.type. For example, if the recipe type were "make", then this would
        /// point to the source containing the Makefile, not the make program itself.
        /// Set to -1 if the recipe doesn't come from a material, as zero is default
        /// unset value for int64.
        pub defined_in_material: i64,

        /// String identifying the entry point into the build.
        /// This is often a path to a configuration file and/or a target label within
        /// that file. The syntax and meaning are defined by recipe.type. For
        /// example, if the recipe type were "make", then this would reference the
        /// directory in which to run make as well as which target to use.
        pub entry_point: std::string::String,

        /// Collection of all external inputs that influenced the build on top of
        /// recipe.definedInMaterial and recipe.entryPoint. For example, if the
        /// recipe type were "make", then this might be the flags passed to make
        /// aside from the target, which is captured in recipe.entryPoint. Depending
        /// on the recipe Type, the structure may be different.
        pub arguments: std::option::Option<wkt::Any>,

        /// Any other builder-controlled inputs necessary for correctly evaluating
        /// the recipe. Usually only needed for reproducing the build but not
        /// evaluated as part of policy. Depending on the recipe Type, the structure
        /// may be different.
        pub environment: std::option::Option<wkt::Any>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaRecipe {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::slsa_provenance::SlsaRecipe::type].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaRecipe;
        /// let x = SlsaRecipe::new().set_type("example");
        /// ```
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [defined_in_material][crate::model::slsa_provenance::SlsaRecipe::defined_in_material].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaRecipe;
        /// let x = SlsaRecipe::new().set_defined_in_material(42);
        /// ```
        pub fn set_defined_in_material<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.defined_in_material = v.into();
            self
        }

        /// Sets the value of [entry_point][crate::model::slsa_provenance::SlsaRecipe::entry_point].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaRecipe;
        /// let x = SlsaRecipe::new().set_entry_point("example");
        /// ```
        pub fn set_entry_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entry_point = v.into();
            self
        }

        /// Sets the value of [arguments][crate::model::slsa_provenance::SlsaRecipe::arguments].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaRecipe;
        /// use wkt::Any;
        /// let x = SlsaRecipe::new().set_arguments(Any::default()/* use setters */);
        /// ```
        pub fn set_arguments<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Any>
        {
            self.arguments = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [arguments][crate::model::slsa_provenance::SlsaRecipe::arguments].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaRecipe;
        /// use wkt::Any;
        /// let x = SlsaRecipe::new().set_or_clear_arguments(Some(Any::default()/* use setters */));
        /// let x = SlsaRecipe::new().set_or_clear_arguments(None::<Any>);
        /// ```
        pub fn set_or_clear_arguments<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Any>
        {
            self.arguments = v.map(|x| x.into());
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance::SlsaRecipe::environment].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaRecipe;
        /// use wkt::Any;
        /// let x = SlsaRecipe::new().set_environment(Any::default()/* use setters */);
        /// ```
        pub fn set_environment<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Any>
        {
            self.environment = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [environment][crate::model::slsa_provenance::SlsaRecipe::environment].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaRecipe;
        /// use wkt::Any;
        /// let x = SlsaRecipe::new().set_or_clear_environment(Some(Any::default()/* use setters */));
        /// let x = SlsaRecipe::new().set_or_clear_environment(None::<Any>);
        /// ```
        pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Any>
        {
            self.environment = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SlsaRecipe {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaRecipe"
        }
    }

    /// Indicates that the builder claims certain fields in this message to be
    /// complete.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaCompleteness {

        /// If true, the builder claims that recipe.arguments is complete, meaning
        /// that all external inputs are properly captured in the recipe.
        pub arguments: bool,

        /// If true, the builder claims that recipe.environment is claimed to be
        /// complete.
        pub environment: bool,

        /// If true, the builder claims that materials are complete, usually through
        /// some controls to prevent network access. Sometimes called "hermetic".
        pub materials: bool,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaCompleteness {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [arguments][crate::model::slsa_provenance::SlsaCompleteness::arguments].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaCompleteness;
        /// let x = SlsaCompleteness::new().set_arguments(true);
        /// ```
        pub fn set_arguments<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.arguments = v.into();
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance::SlsaCompleteness::environment].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaCompleteness;
        /// let x = SlsaCompleteness::new().set_environment(true);
        /// ```
        pub fn set_environment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.environment = v.into();
            self
        }

        /// Sets the value of [materials][crate::model::slsa_provenance::SlsaCompleteness::materials].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaCompleteness;
        /// let x = SlsaCompleteness::new().set_materials(true);
        /// ```
        pub fn set_materials<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.materials = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaCompleteness {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaCompleteness"
        }
    }

    /// Other properties of the build.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaMetadata {

        /// Identifies the particular build invocation, which can be useful for
        /// finding associated logs or other ad-hoc analysis. The value SHOULD be
        /// globally unique, per in-toto Provenance spec.
        pub build_invocation_id: std::string::String,

        /// The timestamp of when the build started.
        pub build_started_on: std::option::Option<wkt::Timestamp>,

        /// The timestamp of when the build completed.
        pub build_finished_on: std::option::Option<wkt::Timestamp>,

        /// Indicates that the builder claims certain fields in this message to be
        /// complete.
        pub completeness: std::option::Option<crate::model::slsa_provenance::SlsaCompleteness>,

        /// If true, the builder claims that running the recipe on materials will
        /// produce bit-for-bit identical output.
        pub reproducible: bool,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_invocation_id][crate::model::slsa_provenance::SlsaMetadata::build_invocation_id].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaMetadata;
        /// let x = SlsaMetadata::new().set_build_invocation_id("example");
        /// ```
        pub fn set_build_invocation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.build_invocation_id = v.into();
            self
        }

        /// Sets the value of [build_started_on][crate::model::slsa_provenance::SlsaMetadata::build_started_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaMetadata;
        /// use wkt::Timestamp;
        /// let x = SlsaMetadata::new().set_build_started_on(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_build_started_on<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.build_started_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_started_on][crate::model::slsa_provenance::SlsaMetadata::build_started_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaMetadata;
        /// use wkt::Timestamp;
        /// let x = SlsaMetadata::new().set_or_clear_build_started_on(Some(Timestamp::default()/* use setters */));
        /// let x = SlsaMetadata::new().set_or_clear_build_started_on(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_build_started_on<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.build_started_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [build_finished_on][crate::model::slsa_provenance::SlsaMetadata::build_finished_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaMetadata;
        /// use wkt::Timestamp;
        /// let x = SlsaMetadata::new().set_build_finished_on(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_build_finished_on<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.build_finished_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_finished_on][crate::model::slsa_provenance::SlsaMetadata::build_finished_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaMetadata;
        /// use wkt::Timestamp;
        /// let x = SlsaMetadata::new().set_or_clear_build_finished_on(Some(Timestamp::default()/* use setters */));
        /// let x = SlsaMetadata::new().set_or_clear_build_finished_on(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_build_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.build_finished_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [completeness][crate::model::slsa_provenance::SlsaMetadata::completeness].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaMetadata;
        /// use google_cloud_grafeas_v1::model::slsa_provenance::SlsaCompleteness;
        /// let x = SlsaMetadata::new().set_completeness(SlsaCompleteness::default()/* use setters */);
        /// ```
        pub fn set_completeness<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::slsa_provenance::SlsaCompleteness>
        {
            self.completeness = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [completeness][crate::model::slsa_provenance::SlsaMetadata::completeness].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaMetadata;
        /// use google_cloud_grafeas_v1::model::slsa_provenance::SlsaCompleteness;
        /// let x = SlsaMetadata::new().set_or_clear_completeness(Some(SlsaCompleteness::default()/* use setters */));
        /// let x = SlsaMetadata::new().set_or_clear_completeness(None::<SlsaCompleteness>);
        /// ```
        pub fn set_or_clear_completeness<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::slsa_provenance::SlsaCompleteness>
        {
            self.completeness = v.map(|x| x.into());
            self
        }

        /// Sets the value of [reproducible][crate::model::slsa_provenance::SlsaMetadata::reproducible].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaMetadata;
        /// let x = SlsaMetadata::new().set_reproducible(true);
        /// ```
        pub fn set_reproducible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.reproducible = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaMetadata"
        }
    }

    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaBuilder {

        pub id: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaBuilder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::slsa_provenance::SlsaBuilder::id].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::SlsaBuilder;
        /// let x = SlsaBuilder::new().set_id("example");
        /// ```
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaBuilder {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.SlsaBuilder"
        }
    }

    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Material {

        pub uri: std::string::String,

        pub digest: std::collections::HashMap<std::string::String,std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Material {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::slsa_provenance::Material::uri].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::Material;
        /// let x = Material::new().set_uri("example");
        /// ```
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::slsa_provenance::Material::digest].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance::Material;
        /// let x = Material::new().set_digest([
        ///     ("key0", "abc"),
        ///     ("key1", "xyz"),
        /// ]);
        /// ```
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for Material {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenance.Material"
        }
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SlsaProvenanceZeroTwo {

    pub builder: std::option::Option<crate::model::slsa_provenance_zero_two::SlsaBuilder>,

    pub build_type: std::string::String,

    pub invocation: std::option::Option<crate::model::slsa_provenance_zero_two::SlsaInvocation>,

    pub build_config: std::option::Option<wkt::Struct>,

    pub metadata: std::option::Option<crate::model::slsa_provenance_zero_two::SlsaMetadata>,

    pub materials: std::vec::Vec<crate::model::slsa_provenance_zero_two::SlsaMaterial>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SlsaProvenanceZeroTwo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builder][crate::model::SlsaProvenanceZeroTwo::builder].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenanceZeroTwo;
    /// use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaBuilder;
    /// let x = SlsaProvenanceZeroTwo::new().set_builder(SlsaBuilder::default()/* use setters */);
    /// ```
    pub fn set_builder<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaBuilder>
    {
        self.builder = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [builder][crate::model::SlsaProvenanceZeroTwo::builder].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenanceZeroTwo;
    /// use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaBuilder;
    /// let x = SlsaProvenanceZeroTwo::new().set_or_clear_builder(Some(SlsaBuilder::default()/* use setters */));
    /// let x = SlsaProvenanceZeroTwo::new().set_or_clear_builder(None::<SlsaBuilder>);
    /// ```
    pub fn set_or_clear_builder<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaBuilder>
    {
        self.builder = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_type][crate::model::SlsaProvenanceZeroTwo::build_type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenanceZeroTwo;
    /// let x = SlsaProvenanceZeroTwo::new().set_build_type("example");
    /// ```
    pub fn set_build_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build_type = v.into();
        self
    }

    /// Sets the value of [invocation][crate::model::SlsaProvenanceZeroTwo::invocation].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenanceZeroTwo;
    /// use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaInvocation;
    /// let x = SlsaProvenanceZeroTwo::new().set_invocation(SlsaInvocation::default()/* use setters */);
    /// ```
    pub fn set_invocation<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaInvocation>
    {
        self.invocation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [invocation][crate::model::SlsaProvenanceZeroTwo::invocation].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenanceZeroTwo;
    /// use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaInvocation;
    /// let x = SlsaProvenanceZeroTwo::new().set_or_clear_invocation(Some(SlsaInvocation::default()/* use setters */));
    /// let x = SlsaProvenanceZeroTwo::new().set_or_clear_invocation(None::<SlsaInvocation>);
    /// ```
    pub fn set_or_clear_invocation<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaInvocation>
    {
        self.invocation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_config][crate::model::SlsaProvenanceZeroTwo::build_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenanceZeroTwo;
    /// use wkt::Struct;
    /// let x = SlsaProvenanceZeroTwo::new().set_build_config(Struct::default()/* use setters */);
    /// ```
    pub fn set_build_config<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Struct>
    {
        self.build_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_config][crate::model::SlsaProvenanceZeroTwo::build_config].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenanceZeroTwo;
    /// use wkt::Struct;
    /// let x = SlsaProvenanceZeroTwo::new().set_or_clear_build_config(Some(Struct::default()/* use setters */));
    /// let x = SlsaProvenanceZeroTwo::new().set_or_clear_build_config(None::<Struct>);
    /// ```
    pub fn set_or_clear_build_config<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Struct>
    {
        self.build_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::SlsaProvenanceZeroTwo::metadata].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenanceZeroTwo;
    /// use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMetadata;
    /// let x = SlsaProvenanceZeroTwo::new().set_metadata(SlsaMetadata::default()/* use setters */);
    /// ```
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaMetadata>
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::SlsaProvenanceZeroTwo::metadata].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenanceZeroTwo;
    /// use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMetadata;
    /// let x = SlsaProvenanceZeroTwo::new().set_or_clear_metadata(Some(SlsaMetadata::default()/* use setters */));
    /// let x = SlsaProvenanceZeroTwo::new().set_or_clear_metadata(None::<SlsaMetadata>);
    /// ```
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaMetadata>
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [materials][crate::model::SlsaProvenanceZeroTwo::materials].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::SlsaProvenanceZeroTwo;
    /// use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMaterial;
    /// let x = SlsaProvenanceZeroTwo::new()
    ///     .set_materials([
    ///         SlsaMaterial::default()/* use setters */,
    ///         SlsaMaterial::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_materials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaMaterial>
    {
        use std::iter::Iterator;
        self.materials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SlsaProvenanceZeroTwo {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo"
    }
}

/// Defines additional types related to [SlsaProvenanceZeroTwo].
pub mod slsa_provenance_zero_two {
    #[allow(unused_imports)]
    use super::*;


    /// Identifies the entity that executed the recipe, which is trusted to have
    /// correctly performed the operation and populated this provenance.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaBuilder {

        pub id: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaBuilder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::slsa_provenance_zero_two::SlsaBuilder::id].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaBuilder;
        /// let x = SlsaBuilder::new().set_id("example");
        /// ```
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaBuilder {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaBuilder"
        }
    }

    /// The collection of artifacts that influenced the build including sources,
    /// dependencies, build tools, base images, and so on.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaMaterial {

        pub uri: std::string::String,

        pub digest: std::collections::HashMap<std::string::String,std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaMaterial {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::slsa_provenance_zero_two::SlsaMaterial::uri].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMaterial;
        /// let x = SlsaMaterial::new().set_uri("example");
        /// ```
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::slsa_provenance_zero_two::SlsaMaterial::digest].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMaterial;
        /// let x = SlsaMaterial::new().set_digest([
        ///     ("key0", "abc"),
        ///     ("key1", "xyz"),
        /// ]);
        /// ```
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for SlsaMaterial {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaMaterial"
        }
    }

    /// Identifies the event that kicked off the build.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaInvocation {

        pub config_source: std::option::Option<crate::model::slsa_provenance_zero_two::SlsaConfigSource>,

        pub parameters: std::option::Option<wkt::Struct>,

        pub environment: std::option::Option<wkt::Struct>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaInvocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [config_source][crate::model::slsa_provenance_zero_two::SlsaInvocation::config_source].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaInvocation;
        /// use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaConfigSource;
        /// let x = SlsaInvocation::new().set_config_source(SlsaConfigSource::default()/* use setters */);
        /// ```
        pub fn set_config_source<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaConfigSource>
        {
            self.config_source = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [config_source][crate::model::slsa_provenance_zero_two::SlsaInvocation::config_source].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaInvocation;
        /// use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaConfigSource;
        /// let x = SlsaInvocation::new().set_or_clear_config_source(Some(SlsaConfigSource::default()/* use setters */));
        /// let x = SlsaInvocation::new().set_or_clear_config_source(None::<SlsaConfigSource>);
        /// ```
        pub fn set_or_clear_config_source<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaConfigSource>
        {
            self.config_source = v.map(|x| x.into());
            self
        }

        /// Sets the value of [parameters][crate::model::slsa_provenance_zero_two::SlsaInvocation::parameters].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaInvocation;
        /// use wkt::Struct;
        /// let x = SlsaInvocation::new().set_parameters(Struct::default()/* use setters */);
        /// ```
        pub fn set_parameters<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Struct>
        {
            self.parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [parameters][crate::model::slsa_provenance_zero_two::SlsaInvocation::parameters].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaInvocation;
        /// use wkt::Struct;
        /// let x = SlsaInvocation::new().set_or_clear_parameters(Some(Struct::default()/* use setters */));
        /// let x = SlsaInvocation::new().set_or_clear_parameters(None::<Struct>);
        /// ```
        pub fn set_or_clear_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Struct>
        {
            self.parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance_zero_two::SlsaInvocation::environment].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaInvocation;
        /// use wkt::Struct;
        /// let x = SlsaInvocation::new().set_environment(Struct::default()/* use setters */);
        /// ```
        pub fn set_environment<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Struct>
        {
            self.environment = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [environment][crate::model::slsa_provenance_zero_two::SlsaInvocation::environment].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaInvocation;
        /// use wkt::Struct;
        /// let x = SlsaInvocation::new().set_or_clear_environment(Some(Struct::default()/* use setters */));
        /// let x = SlsaInvocation::new().set_or_clear_environment(None::<Struct>);
        /// ```
        pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Struct>
        {
            self.environment = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SlsaInvocation {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaInvocation"
        }
    }

    /// Describes where the config file that kicked off the build came from.
    /// This is effectively a pointer to the source where buildConfig came from.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaConfigSource {

        pub uri: std::string::String,

        pub digest: std::collections::HashMap<std::string::String,std::string::String>,

        pub entry_point: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaConfigSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::slsa_provenance_zero_two::SlsaConfigSource::uri].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaConfigSource;
        /// let x = SlsaConfigSource::new().set_uri("example");
        /// ```
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [digest][crate::model::slsa_provenance_zero_two::SlsaConfigSource::digest].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaConfigSource;
        /// let x = SlsaConfigSource::new().set_digest([
        ///     ("key0", "abc"),
        ///     ("key1", "xyz"),
        /// ]);
        /// ```
        pub fn set_digest<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.digest = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [entry_point][crate::model::slsa_provenance_zero_two::SlsaConfigSource::entry_point].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaConfigSource;
        /// let x = SlsaConfigSource::new().set_entry_point("example");
        /// ```
        pub fn set_entry_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entry_point = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaConfigSource {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaConfigSource"
        }
    }

    /// Other properties of the build.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaMetadata {

        pub build_invocation_id: std::string::String,

        pub build_started_on: std::option::Option<wkt::Timestamp>,

        pub build_finished_on: std::option::Option<wkt::Timestamp>,

        pub completeness: std::option::Option<crate::model::slsa_provenance_zero_two::SlsaCompleteness>,

        pub reproducible: bool,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [build_invocation_id][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_invocation_id].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMetadata;
        /// let x = SlsaMetadata::new().set_build_invocation_id("example");
        /// ```
        pub fn set_build_invocation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.build_invocation_id = v.into();
            self
        }

        /// Sets the value of [build_started_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_started_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMetadata;
        /// use wkt::Timestamp;
        /// let x = SlsaMetadata::new().set_build_started_on(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_build_started_on<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.build_started_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_started_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_started_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMetadata;
        /// use wkt::Timestamp;
        /// let x = SlsaMetadata::new().set_or_clear_build_started_on(Some(Timestamp::default()/* use setters */));
        /// let x = SlsaMetadata::new().set_or_clear_build_started_on(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_build_started_on<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.build_started_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [build_finished_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_finished_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMetadata;
        /// use wkt::Timestamp;
        /// let x = SlsaMetadata::new().set_build_finished_on(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_build_finished_on<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.build_finished_on = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [build_finished_on][crate::model::slsa_provenance_zero_two::SlsaMetadata::build_finished_on].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMetadata;
        /// use wkt::Timestamp;
        /// let x = SlsaMetadata::new().set_or_clear_build_finished_on(Some(Timestamp::default()/* use setters */));
        /// let x = SlsaMetadata::new().set_or_clear_build_finished_on(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_build_finished_on<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.build_finished_on = v.map(|x| x.into());
            self
        }

        /// Sets the value of [completeness][crate::model::slsa_provenance_zero_two::SlsaMetadata::completeness].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMetadata;
        /// use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaCompleteness;
        /// let x = SlsaMetadata::new().set_completeness(SlsaCompleteness::default()/* use setters */);
        /// ```
        pub fn set_completeness<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaCompleteness>
        {
            self.completeness = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [completeness][crate::model::slsa_provenance_zero_two::SlsaMetadata::completeness].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMetadata;
        /// use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaCompleteness;
        /// let x = SlsaMetadata::new().set_or_clear_completeness(Some(SlsaCompleteness::default()/* use setters */));
        /// let x = SlsaMetadata::new().set_or_clear_completeness(None::<SlsaCompleteness>);
        /// ```
        pub fn set_or_clear_completeness<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::slsa_provenance_zero_two::SlsaCompleteness>
        {
            self.completeness = v.map(|x| x.into());
            self
        }

        /// Sets the value of [reproducible][crate::model::slsa_provenance_zero_two::SlsaMetadata::reproducible].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaMetadata;
        /// let x = SlsaMetadata::new().set_reproducible(true);
        /// ```
        pub fn set_reproducible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.reproducible = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaMetadata"
        }
    }

    /// Indicates that the builder claims certain fields in this message to be
    /// complete.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlsaCompleteness {

        pub parameters: bool,

        pub environment: bool,

        pub materials: bool,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlsaCompleteness {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameters][crate::model::slsa_provenance_zero_two::SlsaCompleteness::parameters].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaCompleteness;
        /// let x = SlsaCompleteness::new().set_parameters(true);
        /// ```
        pub fn set_parameters<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.parameters = v.into();
            self
        }

        /// Sets the value of [environment][crate::model::slsa_provenance_zero_two::SlsaCompleteness::environment].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaCompleteness;
        /// let x = SlsaCompleteness::new().set_environment(true);
        /// ```
        pub fn set_environment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.environment = v.into();
            self
        }

        /// Sets the value of [materials][crate::model::slsa_provenance_zero_two::SlsaCompleteness::materials].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::slsa_provenance_zero_two::SlsaCompleteness;
        /// let x = SlsaCompleteness::new().set_materials(true);
        /// ```
        pub fn set_materials<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.materials = v.into();
            self
        }
    }

    impl wkt::message::Message for SlsaCompleteness {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.SlsaProvenanceZeroTwo.SlsaCompleteness"
        }
    }
}

/// An Upgrade Note represents a potential upgrade of a package to a given
/// version. For each package version combination (i.e. bash 4.0, bash 4.1,
/// bash 4.1.2), there will be an Upgrade Note. For Windows, windows_update field
/// represents the information related to the update.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeNote {

    /// Required for non-Windows OS. The package this Upgrade is for.
    pub package: std::string::String,

    /// Required for non-Windows OS. The version of the package in machine + human
    /// readable form.
    pub version: std::option::Option<crate::model::Version>,

    /// Metadata about the upgrade for each specific operating system.
    pub distributions: std::vec::Vec<crate::model::UpgradeDistribution>,

    /// Required for Windows OS. Represents the metadata about the Windows update.
    pub windows_update: std::option::Option<crate::model::WindowsUpdate>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package][crate::model::UpgradeNote::package].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeNote;
    /// let x = UpgradeNote::new().set_package("example");
    /// ```
    pub fn set_package<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package = v.into();
        self
    }

    /// Sets the value of [version][crate::model::UpgradeNote::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeNote;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = UpgradeNote::new().set_version(Version::default()/* use setters */);
    /// ```
    pub fn set_version<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::UpgradeNote::version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeNote;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = UpgradeNote::new().set_or_clear_version(Some(Version::default()/* use setters */));
    /// let x = UpgradeNote::new().set_or_clear_version(None::<Version>);
    /// ```
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [distributions][crate::model::UpgradeNote::distributions].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeNote;
    /// use google_cloud_grafeas_v1::model::UpgradeDistribution;
    /// let x = UpgradeNote::new()
    ///     .set_distributions([
    ///         UpgradeDistribution::default()/* use setters */,
    ///         UpgradeDistribution::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_distributions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpgradeDistribution>
    {
        use std::iter::Iterator;
        self.distributions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [windows_update][crate::model::UpgradeNote::windows_update].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeNote;
    /// use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// let x = UpgradeNote::new().set_windows_update(WindowsUpdate::default()/* use setters */);
    /// ```
    pub fn set_windows_update<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::WindowsUpdate>
    {
        self.windows_update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [windows_update][crate::model::UpgradeNote::windows_update].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeNote;
    /// use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// let x = UpgradeNote::new().set_or_clear_windows_update(Some(WindowsUpdate::default()/* use setters */));
    /// let x = UpgradeNote::new().set_or_clear_windows_update(None::<WindowsUpdate>);
    /// ```
    pub fn set_or_clear_windows_update<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::WindowsUpdate>
    {
        self.windows_update = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpgradeNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpgradeNote"
    }
}

/// The Upgrade Distribution represents metadata about the Upgrade for each
/// operating system (CPE). Some distributions have additional metadata around
/// updates, classifying them into various categories and severities.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeDistribution {

    /// Required - The specific operating system this metadata applies to. See
    /// <https://cpe.mitre.org/specification/>.
    pub cpe_uri: std::string::String,

    /// The operating system classification of this Upgrade, as specified by the
    /// upstream operating system upgrade feed. For Windows the classification is
    /// one of the category_ids listed at
    /// <https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ff357803>(v=vs.85)
    pub classification: std::string::String,

    /// The severity as specified by the upstream operating system.
    pub severity: std::string::String,

    /// The cve tied to this Upgrade.
    pub cve: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeDistribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpe_uri][crate::model::UpgradeDistribution::cpe_uri].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeDistribution;
    /// let x = UpgradeDistribution::new().set_cpe_uri("example");
    /// ```
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [classification][crate::model::UpgradeDistribution::classification].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeDistribution;
    /// let x = UpgradeDistribution::new().set_classification("example");
    /// ```
    pub fn set_classification<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.classification = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::UpgradeDistribution::severity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeDistribution;
    /// let x = UpgradeDistribution::new().set_severity("example");
    /// ```
    pub fn set_severity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [cve][crate::model::UpgradeDistribution::cve].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeDistribution;
    /// let x = UpgradeDistribution::new().set_cve(["a", "b", "c"]);
    /// ```
    pub fn set_cve<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.cve = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpgradeDistribution {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpgradeDistribution"
    }
}

/// Windows Update represents the metadata about the update for the Windows
/// operating system. The fields in this message come from the Windows Update API
/// documented at
/// <https://docs.microsoft.com/en-us/windows/win32/api/wuapi/nn-wuapi-iupdate>.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WindowsUpdate {

    /// Required - The unique identifier for the update.
    pub identity: std::option::Option<crate::model::windows_update::Identity>,

    /// The localized title of the update.
    pub title: std::string::String,

    /// The localized description of the update.
    pub description: std::string::String,

    /// The list of categories to which the update belongs.
    pub categories: std::vec::Vec<crate::model::windows_update::Category>,

    /// The Microsoft Knowledge Base article IDs that are associated with the
    /// update.
    pub kb_article_ids: std::vec::Vec<std::string::String>,

    /// The hyperlink to the support information for the update.
    pub support_url: std::string::String,

    /// The last published timestamp of the update.
    pub last_published_timestamp: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WindowsUpdate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [identity][crate::model::WindowsUpdate::identity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// use google_cloud_grafeas_v1::model::windows_update::Identity;
    /// let x = WindowsUpdate::new().set_identity(Identity::default()/* use setters */);
    /// ```
    pub fn set_identity<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::windows_update::Identity>
    {
        self.identity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [identity][crate::model::WindowsUpdate::identity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// use google_cloud_grafeas_v1::model::windows_update::Identity;
    /// let x = WindowsUpdate::new().set_or_clear_identity(Some(Identity::default()/* use setters */));
    /// let x = WindowsUpdate::new().set_or_clear_identity(None::<Identity>);
    /// ```
    pub fn set_or_clear_identity<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::windows_update::Identity>
    {
        self.identity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [title][crate::model::WindowsUpdate::title].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// let x = WindowsUpdate::new().set_title("example");
    /// ```
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::WindowsUpdate::description].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// let x = WindowsUpdate::new().set_description("example");
    /// ```
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [categories][crate::model::WindowsUpdate::categories].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// use google_cloud_grafeas_v1::model::windows_update::Category;
    /// let x = WindowsUpdate::new()
    ///     .set_categories([
    ///         Category::default()/* use setters */,
    ///         Category::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::windows_update::Category>
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kb_article_ids][crate::model::WindowsUpdate::kb_article_ids].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// let x = WindowsUpdate::new().set_kb_article_ids(["a", "b", "c"]);
    /// ```
    pub fn set_kb_article_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.kb_article_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [support_url][crate::model::WindowsUpdate::support_url].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// let x = WindowsUpdate::new().set_support_url("example");
    /// ```
    pub fn set_support_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.support_url = v.into();
        self
    }

    /// Sets the value of [last_published_timestamp][crate::model::WindowsUpdate::last_published_timestamp].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// use wkt::Timestamp;
    /// let x = WindowsUpdate::new().set_last_published_timestamp(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_last_published_timestamp<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.last_published_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_published_timestamp][crate::model::WindowsUpdate::last_published_timestamp].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// use wkt::Timestamp;
    /// let x = WindowsUpdate::new().set_or_clear_last_published_timestamp(Some(Timestamp::default()/* use setters */));
    /// let x = WindowsUpdate::new().set_or_clear_last_published_timestamp(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_last_published_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.last_published_timestamp = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WindowsUpdate {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.WindowsUpdate"
    }
}

/// Defines additional types related to [WindowsUpdate].
pub mod windows_update {
    #[allow(unused_imports)]
    use super::*;


    /// The unique identifier of the update.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Identity {

        /// The revision independent identifier of the update.
        pub update_id: std::string::String,

        /// The revision number of the update.
        pub revision: i32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Identity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [update_id][crate::model::windows_update::Identity::update_id].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::windows_update::Identity;
        /// let x = Identity::new().set_update_id("example");
        /// ```
        pub fn set_update_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.update_id = v.into();
            self
        }

        /// Sets the value of [revision][crate::model::windows_update::Identity::revision].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::windows_update::Identity;
        /// let x = Identity::new().set_revision(42);
        /// ```
        pub fn set_revision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.revision = v.into();
            self
        }
    }

    impl wkt::message::Message for Identity {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.WindowsUpdate.Identity"
        }
    }

    /// The category to which the update belongs.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Category {

        /// The identifier of the category.
        pub category_id: std::string::String,

        /// The localized name of the category.
        pub name: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Category {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [category_id][crate::model::windows_update::Category::category_id].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::windows_update::Category;
        /// let x = Category::new().set_category_id("example");
        /// ```
        pub fn set_category_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.category_id = v.into();
            self
        }

        /// Sets the value of [name][crate::model::windows_update::Category::name].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::windows_update::Category;
        /// let x = Category::new().set_name("example");
        /// ```
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for Category {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.WindowsUpdate.Category"
        }
    }
}

/// An Upgrade Occurrence represents that a specific resource_url could install a
/// specific upgrade. This presence is supplied via local sources (i.e. it is
/// present in the mirror and the running system has noticed its availability).
/// For Windows, both distribution and windows_update contain information for the
/// Windows update.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeOccurrence {

    /// Required for non-Windows OS. The package this Upgrade is for.
    pub package: std::string::String,

    /// Required for non-Windows OS. The version of the package in a machine +
    /// human readable form.
    pub parsed_version: std::option::Option<crate::model::Version>,

    /// Metadata about the upgrade for available for the specific operating system
    /// for the resource_url. This allows efficient filtering, as well as
    /// making it easier to use the occurrence.
    pub distribution: std::option::Option<crate::model::UpgradeDistribution>,

    /// Required for Windows OS. Represents the metadata about the Windows update.
    pub windows_update: std::option::Option<crate::model::WindowsUpdate>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package][crate::model::UpgradeOccurrence::package].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeOccurrence;
    /// let x = UpgradeOccurrence::new().set_package("example");
    /// ```
    pub fn set_package<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package = v.into();
        self
    }

    /// Sets the value of [parsed_version][crate::model::UpgradeOccurrence::parsed_version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeOccurrence;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = UpgradeOccurrence::new().set_parsed_version(Version::default()/* use setters */);
    /// ```
    pub fn set_parsed_version<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.parsed_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parsed_version][crate::model::UpgradeOccurrence::parsed_version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeOccurrence;
    /// use google_cloud_grafeas_v1::model::Version;
    /// let x = UpgradeOccurrence::new().set_or_clear_parsed_version(Some(Version::default()/* use setters */));
    /// let x = UpgradeOccurrence::new().set_or_clear_parsed_version(None::<Version>);
    /// ```
    pub fn set_or_clear_parsed_version<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Version>
    {
        self.parsed_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [distribution][crate::model::UpgradeOccurrence::distribution].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeOccurrence;
    /// use google_cloud_grafeas_v1::model::UpgradeDistribution;
    /// let x = UpgradeOccurrence::new().set_distribution(UpgradeDistribution::default()/* use setters */);
    /// ```
    pub fn set_distribution<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::UpgradeDistribution>
    {
        self.distribution = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [distribution][crate::model::UpgradeOccurrence::distribution].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeOccurrence;
    /// use google_cloud_grafeas_v1::model::UpgradeDistribution;
    /// let x = UpgradeOccurrence::new().set_or_clear_distribution(Some(UpgradeDistribution::default()/* use setters */));
    /// let x = UpgradeOccurrence::new().set_or_clear_distribution(None::<UpgradeDistribution>);
    /// ```
    pub fn set_or_clear_distribution<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::UpgradeDistribution>
    {
        self.distribution = v.map(|x| x.into());
        self
    }

    /// Sets the value of [windows_update][crate::model::UpgradeOccurrence::windows_update].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeOccurrence;
    /// use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// let x = UpgradeOccurrence::new().set_windows_update(WindowsUpdate::default()/* use setters */);
    /// ```
    pub fn set_windows_update<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::WindowsUpdate>
    {
        self.windows_update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [windows_update][crate::model::UpgradeOccurrence::windows_update].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::UpgradeOccurrence;
    /// use google_cloud_grafeas_v1::model::WindowsUpdate;
    /// let x = UpgradeOccurrence::new().set_or_clear_windows_update(Some(WindowsUpdate::default()/* use setters */));
    /// let x = UpgradeOccurrence::new().set_or_clear_windows_update(None::<WindowsUpdate>);
    /// ```
    pub fn set_or_clear_windows_update<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::WindowsUpdate>
    {
        self.windows_update = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpgradeOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.UpgradeOccurrence"
    }
}

/// A single VulnerabilityAssessmentNote represents
/// one particular product's vulnerability assessment for one CVE.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VulnerabilityAssessmentNote {

    /// The title of the note. E.g. `Vex-Debian-11.4`
    pub title: std::string::String,

    /// A one sentence description of this Vex.
    pub short_description: std::string::String,

    /// A detailed description of this Vex.
    pub long_description: std::string::String,

    /// Identifies the language used by this document,
    /// corresponding to IETF BCP 47 / RFC 5646.
    pub language_code: std::string::String,

    /// Publisher details of this Note.
    pub publisher: std::option::Option<crate::model::vulnerability_assessment_note::Publisher>,

    /// The product affected by this vex.
    pub product: std::option::Option<crate::model::vulnerability_assessment_note::Product>,

    /// Represents a vulnerability assessment for the product.
    pub assessment: std::option::Option<crate::model::vulnerability_assessment_note::Assessment>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityAssessmentNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::VulnerabilityAssessmentNote::title].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityAssessmentNote;
    /// let x = VulnerabilityAssessmentNote::new().set_title("example");
    /// ```
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [short_description][crate::model::VulnerabilityAssessmentNote::short_description].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityAssessmentNote;
    /// let x = VulnerabilityAssessmentNote::new().set_short_description("example");
    /// ```
    pub fn set_short_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.short_description = v.into();
        self
    }

    /// Sets the value of [long_description][crate::model::VulnerabilityAssessmentNote::long_description].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityAssessmentNote;
    /// let x = VulnerabilityAssessmentNote::new().set_long_description("example");
    /// ```
    pub fn set_long_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.long_description = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::VulnerabilityAssessmentNote::language_code].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityAssessmentNote;
    /// let x = VulnerabilityAssessmentNote::new().set_language_code("example");
    /// ```
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [publisher][crate::model::VulnerabilityAssessmentNote::publisher].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityAssessmentNote;
    /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Publisher;
    /// let x = VulnerabilityAssessmentNote::new().set_publisher(Publisher::default()/* use setters */);
    /// ```
    pub fn set_publisher<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::vulnerability_assessment_note::Publisher>
    {
        self.publisher = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [publisher][crate::model::VulnerabilityAssessmentNote::publisher].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityAssessmentNote;
    /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Publisher;
    /// let x = VulnerabilityAssessmentNote::new().set_or_clear_publisher(Some(Publisher::default()/* use setters */));
    /// let x = VulnerabilityAssessmentNote::new().set_or_clear_publisher(None::<Publisher>);
    /// ```
    pub fn set_or_clear_publisher<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::vulnerability_assessment_note::Publisher>
    {
        self.publisher = v.map(|x| x.into());
        self
    }

    /// Sets the value of [product][crate::model::VulnerabilityAssessmentNote::product].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityAssessmentNote;
    /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Product;
    /// let x = VulnerabilityAssessmentNote::new().set_product(Product::default()/* use setters */);
    /// ```
    pub fn set_product<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::vulnerability_assessment_note::Product>
    {
        self.product = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product][crate::model::VulnerabilityAssessmentNote::product].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityAssessmentNote;
    /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Product;
    /// let x = VulnerabilityAssessmentNote::new().set_or_clear_product(Some(Product::default()/* use setters */));
    /// let x = VulnerabilityAssessmentNote::new().set_or_clear_product(None::<Product>);
    /// ```
    pub fn set_or_clear_product<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::vulnerability_assessment_note::Product>
    {
        self.product = v.map(|x| x.into());
        self
    }

    /// Sets the value of [assessment][crate::model::VulnerabilityAssessmentNote::assessment].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityAssessmentNote;
    /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
    /// let x = VulnerabilityAssessmentNote::new().set_assessment(Assessment::default()/* use setters */);
    /// ```
    pub fn set_assessment<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::vulnerability_assessment_note::Assessment>
    {
        self.assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assessment][crate::model::VulnerabilityAssessmentNote::assessment].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityAssessmentNote;
    /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
    /// let x = VulnerabilityAssessmentNote::new().set_or_clear_assessment(Some(Assessment::default()/* use setters */));
    /// let x = VulnerabilityAssessmentNote::new().set_or_clear_assessment(None::<Assessment>);
    /// ```
    pub fn set_or_clear_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::vulnerability_assessment_note::Assessment>
    {
        self.assessment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VulnerabilityAssessmentNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote"
    }
}

/// Defines additional types related to [VulnerabilityAssessmentNote].
pub mod vulnerability_assessment_note {
    #[allow(unused_imports)]
    use super::*;


    /// Publisher contains information about the publisher of
    /// this Note.
    /// (-- api-linter: core::0123::resource-annotation=disabled
    /// aip.dev/not-precedent: Publisher is not a separate resource. --)
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Publisher {

        /// Name of the publisher.
        /// Examples: 'Google', 'Google Cloud Platform'.
        pub name: std::string::String,

        /// Provides information about the authority of the issuing party to
        /// release the document, in particular, the party's constituency and
        /// responsibilities or other obligations.
        pub issuing_authority: std::string::String,

        /// The context or namespace.
        /// Contains a URL which is under control of the issuing party and can
        /// be used as a globally unique identifier for that issuing party.
        /// Example: <https://csaf.io>
        pub publisher_namespace: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Publisher {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::vulnerability_assessment_note::Publisher::name].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Publisher;
        /// let x = Publisher::new().set_name("example");
        /// ```
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [issuing_authority][crate::model::vulnerability_assessment_note::Publisher::issuing_authority].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Publisher;
        /// let x = Publisher::new().set_issuing_authority("example");
        /// ```
        pub fn set_issuing_authority<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.issuing_authority = v.into();
            self
        }

        /// Sets the value of [publisher_namespace][crate::model::vulnerability_assessment_note::Publisher::publisher_namespace].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Publisher;
        /// let x = Publisher::new().set_publisher_namespace("example");
        /// ```
        pub fn set_publisher_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.publisher_namespace = v.into();
            self
        }
    }

    impl wkt::message::Message for Publisher {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Publisher"
        }
    }

    /// Product contains information about a product and how to uniquely identify
    /// it.
    /// (-- api-linter: core::0123::resource-annotation=disabled
    /// aip.dev/not-precedent: Product is not a separate resource. --)
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Product {

        /// Name of the product.
        pub name: std::string::String,

        /// Token that identifies a product so that it can be referred to from other
        /// parts in the document. There is no predefined format as long as it
        /// uniquely identifies a group in the context of the current document.
        pub id: std::string::String,

        pub identifier: std::option::Option<crate::model::vulnerability_assessment_note::product::Identifier>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Product {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::vulnerability_assessment_note::Product::name].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Product;
        /// let x = Product::new().set_name("example");
        /// ```
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [id][crate::model::vulnerability_assessment_note::Product::id].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Product;
        /// let x = Product::new().set_id("example");
        /// ```
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [identifier][crate::model::vulnerability_assessment_note::Product::identifier].
        ///
        /// Note that all the setters affecting `identifier` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Product;
        /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::product::Identifier;
        /// let x = Product::new().set_identifier(Some(Identifier::GenericUri("example".to_string())));
        /// ```
        pub fn set_identifier<T: std::convert::Into<std::option::Option<crate::model::vulnerability_assessment_note::product::Identifier>>>(mut self, v: T) -> Self
        {
            self.identifier = v.into();
            self
        }

        /// The value of [identifier][crate::model::vulnerability_assessment_note::Product::identifier]
        /// if it holds a `GenericUri`, `None` if the field is not set or
        /// holds a different branch.
        pub fn generic_uri(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.identifier.as_ref().and_then(|v| match v {
                crate::model::vulnerability_assessment_note::product::Identifier::GenericUri(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [identifier][crate::model::vulnerability_assessment_note::Product::identifier]
        /// to hold a `GenericUri`.
        ///
        /// Note that all the setters affecting `identifier` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Product;
        /// let x = Product::new().set_generic_uri("example");
        /// assert!(x.generic_uri().is_some());
        /// ```
        pub fn set_generic_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.identifier = std::option::Option::Some(
                crate::model::vulnerability_assessment_note::product::Identifier::GenericUri(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for Product {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Product"
        }
    }

    /// Defines additional types related to [Product].
    pub mod product {
        #[allow(unused_imports)]
        use super::*;


        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Identifier {
            /// Contains a URI which is vendor-specific.
            /// Example: The artifact repository URL of an image.
            GenericUri(std::string::String),
        }
    }

    /// Assessment provides all information that is related to a single
    /// vulnerability for this product.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Assessment {

        /// Holds the MITRE standard Common Vulnerabilities and Exposures (CVE)
        /// tracking number for the vulnerability.
        /// Deprecated: Use vulnerability_id instead to denote CVEs.
        #[deprecated]
        pub cve: std::string::String,

        /// The vulnerability identifier for this Assessment. Will hold one of
        /// common identifiers e.g. CVE, GHSA etc.
        pub vulnerability_id: std::string::String,

        /// A one sentence description of this Vex.
        pub short_description: std::string::String,

        /// A detailed description of this Vex.
        pub long_description: std::string::String,

        /// Holds a list of references associated with this vulnerability item and
        /// assessment. These uris have additional information about the
        /// vulnerability and the assessment itself. E.g. Link to a document which
        /// details how this assessment concluded the state of this vulnerability.
        pub related_uris: std::vec::Vec<crate::model::RelatedUrl>,

        /// Provides the state of this Vulnerability assessment.
        pub state: crate::model::vulnerability_assessment_note::assessment::State,

        /// Contains information about the impact of this vulnerability,
        /// this will change with time.
        pub impacts: std::vec::Vec<std::string::String>,

        /// Justification provides the justification when the state of the
        /// assessment if NOT_AFFECTED.
        pub justification: std::option::Option<crate::model::vulnerability_assessment_note::assessment::Justification>,

        /// Specifies details on how to handle (and presumably, fix) a vulnerability.
        pub remediations: std::vec::Vec<crate::model::vulnerability_assessment_note::assessment::Remediation>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Assessment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cve][crate::model::vulnerability_assessment_note::Assessment::cve].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
        /// let x = Assessment::new().set_cve("example");
        /// ```
        #[deprecated]
        pub fn set_cve<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cve = v.into();
            self
        }

        /// Sets the value of [vulnerability_id][crate::model::vulnerability_assessment_note::Assessment::vulnerability_id].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
        /// let x = Assessment::new().set_vulnerability_id("example");
        /// ```
        pub fn set_vulnerability_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.vulnerability_id = v.into();
            self
        }

        /// Sets the value of [short_description][crate::model::vulnerability_assessment_note::Assessment::short_description].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
        /// let x = Assessment::new().set_short_description("example");
        /// ```
        pub fn set_short_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.short_description = v.into();
            self
        }

        /// Sets the value of [long_description][crate::model::vulnerability_assessment_note::Assessment::long_description].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
        /// let x = Assessment::new().set_long_description("example");
        /// ```
        pub fn set_long_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.long_description = v.into();
            self
        }

        /// Sets the value of [related_uris][crate::model::vulnerability_assessment_note::Assessment::related_uris].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
        /// use google_cloud_grafeas_v1::model::RelatedUrl;
        /// let x = Assessment::new()
        ///     .set_related_uris([
        ///         RelatedUrl::default()/* use setters */,
        ///         RelatedUrl::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_related_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::RelatedUrl>
        {
            use std::iter::Iterator;
            self.related_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [state][crate::model::vulnerability_assessment_note::Assessment::state].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
        /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::State;
        /// let x0 = Assessment::new().set_state(State::Affected);
        /// let x1 = Assessment::new().set_state(State::NotAffected);
        /// let x2 = Assessment::new().set_state(State::Fixed);
        /// ```
        pub fn set_state<T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::State>>(mut self, v: T) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [impacts][crate::model::vulnerability_assessment_note::Assessment::impacts].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
        /// let x = Assessment::new().set_impacts(["a", "b", "c"]);
        /// ```
        pub fn set_impacts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>
        {
            use std::iter::Iterator;
            self.impacts = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [justification][crate::model::vulnerability_assessment_note::Assessment::justification].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
        /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Justification;
        /// let x = Assessment::new().set_justification(Justification::default()/* use setters */);
        /// ```
        pub fn set_justification<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::Justification>
        {
            self.justification = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [justification][crate::model::vulnerability_assessment_note::Assessment::justification].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
        /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Justification;
        /// let x = Assessment::new().set_or_clear_justification(Some(Justification::default()/* use setters */));
        /// let x = Assessment::new().set_or_clear_justification(None::<Justification>);
        /// ```
        pub fn set_or_clear_justification<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::Justification>
        {
            self.justification = v.map(|x| x.into());
            self
        }

        /// Sets the value of [remediations][crate::model::vulnerability_assessment_note::Assessment::remediations].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::Assessment;
        /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Remediation;
        /// let x = Assessment::new()
        ///     .set_remediations([
        ///         Remediation::default()/* use setters */,
        ///         Remediation::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_remediations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::Remediation>
        {
            use std::iter::Iterator;
            self.remediations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Assessment {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Assessment"
        }
    }

    /// Defines additional types related to [Assessment].
    pub mod assessment {
        #[allow(unused_imports)]
        use super::*;


        /// Justification provides the justification when the state of the
        /// assessment if NOT_AFFECTED.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Justification {

            /// The justification type for this vulnerability.
            pub justification_type: crate::model::vulnerability_assessment_note::assessment::justification::JustificationType,

            /// Additional details on why this justification was chosen.
            pub details: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Justification {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [justification_type][crate::model::vulnerability_assessment_note::assessment::Justification::justification_type].
            ///
            /// # Example
            /// ```ignore,no_run
            /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Justification;
            /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::justification::JustificationType;
            /// let x0 = Justification::new().set_justification_type(JustificationType::ComponentNotPresent);
            /// let x1 = Justification::new().set_justification_type(JustificationType::VulnerableCodeNotPresent);
            /// let x2 = Justification::new().set_justification_type(JustificationType::VulnerableCodeNotInExecutePath);
            /// ```
            pub fn set_justification_type<T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::justification::JustificationType>>(mut self, v: T) -> Self {
                self.justification_type = v.into();
                self
            }

            /// Sets the value of [details][crate::model::vulnerability_assessment_note::assessment::Justification::details].
            ///
            /// # Example
            /// ```ignore,no_run
            /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Justification;
            /// let x = Justification::new().set_details("example");
            /// ```
            pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.details = v.into();
                self
            }
        }

        impl wkt::message::Message for Justification {
            fn typename() -> &'static str {
                "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Assessment.Justification"
            }
        }

        /// Defines additional types related to [Justification].
        pub mod justification {
            #[allow(unused_imports)]
            use super::*;


            /// Provides the type of justification.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum JustificationType {
                /// JUSTIFICATION_TYPE_UNSPECIFIED.
                Unspecified,
                /// The vulnerable component is not present in the product.
                ComponentNotPresent,
                /// The vulnerable code is not present. Typically this case
                /// occurs when source code is configured or built in a way that excludes
                /// the vulnerable code.
                VulnerableCodeNotPresent,
                /// The vulnerable code can not be executed.
                /// Typically this case occurs when the product includes the vulnerable
                /// code but does not call or use the vulnerable code.
                VulnerableCodeNotInExecutePath,
                /// The vulnerable code cannot be controlled by an attacker to exploit
                /// the vulnerability.
                VulnerableCodeCannotBeControlledByAdversary,
                /// The product includes built-in protections or features that prevent
                /// exploitation of the vulnerability. These built-in protections cannot
                /// be subverted by the attacker and cannot be configured or disabled by
                /// the user. These mitigations completely prevent exploitation based on
                /// known attack vectors.
                InlineMitigationsAlreadyExist,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [JustificationType::value] or
                /// [JustificationType::name].
                UnknownValue(justification_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod justification_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl JustificationType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::ComponentNotPresent => std::option::Option::Some(1),
                        Self::VulnerableCodeNotPresent => std::option::Option::Some(2),
                        Self::VulnerableCodeNotInExecutePath => std::option::Option::Some(3),
                        Self::VulnerableCodeCannotBeControlledByAdversary => std::option::Option::Some(4),
                        Self::InlineMitigationsAlreadyExist => std::option::Option::Some(5),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("JUSTIFICATION_TYPE_UNSPECIFIED"),
                        Self::ComponentNotPresent => std::option::Option::Some("COMPONENT_NOT_PRESENT"),
                        Self::VulnerableCodeNotPresent => std::option::Option::Some("VULNERABLE_CODE_NOT_PRESENT"),
                        Self::VulnerableCodeNotInExecutePath => std::option::Option::Some("VULNERABLE_CODE_NOT_IN_EXECUTE_PATH"),
                        Self::VulnerableCodeCannotBeControlledByAdversary => std::option::Option::Some("VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY"),
                        Self::InlineMitigationsAlreadyExist => std::option::Option::Some("INLINE_MITIGATIONS_ALREADY_EXIST"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for JustificationType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for JustificationType {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for JustificationType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::ComponentNotPresent,
                        2 => Self::VulnerableCodeNotPresent,
                        3 => Self::VulnerableCodeNotInExecutePath,
                        4 => Self::VulnerableCodeCannotBeControlledByAdversary,
                        5 => Self::InlineMitigationsAlreadyExist,
                        _ => Self::UnknownValue(justification_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                    }
                }
            }

            impl std::convert::From<&str> for JustificationType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "JUSTIFICATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "COMPONENT_NOT_PRESENT" => Self::ComponentNotPresent,
                        "VULNERABLE_CODE_NOT_PRESENT" => Self::VulnerableCodeNotPresent,
                        "VULNERABLE_CODE_NOT_IN_EXECUTE_PATH" => Self::VulnerableCodeNotInExecutePath,
                        "VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY" => Self::VulnerableCodeCannotBeControlledByAdversary,
                        "INLINE_MITIGATIONS_ALREADY_EXIST" => Self::InlineMitigationsAlreadyExist,
                        _ => Self::UnknownValue(justification_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                    }
                }
            }

            impl serde::ser::Serialize for JustificationType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::ComponentNotPresent => serializer.serialize_i32(1),
                        Self::VulnerableCodeNotPresent => serializer.serialize_i32(2),
                        Self::VulnerableCodeNotInExecutePath => serializer.serialize_i32(3),
                        Self::VulnerableCodeCannotBeControlledByAdversary => serializer.serialize_i32(4),
                        Self::InlineMitigationsAlreadyExist => serializer.serialize_i32(5),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for JustificationType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<JustificationType>::new(
                        ".grafeas.v1.VulnerabilityAssessmentNote.Assessment.Justification.JustificationType"))
                }
            }
        }

        /// Specifies details on how to handle (and presumably, fix) a vulnerability.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Remediation {

            /// The type of remediation that can be applied.
            pub remediation_type: crate::model::vulnerability_assessment_note::assessment::remediation::RemediationType,

            /// Contains a comprehensive human-readable discussion of the remediation.
            pub details: std::string::String,

            /// Contains the URL where to obtain the remediation.
            pub remediation_uri: std::option::Option<crate::model::RelatedUrl>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Remediation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [remediation_type][crate::model::vulnerability_assessment_note::assessment::Remediation::remediation_type].
            ///
            /// # Example
            /// ```ignore,no_run
            /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Remediation;
            /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::remediation::RemediationType;
            /// let x0 = Remediation::new().set_remediation_type(RemediationType::Mitigation);
            /// let x1 = Remediation::new().set_remediation_type(RemediationType::NoFixPlanned);
            /// let x2 = Remediation::new().set_remediation_type(RemediationType::NoneAvailable);
            /// ```
            pub fn set_remediation_type<T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::remediation::RemediationType>>(mut self, v: T) -> Self {
                self.remediation_type = v.into();
                self
            }

            /// Sets the value of [details][crate::model::vulnerability_assessment_note::assessment::Remediation::details].
            ///
            /// # Example
            /// ```ignore,no_run
            /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Remediation;
            /// let x = Remediation::new().set_details("example");
            /// ```
            pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.details = v.into();
                self
            }

            /// Sets the value of [remediation_uri][crate::model::vulnerability_assessment_note::assessment::Remediation::remediation_uri].
            ///
            /// # Example
            /// ```ignore,no_run
            /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Remediation;
            /// use google_cloud_grafeas_v1::model::RelatedUrl;
            /// let x = Remediation::new().set_remediation_uri(RelatedUrl::default()/* use setters */);
            /// ```
            pub fn set_remediation_uri<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::RelatedUrl>
            {
                self.remediation_uri = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [remediation_uri][crate::model::vulnerability_assessment_note::assessment::Remediation::remediation_uri].
            ///
            /// # Example
            /// ```ignore,no_run
            /// # use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Remediation;
            /// use google_cloud_grafeas_v1::model::RelatedUrl;
            /// let x = Remediation::new().set_or_clear_remediation_uri(Some(RelatedUrl::default()/* use setters */));
            /// let x = Remediation::new().set_or_clear_remediation_uri(None::<RelatedUrl>);
            /// ```
            pub fn set_or_clear_remediation_uri<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::RelatedUrl>
            {
                self.remediation_uri = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Remediation {
            fn typename() -> &'static str {
                "type.googleapis.com/grafeas.v1.VulnerabilityAssessmentNote.Assessment.Remediation"
            }
        }

        /// Defines additional types related to [Remediation].
        pub mod remediation {
            #[allow(unused_imports)]
            use super::*;


            /// The type of remediation that can be applied.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum RemediationType {
                /// No remediation type specified.
                Unspecified,
                /// A MITIGATION is available.
                Mitigation,
                /// No fix is planned.
                NoFixPlanned,
                /// Not available.
                NoneAvailable,
                /// A vendor fix is available.
                VendorFix,
                /// A workaround is available.
                Workaround,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [RemediationType::value] or
                /// [RemediationType::name].
                UnknownValue(remediation_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod remediation_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl RemediationType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Mitigation => std::option::Option::Some(1),
                        Self::NoFixPlanned => std::option::Option::Some(2),
                        Self::NoneAvailable => std::option::Option::Some(3),
                        Self::VendorFix => std::option::Option::Some(4),
                        Self::Workaround => std::option::Option::Some(5),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("REMEDIATION_TYPE_UNSPECIFIED"),
                        Self::Mitigation => std::option::Option::Some("MITIGATION"),
                        Self::NoFixPlanned => std::option::Option::Some("NO_FIX_PLANNED"),
                        Self::NoneAvailable => std::option::Option::Some("NONE_AVAILABLE"),
                        Self::VendorFix => std::option::Option::Some("VENDOR_FIX"),
                        Self::Workaround => std::option::Option::Some("WORKAROUND"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for RemediationType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for RemediationType {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for RemediationType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Mitigation,
                        2 => Self::NoFixPlanned,
                        3 => Self::NoneAvailable,
                        4 => Self::VendorFix,
                        5 => Self::Workaround,
                        _ => Self::UnknownValue(remediation_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                    }
                }
            }

            impl std::convert::From<&str> for RemediationType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "REMEDIATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "MITIGATION" => Self::Mitigation,
                        "NO_FIX_PLANNED" => Self::NoFixPlanned,
                        "NONE_AVAILABLE" => Self::NoneAvailable,
                        "VENDOR_FIX" => Self::VendorFix,
                        "WORKAROUND" => Self::Workaround,
                        _ => Self::UnknownValue(remediation_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                    }
                }
            }

            impl serde::ser::Serialize for RemediationType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Mitigation => serializer.serialize_i32(1),
                        Self::NoFixPlanned => serializer.serialize_i32(2),
                        Self::NoneAvailable => serializer.serialize_i32(3),
                        Self::VendorFix => serializer.serialize_i32(4),
                        Self::Workaround => serializer.serialize_i32(5),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for RemediationType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<RemediationType>::new(
                        ".grafeas.v1.VulnerabilityAssessmentNote.Assessment.Remediation.RemediationType"))
                }
            }
        }

        /// Provides the state of this Vulnerability assessment.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// No state is specified.
            Unspecified,
            /// This product is known to be affected by this vulnerability.
            Affected,
            /// This product is known to be not affected by this vulnerability.
            NotAffected,
            /// This product contains a fix for this vulnerability.
            Fixed,
            /// It is not known yet whether these versions are or are not affected
            /// by the vulnerability. However, it is still under investigation.
            UnderInvestigation,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Affected => std::option::Option::Some(1),
                    Self::NotAffected => std::option::Option::Some(2),
                    Self::Fixed => std::option::Option::Some(3),
                    Self::UnderInvestigation => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Affected => std::option::Option::Some("AFFECTED"),
                    Self::NotAffected => std::option::Option::Some("NOT_AFFECTED"),
                    Self::Fixed => std::option::Option::Some("FIXED"),
                    Self::UnderInvestigation => std::option::Option::Some("UNDER_INVESTIGATION"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Affected,
                    2 => Self::NotAffected,
                    3 => Self::Fixed,
                    4 => Self::UnderInvestigation,
                    _ => Self::UnknownValue(state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "AFFECTED" => Self::Affected,
                    "NOT_AFFECTED" => Self::NotAffected,
                    "FIXED" => Self::Fixed,
                    "UNDER_INVESTIGATION" => Self::UnderInvestigation,
                    _ => Self::UnknownValue(state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Affected => serializer.serialize_i32(1),
                    Self::NotAffected => serializer.serialize_i32(2),
                    Self::Fixed => serializer.serialize_i32(3),
                    Self::UnderInvestigation => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".grafeas.v1.VulnerabilityAssessmentNote.Assessment.State"))
            }
        }
    }
}

/// A security vulnerability that can be found in resources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VulnerabilityNote {

    /// The CVSS score of this vulnerability. CVSS score is on a scale of 0 - 10
    /// where 0 indicates low severity and 10 indicates high severity.
    pub cvss_score: f32,

    /// The note provider assigned severity of this vulnerability.
    pub severity: crate::model::Severity,

    /// Details of all known distros and packages affected by this vulnerability.
    pub details: std::vec::Vec<crate::model::vulnerability_note::Detail>,

    /// The full description of the CVSSv3 for this vulnerability.
    pub cvss_v3: std::option::Option<crate::model::CVSSv3>,

    /// Windows details get their own format because the information format and
    /// model don't match a normal detail. Specifically Windows updates are done as
    /// patches, thus Windows vulnerabilities really are a missing package, rather
    /// than a package being at an incorrect version.
    pub windows_details: std::vec::Vec<crate::model::vulnerability_note::WindowsDetail>,

    /// The time this information was last changed at the source. This is an
    /// upstream timestamp from the underlying information source - e.g. Ubuntu
    /// security tracker.
    pub source_update_time: std::option::Option<wkt::Timestamp>,

    /// CVSS version used to populate cvss_score and severity.
    pub cvss_version: crate::model::CVSSVersion,

    /// The full description of the v2 CVSS for this vulnerability.
    pub cvss_v2: std::option::Option<crate::model::Cvss>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cvss_score][crate::model::VulnerabilityNote::cvss_score].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// let x = VulnerabilityNote::new().set_cvss_score(42.0);
    /// ```
    pub fn set_cvss_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.cvss_score = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::VulnerabilityNote::severity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// use google_cloud_grafeas_v1::model::Severity;
    /// let x0 = VulnerabilityNote::new().set_severity(Severity::Minimal);
    /// let x1 = VulnerabilityNote::new().set_severity(Severity::Low);
    /// let x2 = VulnerabilityNote::new().set_severity(Severity::Medium);
    /// ```
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [details][crate::model::VulnerabilityNote::details].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
    /// let x = VulnerabilityNote::new()
    ///     .set_details([
    ///         Detail::default()/* use setters */,
    ///         Detail::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerability_note::Detail>
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cvss_v3][crate::model::VulnerabilityNote::cvss_v3].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// use google_cloud_grafeas_v1::model::CVSSv3;
    /// let x = VulnerabilityNote::new().set_cvss_v3(CVSSv3::default()/* use setters */);
    /// ```
    pub fn set_cvss_v3<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::CVSSv3>
    {
        self.cvss_v3 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvss_v3][crate::model::VulnerabilityNote::cvss_v3].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// use google_cloud_grafeas_v1::model::CVSSv3;
    /// let x = VulnerabilityNote::new().set_or_clear_cvss_v3(Some(CVSSv3::default()/* use setters */));
    /// let x = VulnerabilityNote::new().set_or_clear_cvss_v3(None::<CVSSv3>);
    /// ```
    pub fn set_or_clear_cvss_v3<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::CVSSv3>
    {
        self.cvss_v3 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [windows_details][crate::model::VulnerabilityNote::windows_details].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// use google_cloud_grafeas_v1::model::vulnerability_note::WindowsDetail;
    /// let x = VulnerabilityNote::new()
    ///     .set_windows_details([
    ///         WindowsDetail::default()/* use setters */,
    ///         WindowsDetail::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_windows_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerability_note::WindowsDetail>
    {
        use std::iter::Iterator;
        self.windows_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_update_time][crate::model::VulnerabilityNote::source_update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// use wkt::Timestamp;
    /// let x = VulnerabilityNote::new().set_source_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_source_update_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.source_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_update_time][crate::model::VulnerabilityNote::source_update_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// use wkt::Timestamp;
    /// let x = VulnerabilityNote::new().set_or_clear_source_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = VulnerabilityNote::new().set_or_clear_source_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_source_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.source_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cvss_version][crate::model::VulnerabilityNote::cvss_version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// use google_cloud_grafeas_v1::model::CVSSVersion;
    /// let x0 = VulnerabilityNote::new().set_cvss_version(CVSSVersion::CvssVersion2);
    /// let x1 = VulnerabilityNote::new().set_cvss_version(CVSSVersion::CvssVersion3);
    /// ```
    pub fn set_cvss_version<T: std::convert::Into<crate::model::CVSSVersion>>(mut self, v: T) -> Self {
        self.cvss_version = v.into();
        self
    }

    /// Sets the value of [cvss_v2][crate::model::VulnerabilityNote::cvss_v2].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// use google_cloud_grafeas_v1::model::Cvss;
    /// let x = VulnerabilityNote::new().set_cvss_v2(Cvss::default()/* use setters */);
    /// ```
    pub fn set_cvss_v2<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Cvss>
    {
        self.cvss_v2 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvss_v2][crate::model::VulnerabilityNote::cvss_v2].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityNote;
    /// use google_cloud_grafeas_v1::model::Cvss;
    /// let x = VulnerabilityNote::new().set_or_clear_cvss_v2(Some(Cvss::default()/* use setters */));
    /// let x = VulnerabilityNote::new().set_or_clear_cvss_v2(None::<Cvss>);
    /// ```
    pub fn set_or_clear_cvss_v2<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Cvss>
    {
        self.cvss_v2 = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VulnerabilityNote {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.VulnerabilityNote"
    }
}

/// Defines additional types related to [VulnerabilityNote].
pub mod vulnerability_note {
    #[allow(unused_imports)]
    use super::*;


    /// A detail for a distro and package affected by this vulnerability and its
    /// associated fix (if one is available).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Detail {

        /// The distro assigned severity of this vulnerability.
        pub severity_name: std::string::String,

        /// A vendor-specific description of this vulnerability.
        pub description: std::string::String,

        /// The type of package; whether native or non native (e.g., ruby gems,
        /// node.js packages, etc.).
        pub package_type: std::string::String,

        /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
        /// vulnerability affects.
        pub affected_cpe_uri: std::string::String,

        /// Required. The package this vulnerability affects.
        pub affected_package: std::string::String,

        /// The version number at the start of an interval in which this
        /// vulnerability exists. A vulnerability can affect a package between
        /// version numbers that are disjoint sets of intervals (example:
        /// [1.0.0-1.1.0], [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be
        /// represented in its own Detail. If a specific affected version is provided
        /// by a vulnerability database, affected_version_start and
        /// affected_version_end will be the same in that Detail.
        pub affected_version_start: std::option::Option<crate::model::Version>,

        /// The version number at the end of an interval in which this vulnerability
        /// exists. A vulnerability can affect a package between version numbers
        /// that are disjoint sets of intervals (example: [1.0.0-1.1.0],
        /// [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be represented in its
        /// own Detail. If a specific affected version is provided by a vulnerability
        /// database, affected_version_start and affected_version_end will be the
        /// same in that Detail.
        pub affected_version_end: std::option::Option<crate::model::Version>,

        /// The distro recommended [CPE URI](https://cpe.mitre.org/specification/)
        /// to update to that contains a fix for this vulnerability. It is possible
        /// for this to be different from the affected_cpe_uri.
        pub fixed_cpe_uri: std::string::String,

        /// The distro recommended package to update to that contains a fix for this
        /// vulnerability. It is possible for this to be different from the
        /// affected_package.
        pub fixed_package: std::string::String,

        /// The distro recommended version to update to that contains a
        /// fix for this vulnerability. Setting this to VersionKind.MAXIMUM means no
        /// such version is yet available.
        pub fixed_version: std::option::Option<crate::model::Version>,

        /// Whether this detail is obsolete. Occurrences are expected not to point to
        /// obsolete details.
        pub is_obsolete: bool,

        /// The time this information was last changed at the source. This is an
        /// upstream timestamp from the underlying information source - e.g. Ubuntu
        /// security tracker.
        pub source_update_time: std::option::Option<wkt::Timestamp>,

        /// The source from which the information in this Detail was obtained.
        pub source: std::string::String,

        /// The name of the vendor of the product.
        pub vendor: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Detail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [severity_name][crate::model::vulnerability_note::Detail::severity_name].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// let x = Detail::new().set_severity_name("example");
        /// ```
        pub fn set_severity_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.severity_name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::vulnerability_note::Detail::description].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// let x = Detail::new().set_description("example");
        /// ```
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [package_type][crate::model::vulnerability_note::Detail::package_type].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// let x = Detail::new().set_package_type("example");
        /// ```
        pub fn set_package_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.package_type = v.into();
            self
        }

        /// Sets the value of [affected_cpe_uri][crate::model::vulnerability_note::Detail::affected_cpe_uri].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// let x = Detail::new().set_affected_cpe_uri("example");
        /// ```
        pub fn set_affected_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.affected_cpe_uri = v.into();
            self
        }

        /// Sets the value of [affected_package][crate::model::vulnerability_note::Detail::affected_package].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// let x = Detail::new().set_affected_package("example");
        /// ```
        pub fn set_affected_package<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.affected_package = v.into();
            self
        }

        /// Sets the value of [affected_version_start][crate::model::vulnerability_note::Detail::affected_version_start].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// use google_cloud_grafeas_v1::model::Version;
        /// let x = Detail::new().set_affected_version_start(Version::default()/* use setters */);
        /// ```
        pub fn set_affected_version_start<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::Version>
        {
            self.affected_version_start = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [affected_version_start][crate::model::vulnerability_note::Detail::affected_version_start].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// use google_cloud_grafeas_v1::model::Version;
        /// let x = Detail::new().set_or_clear_affected_version_start(Some(Version::default()/* use setters */));
        /// let x = Detail::new().set_or_clear_affected_version_start(None::<Version>);
        /// ```
        pub fn set_or_clear_affected_version_start<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::Version>
        {
            self.affected_version_start = v.map(|x| x.into());
            self
        }

        /// Sets the value of [affected_version_end][crate::model::vulnerability_note::Detail::affected_version_end].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// use google_cloud_grafeas_v1::model::Version;
        /// let x = Detail::new().set_affected_version_end(Version::default()/* use setters */);
        /// ```
        pub fn set_affected_version_end<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::Version>
        {
            self.affected_version_end = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [affected_version_end][crate::model::vulnerability_note::Detail::affected_version_end].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// use google_cloud_grafeas_v1::model::Version;
        /// let x = Detail::new().set_or_clear_affected_version_end(Some(Version::default()/* use setters */));
        /// let x = Detail::new().set_or_clear_affected_version_end(None::<Version>);
        /// ```
        pub fn set_or_clear_affected_version_end<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::Version>
        {
            self.affected_version_end = v.map(|x| x.into());
            self
        }

        /// Sets the value of [fixed_cpe_uri][crate::model::vulnerability_note::Detail::fixed_cpe_uri].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// let x = Detail::new().set_fixed_cpe_uri("example");
        /// ```
        pub fn set_fixed_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.fixed_cpe_uri = v.into();
            self
        }

        /// Sets the value of [fixed_package][crate::model::vulnerability_note::Detail::fixed_package].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// let x = Detail::new().set_fixed_package("example");
        /// ```
        pub fn set_fixed_package<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.fixed_package = v.into();
            self
        }

        /// Sets the value of [fixed_version][crate::model::vulnerability_note::Detail::fixed_version].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// use google_cloud_grafeas_v1::model::Version;
        /// let x = Detail::new().set_fixed_version(Version::default()/* use setters */);
        /// ```
        pub fn set_fixed_version<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::Version>
        {
            self.fixed_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [fixed_version][crate::model::vulnerability_note::Detail::fixed_version].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// use google_cloud_grafeas_v1::model::Version;
        /// let x = Detail::new().set_or_clear_fixed_version(Some(Version::default()/* use setters */));
        /// let x = Detail::new().set_or_clear_fixed_version(None::<Version>);
        /// ```
        pub fn set_or_clear_fixed_version<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::Version>
        {
            self.fixed_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [is_obsolete][crate::model::vulnerability_note::Detail::is_obsolete].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// let x = Detail::new().set_is_obsolete(true);
        /// ```
        pub fn set_is_obsolete<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_obsolete = v.into();
            self
        }

        /// Sets the value of [source_update_time][crate::model::vulnerability_note::Detail::source_update_time].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// use wkt::Timestamp;
        /// let x = Detail::new().set_source_update_time(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_source_update_time<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.source_update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source_update_time][crate::model::vulnerability_note::Detail::source_update_time].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// use wkt::Timestamp;
        /// let x = Detail::new().set_or_clear_source_update_time(Some(Timestamp::default()/* use setters */));
        /// let x = Detail::new().set_or_clear_source_update_time(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_source_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.source_update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source][crate::model::vulnerability_note::Detail::source].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// let x = Detail::new().set_source("example");
        /// ```
        pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = v.into();
            self
        }

        /// Sets the value of [vendor][crate::model::vulnerability_note::Detail::vendor].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::Detail;
        /// let x = Detail::new().set_vendor("example");
        /// ```
        pub fn set_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.vendor = v.into();
            self
        }
    }

    impl wkt::message::Message for Detail {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityNote.Detail"
        }
    }

    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WindowsDetail {

        /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
        /// vulnerability affects.
        pub cpe_uri: std::string::String,

        /// Required. The name of this vulnerability.
        pub name: std::string::String,

        /// The description of this vulnerability.
        pub description: std::string::String,

        /// Required. The names of the KBs which have hotfixes to mitigate this
        /// vulnerability. Note that there may be multiple hotfixes (and thus
        /// multiple KBs) that mitigate a given vulnerability. Currently any listed
        /// KBs presence is considered a fix.
        pub fixing_kbs: std::vec::Vec<crate::model::vulnerability_note::windows_detail::KnowledgeBase>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WindowsDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpe_uri][crate::model::vulnerability_note::WindowsDetail::cpe_uri].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::WindowsDetail;
        /// let x = WindowsDetail::new().set_cpe_uri("example");
        /// ```
        pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cpe_uri = v.into();
            self
        }

        /// Sets the value of [name][crate::model::vulnerability_note::WindowsDetail::name].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::WindowsDetail;
        /// let x = WindowsDetail::new().set_name("example");
        /// ```
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::vulnerability_note::WindowsDetail::description].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::WindowsDetail;
        /// let x = WindowsDetail::new().set_description("example");
        /// ```
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [fixing_kbs][crate::model::vulnerability_note::WindowsDetail::fixing_kbs].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_note::WindowsDetail;
        /// use google_cloud_grafeas_v1::model::vulnerability_note::windows_detail::KnowledgeBase;
        /// let x = WindowsDetail::new()
        ///     .set_fixing_kbs([
        ///         KnowledgeBase::default()/* use setters */,
        ///         KnowledgeBase::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_fixing_kbs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::vulnerability_note::windows_detail::KnowledgeBase>
        {
            use std::iter::Iterator;
            self.fixing_kbs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for WindowsDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityNote.WindowsDetail"
        }
    }

    /// Defines additional types related to [WindowsDetail].
    pub mod windows_detail {
        #[allow(unused_imports)]
        use super::*;


        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct KnowledgeBase {

            /// The KB name (generally of the form KB[0-9]+ (e.g., KB123456)).
            pub name: std::string::String,

            /// A link to the KB in the [Windows update catalog]
            /// (<https://www.catalog.update.microsoft.com/>).
            pub url: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl KnowledgeBase {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::vulnerability_note::windows_detail::KnowledgeBase::name].
            ///
            /// # Example
            /// ```ignore,no_run
            /// # use google_cloud_grafeas_v1::model::vulnerability_note::windows_detail::KnowledgeBase;
            /// let x = KnowledgeBase::new().set_name("example");
            /// ```
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [url][crate::model::vulnerability_note::windows_detail::KnowledgeBase::url].
            ///
            /// # Example
            /// ```ignore,no_run
            /// # use google_cloud_grafeas_v1::model::vulnerability_note::windows_detail::KnowledgeBase;
            /// let x = KnowledgeBase::new().set_url("example");
            /// ```
            pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.url = v.into();
                self
            }
        }

        impl wkt::message::Message for KnowledgeBase {
            fn typename() -> &'static str {
                "type.googleapis.com/grafeas.v1.VulnerabilityNote.WindowsDetail.KnowledgeBase"
            }
        }
    }
}

/// An occurrence of a severity vulnerability on a resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VulnerabilityOccurrence {

    /// The type of package; whether native or non native (e.g., ruby gems, node.js
    /// packages, etc.).
    pub r#type: std::string::String,

    /// Output only. The note provider assigned severity of this vulnerability.
    pub severity: crate::model::Severity,

    /// Output only. The CVSS score of this vulnerability. CVSS score is on a
    /// scale of 0 - 10 where 0 indicates low severity and 10 indicates high
    /// severity.
    pub cvss_score: f32,

    /// The cvss v3 score for the vulnerability.
    pub cvssv3: std::option::Option<crate::model::Cvss>,

    /// Required. The set of affected locations and their fixes (if available)
    /// within the associated resource.
    pub package_issue: std::vec::Vec<crate::model::vulnerability_occurrence::PackageIssue>,

    /// Output only. A one sentence description of this vulnerability.
    pub short_description: std::string::String,

    /// Output only. A detailed description of this vulnerability.
    pub long_description: std::string::String,

    /// Output only. URLs related to this vulnerability.
    pub related_urls: std::vec::Vec<crate::model::RelatedUrl>,

    /// The distro assigned severity for this vulnerability when it is available,
    /// otherwise this is the note provider assigned severity.
    ///
    /// When there are multiple PackageIssues for this vulnerability, they can have
    /// different effective severities because some might be provided by the distro
    /// while others are provided by the language ecosystem for a language pack.
    /// For this reason, it is advised to use the effective severity on the
    /// PackageIssue level. In the case where multiple PackageIssues have differing
    /// effective severities, this field should be the highest severity for any of
    /// the PackageIssues.
    pub effective_severity: crate::model::Severity,

    /// Output only. Whether at least one of the affected packages has a fix
    /// available.
    pub fix_available: bool,

    /// Output only. CVSS version used to populate cvss_score and severity.
    pub cvss_version: crate::model::CVSSVersion,

    /// The cvss v2 score for the vulnerability.
    pub cvss_v2: std::option::Option<crate::model::Cvss>,

    pub vex_assessment: std::option::Option<crate::model::vulnerability_occurrence::VexAssessment>,

    /// Occurrence-specific extra details about the vulnerability.
    pub extra_details: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityOccurrence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::VulnerabilityOccurrence::type].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// let x = VulnerabilityOccurrence::new().set_type("example");
    /// ```
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::VulnerabilityOccurrence::severity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// use google_cloud_grafeas_v1::model::Severity;
    /// let x0 = VulnerabilityOccurrence::new().set_severity(Severity::Minimal);
    /// let x1 = VulnerabilityOccurrence::new().set_severity(Severity::Low);
    /// let x2 = VulnerabilityOccurrence::new().set_severity(Severity::Medium);
    /// ```
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [cvss_score][crate::model::VulnerabilityOccurrence::cvss_score].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// let x = VulnerabilityOccurrence::new().set_cvss_score(42.0);
    /// ```
    pub fn set_cvss_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.cvss_score = v.into();
        self
    }

    /// Sets the value of [cvssv3][crate::model::VulnerabilityOccurrence::cvssv3].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// use google_cloud_grafeas_v1::model::Cvss;
    /// let x = VulnerabilityOccurrence::new().set_cvssv3(Cvss::default()/* use setters */);
    /// ```
    pub fn set_cvssv3<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Cvss>
    {
        self.cvssv3 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvssv3][crate::model::VulnerabilityOccurrence::cvssv3].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// use google_cloud_grafeas_v1::model::Cvss;
    /// let x = VulnerabilityOccurrence::new().set_or_clear_cvssv3(Some(Cvss::default()/* use setters */));
    /// let x = VulnerabilityOccurrence::new().set_or_clear_cvssv3(None::<Cvss>);
    /// ```
    pub fn set_or_clear_cvssv3<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Cvss>
    {
        self.cvssv3 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [package_issue][crate::model::VulnerabilityOccurrence::package_issue].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
    /// let x = VulnerabilityOccurrence::new()
    ///     .set_package_issue([
    ///         PackageIssue::default()/* use setters */,
    ///         PackageIssue::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_package_issue<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerability_occurrence::PackageIssue>
    {
        use std::iter::Iterator;
        self.package_issue = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [short_description][crate::model::VulnerabilityOccurrence::short_description].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// let x = VulnerabilityOccurrence::new().set_short_description("example");
    /// ```
    pub fn set_short_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.short_description = v.into();
        self
    }

    /// Sets the value of [long_description][crate::model::VulnerabilityOccurrence::long_description].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// let x = VulnerabilityOccurrence::new().set_long_description("example");
    /// ```
    pub fn set_long_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.long_description = v.into();
        self
    }

    /// Sets the value of [related_urls][crate::model::VulnerabilityOccurrence::related_urls].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// use google_cloud_grafeas_v1::model::RelatedUrl;
    /// let x = VulnerabilityOccurrence::new()
    ///     .set_related_urls([
    ///         RelatedUrl::default()/* use setters */,
    ///         RelatedUrl::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_related_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedUrl>
    {
        use std::iter::Iterator;
        self.related_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [effective_severity][crate::model::VulnerabilityOccurrence::effective_severity].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// use google_cloud_grafeas_v1::model::Severity;
    /// let x0 = VulnerabilityOccurrence::new().set_effective_severity(Severity::Minimal);
    /// let x1 = VulnerabilityOccurrence::new().set_effective_severity(Severity::Low);
    /// let x2 = VulnerabilityOccurrence::new().set_effective_severity(Severity::Medium);
    /// ```
    pub fn set_effective_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.effective_severity = v.into();
        self
    }

    /// Sets the value of [fix_available][crate::model::VulnerabilityOccurrence::fix_available].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// let x = VulnerabilityOccurrence::new().set_fix_available(true);
    /// ```
    pub fn set_fix_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.fix_available = v.into();
        self
    }

    /// Sets the value of [cvss_version][crate::model::VulnerabilityOccurrence::cvss_version].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// use google_cloud_grafeas_v1::model::CVSSVersion;
    /// let x0 = VulnerabilityOccurrence::new().set_cvss_version(CVSSVersion::CvssVersion2);
    /// let x1 = VulnerabilityOccurrence::new().set_cvss_version(CVSSVersion::CvssVersion3);
    /// ```
    pub fn set_cvss_version<T: std::convert::Into<crate::model::CVSSVersion>>(mut self, v: T) -> Self {
        self.cvss_version = v.into();
        self
    }

    /// Sets the value of [cvss_v2][crate::model::VulnerabilityOccurrence::cvss_v2].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// use google_cloud_grafeas_v1::model::Cvss;
    /// let x = VulnerabilityOccurrence::new().set_cvss_v2(Cvss::default()/* use setters */);
    /// ```
    pub fn set_cvss_v2<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Cvss>
    {
        self.cvss_v2 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvss_v2][crate::model::VulnerabilityOccurrence::cvss_v2].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// use google_cloud_grafeas_v1::model::Cvss;
    /// let x = VulnerabilityOccurrence::new().set_or_clear_cvss_v2(Some(Cvss::default()/* use setters */));
    /// let x = VulnerabilityOccurrence::new().set_or_clear_cvss_v2(None::<Cvss>);
    /// ```
    pub fn set_or_clear_cvss_v2<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Cvss>
    {
        self.cvss_v2 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vex_assessment][crate::model::VulnerabilityOccurrence::vex_assessment].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// use google_cloud_grafeas_v1::model::vulnerability_occurrence::VexAssessment;
    /// let x = VulnerabilityOccurrence::new().set_vex_assessment(VexAssessment::default()/* use setters */);
    /// ```
    pub fn set_vex_assessment<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::vulnerability_occurrence::VexAssessment>
    {
        self.vex_assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vex_assessment][crate::model::VulnerabilityOccurrence::vex_assessment].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// use google_cloud_grafeas_v1::model::vulnerability_occurrence::VexAssessment;
    /// let x = VulnerabilityOccurrence::new().set_or_clear_vex_assessment(Some(VexAssessment::default()/* use setters */));
    /// let x = VulnerabilityOccurrence::new().set_or_clear_vex_assessment(None::<VexAssessment>);
    /// ```
    pub fn set_or_clear_vex_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::vulnerability_occurrence::VexAssessment>
    {
        self.vex_assessment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [extra_details][crate::model::VulnerabilityOccurrence::extra_details].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_grafeas_v1::model::VulnerabilityOccurrence;
    /// let x = VulnerabilityOccurrence::new().set_extra_details("example");
    /// ```
    pub fn set_extra_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.extra_details = v.into();
        self
    }
}

impl wkt::message::Message for VulnerabilityOccurrence {
    fn typename() -> &'static str {
        "type.googleapis.com/grafeas.v1.VulnerabilityOccurrence"
    }
}

/// Defines additional types related to [VulnerabilityOccurrence].
pub mod vulnerability_occurrence {
    #[allow(unused_imports)]
    use super::*;


    /// A detail for a distro and package this vulnerability occurrence was found
    /// in and its associated fix (if one is available).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PackageIssue {

        /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
        /// vulnerability was found in.
        pub affected_cpe_uri: std::string::String,

        /// Required. The package this vulnerability was found in.
        pub affected_package: std::string::String,

        /// Required. The version of the package that is installed on the resource
        /// affected by this vulnerability.
        pub affected_version: std::option::Option<crate::model::Version>,

        /// The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability
        /// was fixed in. It is possible for this to be different from the
        /// affected_cpe_uri.
        pub fixed_cpe_uri: std::string::String,

        /// The package this vulnerability was fixed in. It is possible for this to
        /// be different from the affected_package.
        pub fixed_package: std::string::String,

        /// Required. The version of the package this vulnerability was fixed in.
        /// Setting this to VersionKind.MAXIMUM means no fix is yet available.
        pub fixed_version: std::option::Option<crate::model::Version>,

        /// Output only. Whether a fix is available for this package.
        pub fix_available: bool,

        /// The type of package (e.g. OS, MAVEN, GO).
        pub package_type: std::string::String,

        /// The distro or language system assigned severity for this vulnerability
        /// when that is available and note provider assigned severity when it is not
        /// available.
        pub effective_severity: crate::model::Severity,

        /// The location at which this package was found.
        pub file_location: std::vec::Vec<crate::model::FileLocation>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PackageIssue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [affected_cpe_uri][crate::model::vulnerability_occurrence::PackageIssue::affected_cpe_uri].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// let x = PackageIssue::new().set_affected_cpe_uri("example");
        /// ```
        pub fn set_affected_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.affected_cpe_uri = v.into();
            self
        }

        /// Sets the value of [affected_package][crate::model::vulnerability_occurrence::PackageIssue::affected_package].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// let x = PackageIssue::new().set_affected_package("example");
        /// ```
        pub fn set_affected_package<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.affected_package = v.into();
            self
        }

        /// Sets the value of [affected_version][crate::model::vulnerability_occurrence::PackageIssue::affected_version].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// use google_cloud_grafeas_v1::model::Version;
        /// let x = PackageIssue::new().set_affected_version(Version::default()/* use setters */);
        /// ```
        pub fn set_affected_version<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::Version>
        {
            self.affected_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [affected_version][crate::model::vulnerability_occurrence::PackageIssue::affected_version].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// use google_cloud_grafeas_v1::model::Version;
        /// let x = PackageIssue::new().set_or_clear_affected_version(Some(Version::default()/* use setters */));
        /// let x = PackageIssue::new().set_or_clear_affected_version(None::<Version>);
        /// ```
        pub fn set_or_clear_affected_version<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::Version>
        {
            self.affected_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [fixed_cpe_uri][crate::model::vulnerability_occurrence::PackageIssue::fixed_cpe_uri].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// let x = PackageIssue::new().set_fixed_cpe_uri("example");
        /// ```
        pub fn set_fixed_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.fixed_cpe_uri = v.into();
            self
        }

        /// Sets the value of [fixed_package][crate::model::vulnerability_occurrence::PackageIssue::fixed_package].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// let x = PackageIssue::new().set_fixed_package("example");
        /// ```
        pub fn set_fixed_package<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.fixed_package = v.into();
            self
        }

        /// Sets the value of [fixed_version][crate::model::vulnerability_occurrence::PackageIssue::fixed_version].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// use google_cloud_grafeas_v1::model::Version;
        /// let x = PackageIssue::new().set_fixed_version(Version::default()/* use setters */);
        /// ```
        pub fn set_fixed_version<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::Version>
        {
            self.fixed_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [fixed_version][crate::model::vulnerability_occurrence::PackageIssue::fixed_version].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// use google_cloud_grafeas_v1::model::Version;
        /// let x = PackageIssue::new().set_or_clear_fixed_version(Some(Version::default()/* use setters */));
        /// let x = PackageIssue::new().set_or_clear_fixed_version(None::<Version>);
        /// ```
        pub fn set_or_clear_fixed_version<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::Version>
        {
            self.fixed_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [fix_available][crate::model::vulnerability_occurrence::PackageIssue::fix_available].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// let x = PackageIssue::new().set_fix_available(true);
        /// ```
        pub fn set_fix_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.fix_available = v.into();
            self
        }

        /// Sets the value of [package_type][crate::model::vulnerability_occurrence::PackageIssue::package_type].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// let x = PackageIssue::new().set_package_type("example");
        /// ```
        pub fn set_package_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.package_type = v.into();
            self
        }

        /// Sets the value of [effective_severity][crate::model::vulnerability_occurrence::PackageIssue::effective_severity].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// use google_cloud_grafeas_v1::model::Severity;
        /// let x0 = PackageIssue::new().set_effective_severity(Severity::Minimal);
        /// let x1 = PackageIssue::new().set_effective_severity(Severity::Low);
        /// let x2 = PackageIssue::new().set_effective_severity(Severity::Medium);
        /// ```
        pub fn set_effective_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
            self.effective_severity = v.into();
            self
        }

        /// Sets the value of [file_location][crate::model::vulnerability_occurrence::PackageIssue::file_location].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::PackageIssue;
        /// use google_cloud_grafeas_v1::model::FileLocation;
        /// let x = PackageIssue::new()
        ///     .set_file_location([
        ///         FileLocation::default()/* use setters */,
        ///         FileLocation::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_file_location<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FileLocation>
        {
            use std::iter::Iterator;
            self.file_location = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PackageIssue {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityOccurrence.PackageIssue"
        }
    }

    /// VexAssessment provides all publisher provided Vex information that is
    /// related to this vulnerability.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VexAssessment {

        /// Holds the MITRE standard Common Vulnerabilities and Exposures (CVE)
        /// tracking number for the vulnerability.
        /// Deprecated: Use vulnerability_id instead to denote CVEs.
        #[deprecated]
        pub cve: std::string::String,

        /// The vulnerability identifier for this Assessment. Will hold one of
        /// common identifiers e.g. CVE, GHSA etc.
        pub vulnerability_id: std::string::String,

        /// Holds a list of references associated with this vulnerability item and
        /// assessment.
        pub related_uris: std::vec::Vec<crate::model::RelatedUrl>,

        /// The VulnerabilityAssessment note from which this VexAssessment was
        /// generated.
        /// This will be of the form: `projects/[PROJECT_ID]/notes/[NOTE_ID]`.
        /// (-- api-linter: core::0122::name-suffix=disabled
        /// aip.dev/not-precedent: The suffix is kept for consistency. --)
        pub note_name: std::string::String,

        /// Provides the state of this Vulnerability assessment.
        pub state: crate::model::vulnerability_assessment_note::assessment::State,

        /// Contains information about the impact of this vulnerability,
        /// this will change with time.
        pub impacts: std::vec::Vec<std::string::String>,

        /// Specifies details on how to handle (and presumably, fix) a vulnerability.
        pub remediations: std::vec::Vec<crate::model::vulnerability_assessment_note::assessment::Remediation>,

        /// Justification provides the justification when the state of the
        /// assessment if NOT_AFFECTED.
        pub justification: std::option::Option<crate::model::vulnerability_assessment_note::assessment::Justification>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VexAssessment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cve][crate::model::vulnerability_occurrence::VexAssessment::cve].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::VexAssessment;
        /// let x = VexAssessment::new().set_cve("example");
        /// ```
        #[deprecated]
        pub fn set_cve<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cve = v.into();
            self
        }

        /// Sets the value of [vulnerability_id][crate::model::vulnerability_occurrence::VexAssessment::vulnerability_id].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::VexAssessment;
        /// let x = VexAssessment::new().set_vulnerability_id("example");
        /// ```
        pub fn set_vulnerability_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.vulnerability_id = v.into();
            self
        }

        /// Sets the value of [related_uris][crate::model::vulnerability_occurrence::VexAssessment::related_uris].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::VexAssessment;
        /// use google_cloud_grafeas_v1::model::RelatedUrl;
        /// let x = VexAssessment::new()
        ///     .set_related_uris([
        ///         RelatedUrl::default()/* use setters */,
        ///         RelatedUrl::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_related_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::RelatedUrl>
        {
            use std::iter::Iterator;
            self.related_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [note_name][crate::model::vulnerability_occurrence::VexAssessment::note_name].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::VexAssessment;
        /// let x = VexAssessment::new().set_note_name("example");
        /// ```
        pub fn set_note_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.note_name = v.into();
            self
        }

        /// Sets the value of [state][crate::model::vulnerability_occurrence::VexAssessment::state].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::VexAssessment;
        /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::State;
        /// let x0 = VexAssessment::new().set_state(State::Affected);
        /// let x1 = VexAssessment::new().set_state(State::NotAffected);
        /// let x2 = VexAssessment::new().set_state(State::Fixed);
        /// ```
        pub fn set_state<T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::State>>(mut self, v: T) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [impacts][crate::model::vulnerability_occurrence::VexAssessment::impacts].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::VexAssessment;
        /// let x = VexAssessment::new().set_impacts(["a", "b", "c"]);
        /// ```
        pub fn set_impacts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>
        {
            use std::iter::Iterator;
            self.impacts = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [remediations][crate::model::vulnerability_occurrence::VexAssessment::remediations].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::VexAssessment;
        /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Remediation;
        /// let x = VexAssessment::new()
        ///     .set_remediations([
        ///         Remediation::default()/* use setters */,
        ///         Remediation::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_remediations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::Remediation>
        {
            use std::iter::Iterator;
            self.remediations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [justification][crate::model::vulnerability_occurrence::VexAssessment::justification].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::VexAssessment;
        /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Justification;
        /// let x = VexAssessment::new().set_justification(Justification::default()/* use setters */);
        /// ```
        pub fn set_justification<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::Justification>
        {
            self.justification = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [justification][crate::model::vulnerability_occurrence::VexAssessment::justification].
        ///
        /// # Example
        /// ```ignore,no_run
        /// # use google_cloud_grafeas_v1::model::vulnerability_occurrence::VexAssessment;
        /// use google_cloud_grafeas_v1::model::vulnerability_assessment_note::assessment::Justification;
        /// let x = VexAssessment::new().set_or_clear_justification(Some(Justification::default()/* use setters */));
        /// let x = VexAssessment::new().set_or_clear_justification(None::<Justification>);
        /// ```
        pub fn set_or_clear_justification<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::vulnerability_assessment_note::assessment::Justification>
        {
            self.justification = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for VexAssessment {
        fn typename() -> &'static str {
            "type.googleapis.com/grafeas.v1.VulnerabilityOccurrence.VexAssessment"
        }
    }
}

/// Kind represents the kinds of notes supported.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NoteKind {
    /// Default value. This value is unused.
    Unspecified,
    /// The note and occurrence represent a package vulnerability.
    Vulnerability,
    /// The note and occurrence assert build provenance.
    Build,
    /// This represents an image basis relationship.
    Image,
    /// This represents a package installed via a package manager.
    Package,
    /// The note and occurrence track deployment events.
    Deployment,
    /// The note and occurrence track the initial discovery status of a resource.
    Discovery,
    /// This represents a logical "role" that can attest to artifacts.
    Attestation,
    /// This represents an available package upgrade.
    Upgrade,
    /// This represents a Compliance Note
    Compliance,
    /// This represents a DSSE attestation Note
    DsseAttestation,
    /// This represents a Vulnerability Assessment.
    VulnerabilityAssessment,
    /// This represents an SBOM Reference.
    SbomReference,
    /// This represents a secret.
    Secret,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NoteKind::value] or
    /// [NoteKind::name].
    UnknownValue(note_kind::UnknownValue),
}

#[doc(hidden)]
pub mod note_kind {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NoteKind {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Vulnerability => std::option::Option::Some(1),
            Self::Build => std::option::Option::Some(2),
            Self::Image => std::option::Option::Some(3),
            Self::Package => std::option::Option::Some(4),
            Self::Deployment => std::option::Option::Some(5),
            Self::Discovery => std::option::Option::Some(6),
            Self::Attestation => std::option::Option::Some(7),
            Self::Upgrade => std::option::Option::Some(8),
            Self::Compliance => std::option::Option::Some(9),
            Self::DsseAttestation => std::option::Option::Some(10),
            Self::VulnerabilityAssessment => std::option::Option::Some(11),
            Self::SbomReference => std::option::Option::Some(12),
            Self::Secret => std::option::Option::Some(13),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NOTE_KIND_UNSPECIFIED"),
            Self::Vulnerability => std::option::Option::Some("VULNERABILITY"),
            Self::Build => std::option::Option::Some("BUILD"),
            Self::Image => std::option::Option::Some("IMAGE"),
            Self::Package => std::option::Option::Some("PACKAGE"),
            Self::Deployment => std::option::Option::Some("DEPLOYMENT"),
            Self::Discovery => std::option::Option::Some("DISCOVERY"),
            Self::Attestation => std::option::Option::Some("ATTESTATION"),
            Self::Upgrade => std::option::Option::Some("UPGRADE"),
            Self::Compliance => std::option::Option::Some("COMPLIANCE"),
            Self::DsseAttestation => std::option::Option::Some("DSSE_ATTESTATION"),
            Self::VulnerabilityAssessment => std::option::Option::Some("VULNERABILITY_ASSESSMENT"),
            Self::SbomReference => std::option::Option::Some("SBOM_REFERENCE"),
            Self::Secret => std::option::Option::Some("SECRET"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NoteKind {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NoteKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NoteKind {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Vulnerability,
            2 => Self::Build,
            3 => Self::Image,
            4 => Self::Package,
            5 => Self::Deployment,
            6 => Self::Discovery,
            7 => Self::Attestation,
            8 => Self::Upgrade,
            9 => Self::Compliance,
            10 => Self::DsseAttestation,
            11 => Self::VulnerabilityAssessment,
            12 => Self::SbomReference,
            13 => Self::Secret,
            _ => Self::UnknownValue(note_kind::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for NoteKind {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NOTE_KIND_UNSPECIFIED" => Self::Unspecified,
            "VULNERABILITY" => Self::Vulnerability,
            "BUILD" => Self::Build,
            "IMAGE" => Self::Image,
            "PACKAGE" => Self::Package,
            "DEPLOYMENT" => Self::Deployment,
            "DISCOVERY" => Self::Discovery,
            "ATTESTATION" => Self::Attestation,
            "UPGRADE" => Self::Upgrade,
            "COMPLIANCE" => Self::Compliance,
            "DSSE_ATTESTATION" => Self::DsseAttestation,
            "VULNERABILITY_ASSESSMENT" => Self::VulnerabilityAssessment,
            "SBOM_REFERENCE" => Self::SbomReference,
            "SECRET" => Self::Secret,
            _ => Self::UnknownValue(note_kind::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for NoteKind {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Vulnerability => serializer.serialize_i32(1),
            Self::Build => serializer.serialize_i32(2),
            Self::Image => serializer.serialize_i32(3),
            Self::Package => serializer.serialize_i32(4),
            Self::Deployment => serializer.serialize_i32(5),
            Self::Discovery => serializer.serialize_i32(6),
            Self::Attestation => serializer.serialize_i32(7),
            Self::Upgrade => serializer.serialize_i32(8),
            Self::Compliance => serializer.serialize_i32(9),
            Self::DsseAttestation => serializer.serialize_i32(10),
            Self::VulnerabilityAssessment => serializer.serialize_i32(11),
            Self::SbomReference => serializer.serialize_i32(12),
            Self::Secret => serializer.serialize_i32(13),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NoteKind {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NoteKind>::new(
            ".grafeas.v1.NoteKind"))
    }
}

/// CVSS Version.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CVSSVersion {
    Unspecified,
    CvssVersion2,
    CvssVersion3,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CVSSVersion::value] or
    /// [CVSSVersion::name].
    UnknownValue(cvss_version::UnknownValue),
}

#[doc(hidden)]
pub mod cvss_version {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CVSSVersion {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::CvssVersion2 => std::option::Option::Some(1),
            Self::CvssVersion3 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CVSS_VERSION_UNSPECIFIED"),
            Self::CvssVersion2 => std::option::Option::Some("CVSS_VERSION_2"),
            Self::CvssVersion3 => std::option::Option::Some("CVSS_VERSION_3"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CVSSVersion {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CVSSVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CVSSVersion {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::CvssVersion2,
            2 => Self::CvssVersion3,
            _ => Self::UnknownValue(cvss_version::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for CVSSVersion {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CVSS_VERSION_UNSPECIFIED" => Self::Unspecified,
            "CVSS_VERSION_2" => Self::CvssVersion2,
            "CVSS_VERSION_3" => Self::CvssVersion3,
            _ => Self::UnknownValue(cvss_version::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for CVSSVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::CvssVersion2 => serializer.serialize_i32(1),
            Self::CvssVersion3 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CVSSVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CVSSVersion>::new(
            ".grafeas.v1.CVSSVersion"))
    }
}

/// Instruction set architectures supported by various package managers.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Architecture {
    /// Unknown architecture.
    Unspecified,
    /// X86 architecture.
    X86,
    /// X64 architecture.
    X64,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Architecture::value] or
    /// [Architecture::name].
    UnknownValue(architecture::UnknownValue),
}

#[doc(hidden)]
pub mod architecture {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Architecture {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::X86 => std::option::Option::Some(1),
            Self::X64 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ARCHITECTURE_UNSPECIFIED"),
            Self::X86 => std::option::Option::Some("X86"),
            Self::X64 => std::option::Option::Some("X64"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Architecture {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Architecture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Architecture {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::X86,
            2 => Self::X64,
            _ => Self::UnknownValue(architecture::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for Architecture {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
            "X86" => Self::X86,
            "X64" => Self::X64,
            _ => Self::UnknownValue(architecture::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for Architecture {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::X86 => serializer.serialize_i32(1),
            Self::X64 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Architecture {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Architecture>::new(
            ".grafeas.v1.Architecture"))
    }
}

/// Kind of secret.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SecretKind {
    /// Unspecified
    Unspecified,
    /// The secret kind is unknown.
    Unknown,
    /// A GCP service account key per:
    /// <https://cloud.google.com/iam/docs/creating-managing-service-account-keys>
    GcpServiceAccountKey,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SecretKind::value] or
    /// [SecretKind::name].
    UnknownValue(secret_kind::UnknownValue),
}

#[doc(hidden)]
pub mod secret_kind {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SecretKind {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Unknown => std::option::Option::Some(1),
            Self::GcpServiceAccountKey => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SECRET_KIND_UNSPECIFIED"),
            Self::Unknown => std::option::Option::Some("SECRET_KIND_UNKNOWN"),
            Self::GcpServiceAccountKey => std::option::Option::Some("SECRET_KIND_GCP_SERVICE_ACCOUNT_KEY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SecretKind {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SecretKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SecretKind {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Unknown,
            2 => Self::GcpServiceAccountKey,
            _ => Self::UnknownValue(secret_kind::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SecretKind {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SECRET_KIND_UNSPECIFIED" => Self::Unspecified,
            "SECRET_KIND_UNKNOWN" => Self::Unknown,
            "SECRET_KIND_GCP_SERVICE_ACCOUNT_KEY" => Self::GcpServiceAccountKey,
            _ => Self::UnknownValue(secret_kind::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SecretKind {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Unknown => serializer.serialize_i32(1),
            Self::GcpServiceAccountKey => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SecretKind {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SecretKind>::new(
            ".grafeas.v1.SecretKind"))
    }
}

/// Note provider assigned severity/impact ranking.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Severity {
    /// Unknown.
    Unspecified,
    /// Minimal severity.
    Minimal,
    /// Low severity.
    Low,
    /// Medium severity.
    Medium,
    /// High severity.
    High,
    /// Critical severity.
    Critical,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Severity::value] or
    /// [Severity::name].
    UnknownValue(severity::UnknownValue),
}

#[doc(hidden)]
pub mod severity {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Severity {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Minimal => std::option::Option::Some(1),
            Self::Low => std::option::Option::Some(2),
            Self::Medium => std::option::Option::Some(3),
            Self::High => std::option::Option::Some(4),
            Self::Critical => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
            Self::Minimal => std::option::Option::Some("MINIMAL"),
            Self::Low => std::option::Option::Some("LOW"),
            Self::Medium => std::option::Option::Some("MEDIUM"),
            Self::High => std::option::Option::Some("HIGH"),
            Self::Critical => std::option::Option::Some("CRITICAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Severity {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Severity {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Minimal,
            2 => Self::Low,
            3 => Self::Medium,
            4 => Self::High,
            5 => Self::Critical,
            _ => Self::UnknownValue(severity::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for Severity {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SEVERITY_UNSPECIFIED" => Self::Unspecified,
            "MINIMAL" => Self::Minimal,
            "LOW" => Self::Low,
            "MEDIUM" => Self::Medium,
            "HIGH" => Self::High,
            "CRITICAL" => Self::Critical,
            _ => Self::UnknownValue(severity::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for Severity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Minimal => serializer.serialize_i32(1),
            Self::Low => serializer.serialize_i32(2),
            Self::Medium => serializer.serialize_i32(3),
            Self::High => serializer.serialize_i32(4),
            Self::Critical => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Severity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
            ".grafeas.v1.Severity"))
    }
}
